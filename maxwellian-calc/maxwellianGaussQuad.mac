load("out-scripts")$
load("modal-basis")$
load("nodalOperations/quadratureFuncs.mac")$

writeCExprsNoExpand1_ssubst(lhs, rhs, subList, writeZeros) := block([expr,i,sExpr],
  expr : float(rhs),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 or writeZeros then (
      sExpr : string(gcfac(expr[i])),
      for sI : 1 thru length(subList) do (
        sExpr : ssubst(subList[sI][1],subList[sI][2],sExpr)
      ),
      printf(fh, "  ~a = ~a; ~%", lhs[i-1], sExpr)
    )
  )
)$

/* Create the kernel that evaluates at configuration space ordinates. */
evaluateConfOrd(fh, funcNm, cdim, vdim, udim, basisNm, polyOrder) := block(
  [basis,numB,den_e,vtSq_e,flowU_c,flowU_e,ordWeightC,normOrdsC,
   ordNumC,fMFac_n,flowU_n,vtSq_n,i,cSub,vd,strSub,expr,sExpr,sI],

  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisNm, cdim, "x", vdim, "v")),

  /* Configuration space basis. */
  basis : basisC[polyOrder],
  numB  : length(basis),

  /* Function which evaluates flow velocity, thermal speed and prefactor at
     configuration space ordinates. */
  if (vdim=udim) then (
    printf(fh, "void ~a_P~a_evAtConfOrd(const double *den, const double *flowU, const double *vtSq, double *flowUOrd, double *vtSqOrd, double *fMFacOrd) {~%", funcNm, polyOrder)
  ) else (
    printf(fh, "void ~aUpar_P~a_evAtConfOrd(const double *den, const double *flowU, const double *vtSq, double *flowUOrd, double *vtSqOrd, double *fMFacOrd) {~%", funcNm, polyOrder)
  ),
  printf(fh,"~%"),

  /* Expand the density, flow velocity and thermal speed squared in basis. */
  den_e   : doExpand1(den, basis),
  vtSq_e  : doExpand1(vtSq, basis),

  /* Flow velocity needs to account for the various vector components. */
  flowU_c : makelist(flowU[cOff+i],i,0,numB-1),
  flowU_e : doExpand(flowU_c, basis),
  
  /* Get the Gaussian quadrature ordinates (in [-1,1] configuration space). */
  ordWeightC : gaussOrdWeight(numQuad,cdim),
  normOrdsC  : float(ordWeightC[1]),
  ordNumC    : length(normOrdsC),

  fMFac_n : makelist(0,i,1,ordNumC),
  flowU_n : makelist(0,i,1,ordNumC*vdim),
  vtSq_n  : makelist(0,i,1,ordNumC),
  for i : 1 thru ordNumC do (
    cSub : makelist(varsC[d]=normOrdsC[i][d],d,1,cdim),

    den_n      : subst(cSub,den_e),
    vtSq_n[i]  : subst(cSub,vtSq_e),
    for vd : 0 thru vdim-1 do (
      if (vdim = udim) then (
        flowU_n[vd*ordNumC+i] : subst(cSub,subst(cOff=vd*numB,flowU_e))
      ) else (
        /* When the flow velocity is uPar, se flowUOrd=0 in first 2 dimensions. */
        if (vd=vdim-1) then (
          flowU_n[vd*ordNumC+i] : subst(cSub,subst(cOff=0,flowU_e))
        ) else (
          flowU_n[vd*ordNumC+i] : 0
        )
      )
    ),

    if vdim<3 then (
      fMFac_n[i] : den_n/(sqrt(2*%pi*vtSqOrd[i-1])^vdim)
    ) else (
      fMFac_n[i] : den_n/(cpow(sqrt(2*%pi*vtSqOrd[i-1]),vdim))
    )
  ),

  strSub : [["std::pow","cpow"]],
  writeCExprsNoExpand1_ssubst(flowUOrd, flowU_n, strSub, true),
  printf(fh,"~%"),
  writeCExprsNoExpand1_ssubst(vtSqOrd, vtSq_n, strSub, true),
  printf(fh,"~%"),

  /* The factor in front of the exponential we will set to very small (almost
     zero) if the thermal speed squared is negative. */
  expr : float(fMFac_n),
  for i : 1 thru length(expr) do (
    printf(fh, "  if (vtSqOrd[~a] <= 0.0)~%", i-1),
    printf(fh, "    fMFacOrd[~a] = 0.;~%", i-1),
    printf(fh, "  else~%"),
    sExpr : string(gcfac(expr[i])),
    for sI : 1 thru length(strSub) do (
      sExpr : ssubst(strSub[sI][1],strSub[sI][2],sExpr)
    ),
    printf(fh, "    ~a = ~a; ~%", fMFacOrd[i-1], sExpr)
  ),
  printf(fh,"~%"),

  printf(fh, "}~%"),
  printf(fh,"~%")
)$

/* Project a Maxwellian onto the DG basis using Gauss quadrature.
   This generates two functions, one to evaluate configuration-space
   quantities as conf-space ordinates, another to preform the quadrature
   in phase space. */
calcMaxwellianProjGauss(fh, funcNm, cdim, vdim, basisNm, polyOrder) := block(
  [numQuad,bP,bC,numBP,numBC,den_e,vtSq_e,flowU_c,flowU_e,ordWeigtC,normOrdsC,
   ordNumC,fMFac_n,flowU_n,vtSq_n,i,cSub,expr,sI,sExpr],

  numQuad : polyOrder+1, /* Number of quarature points in 1D. */

  kill(varsC, varsP, basisC, basisP),

  /* Generate the kernel that evaluates at configuration space ordinates. */
  evaluateConfOrd(fh, funcNm, cdim, vdim, vdim, basisNm, polyOrder),
  if vdim=3 then (
    /* Generate a kernel which takes a single-dimension flow velocity.
       This is to project a Maxwellian on the 3v grid when we take just
       the flow velocity in the third velocity dimension and assume
       zero flow in the other dimensions (e.g. Gyrokinetic -> Vlasov grid). */
    evaluateConfOrd(fh, funcNm, cdim, vdim, 1, basisNm, polyOrder)
  ),

  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisNm, cdim, "x", vdim, "v")),

  /* Phase and configuration space bases. */
  bP : basisP[polyOrder],
  bC : basisC[polyOrder],
  numBP : length(bP),
  numBC : length(bC),

  /* Function which performs the quadrature in phase space. */
  printf(fh, "void ~a_P~a_phaseQuad(const double *flowUOrd, const double *vtSqOrd, const double *fMFacOrd, const double *wc, const double *dxv, double *fMOut) {~%", funcNm, polyOrder),
  printf(fh,"~%"),

  /* Get the Gaussian quadrature ordinates (in [-1,1] configuration space). */
  ordWeightC : gaussOrdWeight(numQuad,cdim),
  normOrdsC  : float(ordWeightC[1]),
  ordNumC    : length(normOrdsC),

  /* Get the Gaussian quadrature ordinates (in [-1,1] velocity space). */
  ordWeightV : gaussOrdWeight(numQuad,vdim),
  normOrdsV  : float(ordWeightV[1]),
  ordNumV    : length(normOrdsV),

  /* Get the Gaussian quadrature weights and ordinates (in [-1,1] phase space). */
  ordWeightP : gaussOrdWeight(numQuad,cdim+vdim),
  normOrdsP  : float(ordWeightP[1]),
  weightsP   : float(ordWeightP[2]),
  ordNumP    : length(normOrdsP),
  
  /* Translate velocity ordinates in [-1,1] to our physical coordinates. */
  ordsV : makelist(makelist(0,d,1,vdim),i,1,ordNumV),
  for i : 1 thru ordNumV do (
    ordsV[i] : makelist(wc[cdim+d-1]+normOrdsV[i][d]*dxv[cdim+d-1]/2,d,1,vdim)
  ),

  fM_c : makelist(0,i,1,numBP),

  /* Write out the Maxwellian evaluated a quadrature points, so it doesn't get
     evaluated multiple times for the various basis functions. */
  fM_n : makelist(0,i,1,ordNumP),
  for i : 1 thru ordNumP do (
    nOrdP  : normOrdsP[i],

    /* Indices of the conf-space and velocity-space ordinates corresponding
       to this phase-space ordinate */
    cOrdIdx : sublist_indices(normOrdsC, lambda([x],x=makelist(nOrdP[d],d,1,cdim)))[1],
    vOrdIdx : sublist_indices(normOrdsV, lambda([x],x=makelist(nOrdP[cdim+d],d,1,vdim)))[1],

    expArg    : -(cpow(v-u,2))/(2*vtSq),
    expArgOrd : sum(subst([v=ordsV[vOrdIdx][d],u=flowUOrd[(d-1)*ordNumC+cOrdIdx-1],vtSq=vtSqOrd[cOrdIdx-1]],expArg),d,1,vdim),

    /* Add contribution to each DG coefficient. */
    fM_n[i] : fMFacOrd[cOrdIdx-1]*cexp(expArgOrd)
  ),

  printf(fh,"  double fMquad[~a];~%",ordNumP),
  strSub : [["exp","cexp"],["std::pow","cpow"]],
  writeCExprsNoExpand1_ssubst(fMquad, fM_n, strSub, false),
  printf(fh,"~%"),

  for i : 1 thru ordNumP do (
    nOrdP : normOrdsP[i],

    /* Add contribution to each DG coefficient. */
    for k : 1 thru numBP do (
      fM_c[k] : fM_c[k]+weightsP[i]*subst(makelist(varsP[d]=nOrdP[d],d,1,cdim+vdim),bP[k])*fMquad[i-1] 
    )

  ),

  strSub : [["exp","cexp"],["std::pow","cpow"]],
  writeCExprsNoExpand1_ssubst(fMOut, fM_c, strSub, false),
  printf(fh,"~%"),

  printf(fh, "}~%")
)$

old(fh, im) := block([],

  /* Get the velocity fields */
  varsV : makelist(varsP[i], i, length(varsC)+1, length(varsP)),
  /*tmp : [dvx, dvy, dvz],
  dVarsV : makelist(tmp[i], i, 1, length(varsV)),
  J : dVarsV[1]/2,
  for i : 2 thru length(dVarsV) do J : J * dVarsV[i]/2,
  tmp : [vcx[jx], vcy[jy], vcz[jz]],
  vcs : makelist(tmp[i], i, 1, length(varsV)),
  vPhys : dVarsV*varsV/2 + vcs,*/
  eta : [-1/sqrt(3), 1/sqrt(3)],
  w : [1, 1],

  /* Load basis and expand the new distribution function g */
  
  fPhys : nExp/sqrt(2*%pi*vth2Exp) * exp(-(vx-uExp)^2/(2*vth2Exp)),
  fk : makelist(subst([vx=dvx*vx/2+vxc], bp[k]*fPhys), k, 1, length(bp)),
  quad : lsum(subst(x=eta[i], w[i]*lsum(subst(vx=eta[j], w[j]*fk), j, [1,2])), i, [1,2]),
  simp : true,
  out : combine(quad),
  out : gcfac(out),
  out : float(out),

  /* Modification to convert from 1-indexed Maxima to 0-indexed C */
  sList : makelist(ns[i]=n[i-1], i, 1, length(bc)),
  printSub : subst(sList, out),
  sList : makelist(us[i]=u[i-1], i, 1, length(bc)*length(varsV)),
  printSub : subst(sList, printSub),
  sList : makelist(vth2s[i]=vth2[i-1], i, 1, length(bc)),
  printSub : subst(sList, printSub),
  printSub : subst(gkyl_ipow, "^", printSub),

  for i : 1 thru 1 do (
    printf(fh, "  f[~a] = ~a;~%", i-1, printSub[i])
  )
)$
