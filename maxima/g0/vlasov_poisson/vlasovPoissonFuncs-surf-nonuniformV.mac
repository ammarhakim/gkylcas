/* Functions called to generate the kernels for the surface terms due
   to the  -grad(phi) . del_v(f) term using upwinding
   in the Vlasov-Poisson equation, with the option to add a contribution
   due to external fields via curl(A) where A is the vector potential.
   NOTE: kernels expect phi and A to be scaled by appropriate factors
   i.e., q/m for plasmas, and G*m for self-gravitation systems. */

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

calcVlasovPoissonStreamUpdateInDirNonuniformV(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,varsV,cid,cv,vv,surfVars,bSurf,fl_e,fc_e,fr_e,Ghat_r_c,
   GhatNoZero_r,Ghat_r_e,Ghat_l_c,GhatNoZero_l,Ghat_l_e,incr_r,incr_l],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  varsV : makelist(varsP[cdim+i],i,1,vdim),
  if polyOrder=1 then (
    bV : basisFromVars("hyb", varsV, polyOrder)
  ) else (
    bV : basisFromVars(basisFun, varsV, polyOrder)
  ),

  numV : length(bV),

  printf(fh, "GKYL_CU_DH double ~a~a_~ax~av_~a_p~a(const double *w, const double *dxv, const double *vcoord, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, varsC[dir], cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // vcoord:    Discrete (DG) velocity coordinate.~%"),
  printf(fh, "  // alpha_geo: Fields used only for general geometry.~%"),
  printf(fh, "  // fl/fc/fr:  Input Distribution function in left/center/right cells.~%"),
  printf(fh, "  // out:       Incremented distribution function in center cell.~%"),

  /* Expand the velocity in each direction using a basis that only depends on
     the variable in that direction. */
  vcoord_c : makelist([],d,1,vdim),
  vcoord_e : makelist([],d,1,vdim),
  for d : 1 thru vdim do (
    velBasis   : copylist(bV),
    ignoreVars : listify(setdifference(setify(varsV),setify([varsV[d]]))),
    for i : 1 thru numV do (
      for v : 1 thru length(ignoreVars) do (
        if not freeof(ignoreVars[v],bV[i]) then (
          velBasis[i] : 0
    ))),

    vcoord_c[d] : subst(a0=numV*(d-1), makelist(vcoord[a0+i-1],i,1,numV) ),
    vcoord_e[d] : doExpand(vcoord_c[d],velBasis)
  ),

  cid : makelist(i,i,0,cdim-1),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* cv = variable in direction of surface update. */
  cv : varsP[dir],
  vv : varsV[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vv dependence. */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  printf(fh, "  const double rdx2 = 2/dxv[~a]; ~%", cid[dir]),
  printf(fh, "  double Ghat_r[~a]; ~%", length(bSurf)),
  printf(fh, "  double Ghat_l[~a]; ~%", length(bSurf)),
  
  printf(fh, "  if (~a>0) { ~%~%",float(subst(vv=0,vcoord_e[dir]))),

  /* Because v > 0, need left edge value */
  /* Evaluate surface projection of Ghat_r = v f_c. */
  Ghat_r_c : calcInnerProdList(surfVars, vcoord_e[dir], bSurf, subst(cv=1, fc_e)),
  writeCExprsCollect1lhsc(Ghat_r, radcan(Ghat_r_c)),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero_r : doMakeExprLst(Ghat_r_c, Ghat_r),
  Ghat_r_e     : doExpand(GhatNoZero_r, bSurf),

  /* Evaluate surface projection of Ghat_l = v f_l. */
  Ghat_l_c : calcInnerProdList(surfVars, vcoord_e[dir], bSurf, subst(cv=1, fl_e)),
  writeCExprsCollect1lhsc(Ghat_l, radcan(Ghat_l_c)),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero_l : doMakeExprLst(Ghat_l_c, Ghat_l),
  Ghat_l_e     : doExpand(GhatNoZero_l, bSurf),

  printf(fh, "  } else { ~%~%"),
  
  /* Because v < 0, need right edge value */
  /* Evaluate surface projection of Ghat_r = v f_r. */
  Ghat_r_c : calcInnerProdList(surfVars, vcoord_e[dir], bSurf, subst(cv=-1, fr_e)),

  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then (
    writeCExprsNoExpand1(Ghat_r, Ghat_r_c)
  ) else (
    writeCExprs1(Ghat_r, Ghat_r_c)
  ),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of Ghat which are empty. */
  GhatNoZero_r : doMakeExprLst(Ghat_r_c, Ghat_r),
  Ghat_r_e     : doExpand(GhatNoZero_r, bSurf),

  /* Evaluate surface projection of Ghat_l = v f_c. */
  Ghat_l_c : calcInnerProdList(surfVars, vcoord_e[dir], bSurf, subst(cv=-1, fc_e)),

  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then (
    writeCExprsNoExpand1(Ghat_l, Ghat_l_c)
  ) else (
    writeCExprs1(Ghat_l, Ghat_l_c)
  ),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of Ghat which are empty. */
  GhatNoZero_l : doMakeExprLst(Ghat_l_c, Ghat_l),
  Ghat_l_e     : doExpand(GhatNoZero_l, bSurf),
  
  printf(fh, "  } ~%"),
  /* Compute surface contribution integral(phi^- Ghat) on the right. */
  incr_l : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Ghat_l_e),
  incr_r : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Ghat_r_e),
  writeCIncrExprsCollect1lhsc(out, rdx2*incr_l + rdx2*incr_r),    
  printf(fh, "~%"),

  printf(fh, "  return 0.;~%"),  /* Return CFL frequency in volume kernel. */
  printf(fh, "~%"),

  printf(fh, "} ~%")
);

calcVlasovPoissonUpdateInDirNonuniformV(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,varsV,numC,numP,pDim,cid,vid,rdx2Vec,d,vv,surfVars,bSurf,phi_e,acc_e,alphaV_c,
   alphaNoZero,alpha_e,surfNodes,alphaOrd_n,surfNodesConfig,numNodesConfig,numNodes,
   numNodesVel,i,j,fHatSurf_l_e,fHatSurf_r_e,Ghat_l_c,GhatNoZero_l,Ghat_l_e,Ghat_r_c,
   GhatNoZero_r,Ghat_r_e,incr_l,incr_r],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  varsV : makelist(varsP[cdim+i],i,1,vdim),

  numC  : length(bC),
  numP  : length(bP),
  pDim  : length(varsP),

  printf(fh, "GKYL_CU_DH double ~a~a_~ax~av_~a_p~a(const double *w, const double *dxv, const double *vcoord, const double *field, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, varsV[dir], cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w:         Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // vcoord:    Discrete (DG) velocity coordinate.~%"),
  printf(fh, "  // field:     potential (scaled by appropriate factors).~%"),
  printf(fh, "  // fl/fc/fr:  Input Distribution function in left/center/right cells ~%"),
  printf(fh, "  // out:       Output distribution function in center cell ~%"),

  cid : makelist(i,i,0,cdim-1),
  vid : makelist(i,i,cdim,cdim+vdim-1),

  printf(fh, "  const double rdv2 = 2/dxv[~a]; ~%", vid[dir]),

  /* access potential data */
  printf(fh, "  const double *phi = &field[~a]; ~%", 0),
  for d : 1 thru cdim do (
    printf(fh, "  const double rd~a2 = 2/dxv[~a]; ~%", varsC[d], cid[d])
  ),
  rdx2Vec : [rdx2,rdy2,rdz2],

  /* vv = variable in direction of surface update. */
  vv : varsV[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(vv,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vv dependence. */
  /* Also generate necessary basis strings and surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),

    surf_cdim : cdim,  surf_vdim : vdim-1,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim),

    basisStr : sconcat("hyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder), 

    surfNodes : gaussOrd(polyOrder+1, pDim-1),

    basisStr : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  NSurf : length(bSurf),
  numNodes : length(surfNodes),

  /* alpha is the phase space flux at the surface. */
  /* NOTE: Due to the form of the Vlasov-Poisson system of equations, this phase space
     flux is the same evaluated at the left edge and right edge in a given direction
     (i.e., the flux does not explicitly depend on the coordinate in the surface direction)
     For example, vx flux is q/m (grad_x phi + vy*(curl(A))_z - vz*(curl(A))_y) */
  printf(fh, "  double alpha[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  phi_e : doExpand1(phi, bC),

  /* alpha_v = -fac*grad(phi) */
  /* fac = q/m for plasma, fac = G*m for self gravitating systems */
  /* In case of external fields, also add q/m*curl(A) */
  varsCall : [x, y, z],
  if (dir = 1) then (
    acc_e : -rdx2Vec[dir]*diff(phi_e,varsCall[1])
  ) elseif (dir = 2) then (
    acc_e : -rdx2Vec[dir]*diff(phi_e,varsCall[2])
  ) else (
    acc_e : -rdx2Vec[dir]*diff(phi_e,varsCall[3])
  ),

  /* Project alpha_v onto surface basis, and print resulting coefficients. */
  alphaV_c : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, subst(vv=1, acc_e))),
  writeCExprs1(alpha, alphaV_c),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of alpha which are empty. */
  alphaNoZero : doMakeExprLst(alphaV_c, alpha),
  alpha_e     : doExpand(alphaNoZero, bSurf),

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     Thus, there is no need for alpha_l and alpha_r. We only need alpha at the ordinates. */
  alphaOrd_n : gcfac(float(evAtNodes(alpha_e,surfNodes,surfVars))),

  /* Vlasov-Poisson flux does not depend on velocity space surface on which it sits
     i.e., grad(phi) term does not depend on vx, vy, or vz
     so sort quadrature points between configuration space and velocity space */
  /* Get number of configuration space nodes */
  surfNodesConfig : gaussOrd(polyOrder+1, cdim),
  numNodesConfig  : length(surfNodesConfig),
  numNodesVel     : numNodes/numNodesConfig,

  printf(fh, "  double fUpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double fUpwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),
  /* Check sign of each quadrature point and choose appropriate distribution function at 
     quadrature points. If alpha > 0, need f_l (at +1) and f_c (at +1). If alpha < 0, 
     need f_c (at -1) and f_r (at -1). */
  for i : 1 thru numNodesConfig do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_n[i]),
    for j : 1 thru numNodesVel do (
      printf(fh, "    fUpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(fl); ~%", (j-1)+(i-1)*numNodesVel, basisStr, cdim+dir, (j-1)+(i-1)*numNodesVel),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(fc); ~%", (j-1)+(i-1)*numNodesVel, basisStr, cdim+dir, (j-1)+(i-1)*numNodesVel)
    ),
    printf(fh, "  } else { ~%"),
    for j : 1 thru numNodesVel do (
      printf(fh, "    fUpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(fc); ~%", (j-1)+(i-1)*numNodesVel, basisStr, cdim+dir, (j-1)+(i-1)*numNodesVel),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(fr); ~%", (j-1)+(i-1)*numNodesVel, basisStr, cdim+dir, (j-1)+(i-1)*numNodesVel)
    ),
    printf(fh, "  } ~%")
  ),

  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  hyb_~ax~av_p1_vdir_upwind_quad_to_modal(fUpwindQuad_l, fUpwind_l); ~%", cdim, vdim),
    printf(fh, "  hyb_~ax~av_p1_vdir_upwind_quad_to_modal(fUpwindQuad_r, fUpwind_r); ~%", cdim, vdim)
  ) else (
    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad_l, fUpwind_l); ~%", basisFun, cdim+vdim, polyOrder),
    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad_r, fUpwind_r); ~%", basisFun, cdim+vdim, polyOrder)
  ),
  printf(fh, "~%"),

  /* Create expansions of f_hat (upwinded f) on the left and right in the surface basis. */
  fHatSurf_l_e : doExpand1(fUpwind_l, bSurf),
  fHatSurf_r_e : doExpand1(fUpwind_r, bSurf),

  /* Print C exprs for Ghat across surface boundary, (LEFT BOUNDARY) */
  Ghat_l_c : fullratsimp(innerProd(surfVars, alpha_e, bSurf, fHatSurf_l_e)),
  writeCExprs1(Ghat_l, Ghat_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Print C exprs for Ghat across surface boundary, (RIGHT BOUNDARY) */
  Ghat_r_c : fullratsimp(innerProd(surfVars, alpha_e, bSurf, fHatSurf_r_e)),
  writeCExprs1(Ghat_r, Ghat_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Expand G_hat in surface basis. */
  Ghat_l_e : doExpand1(Ghat_l, bSurf),
  Ghat_r_e : doExpand1(Ghat_r, bSurf),

  /* Compute surface contribution integral(phi^- Ghat) on the left and right. */
  incr_l : calcInnerProdList(surfVars, 1, subst(vv=-1.0, bP), Ghat_l_e),
  incr_r : calcInnerProdList(surfVars, -1, subst(vv=1.0, bP), Ghat_r_e),
  writeCIncrExprsCollect1lhsc(out, rdv2*incr_l + rdv2*incr_r),  
  printf(fh, "~%"),

  printf(fh, "  return 0.;~%"),  /* Return CFL frequency in volume kernel. */
  printf(fh, "~%"),

  printf(fh, "} ~%")
);

calcVlasovPoissonExtEmUpdateInDirNonuniformV(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,varsV,bV,numC,numV,numP,pDim,vcoord_c,vcoord_e,velBasis,ignoreVars,cid,vid,rdx2Vec,
   d,vv,surfVars,bSurf,phi_e,Ax_e,Ay_e,Az_e,Bx_e,By_e,Bz_e,vTransSubs,acc_e,alphaV_c,alphaNoZero,
   alpha_e,fl_e,fc_e,fr_e,surfNodes,numNodes,alphaOrd_n,i,fHatSurf_l_e,fHatSurf_r_e,Ghat_l_c,
   GhatNoZero_l,Ghat_l_e,Ghat_r_c,GhatNoZero_r,Ghat_r_e,incr_l,incr_r],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  varsV : makelist(varsP[cdim+i],i,1,vdim),
  if polyOrder=1 then (
    bV : basisFromVars("hyb", varsV, polyOrder)
  ) else (
    bV : basisFromVars(basisFun, varsV, polyOrder)
  ),

  numC : length(bC),
  numV : length(bV),
  numP : length(bP),
  pDim : length(varsP),

  printf(fh, "GKYL_CU_DH double ~a~a_~ax~av_~a_p~a(const double *w, const double *dxv, const double *vcoord, const double *field, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, varsV[dir], cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w:         Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // vcoord:    Discrete (DG) velocity coordinate.~%"),
  printf(fh, "  // field:     potentials, including external (scaled by appropriate factors).~%"),
  printf(fh, "  // fl/fc/fr:  Input Distribution function in left/center/right cells ~%"),
  printf(fh, "  // out:       Output distribution function in center cell ~%"),

  /* Expand the velocity in each direction using a basis that only depends on
     the variable in that direction. */
  vcoord_c : makelist([],d,1,vdim),
  vcoord_e : makelist(0,d,1,3),
  for d : 1 thru vdim do (
    velBasis   : copylist(bV),
    ignoreVars : listify(setdifference(setify(varsV),setify([varsV[d]]))),
    for i : 1 thru numV do (
      for v : 1 thru length(ignoreVars) do (
        if not freeof(ignoreVars[v],bV[i]) then (
          velBasis[i] : 0
    ))),

    vcoord_c[d] : subst(a0=numV*(d-1), makelist(vcoord[a0+i-1],i,1,numV) ),
    vcoord_e[d] : doExpand(vcoord_c[d],velBasis)
  ),

  cid : makelist(i,i,0,cdim-1),
  vid : makelist(i,i,cdim,cdim+vdim-1),

  printf(fh, "  const double rdv2 = 2/dxv[~a]; ~%", vid[dir]),

  /* access potential data */
  printf(fh, "  const double *phi = &field[~a]; ~%", 0),
  for d : 1 thru cdim do (
    printf(fh, "  const double rd~a2 = 2/dxv[~a]; ~%", varsC[d], cid[d])
  ),
  rdx2Vec : [rdx2,rdy2,rdz2],

  if vdim > 1 then (
    /* If vdim = 1, then no magnetic field. */
    for d : 1 thru vdim do (
      printf(fh, "  const double *A~a = &field[~a]; ~%", d-1, numC*d)
    )
  ),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* vv = variable in direction of surface update. */
  vv : varsV[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(vv,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vv dependence. */
  /* Also generate necessary basis strings and surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),

    surf_cdim : cdim,  surf_vdim : vdim-1,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim),

    basisStr : sconcat("hyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder), 

    surfNodes : gaussOrd(polyOrder+1, pDim-1),

    basisStr : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  NSurf : length(bSurf),
  numNodes : length(surfNodes),

  /* alpha is the phase space flux at the surface. */
  /* NOTE: Due to the form of the Vlasov-Poisson system of equations, this phase space
     flux is the same evaluated at the left edge and right edge in a given direction
     (i.e., the flux does not explicitly depend on the coordinate in the surface direction)
     For example, vx flux is q/m (grad_x phi + vy*(curl(A))_z - vz*(curl(A))_y) */
  printf(fh, "  double alpha[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  phi_e : doExpand1(phi, bC),

  Afld : [A0, A1, A2],
  Ax_e : doExpand1(Afld[1], bC),
  Ay_e : doExpand1(Afld[2], bC),
  Az_e : doExpand1(Afld[3], bC),

  /* B = curl(A); NOTE: already contains q/m factor */
  varsCall : [x, y, z],
  Bx_e : rdx2Vec[2]*diff(Az_e, varsCall[2]) - rdx2Vec[3]*diff(Ay_e, varsCall[3]),
  By_e : rdx2Vec[3]*diff(Ax_e, varsCall[3]) - rdx2Vec[1]*diff(Az_e, varsCall[1]),
  Bz_e : rdx2Vec[1]*diff(Ay_e, varsCall[1]) - rdx2Vec[2]*diff(Ax_e, varsCall[2]),

  /* alpha_v = -fac*grad(phi) */
  /* fac = q/m for plasma, fac = G*m for self gravitating systems */
  /* In case of external fields, also add q/m*curl(A) */
  if (dir = 1) then (
    acc_e : -rdx2Vec[dir]*diff(phi_e,varsCall[dir]) + vcoord_e[2]*Bz_e - vcoord_e[3]*By_e
  ) elseif (dir = 2) then (
    acc_e : -rdx2Vec[dir]*diff(phi_e,varsCall[dir]) + vcoord_e[3]*Bx_e - vcoord_e[1]*Bz_e
  ) else (
    acc_e : -rdx2Vec[dir]*diff(phi_e,varsCall[dir]) + vcoord_e[1]*By_e - vcoord_e[2]*Bx_e
  ),
  /* Project alpha_v onto surface basis, and print resulting coefficients. */
  alphaV_c : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, subst(vv=1, acc_e))),
  writeCExprs1(alpha, alphaV_c),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of alpha which are empty. */
  alphaNoZero : doMakeExprLst(alphaV_c, alpha),
  alpha_e     : doExpand(alphaNoZero, bSurf),

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     Thus, there is no need for alpha_l and alpha_r. We only need alpha at the ordinates. */
  alphaOrd_n : gcfac(float(evAtNodes(alpha_e,surfNodes,surfVars))),

  printf(fh, "  double fUpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind_l[~a] = {0.0};;~%", NSurf),
  printf(fh, "  double fUpwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),
  /* Check sign of each quadrature point and choose appropriate distribution function at 
     quadrature points. If alpha > 0, need f_l (at +1) and f_c (at +1). If alpha < 0, 
     need f_c (at -1) and f_r (at -1). */
  for i : 1 thru length(alphaOrd_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_n[i]),
    printf(fh, "    fUpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(fl); ~%", i-1, basisStr, cdim+dir, i-1),
    printf(fh, "    fUpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(fc); ~%", i-1, basisStr, cdim+dir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(fc); ~%", i-1, basisStr, cdim+dir, i-1),
    printf(fh, "    fUpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(fr); ~%", i-1, basisStr, cdim+dir, i-1),
    printf(fh, "  } ~%")
  ),

  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  hyb_~ax~av_p1_vdir_upwind_quad_to_modal(fUpwindQuad_l, fUpwind_l); ~%", cdim, vdim),
    printf(fh, "  hyb_~ax~av_p1_vdir_upwind_quad_to_modal(fUpwindQuad_r, fUpwind_r); ~%", cdim, vdim)
  ) else (
    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad_l, fUpwind_l); ~%", basisFun, cdim+vdim, polyOrder),
    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad_r, fUpwind_r); ~%", basisFun, cdim+vdim, polyOrder)
  ),
  printf(fh, "~%"),

  /* Create expansions of f_hat (upwinded f) on the left and right in the surface basis. */
  fHatSurf_l_e : doExpand1(fUpwind_l, bSurf),
  fHatSurf_r_e : doExpand1(fUpwind_r, bSurf),

  /* Print C exprs for Ghat across surface boundary, (LEFT BOUNDARY) */
  Ghat_l_c : fullratsimp(innerProd(surfVars, alpha_e, bSurf, fHatSurf_l_e)),
  writeCExprs1(Ghat_l, Ghat_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Print C exprs for Ghat across surface boundary, (RIGHT BOUNDARY) */
  Ghat_r_c : fullratsimp(innerProd(surfVars, alpha_e, bSurf, fHatSurf_r_e)),
  writeCExprs1(Ghat_r, Ghat_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Expand G_hat in surface basis. */
  Ghat_l_e : doExpand1(Ghat_l, bSurf),
  Ghat_r_e : doExpand1(Ghat_r, bSurf),

  /* Compute surface contribution integral(phi^- Ghat) on the right. */
  incr_l : calcInnerProdList(surfVars, 1, subst(vv=-1.0, bP), Ghat_l_e),
  incr_r : calcInnerProdList(surfVars, -1, subst(vv=1.0, bP), Ghat_r_e),
  writeCIncrExprsCollect1lhsc(out, rdv2*incr_l + rdv2*incr_r),
  printf(fh, "~%"),

  printf(fh, "  return 0.;~%"),  /* Return CFL frequency in volume kernel. */
  printf(fh, "~%"),

  printf(fh, "} ~%")
);
