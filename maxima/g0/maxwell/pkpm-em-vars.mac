/*  Generate kernels for: 
    1. bvar = [b_i (3 components), b_i b_j (6 components)],
    the magnetic field unit vector and unit tensor, b_i = B_i/|B|
    2. Diagnostic EM variables [bvar (9 components), E x B/|B|^2 (3 components)]

    In this case we project quadratic quantities onto a 2*p basis 
    so these quadratic quantities are *exactly* represented.

    Separate the operations into three functions:
    1. Compute the weak multiplications required: B_i B_j 
    2. Set the matrices to be inverted by the weak division process to compute B_i B_j/|B|^2 and (E x B)_i/|B|^2. 
    3. Copy the solution and perform remaining operations. Note for computing b from bb, we use: 
    basis_sqrt_with_sign (obtain expansion of sqrt(A^2) for a DG field A, keeping the sign of A)
    In this case A is only of order p, while A^2 is order 2*p, for checking the sign of A. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
fpprec : 24$

calcBB(fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, bC_2p, NC, NC_2p, 
   Bx_e, By_e, Bz_e, BxBy_c, BxBz_c, ByBz_c],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, 1),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_tensor_~ax_2p_exp_sq.h> ~%", cdim),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *em, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // em:  Input electromagnetic fields. ~%"),
  printf(fh, "  // out: Output B_i B_j tensor. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  double *B_x_sq  = &out[~a]; ~%", NC_2p*0),
  printf(fh, "  double *B_x_B_y = &out[~a]; ~%", NC_2p*1),
  printf(fh, "  double *B_x_B_z = &out[~a]; ~%", NC_2p*2),
  printf(fh, "  double *B_y_sq  = &out[~a]; ~%", NC_2p*3),
  printf(fh, "  double *B_y_B_z = &out[~a]; ~%", NC_2p*4),
  printf(fh, "  double *B_z_sq  = &out[~a]; ~%", NC_2p*5),
  printf(fh, " ~%"),

  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  printf(fh, "  // Calculate B_i B_i. ~%"),
  printf(fh, "  tensor_~ax_2p_exp_sq(B_x, B_x_sq); ~%", cdim),
  printf(fh, "  tensor_~ax_2p_exp_sq(B_y, B_y_sq); ~%", cdim),
  printf(fh, "  tensor_~ax_2p_exp_sq(B_z, B_z_sq); ~%", cdim),
  printf(fh, " ~%"),

  printf(fh, "  // Calculate B_i B_j. ~%"),
  Bx_e : doExpand1(B_x, bC),
  By_e : doExpand1(B_y, bC),
  Bz_e : doExpand1(B_z, bC),
  BxBy_c : calcInnerProdList(varsC, 1, bC_2p, Bx_e*By_e), 
  BxBz_c : calcInnerProdList(varsC, 1, bC_2p, Bx_e*Bz_e), 
  ByBz_c : calcInnerProdList(varsC, 1, bC_2p, By_e*Bz_e), 
  writeCExprs1(B_x_B_y, BxBy_c), 
  writeCExprs1(B_x_B_z, BxBz_c), 
  writeCExprs1(B_y_B_z, ByBz_c), 
  printf(fh, " ~%"),

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$

setbvar(fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, NC, BxSq_e, BySq_e, BzSq_e, magB2_e, magB2_c, 
   expr_bxbx, expr_bxby, expr_bxbz, expr_byby, expr_bybz, expr_bzbz, 
   ue, un, eq, E],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, 1),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, const double *BB) ~%{ ~%", funcNm),
  printf(fh, "  // count: integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A:     preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:   preallocated RHS vector. ~%"),
  printf(fh, "  // BB:    Input magnetic field tensor B_i B_j. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  struct gkyl_mat A_bxbx = gkyl_nmat_get(A, count); ~%"),
  printf(fh, "  struct gkyl_mat A_bxby = gkyl_nmat_get(A, count+1); ~%"),
  printf(fh, "  struct gkyl_mat A_bxbz = gkyl_nmat_get(A, count+2); ~%"),
  printf(fh, "  struct gkyl_mat A_byby = gkyl_nmat_get(A, count+3); ~%"),
  printf(fh, "  struct gkyl_mat A_bybz = gkyl_nmat_get(A, count+4); ~%"),
  printf(fh, "  struct gkyl_mat A_bzbz = gkyl_nmat_get(A, count+5); ~%"),

  printf(fh, "  struct gkyl_mat rhs_bxbx = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbz = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_byby = gkyl_nmat_get(rhs, count+3); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bybz = gkyl_nmat_get(rhs, count+4); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bzbz = gkyl_nmat_get(rhs, count+5); ~%"),

  printf(fh, "  // Clear matrix and rhs for each component of b_i b_j ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxbx, 0.0); gkyl_mat_clear(&rhs_bxbx, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxby, 0.0); gkyl_mat_clear(&rhs_bxby, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxbz, 0.0); gkyl_mat_clear(&rhs_bxbz, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_byby, 0.0); gkyl_mat_clear(&rhs_byby, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bybz, 0.0); gkyl_mat_clear(&rhs_bybz, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bzbz, 0.0); gkyl_mat_clear(&rhs_bzbz, 0.0); ~%"),

  printf(fh, "  const double *B_x_sq  = &BB[~a]; ~%", NC_2p*0),
  printf(fh, "  const double *B_x_B_y = &BB[~a]; ~%", NC_2p*1),
  printf(fh, "  const double *B_x_B_z = &BB[~a]; ~%", NC_2p*2),
  printf(fh, "  const double *B_y_sq  = &BB[~a]; ~%", NC_2p*3),
  printf(fh, "  const double *B_y_B_z = &BB[~a]; ~%", NC_2p*4),
  printf(fh, "  const double *B_z_sq  = &BB[~a]; ~%", NC_2p*5),
  printf(fh, " ~%"),

  BxSq_e : doExpand1(B_x_sq, bC_2p),
  BySq_e : doExpand1(B_y_sq, bC_2p),
  BzSq_e : doExpand1(B_z_sq, bC_2p),
  magB2_e : doExpand1(magB2, bC_2p),

  /* |B|^2 is represented with a basis of order 2*p and thus exactly represented
     guaranteeing positivity of |B|^2 everywhere in the cell */
  printf(fh, "  double magB2[~a] = {0.0}; ~%~%", NC_2p),
  magB2_c : calcInnerProdList(varsC, 1, bC_2p, BxSq_e + BySq_e + BzSq_e),
  writeCExprs1(magB2, magB2_c),
  printf(fh, "~%"),
  flush_output(fh),

  expr_bxbx : float(expand(makelist(B_x_sq[i],i,0,NC_2p-1))),
  expr_bxby : float(expand(makelist(B_x_B_y[i],i,0,NC_2p-1))),
  expr_bxbz : float(expand(makelist(B_x_B_z[i],i,0,NC_2p-1))),
  expr_byby : float(expand(makelist(B_y_sq[i],i,0,NC_2p-1))),
  expr_bybz : float(expand(makelist(B_y_B_z[i],i,0,NC_2p-1))),
  expr_bzbz : float(expand(makelist(B_z_sq[i],i,0,NC_2p-1))),

  for i : 1 thru length(expr_bxbx) do (
    printf(fh,"  gkyl_mat_set(&rhs_bxbx,~a,0,~a); ~%", i-1, expr_bxbx[i]),
    printf(fh,"  gkyl_mat_set(&rhs_bxby,~a,0,~a); ~%", i-1, expr_bxby[i]),
    printf(fh,"  gkyl_mat_set(&rhs_bxbz,~a,0,~a); ~%", i-1, expr_bxbz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_byby,~a,0,~a); ~%", i-1, expr_byby[i]),
    printf(fh,"  gkyl_mat_set(&rhs_bybz,~a,0,~a); ~%", i-1, expr_bybz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_bzbz,~a,0,~a); ~%", i-1, expr_bzbz[i])
  ),
  printf(fh, " ~%"),

  /* Generate matrix of unknown coefficients */
  ue : doExpand1(u, bC_2p),
  un : makelist(u[i], i, 0, NC_2p-1),
  eq : calcInnerProdList(varsC, ue, bC_2p ,magB2_e),
  E  : fullratsimp(coefmatrix(eq,un)),
  /* declare temp since matrix entries in A are the same for all operations
     B_i B_j are all being divided by |B|^2 to create b_i b_j */
  printf(fh, "  double temp = 0.0; ~%"),
  /* Matrix is dense so just do a simple write routine */
  for i : 1 thru NC_2p do (
    for j : 1 thru NC_2p do (
      printf(fh,"  temp = ~a; ~%", float(expand(E[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_bxbx,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_bxby,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_bxbz,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_byby,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_bybz,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_bzbz,~a,~a,~a); ~%", i-1, j-1, temp)
    )
  ),
  printf(fh, "} ~%")
)$

copybvar(fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, bC_2p, NC, NC_2p, surfVarsx, bSurfx, surfVarsy, bSurfy, surfVarsz, bSurfz, NSurf, 
   bx_e, by_e, bz_e, bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e, 
   nodes, bxbxQuad, bybyQuad, bzbzQuad, 
   bx_xl_c, bx_xr_c, by_yl_c, by_yr_c, bz_zl_c, bz_zr_c],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, 1),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  surfVarsx : delete(x,varsC),
  bSurfx : basisFromVars("Tensor",surfVarsx,polyOrder),
  if (cdim > 1) then (
    surfVarsy : delete(y,varsC),
    bSurfy : basisFromVars("Tensor",surfVarsy,polyOrder)
  ),
  if (cdim = 3) then (
    surfVarsz : delete(z,varsC),
    bSurfz : basisFromVars("Tensor",surfVarsz,polyOrder)
  ),

  /* Number of basis monomials. */
  if (cdim = 1) then (
    NSurf : 1
  )
  else (
    NSurf : length(bSurfx)
  ),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_tensor_~ax_2p_sqrt_with_sign.h> ~%", cdim),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *x, const double *em, int* cell_avg_bb, 
    double* GKYL_RESTRICT bvar, double* GKYL_RESTRICT bvar_surf) ~%{ ~%", funcNm),
  printf(fh, "  // count:       Integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // x:           Input solution vector. ~%"),
  printf(fh, "  // em:          Input electromagnetic fields. ~%"),
  printf(fh, "  // cell_avg_bb: Output flag for cell average if bb only used cell averages. ~%"),
  printf(fh, "  // bvar:        Output volume expansion of b_i = B_i/|B| (first 3 components), b_i b_j = B_i B_j/|B|^2 (last 6 components). ~%"),
  printf(fh, "  // bvar_surf:   Output surface expansion of b_i = B_i/|B|. ~%"),
  printf(fh, "  //              [bx_xl, bx_xr, by_yl, by_yr, bz_zl, bz_zr]. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  struct gkyl_mat x_bxbx = gkyl_nmat_get(x, count); ~%"),
  printf(fh, "  struct gkyl_mat x_bxby = gkyl_nmat_get(x, count+1); ~%"),
  printf(fh, "  struct gkyl_mat x_bxbz = gkyl_nmat_get(x, count+2); ~%"),
  printf(fh, "  struct gkyl_mat x_byby = gkyl_nmat_get(x, count+3); ~%"),
  printf(fh, "  struct gkyl_mat x_bybz = gkyl_nmat_get(x, count+4); ~%"),
  printf(fh, "  struct gkyl_mat x_bzbz = gkyl_nmat_get(x, count+5); ~%"),

  printf(fh, "  double *bx = &bvar[~a]; ~%", NC_2p*0),
  printf(fh, "  double *by = &bvar[~a]; ~%", NC_2p*1),
  printf(fh, "  double *bz = &bvar[~a]; ~%", NC_2p*2),
  printf(fh, "  double *bxbx = &bvar[~a]; ~%", NC_2p*3),
  printf(fh, "  double *bxby = &bvar[~a]; ~%", NC_2p*4),
  printf(fh, "  double *bxbz = &bvar[~a]; ~%", NC_2p*5),
  printf(fh, "  double *byby = &bvar[~a]; ~%", NC_2p*6),
  printf(fh, "  double *bybz = &bvar[~a]; ~%", NC_2p*7),
  printf(fh, "  double *bzbz = &bvar[~a]; ~%", NC_2p*8),
  printf(fh, " ~%"),

  for i : 1 thru NC_2p do (
    printf(fh,"  bxbx[~a] = gkyl_mat_get(&x_bxbx,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxby[~a] = gkyl_mat_get(&x_bxby,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxbz[~a] = gkyl_mat_get(&x_bxbz,~a,0); ~%", i-1, i-1),
    printf(fh,"  byby[~a] = gkyl_mat_get(&x_byby,~a,0); ~%", i-1, i-1),
    printf(fh,"  bybz[~a] = gkyl_mat_get(&x_bybz,~a,0); ~%", i-1, i-1),
    printf(fh,"  bzbz[~a] = gkyl_mat_get(&x_bzbz,~a,0); ~%", i-1, i-1)
  ),

  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  /* To insure b . b = 1, we need to check if bxbx, byby, or bzbz < 0.0
     at the quadrature points we use to evaluate the sqrt. If any of these
     points are negative, we switch to just the cell average of b_i b_j */
  /* Expand b and bb */
  bx_e : doExpand1(bx, bC_2p),
  by_e : doExpand1(by, bC_2p),
  bz_e : doExpand1(bz, bC_2p),
  bxbx_e : doExpand1(bxbx, bC_2p),
  byby_e : doExpand1(byby, bC_2p),
  bzbz_e : doExpand1(bzbz, bC_2p),

  nodes : gaussOrd(polyOrder+1, cdim),
  bxbxQuad : expand(float(evAtNodes(bxbx_e,nodes,varsC))),
  bybyQuad : expand(float(evAtNodes(byby_e,nodes,varsC))),
  bzbzQuad : expand(float(evAtNodes(bzbz_e,nodes,varsC))),

  printf(fh, "  int cell_avg_bxbx = 0;~%"),
  printf(fh, "  int cell_avg_byby = 0;~%"),
  printf(fh, "  int cell_avg_bzbz = 0;~%"),
  for i : 1 thru length(nodes) do (
    printf(fh, "  if (~a < 0.0) cell_avg_bxbx = 1; ~%", bxbxQuad[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_byby = 1; ~%", bybyQuad[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_bzbz = 1; ~%", bzbzQuad[i])
  ),

  printf(fh, "  if (cell_avg_bxbx || cell_avg_byby || cell_avg_bzbz) { ~%"),
  /* Use only the cell average bb. */
  for i : 2 thru NC_2p do (
    printf(fh, "    bxbx[~a] = 0.0; ~%", i-1),
    printf(fh, "    bxby[~a] = 0.0; ~%", i-1),
    printf(fh, "    bxbz[~a] = 0.0; ~%", i-1),
    printf(fh, "    byby[~a] = 0.0; ~%", i-1),
    printf(fh, "    bybz[~a] = 0.0; ~%", i-1),
    printf(fh, "    bzbz[~a] = 0.0; ~%", i-1)
  ),
  printf(fh, "    cell_avg_bb[0] = cell_avg_bxbx; ~%"),
  printf(fh, "    cell_avg_bb[1] = cell_avg_byby; ~%"),
  printf(fh, "    cell_avg_bb[2] = cell_avg_bzbz; ~%"),
  printf(fh, "  } ~%"),

  printf(fh, "  // Calculate b_i = B_i/|B| by taking square root of B_i^2/|B|^2 at quadrature points. ~%"),
  printf(fh, "  // Uses the sign of B_i at quadrature points to get the correct sign of b_i. ~%"),
  printf(fh, "  // Also checks if B_i^2/|B|^2 < 0.0 at quadrature points and zeros out the value there. ~%"),
  printf(fh, "  tensor_~ax_2p_sqrt_with_sign(B_x, bxbx, bx); ~%", cdim),
  printf(fh, "  tensor_~ax_2p_sqrt_with_sign(B_y, byby, by); ~%", cdim),
  printf(fh, "  tensor_~ax_2p_sqrt_with_sign(B_z, bzbz, bz); ~%", cdim),
  printf(fh, " ~%"),

  /* Now compute needed surface expansions */
  printf(fh, "  double *bx_xl = &bvar_surf[~a]; ~%", 0*NSurf),
  printf(fh, "  double *bx_xr = &bvar_surf[~a]; ~%", 1*NSurf),
  printf(fh, " ~%"), 
  if (cdim = 1) then (
    printf(fh, "  bx_xl[0] = ~a; ~%", float(expand(subst(x=-1, bx_e)))),
    printf(fh, "  bx_xr[0] = ~a; ~%", float(expand(subst(x=1, bx_e)))),
    printf(fh, " ~%")
  )
  else (
    bx_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, bx_e)),
    writeCExprs1(bx_xl, bx_xl_c), 
    printf(fh, " ~%"), 

    bx_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, bx_e)),
    writeCExprs1(bx_xr, bx_xr_c),  
    printf(fh, " ~%")
  ),
  if (cdim > 1) then (
    printf(fh, "  double *by_yl = &bvar_surf[~a]; ~%", 2*NSurf),
    printf(fh, "  double *by_yr = &bvar_surf[~a]; ~%", 3*NSurf),
    printf(fh, " ~%"), 

    by_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, by_e)),
    writeCExprs1(by_yl, by_yl_c), 
    printf(fh, " ~%"), 

    by_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, by_e)),
    writeCExprs1(by_yr, by_yr_c), 
    printf(fh, " ~%")
  ),
  if (cdim = 3) then (
    printf(fh, "  double *bz_zl = &bvar_surf[~a]; ~%", 4*NSurf),
    printf(fh, "  double *bz_zr = &bvar_surf[~a]; ~%", 5*NSurf),
    printf(fh, " ~%"), 

    bz_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, bz_e)),
    writeCExprs1(bz_zl, bz_zl_c), 
    printf(fh, " ~%"), 

    bz_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, bz_e)),
    writeCExprs1(bz_zr, bz_zr_c),  
    printf(fh, " ~%")
  ),  

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$

setdiag(fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, NC, BxSq_e, BySq_e, BzSq_e, magB2_e, magB2_c, 
   expr_bxbx, expr_bxby, expr_bxbz, expr_byby, expr_bybz, expr_bzbz, 
   ue, un, eq, E],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, 1),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, 
  const double *em, const double *BB) ~%{ ~%", funcNm),
  printf(fh, "  // count: integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A:     preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:   preallocated RHS vector. ~%"),
  printf(fh, "  // em:  Input electromagnetic fields. ~%"),
  printf(fh, "  // BB:    Input magnetic field tensor B_i B_j. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  struct gkyl_mat A_bxbx = gkyl_nmat_get(A, count); ~%"),
  printf(fh, "  struct gkyl_mat A_bxby = gkyl_nmat_get(A, count+1); ~%"),
  printf(fh, "  struct gkyl_mat A_bxbz = gkyl_nmat_get(A, count+2); ~%"),
  printf(fh, "  struct gkyl_mat A_byby = gkyl_nmat_get(A, count+3); ~%"),
  printf(fh, "  struct gkyl_mat A_bybz = gkyl_nmat_get(A, count+4); ~%"),
  printf(fh, "  struct gkyl_mat A_bzbz = gkyl_nmat_get(A, count+5); ~%"),
  printf(fh, "  struct gkyl_mat A_ExBx = gkyl_nmat_get(A, count+6); ~%"),
  printf(fh, "  struct gkyl_mat A_ExBy = gkyl_nmat_get(A, count+7); ~%"),
  printf(fh, "  struct gkyl_mat A_ExBz = gkyl_nmat_get(A, count+8); ~%"),

  printf(fh, "  struct gkyl_mat rhs_bxbx = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbz = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_byby = gkyl_nmat_get(rhs, count+3); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bybz = gkyl_nmat_get(rhs, count+4); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bzbz = gkyl_nmat_get(rhs, count+5); ~%"),
  printf(fh, "  struct gkyl_mat rhs_ExBx = gkyl_nmat_get(rhs, count+6); ~%"),
  printf(fh, "  struct gkyl_mat rhs_ExBy = gkyl_nmat_get(rhs, count+7); ~%"),
  printf(fh, "  struct gkyl_mat rhs_ExBz = gkyl_nmat_get(rhs, count+8); ~%"),

  printf(fh, "  // Clear matrix and rhs for each component of b_i b_j ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxbx, 0.0); gkyl_mat_clear(&rhs_bxbx, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxby, 0.0); gkyl_mat_clear(&rhs_bxby, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxbz, 0.0); gkyl_mat_clear(&rhs_bxbz, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_byby, 0.0); gkyl_mat_clear(&rhs_byby, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bybz, 0.0); gkyl_mat_clear(&rhs_bybz, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bzbz, 0.0); gkyl_mat_clear(&rhs_bzbz, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_ExBx, 0.0); gkyl_mat_clear(&rhs_ExBx, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_ExBy, 0.0); gkyl_mat_clear(&rhs_ExBy, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_ExBz, 0.0); gkyl_mat_clear(&rhs_ExBz, 0.0); ~%"),

  printf(fh, "  const double *B_x_sq  = &BB[~a]; ~%", NC_2p*0),
  printf(fh, "  const double *B_x_B_y = &BB[~a]; ~%", NC_2p*1),
  printf(fh, "  const double *B_x_B_z = &BB[~a]; ~%", NC_2p*2),
  printf(fh, "  const double *B_y_sq  = &BB[~a]; ~%", NC_2p*3),
  printf(fh, "  const double *B_y_B_z = &BB[~a]; ~%", NC_2p*4),
  printf(fh, "  const double *B_z_sq  = &BB[~a]; ~%", NC_2p*5),
  printf(fh, " ~%"),

  printf(fh, "  const double *E_x = &em[~a]; ~%", NC*0),
  printf(fh, "  const double *E_y = &em[~a]; ~%", NC*1),
  printf(fh, "  const double *E_z = &em[~a]; ~%", NC*2),
  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  BxSq_e : doExpand1(B_x_sq, bC_2p),
  BySq_e : doExpand1(B_y_sq, bC_2p),
  BzSq_e : doExpand1(B_z_sq, bC_2p),
  magB2_e : doExpand1(magB2, bC_2p),

  /* |B|^2 is represented with a basis of order 2*p and thus exactly represented
     guaranteeing positivity of |B|^2 everywhere in the cell */
  printf(fh, "  double magB2[~a] = {0.0}; ~%~%", NC_2p),
  magB2_c : calcInnerProdList(varsC, 1, bC_2p, BxSq_e + BySq_e + BzSq_e),
  writeCExprs1(magB2, magB2_c),
  printf(fh, "~%"),
  flush_output(fh),

  expr_bxbx : float(expand(makelist(B_x_sq[i],i,0,NC_2p-1))),
  expr_bxby : float(expand(makelist(B_x_B_y[i],i,0,NC_2p-1))),
  expr_bxbz : float(expand(makelist(B_x_B_z[i],i,0,NC_2p-1))),
  expr_byby : float(expand(makelist(B_y_sq[i],i,0,NC_2p-1))),
  expr_bybz : float(expand(makelist(B_y_B_z[i],i,0,NC_2p-1))),
  expr_bzbz : float(expand(makelist(B_z_sq[i],i,0,NC_2p-1))),

  printf(fh, "  // Calculate E x B numerator. ~%"),
  printf(fh, "  double E_x_B_x[~a] = {0.0}; ~%~%", NC_2p),
  printf(fh, "  double E_x_B_y[~a] = {0.0}; ~%~%", NC_2p),
  printf(fh, "  double E_x_B_z[~a] = {0.0}; ~%~%", NC_2p),
  Ex_e : doExpand1(E_x, bC),
  Ey_e : doExpand1(E_y, bC),
  Ez_e : doExpand1(E_z, bC),  
  Bx_e : doExpand1(B_x, bC),
  By_e : doExpand1(B_y, bC),
  Bz_e : doExpand1(B_z, bC),
  ExBx_c : calcInnerProdList(varsC, 1, bC_2p, Ey_e*Bz_e - Ez_e*By_e), 
  ExBy_c : calcInnerProdList(varsC, 1, bC_2p, Ez_e*Bx_e - Ex_e*Bz_e), 
  ExBz_c : calcInnerProdList(varsC, 1, bC_2p, Ex_e*By_e - Ey_e*Bx_e), 
  writeCExprs1(E_x_B_x, ExBx_c), 
  writeCExprs1(E_x_B_y, ExBy_c), 
  writeCExprs1(E_x_B_z, ExBz_c), 
  printf(fh, " ~%"),

  expr_ExBx : float(expand(makelist(E_x_B_x[i],i,0,NC_2p-1))),
  expr_ExBy : float(expand(makelist(E_x_B_y[i],i,0,NC_2p-1))),
  expr_ExBz : float(expand(makelist(E_x_B_z[i],i,0,NC_2p-1))),

  for i : 1 thru length(expr_bxbx) do (
    printf(fh,"  gkyl_mat_set(&rhs_bxbx,~a,0,~a); ~%", i-1, expr_bxbx[i]),
    printf(fh,"  gkyl_mat_set(&rhs_bxby,~a,0,~a); ~%", i-1, expr_bxby[i]),
    printf(fh,"  gkyl_mat_set(&rhs_bxbz,~a,0,~a); ~%", i-1, expr_bxbz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_byby,~a,0,~a); ~%", i-1, expr_byby[i]),
    printf(fh,"  gkyl_mat_set(&rhs_bybz,~a,0,~a); ~%", i-1, expr_bybz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_bzbz,~a,0,~a); ~%", i-1, expr_bzbz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_ExBx,~a,0,~a); ~%", i-1, expr_ExBx[i]),
    printf(fh,"  gkyl_mat_set(&rhs_ExBy,~a,0,~a); ~%", i-1, expr_ExBy[i]),
    printf(fh,"  gkyl_mat_set(&rhs_ExBz,~a,0,~a); ~%", i-1, expr_ExBz[i])
  ),
  printf(fh, " ~%"),

  /* Generate matrix of unknown coefficients */
  ue : doExpand1(u, bC_2p),
  un : makelist(u[i], i, 0, NC_2p-1),
  eq : calcInnerProdList(varsC, ue, bC_2p ,magB2_e),
  E  : fullratsimp(coefmatrix(eq,un)),
  /* declare temp since matrix entries in A are the same for all operations
     B_i B_j are all being divided by |B|^2 to create b_i b_j 
     and E x B are all being divided by |B|^2 to create (E x B)/|B|^2 */
  printf(fh, "  double temp = 0.0; ~%"),
  /* Matrix is dense so just do a simple write routine */
  for i : 1 thru NC_2p do (
    for j : 1 thru NC_2p do (
      printf(fh,"  temp = ~a; ~%", float(expand(E[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_bxbx,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_bxby,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_bxbz,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_byby,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_bybz,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_bzbz,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_ExBx,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_ExBy,~a,~a,~a); ~%", i-1, j-1, temp),
      printf(fh,"  gkyl_mat_set(&A_ExBz,~a,~a,~a); ~%", i-1, j-1, temp)
    )
  ),
  printf(fh, "} ~%")
)$

copydiag(fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, bC_2p, NC, NC_2p, surfVarsx, bSurfx, surfVarsy, bSurfy, surfVarsz, bSurfz, NSurf, 
   bx_e, by_e, bz_e, bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e, 
   nodes, bxbxQuad, bybyQuad, bzbzQuad, 
   bx_xl_c, bx_xr_c, by_yl_c, by_yr_c, bz_zl_c, bz_zr_c],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, 1),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_tensor_~ax_2p_sqrt_with_sign.h> ~%", cdim),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *x, const double *em, int* cell_avg_bb, 
    double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // count:       Integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // x:           Input solution vector. ~%"),
  printf(fh, "  // em:          Input electromagnetic fields. ~%"),
  printf(fh, "  // cell_avg_bb: Output flag for cell average if bb only used cell averages. ~%"),
  printf(fh, "  // out:         Output volume expansion of diagnostic EM variables. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  struct gkyl_mat x_bxbx = gkyl_nmat_get(x, count); ~%"),
  printf(fh, "  struct gkyl_mat x_bxby = gkyl_nmat_get(x, count+1); ~%"),
  printf(fh, "  struct gkyl_mat x_bxbz = gkyl_nmat_get(x, count+2); ~%"),
  printf(fh, "  struct gkyl_mat x_byby = gkyl_nmat_get(x, count+3); ~%"),
  printf(fh, "  struct gkyl_mat x_bybz = gkyl_nmat_get(x, count+4); ~%"),
  printf(fh, "  struct gkyl_mat x_bzbz = gkyl_nmat_get(x, count+5); ~%"),
  printf(fh, "  struct gkyl_mat x_ExBx = gkyl_nmat_get(x, count+6); ~%"),
  printf(fh, "  struct gkyl_mat x_ExBy = gkyl_nmat_get(x, count+7); ~%"),
  printf(fh, "  struct gkyl_mat x_ExBz = gkyl_nmat_get(x, count+8); ~%"),

  printf(fh, "  double *bx = &out[~a]; ~%", NC_2p*0),
  printf(fh, "  double *by = &out[~a]; ~%", NC_2p*1),
  printf(fh, "  double *bz = &out[~a]; ~%", NC_2p*2),
  printf(fh, "  double *bxbx = &out[~a]; ~%", NC_2p*3),
  printf(fh, "  double *bxby = &out[~a]; ~%", NC_2p*4),
  printf(fh, "  double *bxbz = &out[~a]; ~%", NC_2p*5),
  printf(fh, "  double *byby = &out[~a]; ~%", NC_2p*6),
  printf(fh, "  double *bybz = &out[~a]; ~%", NC_2p*7),
  printf(fh, "  double *bzbz = &out[~a]; ~%", NC_2p*8),
  printf(fh, "  double *ExBx = &out[~a]; ~%", NC_2p*9),
  printf(fh, "  double *ExBy = &out[~a]; ~%", NC_2p*10),
  printf(fh, "  double *ExBz = &out[~a]; ~%", NC_2p*11),
  printf(fh, " ~%"),

  for i : 1 thru NC_2p do (
    printf(fh,"  bxbx[~a] = gkyl_mat_get(&x_bxbx,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxby[~a] = gkyl_mat_get(&x_bxby,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxbz[~a] = gkyl_mat_get(&x_bxbz,~a,0); ~%", i-1, i-1),
    printf(fh,"  byby[~a] = gkyl_mat_get(&x_byby,~a,0); ~%", i-1, i-1),
    printf(fh,"  bybz[~a] = gkyl_mat_get(&x_bybz,~a,0); ~%", i-1, i-1),
    printf(fh,"  bzbz[~a] = gkyl_mat_get(&x_bzbz,~a,0); ~%", i-1, i-1), 
    printf(fh,"  ExBx[~a] = gkyl_mat_get(&x_ExBx,~a,0); ~%", i-1, i-1),
    printf(fh,"  ExBy[~a] = gkyl_mat_get(&x_ExBy,~a,0); ~%", i-1, i-1),
    printf(fh,"  ExBz[~a] = gkyl_mat_get(&x_ExBz,~a,0); ~%", i-1, i-1)
  ),

  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  /* To insure b . b = 1, we need to check if bxbx, byby, or bzbz < 0.0
     at the quadrature points we use to evaluate the sqrt. If any of these
     points are negative, we switch to just the cell average of b_i b_j */
  /* Expand b and bb */
  bx_e : doExpand1(bx, bC_2p),
  by_e : doExpand1(by, bC_2p),
  bz_e : doExpand1(bz, bC_2p),
  bxbx_e : doExpand1(bxbx, bC_2p),
  byby_e : doExpand1(byby, bC_2p),
  bzbz_e : doExpand1(bzbz, bC_2p),

  nodes : gaussOrd(polyOrder+1, cdim),
  bxbxQuad : expand(float(evAtNodes(bxbx_e,nodes,varsC))),
  bybyQuad : expand(float(evAtNodes(byby_e,nodes,varsC))),
  bzbzQuad : expand(float(evAtNodes(bzbz_e,nodes,varsC))),

  printf(fh, "  int cell_avg_bxbx = 0;~%"),
  printf(fh, "  int cell_avg_byby = 0;~%"),
  printf(fh, "  int cell_avg_bzbz = 0;~%"),
  for i : 1 thru length(nodes) do (
    printf(fh, "  if (~a < 0.0) cell_avg_bxbx = 1; ~%", bxbxQuad[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_byby = 1; ~%", bybyQuad[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_bzbz = 1; ~%", bzbzQuad[i])
  ),

  printf(fh, "  if (cell_avg_bxbx || cell_avg_byby || cell_avg_bzbz) { ~%"),
  /* Use only the cell average bb. */
  for i : 2 thru NC_2p do (
    printf(fh, "    bxbx[~a] = 0.0; ~%", i-1),
    printf(fh, "    bxby[~a] = 0.0; ~%", i-1),
    printf(fh, "    bxbz[~a] = 0.0; ~%", i-1),
    printf(fh, "    byby[~a] = 0.0; ~%", i-1),
    printf(fh, "    bybz[~a] = 0.0; ~%", i-1),
    printf(fh, "    bzbz[~a] = 0.0; ~%", i-1)
  ),
  printf(fh, "    cell_avg_bb[0] = cell_avg_bxbx; ~%"),
  printf(fh, "    cell_avg_bb[1] = cell_avg_byby; ~%"),
  printf(fh, "    cell_avg_bb[2] = cell_avg_bzbz; ~%"),
  printf(fh, "  } ~%"),

  printf(fh, "  // Calculate b_i = B_i/|B| by taking square root of B_i^2/|B|^2 at quadrature points. ~%"),
  printf(fh, "  // Uses the sign of B_i at quadrature points to get the correct sign of b_i. ~%"),
  printf(fh, "  // Also checks if B_i^2/|B|^2 < 0.0 at quadrature points and zeros out the value there. ~%"),
  printf(fh, "  tensor_~ax_2p_sqrt_with_sign(B_x, bxbx, bx); ~%", cdim),
  printf(fh, "  tensor_~ax_2p_sqrt_with_sign(B_y, byby, by); ~%", cdim),
  printf(fh, "  tensor_~ax_2p_sqrt_with_sign(B_z, bzbz, bz); ~%", cdim),
  printf(fh, " ~%"),

  printf(fh, "} ~%")
)$