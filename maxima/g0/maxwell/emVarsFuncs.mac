/*  Generate kernels for: 
    1. bvar = [b_i (3 components), b_i b_j (6 components)],
    the magnetic field unit vector and unit tensor, b_i = B_i/|B|
    2. ExB = E x B/|B|^2, 
    the E x B velocity
    3. b_i/kappa = b_i*sqrt(1 - |E x B|^2/(c^2 |B|^4)),
    the magnetic field unit vector divided by the E x B lorentz boost factor.
    Uses basis_exp_sq (obtain expansion of A^2 for a DG field A),
    basis_inv (obtain expansion of 1/A for a DG field A),
    basis_sqrt (obtain expansion of sqrt(A) for a DG field A) */

load("modal-basis");
load("out-scripts");
load(stringproc)$
fpprec : 24$

calcBvar(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC, NC, Bx_e, By_e, Bz_e, BxSq_e, BySq_e, BzSq_e, magB_sq_inv_e, 
   bxbx_c, bxby_c, bxbz_c, byby_c, bybz_c, bzbz_c],

  kill(varsC, basisC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  NC  : length(bC),

  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_exp_sq.h> ~%", basisFun, cdim, polyOrder),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_inv.h> ~%", basisFun, cdim, polyOrder),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_sqrt.h> ~%", basisFun, cdim, polyOrder),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *em, double* GKYL_RESTRICT bvar) ~%{ ~%", funcNm),
  printf(fh, "  // em:   Input electromagnetic fields. ~%"),
  printf(fh, "  // bvar: b_i = B_i/|B| (first 3 components), b_i b_j = B_i B_j/|B|^2 (last 6 components). ~%"),
  printf(fh, " ~%"),

  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  printf(fh, "  double *bx = &bvar[~a]; ~%", 0),
  printf(fh, "  double *by = &bvar[~a]; ~%", NC),
  printf(fh, "  double *bz = &bvar[~a]; ~%", NC*2),
  printf(fh, "  double *bxbx = &bvar[~a]; ~%", NC*3),
  printf(fh, "  double *bxby = &bvar[~a]; ~%", NC*4),
  printf(fh, "  double *bxbz = &bvar[~a]; ~%", NC*5),
  printf(fh, "  double *byby = &bvar[~a]; ~%", NC*6),
  printf(fh, "  double *bybz = &bvar[~a]; ~%", NC*7),
  printf(fh, "  double *bzbz = &bvar[~a]; ~%", NC*8),
  printf(fh, " ~%"),

  Bx_e : doExpand1(B_x, bC),
  By_e : doExpand1(B_y, bC),
  Bz_e : doExpand1(B_z, bC),

  printf(fh, "  // Calculate |B|^2 and get expansion of 1/|B|^2. ~%"),
  printf(fh, "  double B_x_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(B_x, B_x_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double B_y_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(B_y, B_y_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double B_z_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(B_z, B_z_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double magB_sq[~a] = {0.0}; ~%~%", NC),
  for i : 1 thru NC do (
    printf(fh, "  magB_sq[~a] = B_x_sq[~a] + B_y_sq[~a] + B_z_sq[~a]; ~%", i-1, i-1, i-1, i-1)
  ),
  printf(fh, " ~%"),
  printf(fh, "  double magB_sq_inv[~a] = {0.0}; ~%~%", NC),
  printf(fh, "  ~a_~ax_p~a_inv(magB_sq, magB_sq_inv); ~%", basisFun, cdim, polyOrder),

  BxSq_e : doExpand1(B_x_sq, bC),
  BySq_e : doExpand1(B_y_sq, bC),
  BzSq_e : doExpand1(B_z_sq, bC),  
  magB_sq_inv_e : doExpand1(magB_sq_inv, bC),

  printf(fh, "  // Calculate expansions of B_i B_j/|B|^2, which can be calculated free of aliasing errors. ~%"),
  bxbx_c : calcInnerProdList(varsC, 1, bC, BxSq_e*magB_sq_inv_e),
  bxby_c : calcInnerProdList(varsC, 1, bC, Bx_e*By_e*magB_sq_inv_e),
  bxbz_c : calcInnerProdList(varsC, 1, bC, Bx_e*Bz_e*magB_sq_inv_e),
  byby_c : calcInnerProdList(varsC, 1, bC, BySq_e*magB_sq_inv_e),
  bybz_c : calcInnerProdList(varsC, 1, bC, By_e*Bz_e*magB_sq_inv_e),
  bzbz_c : calcInnerProdList(varsC, 1, bC, BzSq_e*magB_sq_inv_e),

  writeCExprs1(bxbx, bxbx_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(bxby, bxby_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(bxbz, bxbz_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(byby, byby_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(bybz, bybz_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(bzbz, bzbz_c),
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "  // Calculate b_i = B_i/|B| by taking square root of B_i^2/|B|^2 at quadrature points. ~%"),
  printf(fh, "  ~a_~ax_p~a_sqrt(bxbx, bx); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_sqrt(byby, by); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_sqrt(bzbz, bz); ~%", basisFun, cdim, polyOrder),

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$

calcExB(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC, NC, Ex_e, Ey_e, Ez_e, Bx_e, By_e, Bz_e, magB_sq_inv_e, 
   ExB_x_c, ExB_y_c, ExB_z_c],

  kill(varsC, basisC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  NC  : length(bC),

  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_exp_sq.h> ~%", basisFun, cdim, polyOrder),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_inv.h> ~%", basisFun, cdim, polyOrder),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *em, double* GKYL_RESTRICT ExB) ~%{ ~%", funcNm),
  printf(fh, "  // em:  Input electromagnetic fields. ~%"),
  printf(fh, "  // ExB: E x B velocity = E x B/|B|^2. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  const double *E_x = &em[~a]; ~%", NC*0),
  printf(fh, "  const double *E_y = &em[~a]; ~%", NC*1),
  printf(fh, "  const double *E_z = &em[~a]; ~%", NC*2),
  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  printf(fh, "  double *ExB_x = &ExB[~a]; ~%", 0),
  printf(fh, "  double *ExB_y = &ExB[~a]; ~%", NC),
  printf(fh, "  double *ExB_z = &ExB[~a]; ~%", NC*2),
  printf(fh, " ~%"),

  printf(fh, "  // Calculate |B|^2 and get expansion of 1/|B|^2. ~%"),
  printf(fh, "  double B_x_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(B_x, B_x_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double B_y_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(B_y, B_y_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double B_z_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(B_z, B_z_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double magB_sq[~a] = {0.0}; ~%~%", NC),
  for i : 1 thru NC do (
    printf(fh, "  magB_sq[~a] = B_x_sq[~a] + B_y_sq[~a] + B_z_sq[~a]; ~%", i-1, i-1, i-1, i-1)
  ),
  printf(fh, " ~%"),
  printf(fh, "  double magB_sq_inv[~a] = {0.0}; ~%~%", NC),
  printf(fh, "  ~a_~ax_p~a_inv(magB_sq, magB_sq_inv); ~%", basisFun, cdim, polyOrder),

  Ex_e : doExpand1(E_x, bC),
  Ey_e : doExpand1(E_y, bC),
  Ez_e : doExpand1(E_z, bC),
  Bx_e : doExpand1(B_x, bC),
  By_e : doExpand1(B_y, bC),
  Bz_e : doExpand1(B_z, bC),
  magB_sq_inv_e : doExpand1(magB_sq_inv, bC),

  ExB_x_c : calcInnerProdList(varsC, 1, bC, (Ey_e*Bz_e - Ez_e*By_e)*magB_sq_inv_e),
  ExB_y_c : calcInnerProdList(varsC, 1, bC, (Ez_e*Bx_e - Ex_e*Bz_e)*magB_sq_inv_e),
  ExB_z_c : calcInnerProdList(varsC, 1, bC, (Ex_e*By_e - Ey_e*Bx_e)*magB_sq_inv_e),

  writeCExprs1(ExB_x, ExB_x_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(ExB_y, ExB_y_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(ExB_z, ExB_z_c),
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$

calcKappaInvB(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC, NC, Bx_e, By_e, Bz_e, BxSq_e, BySq_e, BzSq_e, magB_sq_inv_e, 
   bxbx_c, bxby_c, bxbz_c, byby_c, bybz_c, bzbz_c],

  kill(varsC, basisC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  NC  : length(bC),

  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_exp_sq.h> ~%", basisFun, cdim, polyOrder),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_inv.h> ~%", basisFun, cdim, polyOrder),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_sqrt.h> ~%", basisFun, cdim, polyOrder),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *bvar, const double *ExB, double* GKYL_RESTRICT kappa_inv_b) ~%{ ~%", funcNm),
  printf(fh, "  // bvar:        Input magnetic field unit vector and unit tensor. ~%"),
  printf(fh, "  // ExB:         Input E x B velocity. ~%"),
  printf(fh, "  // kappa_inv_b: b_i/kappa = B_i/|B| * sqrt(1 - |E x B|^2/(c^2 |B|^4)). ~%"),
  printf(fh, " ~%"),

  printf(fh, "  const double *bxbx = &bvar[~a]; ~%", NC*3),
  printf(fh, "  const double *byby = &bvar[~a]; ~%", NC*6),
  printf(fh, "  const double *bzbz = &bvar[~a]; ~%", NC*8),
  printf(fh, " ~%"),

  printf(fh, "  const double *ExB_x = &ExB[~a]; ~%", 0),
  printf(fh, "  const double *ExB_y = &ExB[~a]; ~%", NC),
  printf(fh, "  const double *ExB_z = &ExB[~a]; ~%", NC*2),
  printf(fh, " ~%"),

  printf(fh, "  double *kappa_inv_bx = &kappa_inv_b[~a]; ~%", 0),
  printf(fh, "  double *kappa_inv_by = &kappa_inv_b[~a]; ~%", NC),
  printf(fh, "  double *kappa_inv_bz = &kappa_inv_b[~a]; ~%", NC*2),
  printf(fh, " ~%"),

  printf(fh, "  // Calculate ((E x B)/|B|^2)^2. ~%"),
  printf(fh, "  double ExB_x_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(ExB_x, ExB_x_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double ExB_y_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(ExB_y, ExB_y_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double ExB_z_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_exp_sq(ExB_z, ExB_z_sq); ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),

  ExB_x_sq_e : doExpand1(ExB_x_sq, bC),
  ExB_y_sq_e : doExpand1(ExB_y_sq, bC),
  ExB_z_sq_e : doExpand1(ExB_z_sq, bC),

  bxbx_e : doExpand1(bxbx, bC),
  byby_e : doExpand1(byby, bC),
  bzbz_e : doExpand1(bzbz, bC),

  kappa_inv_bx_sq_c : calcInnerProdList(varsC, 1, bC, bxbx_e*(1 - ExB_x_sq_e - ExB_y_sq_e - ExB_z_sq_e)),
  kappa_inv_by_sq_c : calcInnerProdList(varsC, 1, bC, byby_e*(1 - ExB_x_sq_e - ExB_y_sq_e - ExB_z_sq_e)),
  kappa_inv_bz_sq_c : calcInnerProdList(varsC, 1, bC, bzbz_e*(1 - ExB_x_sq_e - ExB_y_sq_e - ExB_z_sq_e)),

  printf(fh, "  double kappa_inv_bx_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  double kappa_inv_by_sq[~a] = {0.0}; ~%", NC),
  printf(fh, "  double kappa_inv_bz_sq[~a] = {0.0}; ~%", NC),
  printf(fh, " ~%"),

  writeCExprs1(kappa_inv_bx_sq, kappa_inv_bx_sq_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(kappa_inv_by_sq, kappa_inv_by_sq_c),
  printf(fh, "~%"),
  flush_output(fh),
  writeCExprs1(kappa_inv_bz_sq, kappa_inv_bz_sq_c),
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "  ~a_~ax_p~a_sqrt(kappa_inv_bx_sq, kappa_inv_bx); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_sqrt(kappa_inv_by_sq, kappa_inv_by); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_sqrt(kappa_inv_bz_sq, kappa_inv_bz); ~%", basisFun, cdim, polyOrder),

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$