/* This script generates the kernels for calculating the *surface* magnetic field 
   unit vector and unit tensor required to update the PKPM system. Surface variables include:
   1. bx, bxbx, bxby, bxbz at left and right x surfaces
   2. by, bxby, byby, bybz at left and right y surfaces
   3. bz, bxbz, bybz, bzbz at left and right z surfaces 

   In 1D, these surface expansions can be generated with simple division. 
   In 2D/3D, these surface expansions require weak division and with p=1, we can
   still use the basis_inv method for increased computational efficiency. */

load("modal-basis")$
load("out-scripts")$
load("nodal_operations/nodal_functions")$
load(stringproc)$
load("scifac")$
fpprec : 24$
cvars : [x, y, z]$

calcBB_surf_1d(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, B_x_e, B_y_e, B_z_e, 
   B_x_l, B_x_r, B_y_l, B_y_r, B_z_l, B_z_r],

  kill(varsC, basisC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  NC  : length(bC),

  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *em, double* GKYL_RESTRICT out_surf) ~%{ ~%", funcNm),
  printf(fh, "  // em:             Input electromagnetic fields. ~%"),
  printf(fh, "  // out_surf:       Output [BxBx_xl, BxBx_xr, ByBy_xl, ByBy_xr, BzBz_xl, BzBz_xr, BxBy_xl, BxBy_xr, BxBz_xl, BxBz_xr, ~%"),
  printf(fh, "  //                         BxBx_yl, BxBx_yr, ByBy_yl, ByBy_yr, BzBz_yl, BzBz_yr, BxBy_yl, BxBy_yr, ByBz_yl, ByBz_yr, ~%"),
  printf(fh, "  //                         BxBx_zl, BxBx_zr, ByBy_zl, ByBy_zr, BzBz_zl, BzBz_zr, BxBz_zl, BxBz_zr, ByBz_zl, ByBz_zr]. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  double *Bx_sq_xl = &out_surf[~a]; ~%", 0),
  printf(fh, "  double *Bx_sq_xr = &out_surf[~a]; ~%", 1),
  printf(fh, "  double *By_sq_xl = &out_surf[~a]; ~%", 2),
  printf(fh, "  double *By_sq_xr = &out_surf[~a]; ~%", 3),
  printf(fh, "  double *Bz_sq_xl = &out_surf[~a]; ~%", 4),
  printf(fh, "  double *Bz_sq_xr = &out_surf[~a]; ~%", 5),

  printf(fh, "  double *B_x_B_y_xl = &out_surf[~a]; ~%", 6),
  printf(fh, "  double *B_x_B_y_xr = &out_surf[~a]; ~%", 7),
  printf(fh, "  double *B_x_B_z_xl = &out_surf[~a]; ~%", 8),
  printf(fh, "  double *B_x_B_z_xr = &out_surf[~a]; ~%", 9),
  printf(fh, " ~%"),

  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  B_x_e : doExpand1(B_x, bC),
  B_y_e : doExpand1(B_y, bC),
  B_z_e : doExpand1(B_z, bC),

  B_x_l : subst(x=-1, B_x_e),
  B_y_l : subst(x=-1, B_y_e),
  B_z_l : subst(x=-1, B_z_e),

  B_x_r : subst(x=1, B_x_e),
  B_y_r : subst(x=1, B_y_e),
  B_z_r : subst(x=1, B_z_e),

  printf(fh, "  double B_x_l = ~a; ~%", float(expand(B_x_l))),
  printf(fh, "  double B_x_r = ~a; ~%", float(expand(B_x_r))),
  printf(fh, "  double B_y_l = ~a; ~%", float(expand(B_y_l))),
  printf(fh, "  double B_y_r = ~a; ~%", float(expand(B_y_r))),
  printf(fh, "  double B_z_l = ~a; ~%", float(expand(B_z_l))),
  printf(fh, "  double B_z_r = ~a; ~%", float(expand(B_z_r))),

  printf(fh, "  Bx_sq_xl[0] = B_x_l*B_x_l; ~%"),
  printf(fh, "  By_sq_xl[0] = B_y_l*B_y_l; ~%"),
  printf(fh, "  Bz_sq_xl[0] = B_z_l*B_z_l; ~%"),

  printf(fh, "  B_x_B_y_xl[0] = B_x_l*B_y_l; ~%"),
  printf(fh, "  B_x_B_z_xl[0] = B_x_l*B_z_l; ~%"),

  printf(fh, "  Bx_sq_xr[0] = B_x_r*B_x_r; ~%"),
  printf(fh, "  By_sq_xr[0] = B_y_r*B_y_r; ~%"),
  printf(fh, "  Bz_sq_xr[0] = B_z_r*B_z_r; ~%"),

  printf(fh, "  B_x_B_y_xr[0] = B_x_r*B_y_r; ~%"),
  printf(fh, "  B_x_B_z_xr[0] = B_x_r*B_z_r; ~%"),
  printf(fh, " ~%"),

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$

calcBB_surf(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, bSurfx, surfVarsy, bSurfy, surfVarsz, bSurfz, NSurf, 
   B_x_e, B_y_e, B_z_e, 
   B_x_xl_c, B_x_xr_c, B_y_xl_c, B_y_xr_c, B_z_xl_c, B_z_xr_c, 
   B_x_yl_c, B_x_yr_c, B_y_yl_c, B_y_yr_c, B_z_yl_c, B_z_yr_c, 
   B_x_zl_c, B_x_zr_c, B_y_zl_c, B_y_zr_c, B_z_zl_c, B_z_zr_c],

  kill(varsC, basisC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  surfVarsx : delete(x,varsC),
  bSurfx : basisFromVars(basisFun,surfVarsx,polyOrder),
  surfVarsy : delete(y,varsC),
  bSurfy : basisFromVars(basisFun,surfVarsy,polyOrder),
  if (cdim = 3) then (
    surfVarsz : delete(z,varsC),
    bSurfz : basisFromVars(basisFun,surfVarsz,polyOrder)
  ),

  /* Number of basis monomials. */
  NC : length(bC),
  NSurf : length(bSurfx), 

  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *em, double* GKYL_RESTRICT out_surf) ~%{ ~%", funcNm),
  printf(fh, "  // em:             Input electromagnetic fields. ~%"),
  printf(fh, "  // out_surf:       Output [BxBx_xl, BxBx_xr, ByBy_xl, ByBy_xr, BzBz_xl, BzBz_xr, BxBy_xl, BxBy_xr, BxBz_xl, BxBz_xr, ~%"),
  printf(fh, "  //                         BxBx_yl, BxBx_yr, ByBy_yl, ByBy_yr, BzBz_yl, BzBz_yr, BxBy_yl, BxBy_yr, ByBz_yl, ByBz_yr, ~%"),
  printf(fh, "  //                         BxBx_zl, BxBx_zr, ByBy_zl, ByBy_zr, BzBz_zl, BzBz_zr, BxBz_zl, BxBz_zr, ByBz_zl, ByBz_zr]. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  double *Bx_sq_xl = &out_surf[~a]; ~%", 0*NSurf),
  printf(fh, "  double *Bx_sq_xr = &out_surf[~a]; ~%", 1*NSurf),
  printf(fh, "  double *By_sq_xl = &out_surf[~a]; ~%", 2*NSurf),
  printf(fh, "  double *By_sq_xr = &out_surf[~a]; ~%", 3*NSurf),
  printf(fh, "  double *Bz_sq_xl = &out_surf[~a]; ~%", 4*NSurf),
  printf(fh, "  double *Bz_sq_xr = &out_surf[~a]; ~%", 5*NSurf),

  printf(fh, "  double *B_x_B_y_xl = &out_surf[~a]; ~%", 6*NSurf),
  printf(fh, "  double *B_x_B_y_xr = &out_surf[~a]; ~%", 7*NSurf),
  printf(fh, "  double *B_x_B_z_xl = &out_surf[~a]; ~%", 8*NSurf),
  printf(fh, "  double *B_x_B_z_xr = &out_surf[~a]; ~%", 9*NSurf),
  printf(fh, " ~%"),

  printf(fh, "  double *Bx_sq_yl = &out_surf[~a]; ~%", 10*NSurf),
  printf(fh, "  double *Bx_sq_yr = &out_surf[~a]; ~%", 11*NSurf),
  printf(fh, "  double *By_sq_yl = &out_surf[~a]; ~%", 12*NSurf),
  printf(fh, "  double *By_sq_yr = &out_surf[~a]; ~%", 13*NSurf),
  printf(fh, "  double *Bz_sq_yl = &out_surf[~a]; ~%", 14*NSurf),
  printf(fh, "  double *Bz_sq_yr = &out_surf[~a]; ~%", 15*NSurf),

  printf(fh, "  double *B_x_B_y_yl = &out_surf[~a]; ~%", 16*NSurf),
  printf(fh, "  double *B_x_B_y_yr = &out_surf[~a]; ~%", 17*NSurf),
  printf(fh, "  double *B_y_B_z_yl = &out_surf[~a]; ~%", 18*NSurf),
  printf(fh, "  double *B_y_B_z_yr = &out_surf[~a]; ~%", 19*NSurf),
  printf(fh, " ~%"),

  if (cdim = 3) then (
    printf(fh, "  double *Bx_sq_zl = &out_surf[~a]; ~%", 20*NSurf),
    printf(fh, "  double *Bx_sq_zr = &out_surf[~a]; ~%", 21*NSurf),
    printf(fh, "  double *By_sq_zl = &out_surf[~a]; ~%", 22*NSurf),
    printf(fh, "  double *By_sq_zr = &out_surf[~a]; ~%", 23*NSurf),
    printf(fh, "  double *Bz_sq_zl = &out_surf[~a]; ~%", 24*NSurf),
    printf(fh, "  double *Bz_sq_zr = &out_surf[~a]; ~%", 25*NSurf),

    printf(fh, "  double *B_x_B_z_zl = &out_surf[~a]; ~%", 26*NSurf),
    printf(fh, "  double *B_x_B_z_zr = &out_surf[~a]; ~%", 27*NSurf),
    printf(fh, "  double *B_y_B_z_zl = &out_surf[~a]; ~%", 28*NSurf),
    printf(fh, "  double *B_y_B_z_zr = &out_surf[~a]; ~%", 29*NSurf),
    printf(fh, " ~%")
  ),

  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  B_x_e : doExpand1(B_x, bC),
  B_y_e : doExpand1(B_y, bC),
  B_z_e : doExpand1(B_z, bC),

  B_x_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, B_x_e)),
  B_y_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, B_y_e)),
  B_z_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, B_z_e)),

  B_x_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, B_x_e)),
  B_y_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, B_y_e)),
  B_z_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, B_z_e)),

  B_x_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, B_x_e)),
  B_y_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, B_y_e)),
  B_z_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, B_z_e)),

  B_x_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, B_x_e)),
  B_y_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, B_y_e)),
  B_z_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, B_z_e)),

  if (cdim = 3) then (
    B_x_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, B_x_e)),
    B_y_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, B_y_e)),
    B_z_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, B_z_e)),

    B_x_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, B_x_e)),
    B_y_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, B_y_e)),
    B_z_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, B_z_e))
  ),

  /* Temporary arrays for storing surface expansions of B_i at x surfaces */
  printf(fh, "  double B_x_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_x_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_y_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_y_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_z_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_z_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  writeCExprs1(B_x_xl, B_x_xl_c), 
  writeCExprs1(B_x_xr, B_x_xr_c), 
  writeCExprs1(B_y_xl, B_y_xl_c), 
  writeCExprs1(B_y_xr, B_y_xr_c), 
  writeCExprs1(B_z_xl, B_z_xl_c), 
  writeCExprs1(B_z_xr, B_z_xr_c), 

  if (cdim = 2) then (
    printf(fh, "  // Calculate B_i B_j on the left x interface. ~%"),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_xl, B_x_xl, Bx_sq_xl); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_y_xl, B_y_xl, By_sq_xl); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_z_xl, B_z_xl, Bz_sq_xl); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_xl, B_y_xl, B_x_B_y_xl); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_xl, B_z_xl, B_x_B_z_xl); ~%", cdim-1, polyOrder),
    printf(fh, " ~%"),  

    printf(fh, "  // Calculate B_i B_j on the right x interface. ~%"),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_xr, B_x_xr, Bx_sq_xr); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_y_xr, B_y_xr, By_sq_xr); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_z_xr, B_z_xr, Bz_sq_xr); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_xr, B_y_xr, B_x_B_y_xr); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_xr, B_z_xr, B_x_B_z_xr); ~%", cdim-1, polyOrder),
    printf(fh, " ~%")
  )
  else (
    printf(fh, "  // Calculate B_i B_j on the left x interface. ~%"),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_xl, B_x_xl, Bx_sq_xl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_xl, B_y_xl, By_sq_xl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_z_xl, B_z_xl, Bz_sq_xl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_xl, B_y_xl, B_x_B_y_xl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_xl, B_z_xl, B_x_B_z_xl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%"),  

    printf(fh, "  // Calculate B_i B_j on the right x interface. ~%"),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_xr, B_x_xr, Bx_sq_xr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_xr, B_y_xr, By_sq_xr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_z_xr, B_z_xr, Bz_sq_xr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_xr, B_y_xr, B_x_B_y_xr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_xr, B_z_xr, B_x_B_z_xr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%")
  ),

  /* Temporary arrays for storing surface expansions of B_i at y surfaces */
  printf(fh, "  double B_x_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_x_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_y_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_y_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_z_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double B_z_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  writeCExprs1(B_x_yl, B_x_yl_c), 
  writeCExprs1(B_x_yr, B_x_yr_c), 
  writeCExprs1(B_y_yl, B_y_yl_c), 
  writeCExprs1(B_y_yr, B_y_yr_c), 
  writeCExprs1(B_z_yl, B_z_yl_c), 
  writeCExprs1(B_z_yr, B_z_yr_c), 

  if (cdim = 2) then (
    printf(fh, "  // Calculate B_i B_j on the left y interface. ~%"),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_yl, B_x_yl, Bx_sq_yl); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_y_yl, B_y_yl, By_sq_yl); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_z_yl, B_z_yl, Bz_sq_yl); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_yl, B_y_yl, B_x_B_y_yl); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_y_yl, B_z_yl, B_y_B_z_yl); ~%", cdim-1, polyOrder),
    printf(fh, " ~%"),  

    printf(fh, "  // Calculate B_i B_j on the right y interface. ~%"),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_yr, B_x_yr, Bx_sq_yr); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_y_yr, B_y_yr, By_sq_yr); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_z_yr, B_z_yr, Bz_sq_yr); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_x_yr, B_y_yr, B_x_B_y_yr); ~%", cdim-1, polyOrder),
    printf(fh, "  binop_mul_~ad_ser_p~a(B_y_yr, B_z_yr, B_y_B_z_yr); ~%", cdim-1, polyOrder),
    printf(fh, " ~%")
  )
  else (
    printf(fh, "  // Calculate B_i B_j on the left y interface. ~%"),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_yl, B_x_yl, Bx_sq_yl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_yl, B_y_yl, By_sq_yl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_z_yl, B_z_yl, Bz_sq_yl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_yl, B_y_yl, B_x_B_y_yl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_yl, B_z_yl, B_y_B_z_yl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%"),  

    printf(fh, "  // Calculate B_i B_j on the right y interface. ~%"),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_yr, B_x_yr, Bx_sq_yr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_yr, B_y_yr, By_sq_yr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_z_yr, B_z_yr, Bz_sq_yr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_yr, B_y_yr, B_x_B_y_yr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_yr, B_z_yr, B_y_B_z_yr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%")
  ),

  if (cdim = 3) then (
    /* Temporary arrays for storing surface expansions of B_i at z surfaces */
    printf(fh, "  double B_x_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double B_x_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double B_y_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double B_y_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double B_z_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double B_z_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, " ~%"),

    writeCExprs1(B_x_zl, B_x_zl_c), 
    writeCExprs1(B_x_zr, B_x_zr_c), 
    writeCExprs1(B_y_zl, B_y_zl_c), 
    writeCExprs1(B_y_zr, B_y_zr_c), 
    writeCExprs1(B_z_zl, B_z_zl_c), 
    writeCExprs1(B_z_zr, B_z_zr_c), 

    printf(fh, "  // Calculate B_i B_j on the left z interface. ~%"),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_zl, B_x_zl, Bx_sq_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_zl, B_y_zl, By_sq_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_z_zl, B_z_zl, Bz_sq_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_zl, B_z_zl, B_x_B_z_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_zl, B_z_zl, B_y_B_z_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%"),  

    printf(fh, "  // Calculate B_i B_j on the right z interface. ~%"),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_zr, B_x_zr, Bx_sq_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_zr, B_y_zr, By_sq_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_z_zr, B_z_zr, Bz_sq_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_x_zr, B_z_zr, B_x_B_z_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(B_y_zr, B_z_zr, B_y_B_z_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%")
  ),

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$

/* Special set of kernels which compute the surface magnetic field unit tensor and unit vector 
   in 1D, which can be done with simple division without the need for a linear solve. 
   Note that in 1D, there is no need for a positivity check either, as |B|^2 is pointwise
   and thus guaranteed to be positive definite. */
set_surf_bvar_1d(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, const double *BB_surf, int* cell_avg_magB2_surf) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count:   integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A:       preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:     preallocated RHS vector. ~%"),
  printf(fh, "  // BB_surf: Surface B_i B_j [BxBx_xl, BxBx_xr, ByBy_xl, ByBy_xr, BzBz_xl, BzBz_xr, BxBy_xl, BxBy_xr, BxBz_xl, BxBz_xr, ~%"),
  printf(fh, "  //                           BxBx_yl, BxBx_yr, ByBy_yl, ByBy_yr, BzBz_yl, BzBz_yr, BxBy_yl, BxBy_yr, ByBz_yl, ByBz_yr, ~%"),
  printf(fh, "  //                           BxBx_zl, BxBx_zr, ByBy_zl, ByBy_zr, BzBz_zl, BzBz_zr, BxBz_zl, BxBz_zr, ByBz_zl, ByBz_zr]. ~%"),
  printf(fh, "  // cell_avg_magB2_surf:      Output flag for cell average if 1/|B|^2 at a surface only used cell averages. ~%"),
  printf(fh, "~%"),

  /* Surface magnetic field unit vector and unit tensor are organized as:
     [bx_xl, bx_xr, bxbx_xl, bxbx_xr, bxby_xl, bxby_xr, bxbz_xl, bxbz_xr, 
      by_yl, by_yr, byby_yl, byby_yr, bxby_yl, bxby_yr, bybz_yl, bybz_yr, 
      bz_zl, bz_zr, bzbz_zl, bzbz_zr, bxbz_zl, bxbz_zr, bybz_zl, bybz_zr] */

  printf(fh, "  struct gkyl_mat rhs_bxbx_xl = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbx_xr = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_xl = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_xr = gkyl_nmat_get(rhs, count+3); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbz_xl = gkyl_nmat_get(rhs, count+4); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbz_xr = gkyl_nmat_get(rhs, count+5); ~%"),

  printf(fh, "  // Clear rhs for each component of surface magnetic field unit tensor and vector being solved for ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxbx_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxbx_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxby_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxby_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxbz_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxbz_xr, 0.0); ~%"),

  printf(fh, "  const double *Bx_sq_xl = &BB_surf[~a]; ~%", 0),
  printf(fh, "  const double *Bx_sq_xr = &BB_surf[~a]; ~%", 1),
  printf(fh, "  const double *By_sq_xl = &BB_surf[~a]; ~%", 2),
  printf(fh, "  const double *By_sq_xr = &BB_surf[~a]; ~%", 3),
  printf(fh, "  const double *Bz_sq_xl = &BB_surf[~a]; ~%", 4),
  printf(fh, "  const double *Bz_sq_xr = &BB_surf[~a]; ~%", 5),

  printf(fh, "  const double *B_x_B_y_xl = &BB_surf[~a]; ~%", 6),
  printf(fh, "  const double *B_x_B_y_xr = &BB_surf[~a]; ~%", 7),
  printf(fh, "  const double *B_x_B_z_xl = &BB_surf[~a]; ~%", 8),
  printf(fh, "  const double *B_x_B_z_xr = &BB_surf[~a]; ~%", 9),

  printf(fh, "  int *cell_avg_magB2_xl = &cell_avg_magB2_surf[~a]; ~%", 0),
  printf(fh, "  int *cell_avg_magB2_xr = &cell_avg_magB2_surf[~a]; ~%", 1),
  printf(fh, " ~%"),

  printf(fh, "  double magB2_xl = Bx_sq_xl[0] + By_sq_xl[0] + Bz_sq_xl[0]; ~%"),
  printf(fh, "  double magB2_xr = Bx_sq_xr[0] + By_sq_xr[0] + Bz_sq_xr[0]; ~%"),
  printf(fh, " ~%"),

  /* Because evaluation of |B|^2 is just a number in 1D, it is guaranteed to be positive definite */
  printf(fh, "  cell_avg_magB2_xl[0] = 0; ~%"),
  printf(fh, "  cell_avg_magB2_xr[0] = 0; ~%"),
  printf(fh, " ~%"),

  printf(fh, "  double bxbx_xl = Bx_sq_xl[0]/magB2_xl; ~%"),
  printf(fh, "  double bxby_xl = B_x_B_y_xl[0]/magB2_xl; ~%"),
  printf(fh, "  double bxbz_xl = B_x_B_z_xl[0]/magB2_xl; ~%"),

  printf(fh, "  double bxbx_xr = Bx_sq_xr[0]/magB2_xr; ~%"),
  printf(fh, "  double bxby_xr = B_x_B_y_xr[0]/magB2_xr; ~%"),
  printf(fh, "  double bxbz_xr = B_x_B_z_xr[0]/magB2_xr; ~%"),

  printf(fh, "  gkyl_mat_set(&rhs_bxbx_xl,0,0,bxbx_xl); ~%"),
  printf(fh, "  gkyl_mat_set(&rhs_bxbx_xr,0,0,bxbx_xr); ~%"),
  printf(fh, "  gkyl_mat_set(&rhs_bxby_xl,0,0,bxby_xl); ~%"),
  printf(fh, "  gkyl_mat_set(&rhs_bxby_xr,0,0,bxby_xr); ~%"),
  printf(fh, "  gkyl_mat_set(&rhs_bxbz_xl,0,0,bxbz_xl); ~%"),
  printf(fh, "  gkyl_mat_set(&rhs_bxbz_xr,0,0,bxbz_xr); ~%"),

  printf(fh, "} ~%")
)$

/* Special set of kernels which compute the surface magnetic field unit tensor and unit vector 
   for p=1 in 2D and 3D, which can be done with basis_inv without the need for a linear solve. 
   Note that the positivity check for |B|^2 is done *per surface*. */
set_surf_bvar_p1(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, surfVarsx, bSurfx, surfVarsy, bSurfy, surfVarsz, bSurfz, NSurf, 
   unit, nodes, 
   magB2_xl_e, magB2_xr_e, magB2_yl_e, magB2_yr_e, magB2_zl_e, magB2_zr_e, 
   magB2_xl_Corners, magB2_xr_Corners, magB2_yl_Corners, magB2_yr_Corners, magB2_zl_Corners, magB2_zr_Corners],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  surfVarsx : delete(x,varsC),
  bSurfx : basisFromVars(basisFun,surfVarsx,polyOrder),
  surfVarsy : delete(y,varsC),
  bSurfy : basisFromVars(basisFun,surfVarsy,polyOrder),
  if (cdim = 3) then (
    surfVarsz : delete(z,varsC),
    bSurfz : basisFromVars(basisFun,surfVarsz,polyOrder)
  ),

  /* Number of basis monomials. */
  NC : length(bC),
  NSurf : length(bSurfx), 

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_inv.h> ~%", basisFun, cdim-1, polyOrder),
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, const double *BB_surf, int* cell_avg_magB2_surf) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count:   integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A:       preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:     preallocated RHS vector. ~%"),
  printf(fh, "  // BB_surf: Surface B_i B_j [BxBx_xl, BxBx_xr, ByBy_xl, ByBy_xr, BzBz_xl, BzBz_xr, BxBy_xl, BxBy_xr, BxBz_xl, BxBz_xr, ~%"),
  printf(fh, "  //                           BxBx_yl, BxBx_yr, ByBy_yl, ByBy_yr, BzBz_yl, BzBz_yr, BxBy_yl, BxBy_yr, ByBz_yl, ByBz_yr, ~%"),
  printf(fh, "  //                           BxBx_zl, BxBx_zr, ByBy_zl, ByBy_zr, BzBz_zl, BzBz_zr, BxBz_zl, BxBz_zr, ByBz_zl, ByBz_zr]. ~%"),
  printf(fh, "  // cell_avg_magB2_surf:      Output flag for cell average if 1/|B|^2 at a surface only used cell averages. ~%"),
  printf(fh, "~%"),

  /* Surface magnetic field unit vector and unit tensor are organized as:
     [bx_xl, bx_xr, bxbx_xl, bxbx_xr, bxby_xl, bxby_xr, bxbz_xl, bxbz_xr, 
      by_yl, by_yr, byby_yl, byby_yr, bxby_yl, bxby_yr, bybz_yl, bybz_yr, 
      bz_zl, bz_zr, bzbz_zl, bzbz_zr, bxbz_zl, bxbz_zr, bybz_zl, bybz_zr] */

  printf(fh, "  struct gkyl_mat rhs_bxbx_xl = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbx_xr = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_xl = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_xr = gkyl_nmat_get(rhs, count+3); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbz_xl = gkyl_nmat_get(rhs, count+4); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbz_xr = gkyl_nmat_get(rhs, count+5); ~%"),

  printf(fh, "  gkyl_mat_clear(&rhs_bxbx_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxbx_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxby_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxby_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxbz_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxbz_xr, 0.0); ~%"),

  printf(fh, "  const double *Bx_sq_xl = &BB_surf[~a]; ~%", 0*NSurf),
  printf(fh, "  const double *Bx_sq_xr = &BB_surf[~a]; ~%", 1*NSurf),
  printf(fh, "  const double *By_sq_xl = &BB_surf[~a]; ~%", 2*NSurf),
  printf(fh, "  const double *By_sq_xr = &BB_surf[~a]; ~%", 3*NSurf),
  printf(fh, "  const double *Bz_sq_xl = &BB_surf[~a]; ~%", 4*NSurf),
  printf(fh, "  const double *Bz_sq_xr = &BB_surf[~a]; ~%", 5*NSurf),

  printf(fh, "  const double *B_x_B_y_xl = &BB_surf[~a]; ~%", 6*NSurf),
  printf(fh, "  const double *B_x_B_y_xr = &BB_surf[~a]; ~%", 7*NSurf),
  printf(fh, "  const double *B_x_B_z_xl = &BB_surf[~a]; ~%", 8*NSurf),
  printf(fh, "  const double *B_x_B_z_xr = &BB_surf[~a]; ~%", 9*NSurf),

  printf(fh, "  int *cell_avg_magB2_xl = &cell_avg_magB2_surf[~a]; ~%", 0),
  printf(fh, "  int *cell_avg_magB2_xr = &cell_avg_magB2_surf[~a]; ~%", 1),
  printf(fh, " ~%"),

  printf(fh, "  struct gkyl_mat rhs_byby_yl = gkyl_nmat_get(rhs, count+6); ~%"),
  printf(fh, "  struct gkyl_mat rhs_byby_yr = gkyl_nmat_get(rhs, count+7); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_yl = gkyl_nmat_get(rhs, count+8); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_yr = gkyl_nmat_get(rhs, count+9); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bybz_yl = gkyl_nmat_get(rhs, count+10); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bybz_yr = gkyl_nmat_get(rhs, count+11); ~%"),

  printf(fh, "  gkyl_mat_clear(&rhs_byby_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_byby_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxby_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bxby_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bybz_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_bybz_yr, 0.0); ~%"),

  printf(fh, "  const double *Bx_sq_yl = &BB_surf[~a]; ~%", 10*NSurf),
  printf(fh, "  const double *Bx_sq_yr = &BB_surf[~a]; ~%", 11*NSurf),
  printf(fh, "  const double *By_sq_yl = &BB_surf[~a]; ~%", 12*NSurf),
  printf(fh, "  const double *By_sq_yr = &BB_surf[~a]; ~%", 13*NSurf),
  printf(fh, "  const double *Bz_sq_yl = &BB_surf[~a]; ~%", 14*NSurf),
  printf(fh, "  const double *Bz_sq_yr = &BB_surf[~a]; ~%", 15*NSurf),

  printf(fh, "  const double *B_x_B_y_yl = &BB_surf[~a]; ~%", 16*NSurf),
  printf(fh, "  const double *B_x_B_y_yr = &BB_surf[~a]; ~%", 17*NSurf),
  printf(fh, "  const double *B_y_B_z_yl = &BB_surf[~a]; ~%", 18*NSurf),
  printf(fh, "  const double *B_y_B_z_yr = &BB_surf[~a]; ~%", 19*NSurf),

  printf(fh, "  int *cell_avg_magB2_yl = &cell_avg_magB2_surf[~a]; ~%", 2),
  printf(fh, "  int *cell_avg_magB2_yr = &cell_avg_magB2_surf[~a]; ~%", 3),
  printf(fh, " ~%"),

  if (cdim = 3) then (
    printf(fh, "  struct gkyl_mat rhs_bzbz_zl = gkyl_nmat_get(rhs, count+12); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bzbz_zr = gkyl_nmat_get(rhs, count+13); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bxbz_zl = gkyl_nmat_get(rhs, count+14); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bxbz_zr = gkyl_nmat_get(rhs, count+15); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bybz_zl = gkyl_nmat_get(rhs, count+16); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bybz_zr = gkyl_nmat_get(rhs, count+17); ~%"),

    printf(fh, "  gkyl_mat_clear(&rhs_bzbz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_bzbz_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_bxbz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_bxbz_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_bybz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_bybz_zr, 0.0); ~%"),

    printf(fh, "  const double *Bx_sq_zl = &BB_surf[~a]; ~%", 20*NSurf),
    printf(fh, "  const double *Bx_sq_zr = &BB_surf[~a]; ~%", 21*NSurf),
    printf(fh, "  const double *By_sq_zl = &BB_surf[~a]; ~%", 22*NSurf),
    printf(fh, "  const double *By_sq_zr = &BB_surf[~a]; ~%", 23*NSurf),
    printf(fh, "  const double *Bz_sq_zl = &BB_surf[~a]; ~%", 24*NSurf),
    printf(fh, "  const double *Bz_sq_zr = &BB_surf[~a]; ~%", 25*NSurf),

    printf(fh, "  const double *B_x_B_z_zl = &BB_surf[~a]; ~%", 26*NSurf),
    printf(fh, "  const double *B_x_B_z_zr = &BB_surf[~a]; ~%", 27*NSurf),
    printf(fh, "  const double *B_y_B_z_zl = &BB_surf[~a]; ~%", 28*NSurf),
    printf(fh, "  const double *B_y_B_z_zr = &BB_surf[~a]; ~%", 29*NSurf),

    printf(fh, "  int *cell_avg_magB2_zl = &cell_avg_magB2_surf[~a]; ~%", 4),
    printf(fh, "  int *cell_avg_magB2_zr = &cell_avg_magB2_surf[~a]; ~%", 5),
    printf(fh, " ~%")
  ),

  printf(fh, "  double magB2_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double magB2_xr[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double magB2_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double magB2_yr[~a] = {0.0}; ~%", NSurf),

  if (cdim = 3) then (
    printf(fh, "  double magB2_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double magB2_zr[~a] = {0.0}; ~%", NSurf)
  ),

  for i : 1 thru NSurf do (
    printf(fh, "  magB2_xl[~a] = Bx_sq_xl[~a] + By_sq_xl[~a] + Bz_sq_xl[~a]; ~%", i-1, i-1, i-1, i-1),
    printf(fh, "  magB2_xr[~a] = Bx_sq_xr[~a] + By_sq_xr[~a] + Bz_sq_xr[~a]; ~%", i-1, i-1, i-1, i-1),
    printf(fh, "  magB2_yl[~a] = Bx_sq_yl[~a] + By_sq_yl[~a] + Bz_sq_yl[~a]; ~%", i-1, i-1, i-1, i-1),
    printf(fh, "  magB2_yr[~a] = Bx_sq_yr[~a] + By_sq_yr[~a] + Bz_sq_yr[~a]; ~%", i-1, i-1, i-1, i-1),
    if (cdim = 3) then (
      printf(fh, "  magB2_zl[~a] = Bx_sq_zl[~a] + By_sq_zl[~a] + Bz_sq_zl[~a]; ~%", i-1, i-1, i-1, i-1),
      printf(fh, "  magB2_zr[~a] = Bx_sq_zr[~a] + By_sq_zr[~a] + Bz_sq_zr[~a]; ~%", i-1, i-1, i-1, i-1)
    )
  ),
  /* For p = 1 |B|^2 guaranteed to be positive if it's positive at the
     corners. For p = 2, we use the positivity control points (-1, 0, 1) */
  printf(fh, "  // If |B|^2 < 0 at control points along a surface, only use cell average to get 1/|B|^2. ~%"),
  printf(fh, "  // Each surface is checked independently. ~%"),
  unit : calcInnerProdList(surfVarsx, 1, bSurfx, 1.0), /* Normalization for cell average */
  nodes : getNodes(basisFun, cdim-1, polyOrder),

  magB2_xl_e : doExpand1(magB2_xl, bSurfx),
  magB2_xr_e : doExpand1(magB2_xr, bSurfx),
  magB2_yl_e : doExpand1(magB2_yl, bSurfy),
  magB2_yr_e : doExpand1(magB2_yr, bSurfy),

  magB2_xl_Corners : expand(float(evAtNodes(magB2_xl_e,nodes,surfVarsx))),
  magB2_xr_Corners : expand(float(evAtNodes(magB2_xr_e,nodes,surfVarsx))),
  magB2_yl_Corners : expand(float(evAtNodes(magB2_yl_e,nodes,surfVarsy))),
  magB2_yr_Corners : expand(float(evAtNodes(magB2_yr_e,nodes,surfVarsy))),

  printf(fh, "  int cell_avg_xl = 0;~%"),
  printf(fh, "  double bxbx_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double bxby_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double bxbz_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  printf(fh, "  int cell_avg_xr = 0;~%"),
  printf(fh, "  double bxbx_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double bxby_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double bxbz_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  printf(fh, "  int cell_avg_yl = 0;~%"),
  printf(fh, "  double byby_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double bxby_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double bybz_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  printf(fh, "  int cell_avg_yr = 0;~%"),
  printf(fh, "  double byby_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double bxby_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double bybz_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  if (cdim = 3) then (
    magB2_zl_e : doExpand1(magB2_zl, bSurfz),
    magB2_zr_e : doExpand1(magB2_zr, bSurfz),

    magB2_zl_Corners : expand(float(evAtNodes(magB2_zl_e,nodes,surfVarsz))),
    magB2_zr_Corners : expand(float(evAtNodes(magB2_zr_e,nodes,surfVarsz))),

    printf(fh, "  int cell_avg_zl = 0;~%"),
    printf(fh, "  double bzbz_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double bxbz_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double bybz_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, " ~%"),

    printf(fh, "  int cell_avg_zr = 0;~%"),
    printf(fh, "  double bzbz_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double bxbz_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double bybz_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, " ~%")
  ),

  for i : 1 thru length(nodes) do (
    printf(fh, "  if (~a < 0.0) cell_avg_xl = 1; ~%", magB2_xl_Corners[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_xr = 1; ~%", magB2_xr_Corners[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_yl = 1; ~%", magB2_yl_Corners[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_yr = 1; ~%", magB2_yr_Corners[i]),
    if (cdim = 3) then (
      printf(fh, "  if (~a < 0.0) cell_avg_zl = 1; ~%", magB2_zl_Corners[i]),
      printf(fh, "  if (~a < 0.0) cell_avg_zr = 1; ~%", magB2_zr_Corners[i])
    )
  ),  
  printf(fh, " ~%"),
  printf(fh, "  cell_avg_magB2_xl[0] = cell_avg_xl; ~%"),
  printf(fh, "  cell_avg_magB2_xr[0] = cell_avg_xr; ~%"),
  printf(fh, "  cell_avg_magB2_yl[0] = cell_avg_yl; ~%"),
  printf(fh, "  cell_avg_magB2_yr[0] = cell_avg_yr; ~%"),
  if (cdim = 3) then (
    printf(fh, "  cell_avg_magB2_zl[0] = cell_avg_zl; ~%"),
    printf(fh, "  cell_avg_magB2_zr[0] = cell_avg_zr; ~%")
  ),
  printf(fh, " ~%"),

  printf(fh, "  double magB2_inv_xl[~a] = {0.0}; ~%~%", NSurf),
  printf(fh, "  if (cell_avg_xl) { ~%"),
  printf(fh, "  magB2_inv_xl[0] = ~a/magB2_xl[0]; ~%", float(expand(unit[1]*unit[1]))),
  printf(fh, "  } else { ~%"),
  printf(fh, "  ~a_~ax_p~a_inv(magB2_xl, magB2_inv_xl); ~%", basisFun, cdim-1, polyOrder),
  printf(fh, "  } ~%"),

  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_xl, Bx_sq_xl, bxbx_xl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_xl, B_x_B_y_xl, bxby_xl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_xl, B_x_B_z_xl, bxbz_xl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double magB2_inv_xr[~a] = {0.0}; ~%~%", NSurf),
  printf(fh, "  if (cell_avg_xr) { ~%"),
  printf(fh, "  magB2_inv_xr[0] = ~a/magB2_xr[0]; ~%", float(expand(unit[1]*unit[1]))),
  printf(fh, "  } else { ~%"),
  printf(fh, "  ~a_~ax_p~a_inv(magB2_xr, magB2_inv_xr); ~%", basisFun, cdim-1, polyOrder),
  printf(fh, "  } ~%"),

  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_xr, Bx_sq_xr, bxbx_xr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_xr, B_x_B_y_xr, bxby_xr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_xr, B_x_B_z_xr, bxbz_xr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double magB2_inv_yl[~a] = {0.0}; ~%~%", NSurf),
  printf(fh, "  if (cell_avg_yl) { ~%"),
  printf(fh, "  magB2_inv_yl[0] = ~a/magB2_yl[0]; ~%", float(expand(unit[1]*unit[1]))),
  printf(fh, "  } else { ~%"),
  printf(fh, "  ~a_~ax_p~a_inv(magB2_yl, magB2_inv_yl); ~%", basisFun, cdim-1, polyOrder),
  printf(fh, "  } ~%"),

  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_yl, By_sq_yl, byby_yl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_yl, B_x_B_y_yl, bxby_yl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_yl, B_y_B_z_yl, bybz_yl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, " ~%"),

  printf(fh, "  double magB2_inv_yr[~a] = {0.0}; ~%~%", NSurf),
  printf(fh, "  if (cell_avg_yr) { ~%"),
  printf(fh, "  magB2_inv_yr[0] = ~a/magB2_yr[0]; ~%", float(expand(unit[1]*unit[1]))),
  printf(fh, "  } else { ~%"),
  printf(fh, "  ~a_~ax_p~a_inv(magB2_yr, magB2_inv_yr); ~%", basisFun, cdim-1, polyOrder),
  printf(fh, "  } ~%"),

  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_yr, By_sq_yr, byby_yr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_yr, B_x_B_y_yr, bxby_yr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_yr, B_y_B_z_yr, bybz_yr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, " ~%"),

  if (cdim = 3) then (
    printf(fh, "  double magB2_inv_zl[~a] = {0.0}; ~%~%", NSurf),
    printf(fh, "  if (cell_avg_zl) { ~%"),
    printf(fh, "  magB2_inv_zl[0] = ~a/magB2_zl[0]; ~%", float(expand(unit[1]*unit[1]))),
    printf(fh, "  } else { ~%"),
    printf(fh, "  ~a_~ax_p~a_inv(magB2_zl, magB2_inv_zl); ~%", basisFun, cdim-1, polyOrder),
    printf(fh, "  } ~%"),

    printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_zl, Bz_sq_zl, bzbz_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_zl, B_x_B_z_zl, bxbz_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_zl, B_y_B_z_zl, bybz_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%"),

    printf(fh, "  double magB2_inv_zr[~a] = {0.0}; ~%~%", NSurf),
    printf(fh, "  if (cell_avg_zr) { ~%"),
    printf(fh, "  magB2_inv_zr[0] = ~a/magB2_zr[0]; ~%", float(expand(unit[1]*unit[1]))),
    printf(fh, "  } else { ~%"),
    printf(fh, "  ~a_~ax_p~a_inv(magB2_zr, magB2_inv_zr); ~%", basisFun, cdim-1, polyOrder),
    printf(fh, "  } ~%"), 

    printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_zr, Bz_sq_zr, bzbz_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_zr, B_x_B_z_zr, bxbz_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(magB2_inv_zr, B_y_B_z_zr, bybz_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%")
  ),

  for i : 1 thru NSurf do (
    printf(fh,"  gkyl_mat_set(&rhs_bxbx_xl,~a,0,bxbx_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxbx_xr,~a,0,bxbx_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxby_xl,~a,0,bxby_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxby_xr,~a,0,bxby_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxbz_xl,~a,0,bxbz_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxbz_xr,~a,0,bxbz_xr[~a]); ~%", i-1, i-1),
    printf(fh, " ~%"), 
    printf(fh,"  gkyl_mat_set(&rhs_byby_yl,~a,0,byby_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_byby_yr,~a,0,byby_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxby_yl,~a,0,bxby_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxby_yr,~a,0,bxby_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bybz_yl,~a,0,bybz_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bybz_yr,~a,0,bybz_yr[~a]); ~%", i-1, i-1),
    printf(fh, " ~%"), 
    if (cdim = 3) then (
      printf(fh,"  gkyl_mat_set(&rhs_bzbz_zl,~a,0,bzbz_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bzbz_zr,~a,0,bzbz_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bxbz_zl,~a,0,bxbz_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bxbz_zr,~a,0,bxbz_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bybz_zl,~a,0,bybz_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bybz_zr,~a,0,bybz_zr[~a]); ~%", i-1, i-1),
      printf(fh, " ~%")
    )
  ),
  printf(fh, "} ~%")
)$

/* Kernels which compute the surface magnetic field unit tensor and unit vector 
   for p>1 in 2D and 3D, by constructing the linear system for weak division. 
   Note that the positivity check for |B|^2 is done *per surface*. */
set_surf_bvar(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, surfVarsx, bSurfx, surfVarsy, bSurfy, surfVarsz, bSurfz, NSurf, 
   unit, nodes, 
   magB2_xl_e, magB2_xr_e, magB2_yl_e, magB2_yr_e, magB2_zl_e, magB2_zr_e, 
   magB2_xl_Corners, magB2_xr_Corners, magB2_yl_Corners, magB2_yr_Corners, magB2_zl_Corners, magB2_zr_Corners, 
   uxe, uxn, eq_magB2_xl, E_magB2_xl, eq_magB2_xr, E_magB2_xr, 
   uye, uyn, eq_magB2_yl, E_magB2_yl, eq_magB2_yr, E_magB2_yr, 
   uze, uzn, eq_magB2_zl, E_magB2_zl, eq_magB2_zr, E_magB2_zr],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  surfVarsx : delete(x,varsC),
  bSurfx : basisFromVars(basisFun,surfVarsx,polyOrder),
  surfVarsy : delete(y,varsC),
  bSurfy : basisFromVars(basisFun,surfVarsy,polyOrder),
  if (cdim = 3) then (
    surfVarsz : delete(z,varsC),
    bSurfz : basisFromVars(basisFun,surfVarsz,polyOrder)
  ),

  /* Number of basis monomials. */
  NC : length(bC),
  NSurf : length(bSurfx), 

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, const double *BB_surf, int* cell_avg_magB2_surf) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count:   integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A:       preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:     preallocated RHS vector. ~%"),
  printf(fh, "  // BB_surf: Surface B_i B_j [BxBx_xl, BxBx_xr, ByBy_xl, ByBy_xr, BzBz_xl, BzBz_xr, BxBy_xl, BxBy_xr, BxBz_xl, BxBz_xr, ~%"),
  printf(fh, "  //                           BxBx_yl, BxBx_yr, ByBy_yl, ByBy_yr, BzBz_yl, BzBz_yr, BxBy_yl, BxBy_yr, ByBz_yl, ByBz_yr, ~%"),
  printf(fh, "  //                           BxBx_zl, BxBx_zr, ByBy_zl, ByBy_zr, BzBz_zl, BzBz_zr, BxBz_zl, BxBz_zr, ByBz_zl, ByBz_zr]. ~%"),
  printf(fh, "  // cell_avg_magB2_surf:      Output flag for cell average if 1/|B|^2 at a surface only used cell averages. ~%"),
  printf(fh, "~%"),

  /* Surface magnetic field unit vector and unit tensor are organized as:
     [bx_xl, bx_xr, bxbx_xl, bxbx_xr, bxby_xl, bxby_xr, bxbz_xl, bxbz_xr, 
      by_yl, by_yr, byby_yl, byby_yr, bxby_yl, bxby_yr, bybz_yl, bybz_yr, 
      bz_zl, bz_zr, bzbz_zl, bzbz_zr, bxbz_zl, bxbz_zr, bybz_zl, bybz_zr] */

  printf(fh, "  struct gkyl_mat A_bxbx_xl = gkyl_nmat_get(A, count); ~%"),
  printf(fh, "  struct gkyl_mat A_bxbx_xr = gkyl_nmat_get(A, count+1); ~%"),
  printf(fh, "  struct gkyl_mat A_bxby_xl = gkyl_nmat_get(A, count+2); ~%"),
  printf(fh, "  struct gkyl_mat A_bxby_xr = gkyl_nmat_get(A, count+3); ~%"),
  printf(fh, "  struct gkyl_mat A_bxbz_xl = gkyl_nmat_get(A, count+4); ~%"),
  printf(fh, "  struct gkyl_mat A_bxbz_xr = gkyl_nmat_get(A, count+5); ~%"),

  printf(fh, "  struct gkyl_mat rhs_bxbx_xl = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbx_xr = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_xl = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_xr = gkyl_nmat_get(rhs, count+3); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbz_xl = gkyl_nmat_get(rhs, count+4); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxbz_xr = gkyl_nmat_get(rhs, count+5); ~%"),

  printf(fh, "  gkyl_mat_clear(&A_bxbx_xl, 0.0); gkyl_mat_clear(&rhs_bxbx_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxbx_xr, 0.0); gkyl_mat_clear(&rhs_bxbx_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxby_xl, 0.0); gkyl_mat_clear(&rhs_bxby_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxby_xr, 0.0); gkyl_mat_clear(&rhs_bxby_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxbz_xl, 0.0); gkyl_mat_clear(&rhs_bxbz_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxbz_xr, 0.0); gkyl_mat_clear(&rhs_bxbz_xr, 0.0); ~%"),

  printf(fh, "  const double *Bx_sq_xl = &BB_surf[~a]; ~%", 0*NSurf),
  printf(fh, "  const double *Bx_sq_xr = &BB_surf[~a]; ~%", 1*NSurf),
  printf(fh, "  const double *By_sq_xl = &BB_surf[~a]; ~%", 2*NSurf),
  printf(fh, "  const double *By_sq_xr = &BB_surf[~a]; ~%", 3*NSurf),
  printf(fh, "  const double *Bz_sq_xl = &BB_surf[~a]; ~%", 4*NSurf),
  printf(fh, "  const double *Bz_sq_xr = &BB_surf[~a]; ~%", 5*NSurf),

  printf(fh, "  const double *B_x_B_y_xl = &BB_surf[~a]; ~%", 6*NSurf),
  printf(fh, "  const double *B_x_B_y_xr = &BB_surf[~a]; ~%", 7*NSurf),
  printf(fh, "  const double *B_x_B_z_xl = &BB_surf[~a]; ~%", 8*NSurf),
  printf(fh, "  const double *B_x_B_z_xr = &BB_surf[~a]; ~%", 9*NSurf),

  printf(fh, "  int *cell_avg_magB2_xl = &cell_avg_magB2_surf[~a]; ~%", 0),
  printf(fh, "  int *cell_avg_magB2_xr = &cell_avg_magB2_surf[~a]; ~%", 1),
  printf(fh, " ~%"),

  printf(fh, "  struct gkyl_mat A_byby_yl = gkyl_nmat_get(A, count+6); ~%"),
  printf(fh, "  struct gkyl_mat A_byby_yr = gkyl_nmat_get(A, count+7); ~%"),
  printf(fh, "  struct gkyl_mat A_bxby_yl = gkyl_nmat_get(A, count+8); ~%"),
  printf(fh, "  struct gkyl_mat A_bxby_yr = gkyl_nmat_get(A, count+9); ~%"),
  printf(fh, "  struct gkyl_mat A_bybz_yl = gkyl_nmat_get(A, count+10); ~%"),
  printf(fh, "  struct gkyl_mat A_bybz_yr = gkyl_nmat_get(A, count+11); ~%"),

  printf(fh, "  struct gkyl_mat rhs_byby_yl = gkyl_nmat_get(rhs, count+6); ~%"),
  printf(fh, "  struct gkyl_mat rhs_byby_yr = gkyl_nmat_get(rhs, count+7); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_yl = gkyl_nmat_get(rhs, count+8); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bxby_yr = gkyl_nmat_get(rhs, count+9); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bybz_yl = gkyl_nmat_get(rhs, count+10); ~%"),
  printf(fh, "  struct gkyl_mat rhs_bybz_yr = gkyl_nmat_get(rhs, count+11); ~%"),

  printf(fh, "  gkyl_mat_clear(&A_byby_yl, 0.0); gkyl_mat_clear(&rhs_byby_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_byby_yr, 0.0); gkyl_mat_clear(&rhs_byby_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxby_yl, 0.0); gkyl_mat_clear(&rhs_bxby_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bxby_yr, 0.0); gkyl_mat_clear(&rhs_bxby_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bybz_yl, 0.0); gkyl_mat_clear(&rhs_bybz_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_bybz_yr, 0.0); gkyl_mat_clear(&rhs_bybz_yr, 0.0); ~%"),

  printf(fh, "  const double *Bx_sq_yl = &BB_surf[~a]; ~%", 10*NSurf),
  printf(fh, "  const double *Bx_sq_yr = &BB_surf[~a]; ~%", 11*NSurf),
  printf(fh, "  const double *By_sq_yl = &BB_surf[~a]; ~%", 12*NSurf),
  printf(fh, "  const double *By_sq_yr = &BB_surf[~a]; ~%", 13*NSurf),
  printf(fh, "  const double *Bz_sq_yl = &BB_surf[~a]; ~%", 14*NSurf),
  printf(fh, "  const double *Bz_sq_yr = &BB_surf[~a]; ~%", 15*NSurf),

  printf(fh, "  const double *B_x_B_y_yl = &BB_surf[~a]; ~%", 16*NSurf),
  printf(fh, "  const double *B_x_B_y_yr = &BB_surf[~a]; ~%", 17*NSurf),
  printf(fh, "  const double *B_y_B_z_yl = &BB_surf[~a]; ~%", 18*NSurf),
  printf(fh, "  const double *B_y_B_z_yr = &BB_surf[~a]; ~%", 19*NSurf),

  printf(fh, "  int *cell_avg_magB2_yl = &cell_avg_magB2_surf[~a]; ~%", 2),
  printf(fh, "  int *cell_avg_magB2_yr = &cell_avg_magB2_surf[~a]; ~%", 3),
  printf(fh, " ~%"),

  if (cdim = 3) then (
    printf(fh, "  struct gkyl_mat A_bzbz_zl = gkyl_nmat_get(A, count+12); ~%"),
    printf(fh, "  struct gkyl_mat A_bzbz_zr = gkyl_nmat_get(A, count+13); ~%"),
    printf(fh, "  struct gkyl_mat A_bxbz_zl = gkyl_nmat_get(A, count+14); ~%"),
    printf(fh, "  struct gkyl_mat A_bxbz_zr = gkyl_nmat_get(A, count+15); ~%"),
    printf(fh, "  struct gkyl_mat A_bybz_zl = gkyl_nmat_get(A, count+16); ~%"),
    printf(fh, "  struct gkyl_mat A_bybz_zr = gkyl_nmat_get(A, count+17); ~%"),

    printf(fh, "  struct gkyl_mat rhs_bzbz_zl = gkyl_nmat_get(rhs, count+12); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bzbz_zr = gkyl_nmat_get(rhs, count+13); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bxbz_zl = gkyl_nmat_get(rhs, count+14); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bxbz_zr = gkyl_nmat_get(rhs, count+15); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bybz_zl = gkyl_nmat_get(rhs, count+16); ~%"),
    printf(fh, "  struct gkyl_mat rhs_bybz_zr = gkyl_nmat_get(rhs, count+17); ~%"),

    printf(fh, "  gkyl_mat_clear(&A_bzbz_zl, 0.0); gkyl_mat_clear(&rhs_bzbz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_bzbz_zr, 0.0); gkyl_mat_clear(&rhs_bzbz_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_bxbz_zl, 0.0); gkyl_mat_clear(&rhs_bxbz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_bxbz_zr, 0.0); gkyl_mat_clear(&rhs_bxbz_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_bybz_zl, 0.0); gkyl_mat_clear(&rhs_bybz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_bybz_zr, 0.0); gkyl_mat_clear(&rhs_bybz_zr, 0.0); ~%"),

    printf(fh, "  const double *Bx_sq_zl = &BB_surf[~a]; ~%", 20*NSurf),
    printf(fh, "  const double *Bx_sq_zr = &BB_surf[~a]; ~%", 21*NSurf),
    printf(fh, "  const double *By_sq_zl = &BB_surf[~a]; ~%", 22*NSurf),
    printf(fh, "  const double *By_sq_zr = &BB_surf[~a]; ~%", 23*NSurf),
    printf(fh, "  const double *Bz_sq_zl = &BB_surf[~a]; ~%", 24*NSurf),
    printf(fh, "  const double *Bz_sq_zr = &BB_surf[~a]; ~%", 25*NSurf),

    printf(fh, "  const double *B_x_B_z_zl = &BB_surf[~a]; ~%", 26*NSurf),
    printf(fh, "  const double *B_x_B_z_zr = &BB_surf[~a]; ~%", 27*NSurf),
    printf(fh, "  const double *B_y_B_z_zl = &BB_surf[~a]; ~%", 28*NSurf),
    printf(fh, "  const double *B_y_B_z_zr = &BB_surf[~a]; ~%", 29*NSurf),

    printf(fh, "  int *cell_avg_magB2_zl = &cell_avg_magB2_surf[~a]; ~%", 4),
    printf(fh, "  int *cell_avg_magB2_zr = &cell_avg_magB2_surf[~a]; ~%", 5),
    printf(fh, " ~%")
  ),

  printf(fh, "  double magB2_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double magB2_xr[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double magB2_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double magB2_yr[~a] = {0.0}; ~%", NSurf),

  if (cdim = 3) then (
    printf(fh, "  double magB2_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double magB2_zr[~a] = {0.0}; ~%", NSurf)
  ),

  for i : 1 thru NSurf do (
    printf(fh, "  magB2_xl[~a] = Bx_sq_xl[~a] + By_sq_xl[~a] + Bz_sq_xl[~a]; ~%", i-1, i-1, i-1, i-1),
    printf(fh, "  magB2_xr[~a] = Bx_sq_xr[~a] + By_sq_xr[~a] + Bz_sq_xr[~a]; ~%", i-1, i-1, i-1, i-1),
    printf(fh, "  magB2_yl[~a] = Bx_sq_yl[~a] + By_sq_yl[~a] + Bz_sq_yl[~a]; ~%", i-1, i-1, i-1, i-1),
    printf(fh, "  magB2_yr[~a] = Bx_sq_yr[~a] + By_sq_yr[~a] + Bz_sq_yr[~a]; ~%", i-1, i-1, i-1, i-1),
    if (cdim = 3) then (
      printf(fh, "  magB2_zl[~a] = Bx_sq_zl[~a] + By_sq_zl[~a] + Bz_sq_zl[~a]; ~%", i-1, i-1, i-1, i-1),
      printf(fh, "  magB2_zr[~a] = Bx_sq_zr[~a] + By_sq_zr[~a] + Bz_sq_zr[~a]; ~%", i-1, i-1, i-1, i-1)
    )
  ),
  /* For p = 1 |B|^2 guaranteed to be positive if it's positive at the
     corners. For p = 2, we use the positivity control points (-1, 0, 1) */
  printf(fh, "  // If |B|^2 < 0 at control points along a surface, only use cell average to get 1/|B|^2. ~%"),
  printf(fh, "  // Each surface is checked independently. ~%"),
  nodes : getNodes(basisFun, cdim-1, polyOrder),

  magB2_xl_e : doExpand1(magB2_xl, bSurfx),
  magB2_xr_e : doExpand1(magB2_xr, bSurfx),
  magB2_yl_e : doExpand1(magB2_yl, bSurfy),
  magB2_yr_e : doExpand1(magB2_yr, bSurfy),

  magB2_xl_Corners : expand(float(evAtNodes(magB2_xl_e,nodes,surfVarsx))),
  magB2_xr_Corners : expand(float(evAtNodes(magB2_xr_e,nodes,surfVarsx))),
  magB2_yl_Corners : expand(float(evAtNodes(magB2_yl_e,nodes,surfVarsy))),
  magB2_yr_Corners : expand(float(evAtNodes(magB2_yr_e,nodes,surfVarsy))),

  printf(fh, "  int cell_avg_xl = 0;~%"),
  printf(fh, "  int cell_avg_xr = 0;~%"),
  printf(fh, "  int cell_avg_yl = 0;~%"),
  printf(fh, "  int cell_avg_yr = 0;~%"),
  if (cdim = 3) then (
    magB2_zl_e : doExpand1(magB2_zl, bSurfz),
    magB2_zr_e : doExpand1(magB2_zr, bSurfz),

    magB2_zl_Corners : expand(float(evAtNodes(magB2_zl_e,nodes,surfVarsz))),
    magB2_zr_Corners : expand(float(evAtNodes(magB2_zr_e,nodes,surfVarsz))),

    printf(fh, "  int cell_avg_zl = 0;~%"),
    printf(fh, "  int cell_avg_zr = 0;~%")
  ),
  printf(fh, " ~%"),

  for i : 1 thru length(nodes) do (
    printf(fh, "  if (~a < 0.0) cell_avg_xl = 1; ~%", magB2_xl_Corners[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_xr = 1; ~%", magB2_xr_Corners[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_yl = 1; ~%", magB2_yl_Corners[i]),
    printf(fh, "  if (~a < 0.0) cell_avg_yr = 1; ~%", magB2_yr_Corners[i]),
    if (cdim = 3) then (
      printf(fh, "  if (~a < 0.0) cell_avg_zl = 1; ~%", magB2_zl_Corners[i]),
      printf(fh, "  if (~a < 0.0) cell_avg_zr = 1; ~%", magB2_zr_Corners[i])
    )
  ),  
  printf(fh, " ~%"),
  printf(fh, "  cell_avg_magB2_xl[0] = cell_avg_xl; ~%"),
  printf(fh, "  cell_avg_magB2_xr[0] = cell_avg_xr; ~%"),
  printf(fh, "  cell_avg_magB2_yl[0] = cell_avg_yl; ~%"),
  printf(fh, "  cell_avg_magB2_yr[0] = cell_avg_yr; ~%"),
  if (cdim = 3) then (
    printf(fh, "  cell_avg_magB2_zl[0] = cell_avg_zl; ~%"),
    printf(fh, "  cell_avg_magB2_zr[0] = cell_avg_zr; ~%")
  ),
  printf(fh, " ~%"),


  printf(fh, "  if (cell_avg_xl) { ~%"),
  for i : 2 thru NSurf do (
    printf(fh, "  magB2_xl[~a] = 0.0; ~%", i-1)
  ),
  printf(fh, "  } ~%"),
  printf(fh, " ~%"),

  printf(fh, "  if (cell_avg_xr) { ~%"),
  for i : 2 thru NSurf do (
    printf(fh, "  magB2_xr[~a] = 0.0; ~%", i-1)
  ),
  printf(fh, "  } ~%"),
  printf(fh, " ~%"),

  printf(fh, "  if (cell_avg_yl) { ~%"),
  for i : 2 thru NSurf do (
    printf(fh, "  magB2_yl[~a] = 0.0; ~%", i-1)
  ),
  printf(fh, "  } ~%"),
  printf(fh, " ~%"),

  printf(fh, "  if (cell_avg_yr) { ~%"),
  for i : 2 thru NSurf do (
    printf(fh, "  magB2_yr[~a] = 0.0; ~%", i-1)
  ),
  printf(fh, "  } ~%"),
  printf(fh, " ~%"),

  if (cdim = 3) then (
    printf(fh, "  if (cell_avg_zl) { ~%"),
    for i : 2 thru NSurf do (
      printf(fh, "  magB2_zl[~a] = 0.0; ~%", i-1)
    ),
    printf(fh, "  } ~%"),
    printf(fh, " ~%"),

    printf(fh, "  if (cell_avg_zr) { ~%"),
    for i : 2 thru NSurf do (
      printf(fh, "  magB2_zr[~a] = 0.0; ~%", i-1)
    ),
    printf(fh, "  } ~%"), 
    printf(fh, " ~%")
  ),

  for i : 1 thru NSurf do (
    printf(fh,"  gkyl_mat_set(&rhs_bxbx_xl,~a,0,Bx_sq_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxbx_xr,~a,0,Bx_sq_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxby_xl,~a,0,B_x_B_y_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxby_xr,~a,0,B_x_B_y_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxbz_xl,~a,0,B_x_B_z_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxbz_xr,~a,0,B_x_B_z_xr[~a]); ~%", i-1, i-1),
    printf(fh, " ~%"), 
    printf(fh,"  gkyl_mat_set(&rhs_byby_yl,~a,0,By_sq_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_byby_yr,~a,0,By_sq_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxby_yl,~a,0,B_x_B_y_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bxby_yr,~a,0,B_x_B_y_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bybz_yl,~a,0,B_y_B_z_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_bybz_yr,~a,0,B_y_B_z_yr[~a]); ~%", i-1, i-1),
    printf(fh, " ~%"), 
    if (cdim = 3) then (
      printf(fh,"  gkyl_mat_set(&rhs_bzbz_zl,~a,0,Bz_sq_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bzbz_zr,~a,0,Bz_sq_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bxbz_zl,~a,0,B_x_B_z_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bxbz_zr,~a,0,B_x_B_z_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bybz_zl,~a,0,B_y_B_z_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_bybz_zr,~a,0,B_y_B_z_zr[~a]); ~%", i-1, i-1),
      printf(fh, " ~%")
    )
  ),
  /* Generate matrix of unknown coefficients for x surfaces */
  uxe : doExpand1(ux,bSurfx),
  uxn : makelist(ux[i],i,0,NSurf-1),
  eq_magB2_xl : calcInnerProdList(surfVarsx,uxe,bSurfx,magB2_xl_e),
  E_magB2_xl : fullratsimp(coefmatrix(eq_magB2_xl,uxn)),
  eq_magB2_xr : calcInnerProdList(surfVarsx,uxe,bSurfx,magB2_xr_e),
  E_magB2_xr : fullratsimp(coefmatrix(eq_magB2_xr,uxn)),

  /* Generate matrix of unknown coefficients for y surfaces */
  uye : doExpand1(uy,bSurfy),
  uyn : makelist(uy[i],i,0,NSurf-1),
  eq_magB2_yl : calcInnerProdList(surfVarsy,uye,bSurfy,magB2_yl_e),
  E_magB2_yl : fullratsimp(coefmatrix(eq_magB2_yl,uyn)),
  eq_magB2_yr : calcInnerProdList(surfVarsy,uye,bSurfy,magB2_yr_e),
  E_magB2_yr : fullratsimp(coefmatrix(eq_magB2_yr,uyn)),

  /* declare temporary variables since multiple matrix entries in A are the same */
  printf(fh, "  double temp_magB2_xl = 0.0; ~%"),
  printf(fh, "  double temp_magB2_xr = 0.0; ~%"),
  printf(fh, "  double temp_magB2_yl = 0.0; ~%"),
  printf(fh, "  double temp_magB2_yr = 0.0; ~%"),

  /* Generate matrix of unknown coefficients and temporary variables for z surfaces */
  if (cdim = 3) then (
    uze : doExpand1(uz,bSurfz),
    uzn : makelist(uz[i],i,0,NSurf-1),
    eq_magB2_zl : calcInnerProdList(surfVarsz,uze,bSurfz,magB2_zl_e),
    E_magB2_zl : fullratsimp(coefmatrix(eq_magB2_zl,uzn)),
    eq_magB2_zr : calcInnerProdList(surfVarsz,uze,bSurfz,magB2_zr_e),
    E_magB2_zr : fullratsimp(coefmatrix(eq_magB2_zr,uzn)),
    printf(fh, "  double temp_magB2_zl = 0.0; ~%"),
    printf(fh, "  double temp_magB2_zr = 0.0; ~%")
  ),  
  /* Matrix is dense so just do a simple write routine */
  for i : 1 thru NSurf do (
    for j : 1 thru NSurf do (
      printf(fh,"  temp_magB2_xl = ~a; ~%", float(expand(E_magB2_xl[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_bxbx_xl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_xl),
      printf(fh,"  gkyl_mat_set(&A_bxby_xl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_xl),
      printf(fh,"  gkyl_mat_set(&A_bxbz_xl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_xl),
      printf(fh, " ~%"),

      printf(fh,"  temp_magB2_xr = ~a; ~%", float(expand(E_magB2_xr[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_bxbx_xr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_xr),
      printf(fh,"  gkyl_mat_set(&A_bxby_xr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_xr),
      printf(fh,"  gkyl_mat_set(&A_bxbz_xr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_xr),
      printf(fh, " ~%"),

      printf(fh,"  temp_magB2_yl = ~a; ~%", float(expand(E_magB2_yl[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_byby_yl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_yl),
      printf(fh,"  gkyl_mat_set(&A_bxby_yl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_yl),
      printf(fh,"  gkyl_mat_set(&A_bybz_yl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_yl),
      printf(fh, " ~%"),

      printf(fh,"  temp_magB2_yr = ~a; ~%", float(expand(E_magB2_yr[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_byby_yr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_yr),
      printf(fh,"  gkyl_mat_set(&A_bxby_yr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_yr),
      printf(fh,"  gkyl_mat_set(&A_bybz_yr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_yr),
      printf(fh, " ~%"),
      if (cdim = 3) then (
        printf(fh,"  temp_magB2_zl = ~a; ~%", float(expand(E_magB2_zl[i,j]))),
        printf(fh,"  gkyl_mat_set(&A_bzbz_zl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_zl),
        printf(fh,"  gkyl_mat_set(&A_bxbz_zl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_zl),
        printf(fh,"  gkyl_mat_set(&A_bybz_zl,~a,~a,~a); ~%", i-1, j-1, temp_magB2_zl),
        printf(fh, " ~%"),

        printf(fh,"  temp_magB2_zr = ~a; ~%", float(expand(E_magB2_zr[i,j]))),
        printf(fh,"  gkyl_mat_set(&A_bzbz_zr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_zr),
        printf(fh,"  gkyl_mat_set(&A_bxbz_zr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_zr),
        printf(fh,"  gkyl_mat_set(&A_bybz_zr,~a,~a,~a); ~%", i-1, j-1, temp_magB2_zr),
        printf(fh, " ~%")
      )
    )
  ),  
  printf(fh, "} ~%")
)$

copy_surf_bvar(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, surfVarsx, bSurfx, surfVarsy, bSurfy, surfVarsz, bSurfz, NSurf, 
   B_x_e, B_y_e, B_z_e, 
   B_x_xl_c, B_x_xr_c, B_y_yl_c, B_y_yr_c, B_z_zl_c, B_z_zr_c, 
   bxbx_xl_e, bxbx_xr_e, 
   byby_yl_e, byby_yr_e, 
   bzbz_zl_e, bzbz_zr_e, 
   nodes, 
   bxbx_xl_Quad, bxbx_xr_Quad, 
   byby_yl_Quad, byby_yr_Quad,
   bzbz_zl_Quad, bzbz_zr_Quad],

  kill(varsC, basisC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),
  surfVarsx : delete(x,varsC),
  bSurfx : basisFromVars(basisFun,surfVarsx,polyOrder),
  if (cdim > 1) then (
    surfVarsy : delete(y,varsC),
    bSurfy : basisFromVars(basisFun,surfVarsy,polyOrder)
  ),
  if (cdim = 3) then (
    surfVarsz : delete(z,varsC),
    bSurfz : basisFromVars(basisFun,surfVarsz,polyOrder)
  ),

  /* Number of basis monomials. */
  NC : length(bC),
  if (cdim = 1) then (
    NSurf : 1
  )
  else (
    NSurf : length(bSurfx)
  ),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_maxwell_kernels.h> ~%"),
  if (cdim = 2) then (
    printf(fh, "#include <gkyl_basis_ser_~ax_p~a_sqrt_with_sign.h> ~%", cdim-1, polyOrder)
  )
  else if (cdim = 3) then (
    printf(fh, "#include <gkyl_basis_~a_~ax_p~a_sqrt_with_sign.h> ~%", basisFun, cdim-1, polyOrder)
  ),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *x, const double *em, int* cell_avg_magB2_surf, double* GKYL_RESTRICT bvar_surf) ~%{ ~%", funcNm),
  printf(fh, "  // count:               Integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // x:                   Input solution vector. ~%"),
  printf(fh, "  // em:                  Input electromagnetic fields. ~%"),
  printf(fh, "  // cell_avg_magB2_surf: Output flag for cell average if 1/|B|^2 at a surface only used cell averages. ~%"),
  printf(fh, "  // bvar_surf:           Output magnetic field unit tensor and unit vector at surfaces. ~%"),
  printf(fh, "  //                      [bx_xl, bx_xr, bxbx_xl, bxbx_xr, bxby_xl, bxby_xr, bxbz_xl, bxbz_xr, ~%"),
  printf(fh, "  //                       by_yl, by_yr, byby_yl, byby_yr, bxby_yl, bxby_yr, bybz_yl, bybz_yr, ~%"),
  printf(fh, "  //                       bz_zl, bz_zr, bzbz_zl, bzbz_zr, bxbz_zl, bxbz_zr, bybz_zl, bybz_zr] ~%"),
  printf(fh, " ~%"),

  /* Surface magnetic field unit vector and unit tensor are organized as:
     [bx_xl, bx_xr, bxbx_xl, bxbx_xr, bxby_xl, bxby_xr, bxbz_xl, bxbz_xr, 
      by_yl, by_yr, byby_yl, byby_yr, bxby_yl, bxby_yr, bybz_yl, bybz_yr, 
      bz_zl, bz_zr, bzbz_zl, bzbz_zr, bxbz_zl, bxbz_zr, bybz_zl, bybz_zr] */

  printf(fh, "  struct gkyl_mat x_bxbx_xl = gkyl_nmat_get(x, count); ~%"),
  printf(fh, "  struct gkyl_mat x_bxbx_xr = gkyl_nmat_get(x, count+1); ~%"),
  printf(fh, "  struct gkyl_mat x_bxby_xl = gkyl_nmat_get(x, count+2); ~%"),
  printf(fh, "  struct gkyl_mat x_bxby_xr = gkyl_nmat_get(x, count+3); ~%"),
  printf(fh, "  struct gkyl_mat x_bxbz_xl = gkyl_nmat_get(x, count+4); ~%"),
  printf(fh, "  struct gkyl_mat x_bxbz_xr = gkyl_nmat_get(x, count+5); ~%"),
  printf(fh, " ~%"), 
  printf(fh, "  double *bx_xl = &bvar_surf[~a]; ~%", 0*NSurf),
  printf(fh, "  double *bx_xr = &bvar_surf[~a]; ~%", 1*NSurf),
  printf(fh, "  double *bxbx_xl = &bvar_surf[~a]; ~%", 2*NSurf),
  printf(fh, "  double *bxbx_xr = &bvar_surf[~a]; ~%", 3*NSurf),
  printf(fh, "  double *bxby_xl = &bvar_surf[~a]; ~%", 4*NSurf),
  printf(fh, "  double *bxby_xr = &bvar_surf[~a]; ~%", 5*NSurf),
  printf(fh, "  double *bxbz_xl = &bvar_surf[~a]; ~%", 6*NSurf),
  printf(fh, "  double *bxbz_xr = &bvar_surf[~a]; ~%", 7*NSurf),
  printf(fh, "  int *cell_avg_magB2_xl = &cell_avg_magB2_surf[~a]; ~%", 0),
  printf(fh, "  int *cell_avg_magB2_xr = &cell_avg_magB2_surf[~a]; ~%", 1),
  printf(fh, " ~%"), 
  if (cdim > 1) then (
    printf(fh, "  struct gkyl_mat x_byby_yl = gkyl_nmat_get(x, count+6); ~%"),
    printf(fh, "  struct gkyl_mat x_byby_yr = gkyl_nmat_get(x, count+7); ~%"),
    printf(fh, "  struct gkyl_mat x_bxby_yl = gkyl_nmat_get(x, count+8); ~%"),
    printf(fh, "  struct gkyl_mat x_bxby_yr = gkyl_nmat_get(x, count+9); ~%"),
    printf(fh, "  struct gkyl_mat x_bybz_yl = gkyl_nmat_get(x, count+10); ~%"),
    printf(fh, "  struct gkyl_mat x_bybz_yr = gkyl_nmat_get(x, count+11); ~%"),
    printf(fh, " ~%"), 
    printf(fh, "  double *by_yl = &bvar_surf[~a]; ~%", 8*NSurf),
    printf(fh, "  double *by_yr = &bvar_surf[~a]; ~%", 9*NSurf),
    printf(fh, "  double *byby_yl = &bvar_surf[~a]; ~%", 10*NSurf),
    printf(fh, "  double *byby_yr = &bvar_surf[~a]; ~%", 11*NSurf),
    printf(fh, "  double *bxby_yl = &bvar_surf[~a]; ~%", 12*NSurf),
    printf(fh, "  double *bxby_yr = &bvar_surf[~a]; ~%", 13*NSurf),
    printf(fh, "  double *bybz_yl = &bvar_surf[~a]; ~%", 14*NSurf),
    printf(fh, "  double *bybz_yr = &bvar_surf[~a]; ~%", 15*NSurf),
    printf(fh, "  int *cell_avg_magB2_yl = &cell_avg_magB2_surf[~a]; ~%", 2),
    printf(fh, "  int *cell_avg_magB2_yr = &cell_avg_magB2_surf[~a]; ~%", 3),
    printf(fh, " ~%")
  ),
  if (cdim = 3) then (
    printf(fh, "  struct gkyl_mat x_bzbz_zl = gkyl_nmat_get(x, count+12); ~%"),
    printf(fh, "  struct gkyl_mat x_bzbz_zr = gkyl_nmat_get(x, count+13); ~%"),
    printf(fh, "  struct gkyl_mat x_bxbz_zl = gkyl_nmat_get(x, count+14); ~%"),
    printf(fh, "  struct gkyl_mat x_bxbz_zr = gkyl_nmat_get(x, count+15); ~%"),
    printf(fh, "  struct gkyl_mat x_bybz_zl = gkyl_nmat_get(x, count+16); ~%"),
    printf(fh, "  struct gkyl_mat x_bybz_zr = gkyl_nmat_get(x, count+17); ~%"),
    printf(fh, " ~%"), 
    printf(fh, "  double *bz_zl = &bvar_surf[~a]; ~%", 16*NSurf),
    printf(fh, "  double *bz_zr = &bvar_surf[~a]; ~%", 17*NSurf),
    printf(fh, "  double *bzbz_zl = &bvar_surf[~a]; ~%", 18*NSurf),
    printf(fh, "  double *bzbz_zr = &bvar_surf[~a]; ~%", 19*NSurf),
    printf(fh, "  double *bxbz_zl = &bvar_surf[~a]; ~%", 20*NSurf),
    printf(fh, "  double *bxbz_zr = &bvar_surf[~a]; ~%", 21*NSurf),
    printf(fh, "  double *bybz_zl = &bvar_surf[~a]; ~%", 22*NSurf),
    printf(fh, "  double *bybz_zr = &bvar_surf[~a]; ~%", 23*NSurf),
    printf(fh, "  int *cell_avg_magB2_zl = &cell_avg_magB2_surf[~a]; ~%", 4),
    printf(fh, "  int *cell_avg_magB2_zr = &cell_avg_magB2_surf[~a]; ~%", 5),
    printf(fh, " ~%")
  ),
  for i : 1 thru NSurf do (
    printf(fh,"  bxbx_xl[~a] = gkyl_mat_get(&x_bxbx_xl,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxbx_xr[~a] = gkyl_mat_get(&x_bxbx_xr,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxby_xl[~a] = gkyl_mat_get(&x_bxby_xl,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxby_xr[~a] = gkyl_mat_get(&x_bxby_xr,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxbz_xl[~a] = gkyl_mat_get(&x_bxbz_xl,~a,0); ~%", i-1, i-1),
    printf(fh,"  bxbz_xr[~a] = gkyl_mat_get(&x_bxbz_xr,~a,0); ~%", i-1, i-1), 
    printf(fh, " ~%"), 
    if (cdim > 1) then (
      printf(fh,"  byby_yl[~a] = gkyl_mat_get(&x_byby_yl,~a,0); ~%", i-1, i-1),
      printf(fh,"  byby_yr[~a] = gkyl_mat_get(&x_byby_yr,~a,0); ~%", i-1, i-1),
      printf(fh,"  bxby_yl[~a] = gkyl_mat_get(&x_bxby_yl,~a,0); ~%", i-1, i-1),
      printf(fh,"  bxby_yr[~a] = gkyl_mat_get(&x_bxby_yr,~a,0); ~%", i-1, i-1),
      printf(fh,"  bybz_yl[~a] = gkyl_mat_get(&x_bybz_yl,~a,0); ~%", i-1, i-1),
      printf(fh,"  bybz_yr[~a] = gkyl_mat_get(&x_bybz_yr,~a,0); ~%", i-1, i-1),
      printf(fh, " ~%")
    ), 
    if (cdim = 3) then (
      printf(fh,"  bzbz_zl[~a] = gkyl_mat_get(&x_bzbz_zl,~a,0); ~%", i-1, i-1),
      printf(fh,"  bzbz_zr[~a] = gkyl_mat_get(&x_bzbz_zr,~a,0); ~%", i-1, i-1),
      printf(fh,"  bxbz_zl[~a] = gkyl_mat_get(&x_bxbz_zl,~a,0); ~%", i-1, i-1),
      printf(fh,"  bxbz_zr[~a] = gkyl_mat_get(&x_bxbz_zr,~a,0); ~%", i-1, i-1),
      printf(fh,"  bybz_zl[~a] = gkyl_mat_get(&x_bybz_zl,~a,0); ~%", i-1, i-1),
      printf(fh,"  bybz_zr[~a] = gkyl_mat_get(&x_bybz_zr,~a,0); ~%", i-1, i-1),
      printf(fh, " ~%")
    )
  ),

  printf(fh, "  const double *B_x = &em[~a]; ~%", NC*3),
  printf(fh, "  const double *B_y = &em[~a]; ~%", NC*4),
  printf(fh, "  const double *B_z = &em[~a]; ~%", NC*5),
  printf(fh, " ~%"),

  B_x_e : doExpand1(B_x, bC),
  B_y_e : doExpand1(B_y, bC),
  B_z_e : doExpand1(B_z, bC),

  /* for cdim = 1, bxbx is positive definite, no need to check positivity */
  if (cdim = 1) then (
    printf(fh, "  double B_x_xl = ~a; ~%", float(expand(subst(x=-1, B_x_e)))),
    printf(fh, "  double B_x_xr = ~a; ~%", float(expand(subst(x=1, B_x_e)))),
    printf(fh, "  if (B_x_xl < 0.0) ~%"),
    printf(fh, "    bx_xl[0] = -sqrt(bxbx_xl[0]); ~%"),
    printf(fh, "  else ~%"),
    printf(fh, "    bx_xl[0] = sqrt(bxbx_xl[0]); ~%"),
    printf(fh, " ~%"),
    printf(fh, "  if (B_x_xr < 0.0) ~%"),
    printf(fh, "    bx_xr[0] = -sqrt(bxbx_xr[0]); ~%"),
    printf(fh, "  else ~%"),
    printf(fh, "    bx_xr[0] = sqrt(bxbx_xr[0]); ~%")
  )
  else (
    /* To insure b . b = 1, we need to check if bxbx, byby, or bzbz < 0.0
       at the quadrature points we use to evaluate the sqrt. If any of these
       points are negative, we switch to just the cell average of b_i b_j 
       Note we do this surface by surface (bxbx at xl and xr, byby at yl and yr, and bzbz at zl and zr) */
    nodes : gaussOrd(polyOrder+1, cdim-1),

    bxbx_xl_e : doExpand1(bxbx_xl, bSurfx),
    bxbx_xr_e : doExpand1(bxbx_xr, bSurfx),
    printf(fh, "  int cell_avg_xl = 0;~%"),
    printf(fh, "  int cell_avg_xr = 0;~%"),
    bxbx_xl_Quad : expand(float(evAtNodes(bxbx_xl_e,nodes,surfVarsx))),
    bxbx_xr_Quad : expand(float(evAtNodes(bxbx_xr_e,nodes,surfVarsx))),

    for i : 1 thru length(nodes) do (
      printf(fh, "  if (~a < 0.0) cell_avg_xl = 1; ~%", bxbx_xl_Quad[i]),
      printf(fh, "  if (~a < 0.0) cell_avg_xr = 1; ~%", bxbx_xr_Quad[i])
    ),
    printf(fh, " ~%"),

    printf(fh, "  if (cell_avg_xl || cell_avg_magB2_xl[0]) { ~%"),
    /* Use only the cell average bb at lower x surface. */
    for i : 2 thru NSurf do (
      printf(fh, "    bxbx_xl[~a] = 0.0; ~%", i-1),
      printf(fh, "    bxby_xl[~a] = 0.0; ~%", i-1),
      printf(fh, "    bxbz_xl[~a] = 0.0; ~%", i-1)
    ),
    printf(fh, "    // If bxbx, bxby, or bxbz < 0.0 at the lower x surface quadrature points, ~%"),
    printf(fh, "    // set cell_avg_magB2_xl to be true in case it was not true before. ~%"),
    printf(fh, "    cell_avg_magB2_xl[0] = 1; ~%"),
    printf(fh, "  } ~%"),
    printf(fh, " ~%"),

    printf(fh, "  if (cell_avg_xr || cell_avg_magB2_xr[0]) { ~%"),
    /* Use only the cell average bb at lower x surface. */
    for i : 2 thru NSurf do (
      printf(fh, "    bxbx_xr[~a] = 0.0; ~%", i-1),
      printf(fh, "    bxby_xr[~a] = 0.0; ~%", i-1),
      printf(fh, "    bxbz_xr[~a] = 0.0; ~%", i-1)
    ),
    printf(fh, "    // If bxbx, bxby, or bxbz < 0.0 at the upper x surface quadrature points, ~%"),
    printf(fh, "    // set cell_avg_magB2_xr to be true in case it was not true before. ~%"),
    printf(fh, "    cell_avg_magB2_xr[0] = 1; ~%"),
    printf(fh, "  } ~%"),
    printf(fh, " ~%"),

    byby_yl_e : doExpand1(byby_yl, bSurfy),
    byby_yr_e : doExpand1(byby_yr, bSurfy),
    printf(fh, "  int cell_avg_yl = 0;~%"),
    printf(fh, "  int cell_avg_yr = 0;~%"),
    byby_yl_Quad : expand(float(evAtNodes(byby_yl_e,nodes,surfVarsy))),
    byby_yr_Quad : expand(float(evAtNodes(byby_yr_e,nodes,surfVarsy))),

    for i : 1 thru length(nodes) do (
      printf(fh, "  if (~a < 0.0) cell_avg_yl = 1; ~%", byby_yl_Quad[i]),
      printf(fh, "  if (~a < 0.0) cell_avg_yr = 1; ~%", byby_yr_Quad[i])
    ),
    printf(fh, " ~%"), 

    printf(fh, "  if (cell_avg_yl || cell_avg_magB2_yl[0]) { ~%"),
    /* Use only the cell average bb at lower x surface. */
    for i : 2 thru NSurf do (
      printf(fh, "    byby_yl[~a] = 0.0; ~%", i-1),
      printf(fh, "    bxby_yl[~a] = 0.0; ~%", i-1),
      printf(fh, "    bybz_yl[~a] = 0.0; ~%", i-1)
    ),
    printf(fh, "    // If byby, bxby, or bybz < 0.0 at the lower y surface quadrature points, ~%"),
    printf(fh, "    // set cell_avg_magB2_yl to be true in case it was not true before. ~%"),
    printf(fh, "    cell_avg_magB2_yl[0] = 1; ~%"),
    printf(fh, "  } ~%"),
    printf(fh, " ~%"),

    printf(fh, "  if (cell_avg_yr || cell_avg_magB2_yr[0]) { ~%"),
    /* Use only the cell average bb at lower x surface. */
    for i : 2 thru NSurf do (
      printf(fh, "    byby_yr[~a] = 0.0; ~%", i-1),
      printf(fh, "    bxby_yr[~a] = 0.0; ~%", i-1),
      printf(fh, "    bybz_yr[~a] = 0.0; ~%", i-1)
    ),
    printf(fh, "    // If byby, bxby, or bybz < 0.0 at the upper y surface quadrature points, ~%"),
    printf(fh, "    // set cell_avg_magB2_yr to be true in case it was not true before. ~%"),
    printf(fh, "    cell_avg_magB2_yr[0] = 1; ~%"),
    printf(fh, "  } ~%"),
    printf(fh, " ~%"),
    if (cdim = 3) then (
      bzbz_zl_e : doExpand1(bzbz_zl, bSurfz),
      bzbz_zr_e : doExpand1(bzbz_zr, bSurfz),
      printf(fh, "  int cell_avg_zl = 0;~%"),
      printf(fh, "  int cell_avg_zr = 0;~%"),
      bzbz_zl_Quad : expand(float(evAtNodes(bzbz_zl_e,nodes,surfVarsz))),
      bzbz_zr_Quad : expand(float(evAtNodes(bzbz_zr_e,nodes,surfVarsz))),

      for i : 1 thru length(nodes) do (
        printf(fh, "  if (~a < 0.0) cell_avg_zl = 1; ~%", bzbz_zl_Quad[i]),
        printf(fh, "  if (~a < 0.0) cell_avg_zr = 1; ~%", bzbz_zr_Quad[i])
      ),
      printf(fh, " ~%"),

      printf(fh, "  if (cell_avg_zl || cell_avg_magB2_zl[0]) { ~%"),
      /* Use only the cell average bb at lower x surface. */
      for i : 2 thru NSurf do (
        printf(fh, "    bzbz_zl[~a] = 0.0; ~%", i-1),
        printf(fh, "    bxbz_zl[~a] = 0.0; ~%", i-1),
        printf(fh, "    bybz_zl[~a] = 0.0; ~%", i-1)
      ),
      printf(fh, "    // If bzbz, bxbz, or bybz < 0.0 at the lower z surface quadrature points, ~%"),
      printf(fh, "    // set cell_avg_magB2_zl to be true in case it was not true before. ~%"),
      printf(fh, "    cell_avg_magB2_zl[0] = 1; ~%"),
      printf(fh, "  } ~%"),
      printf(fh, " ~%"),

      printf(fh, "  if (cell_avg_zr || cell_avg_magB2_zr[0]) { ~%"),
      /* Use only the cell average bb at lower x surface. */
      for i : 2 thru NSurf do (
        printf(fh, "    bzbz_zr[~a] = 0.0; ~%", i-1),
        printf(fh, "    bxbz_zr[~a] = 0.0; ~%", i-1),
        printf(fh, "    bybz_zr[~a] = 0.0; ~%", i-1)
      ),
      printf(fh, "    // If bzbz, bxbz, or bybz < 0.0 at the upper z surface quadrature points, ~%"),
      printf(fh, "    // set cell_avg_magB2_zr to be true in case it was not true before. ~%"),
      printf(fh, "    cell_avg_magB2_zr[0] = 1; ~%"),
      printf(fh, "  } ~%"),
      printf(fh, " ~%")
    ),

    printf(fh, "  // Calculate b_i = B_i/|B| by taking square root of B_i^2/|B|^2 at quadrature points. ~%"),
    printf(fh, "  // Uses the sign of B_i at quadrature points *on the surface* to get the correct sign of b_i *on the surface*. ~%"),
    printf(fh, "  // Note: positivity check already happened, so only uses cell average if needed to avoid imaginary values of b_hat. ~%"),
    B_x_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, B_x_e)),
    B_x_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, B_x_e)),
    /* Temporary arrays for storing surface expansions of B_i at x surfaces */
    printf(fh, "  double B_x_xl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double B_x_xr[~a] = {0.0}; ~%", NSurf),
    printf(fh, " ~%"),

    writeCExprs1(B_x_xl, B_x_xl_c), 
    writeCExprs1(B_x_xr, B_x_xr_c), 
    if (d = 2) then (
      printf(fh, "  ser_~ax_p~a_sqrt_with_sign(B_x_xl, bxbx_xl, bx_xl); ~%", cdim-1, polyOrder),
      printf(fh, "  ser_~ax_p~a_sqrt_with_sign(B_x_xr, bxbx_xr, bx_xr); ~%",cdim-1, polyOrder)
    )
    else (
      printf(fh, "  ~a_~ax_p~a_sqrt_with_sign(B_x_xl, bxbx_xl, bx_xl); ~%", basisFun, cdim-1, polyOrder),
      printf(fh, "  ~a_~ax_p~a_sqrt_with_sign(B_x_xr, bxbx_xr, bx_xr); ~%", basisFun, cdim-1, polyOrder)
    ),
    printf(fh, " ~%"),

    B_y_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, B_y_e)),
    B_y_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, B_y_e)),
    /* Temporary arrays for storing surface expansions of B_i at y surfaces */
    printf(fh, "  double B_y_yl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double B_y_yr[~a] = {0.0}; ~%", NSurf),
    printf(fh, " ~%"),

    writeCExprs1(B_y_yl, B_y_yl_c), 
    writeCExprs1(B_y_yr, B_y_yr_c), 
    if (d = 2) then (
      printf(fh, "  ser_~ax_p~a_sqrt_with_sign(B_y_yl, byby_yl, by_yl); ~%", cdim-1, polyOrder),
      printf(fh, "  ser_~ax_p~a_sqrt_with_sign(B_y_yr, byby_yr, by_yr); ~%", cdim-1, polyOrder)
    )
    else (
      printf(fh, "  ~a_~ax_p~a_sqrt_with_sign(B_y_yl, byby_yl, by_yl); ~%", basisFun, cdim-1, polyOrder),
      printf(fh, "  ~a_~ax_p~a_sqrt_with_sign(B_y_yr, byby_yr, by_yr); ~%", basisFun, cdim-1, polyOrder)
    ),
    printf(fh, " ~%"),
    if (cdim = 3) then (
      B_z_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, B_z_e)),
      B_z_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, B_z_e)),
      /* Temporary arrays for storing surface expansions of B_i at z surfaces */
      printf(fh, "  double B_z_zl[~a] = {0.0}; ~%", NSurf),
      printf(fh, "  double B_z_zr[~a] = {0.0}; ~%", NSurf),
      printf(fh, " ~%"),

      writeCExprs1(B_z_zl, B_z_zl_c), 
      writeCExprs1(B_z_zr, B_z_zr_c),
      printf(fh, "  ~a_~ax_p~a_sqrt_with_sign(B_z_zl, bzbz_zl, bz_zl); ~%", basisFun, cdim-1, polyOrder),
      printf(fh, "  ~a_~ax_p~a_sqrt_with_sign(B_z_zl, bzbz_zl, bz_zl); ~%", basisFun, cdim-1, polyOrder),
      printf(fh, " ~%")
    )
  ),
  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$
