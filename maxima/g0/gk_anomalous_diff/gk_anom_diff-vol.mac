load("modal-basis")$
load("recovery") $
load("out-scripts");
load("utilities")$
load(stringproc)$
fpprec : 24$

/* Generate kernels for a gyrokinetic anomalous diffusion volume term. */

gk_anomalous_diff_gen_boundary_vol_ker(fh, funcNm, cdim, vdim, basisType, polyOrder) := block(
  [dir,varsC,basisC,vars,basis,vSub,numBasis,numBasisC,diffVar,nu_c,nu_e,
   Jfin_c,Jfin_e,jacobgeo_inv_e,f_c,f_e,vol_incr_c,pOrderFact,nuAv],

  dir : 1,
    
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dx, const double *nu, const double *jacobgeo_inv, const double *Jfin, double* GKYL_RESTRICT out) ~%{~%", funcNm),
  printf(fh, "  // w[NDIM]: Cell-center coordinates~%"),
  printf(fh, "  // dx[NDIM]: Cell spacing~%"),
  printf(fh, "  // nu: Diffusivity~%"),
  printf(fh, "  // jacobgeo_inv: reciprocal of the configuration space Jacobian.~%"),
  printf(fh, "  // Jfin: Input field times conf-space Jacobian~%"),
  printf(fh, "  // out: Incremented output~%~%"),

  printf(fh, "  const double rdx2sq = pow(2.0/dx[~a],2.0); ~%", dir-1),
  printf(fh, "~%"),

  [varsC, basisC, vars, basis, vSub] : loadGkBasis(basisType, cdim, vdim, polyOrder),
  numBasis : length(basis),
  numBasisC : length(basisC),

  diffVar : vars[dir],

  nu_c : makelist(nu[i-1],i,1,numBasisC),
  nu_e : doExpand(nu_c,basisC),

  Jfin_c : makelist(Jfin[i-1], i, 1, numBasis),
  Jfin_e : doExpand(Jfin_c, basis),

  /* Divide jacobGeo*f by jacobGeo. */
  jacobgeo_inv_e : doExpand1(jacobgeo_inv, basisC),
  
  f_c : calcInnerProdList(vars, jacobgeo_inv_e, basis, Jfin_e),

  /* Divide jacobGeo*f by jacobGeo. */
  printf(fh, "  double fin[~a];~%", numBasis),
  writeCExprsNoExpand1(fin, f_c),
  printf(fh, "~%"),

  f_c : makelist(fin[i-1], i, 1, numBasis),
  f_e : doExpand(f_c, basis),

  /* Volume increment (dimensional factor included later). */
  vol_incr_c : rdx2sq*calcInnerProdList(vars, -1, diff(basis,diffVar)*nu_e, diff(f_e,diffVar)),
  writeCIncrExprs1(out, vol_incr_c),
  printf(fh, "~%"),

  pOrderFact : (polyOrder+1)^2,
  nuAv : fullratsimp(innerProd(varsC, 1, 1, nu_e) / innerProd(varsC, 1, 1, 1)), 

  printf(fh, "  return ~a*rdx2sq; ~%", float(expand(pOrderFact*nuAv))),
  printf(fh, "}~%")
)$
