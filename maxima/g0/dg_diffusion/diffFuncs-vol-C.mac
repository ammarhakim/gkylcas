kill(all) $
load("modal-basis")$
load("recovery") $
load(stringproc)$
fpprec : 24$

genDGdiffKernelVol(fh, dim, basisType, polyOrder, dir) := block(
  [vars,basis,ba,polyFact,d],

  [vars, basis] : loadBasis(basisType, dim, polyOrder),
  ba : basis,
  
  printf(fh, "#include <gkyl_dg_diffusion_kernels.h>~%~%"),
  printf(fh, "GKYL_CU_DH double~%"),
  printf(fh, sconcat("dg_diffusion_vol_", dim, "x_", basisType,
      "_p", polyOrder, "(const double* w, const double* dx,~%")),
  printf(fh,
    "  const double* D, const double* q, double* GKYL_RESTRICT out) ~%"),
  printf(fh, "{~%"),
  printf(fh, "  // w[NDIM]: Cell-center coordinates~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing~%"),
  printf(fh, "  // D: Diffusion tensor~%"),
  printf(fh, "  // q: Input field~%"),
  printf(fh, "  // out: Incremented output~%~%"),

  polyFact : (polyOrder+1)^2,
  printf(fh, "  const double J[~a] = {~a/dx[0]/dx[0]", dim, float(4*polyFact)),
  for d : 2 thru dim do printf(fh, ", ~a/dx[~a]/dx[~a]", float(4*polyFact), d-1, d-1),
  printf(fh, "};~%~%"),
  
  printf(fh, "~%  return D[0]*J[0]"),
  for d : 2 thru dim do printf(fh, " + D[~a]*J[~a]", (d-1)*length(ba), d-1),
  printf(fh, ";~%"),
  printf(fh, "}~%")
)$
