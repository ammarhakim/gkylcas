/* Functions (called by moment-calc.mac) that compute the
   moments of the distribution function in Vlasov model. */

load("modal-basis");
load("out-scripts");
load(stringproc)$
fpprec : 24$

let(wx1^2, wx1_sq)$
let(wx2^2, wx2_sq)$
let(wx3^2, wx3_sq)$
let(dv1^2, dv1_sq)$
let(dv2^2, dv2_sq)$
let(dv3^2, dv3_sq)$

let(wx1^3, wx1_cu)$
let(wx2^3, wx2_cu)$
let(wx3^3, wx3_cu)$
let(dv1^3, dv1_cu)$
let(dv2^3, dv2_cu)$
let(dv3^3, dv3_cu)$

volExpr(cdim, vdim) := prod(dxv[cdim+i-1], i, 1, vdim)$

pVsub : [x=vx,y=vy,z=vz]$

vTrans  : [vx*dv1/2+wx1, vy*dv2/2+wx2, vz*dv3/2+wx3]$
wTrans  : [wx1, wx2, wx3]$
dvTrans : [vx*dv1/2, vy*dv2/2, vz*dv3/2]$
p_over_gamma_fld : [p0_over_gamma, p1_over_gamma, p2_over_gamma]$

/* Number density */
/* M0 = < f > */
calcSRM0(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block([],
  kill(varsC, varsP, basisC, basisP),
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
  load(modNm),
  bP : basisP[polyOrder],
  bC : basisC[polyOrder],
  
  printf(fh, "GKYL_CU_DH void ~a_M0_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, const double *p_over_gamma, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),
  fl : doExpand1(f, bP),
  M : calcInnerProdList(varsP, 1, bC, fl),
  writeCIncrExprs1(out, volFact*M),
  
  printf(fh, "} ~%")
)$


/* Momentum */
calcSRM1i(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [],
  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisFun, vdim, "x")),
  /* Generate basis in velocity space only. */
  bV : subst(pVsub,basisC[polyOrder]),
  NV : length(bV),
  
  kill(varsC, varsP, basisC, basisP),
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
  load(modNm),

  bP : basisP[polyOrder],
  bC : basisC[polyOrder],
  
  printf(fh, "GKYL_CU_DH void ~a_M1i_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, const double *p_over_gamma, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),
  for i : 1 thru vdim do (
    printf(fh, "  const double *p~a_over_gamma = &p_over_gamma[~a]; ~%", i-1, NV*(i-1))
  ),
  
  fl : doExpand1(f, bP),
  
  M : (M : [],
    for dir : 1 thru vdim do (
      M : append(M, calcInnerProdList(varsP, doExpand1(p_over_gamma_fld[dir], bV), bC, fl))
    ),
  M),
  
  clst : [volFact],
  writeCIncrExprsCollect1(out, volFact*M, clst),
  
  printf(fh, "} ~%")
)$

calcSRMoments(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block([],
  printf(fh, "#include <gkyl_mom_vlasov_kernels.h> ~%"),
  calcSRM0(fh, funcNm, cdim, vdim, basisFun, polyOrder),
  calcSRM1i(fh, funcNm, cdim, vdim, basisFun, polyOrder)
)$