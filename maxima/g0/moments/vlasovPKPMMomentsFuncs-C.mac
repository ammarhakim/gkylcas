/* Function that computes the moments of the distribution function in Vlasov 
    parallel-kinetic-perpendicular-moment (pkpm) model. 
    Note the Vlasov equation is in the local plasma rest frame in this model
    so the second moment is the parallel pressure and third moment is parallel heat
    flux (no Reynolds stress for example). */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

cvars : [x, y, z]$

let(wvpar^3, wvpar_cu)$
let(dvpar^3, dvpar_cu)$

let(wvpar^2, wvpar_sq)$
let(dvpar^2, dvpar_sq)$

volExpr(cdim, vdim) := prod(dxv[i-1], i, 1, vdim)$

/* Calculate mass density, parallel pressure, and parallel heat flux (PKPM moments) sequentially */
calcPKPMMoments(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,NP,NC,fl,bx_e,by_e,bz_e,vTrans,rho,ppar,qpar_x,qpar_y,qpar_z,PKPM_moments,clst],
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, double mass, const double *bvar, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),
  printf(fh, "  const double wvpar = w[~a], dvpar = dxv[~a]; ~%", 0, 0),
  printf(fh, "  const double wvpar_sq = wvpar*wvpar, dvpar_sq = dvpar*dvpar; ~%"),
  printf(fh, "  const double wvpar_cu = wvpar*wvpar*wvpar, dvpar_cu = dvpar*dvpar*dvpar; ~%"),
  printf(fh, "~%"),

  printf(fh, "  const double *bx = &bvar[~a]; ~%", 0),
  printf(fh, "  const double *by = &bvar[~a]; ~%", NC),
  printf(fh, "  const double *bz = &bvar[~a]; ~%", NC*2),
  printf(fh, "~%"),

  fl : doExpand1(f, bP),
  bx_e : doExpand1(bx, bC),
  by_e : doExpand1(by, bC),
  bz_e : doExpand1(bz, bC),

  vTrans  : vx*dvpar/2+wvpar,
  
  rho : calcInnerProdList(varsP, 1, bC, fl),
  ppar : calcInnerProdList(varsP, vTrans*vTrans, bC, fl),
  qpar_x : calcInnerProdList(varsP, 0.5*vTrans*vTrans*vTrans*bx_e, bC, fl),
  qpar_y : calcInnerProdList(varsP, 0.5*vTrans*vTrans*vTrans*by_e, bC, fl),
  qpar_z : calcInnerProdList(varsP, 0.5*vTrans*vTrans*vTrans*bz_e, bC, fl),
  
  ppar : map(letsimp, ppar),
  qpar_x : map(letsimp, qpar_x),
  qpar_y : map(letsimp, qpar_y),
  qpar_z : map(letsimp, qpar_z),

  qpar_e : [qpar_x, qpar_y, qpar_z],

  clst : [volFact, mass],
  PKPM_moments : [],
  PKPM_moments : append(PKPM_moments, volFact*mass*rho),
  PKPM_moments : append(PKPM_moments, volFact*mass*ppar),
  for dir : 1 thru cdim do (
    PKPM_moments : append(PKPM_moments, volFact*mass*qpar_e[dir])
  ),
  writeCIncrExprsCollect1(out, PKPM_moments, clst),
  printf(fh, "} ~%")
)$

calcPKPMSurfMoments(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,fl,vTrans,rho,ppar,qpar,PKPM_moments,clst],
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim  : length(varsP),
  
  printf(fh, "GKYL_CU_DH void ~a_surf~a_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, double mass, const double *u_il, const double *u_ir, const double *bvarl, const double *bvarr, const double *fl, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, vdim, basisFun, polyOrder),
  /* Updater assumes loop over *only* velocity grid, so only need the first entry of the cell center and grid space */
  printf(fh, "  const double volFact = dxv[0]/2.0; ~%"),
  printf(fh, "  const double wvpar = w[0], dvpar = dxv[0]; ~%"),
  printf(fh, "  const double wvpar_sq = wvpar*wvpar, dvpar_sq = dvpar*dvpar; ~%"),
  printf(fh, "  const double wvpar_cu = wvpar*wvpar*wvpar, dvpar_cu = dvpar*dvpar*dvpar; ~%"),
  printf(fh, "~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* cv = variable in direction of surface update. */
  cv : varsP[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsP),
  surfConfVars : delete(cv,varsC),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no cv dependence. */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),
    bConfSurf : basisFromVars("hyb",surfConfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder),
    bConfSurf : basisFromVars(basisFun,surfConfVars,polyOrder)
  ),
  NSurf : length(bSurf),
  NConfSurf : length(bConfSurf),

  printf(fh, "  const double *ul_0 = &u_il[~a]; ~%", NC*(dir-1)),
  printf(fh, "  const double *ur_0 = &u_ir[~a]; ~%", NC*(dir-1)),
  printf(fh, "  const double *bl_0 = &bvarl[~a]; ~%", NC*(dir-1)),
  printf(fh, "  const double *br_0 = &bvarr[~a]; ~%", NC*(dir-1)),

  if (cdim = 1) then (
    printf(fh, "  double *rho_flux = &out[0]; ~%"),
    printf(fh, "  double *heat_flux = &out[1]; ~%")
  )
  else (
    printf(fh, "  double *rho_flux = &out[~a]; ~%", NConfSurf*(dir-1)),
    printf(fh, "  double *heat_flux = &out[~a]; ~%", NConfSurf*(dir-1+cdim))
  ),

  /* Expand bulk velocity, magnetic field unit vector, and distribution function 
      in left, center, and right cells */
  ul_e : doExpand1(ul_0,bC),
  bl_e : doExpand1(bl_0,bC),
  fl_e : doExpand1(fl,bP),

  ur_e : doExpand1(ur_0,bC),
  br_e : doExpand1(br_0,bC),
  fr_e : doExpand1(fr,bP),

  vTrans  : vx*dvpar/2+wvpar,

  heat_flux_l_e : 0.5*vTrans*vTrans*vTrans*bl_e,
  heat_flux_r_e : 0.5*vTrans*vTrans*vTrans*br_e,

  /* alpha_l/c/r are the phase space fluxes at the surface. */
  /* Note we need alpha_c at both sides of the cell */
  printf(fh, "  double u_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double u_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double q_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double q_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  /* Project mass density flux and heat flux onto surface basis, and print resulting coefficients. */
  /* These quantities are computed from the distribution function and not yet integrated in velocity space */
  u_l_c : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, ul_e))),
  u_r_c : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1, ur_e))),
  q_l_c : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, heat_flux_l_e))),
  q_r_c : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1, heat_flux_r_e))),

  q_l_c : map(letsimp, q_l_c),
  q_r_c : map(letsimp, q_r_c),

  writeCExprs1(u_l, u_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(u_r, u_r_c ),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(q_l, q_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(q_r, q_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of mass density flux and heat flux which are empty.
      Since these still include velocity dependence, will be lots of empty coefficients. */
  uNoZero_l : doMakeExprLst(u_l_c, u_l),
  u_l_bSurf_e : doExpand(uNoZero_l, bSurf),

  uNoZero_r : doMakeExprLst(u_r_c, u_r),
  u_r_bSurf_e : doExpand(uNoZero_r, bSurf),

  qNoZero_l : doMakeExprLst(q_l_c, q_l),
  q_l_bSurf_e : doExpand(qNoZero_l, bSurf),

  qNoZero_r : doMakeExprLst(q_r_c, q_r),
  q_r_bSurf_e : doExpand(qNoZero_r, bSurf),

  /* Surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    surf_cdim : cdim-1,  surf_vdim : vdim,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim)
  ) else (
    surfNodes : gaussOrd(polyOrder+1, pDim-1)
  ),
  numNodes : length(surfNodes),

  /* Evaluate mass density flux and heat flux at ordinates.
     Note: These are already a surface expansions. */
  uOrd_l_n : gcfac(float(evAtNodes(u_l_bSurf_e,surfNodes,surfVars))),
  uOrd_r_n : gcfac(float(evAtNodes(u_r_bSurf_e,surfNodes,surfVars))),
  qOrd_l_n : gcfac(float(evAtNodes(q_l_bSurf_e,surfNodes,surfVars))),
  qOrd_r_n : gcfac(float(evAtNodes(q_l_bSurf_e,surfNodes,surfVars))),

  printf(fh, "  double uQuad[~a] = {0.0};~%", numNodes),
  printf(fh, "  double qQuad[~a] = {0.0};~%", numNodes),
  printf(fh, "  double uMax[~a] = {0.0};~%", NSurf),
  printf(fh, "  double qMax[~a] = {0.0};~%", NSurf),

  printf(fh, "  double ev_u_l = 0.0; ~%"),
  printf(fh, "  double ev_u_r = 0.0; ~%"),
  printf(fh, "  double ev_q_l = 0.0; ~%"),
  printf(fh, "  double ev_q_r = 0.0; ~%"),
  printf(fh, "~%"),
  for i : 1 thru numNodes do (
    printf(fh, "  ev_u_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(u_l); ~%", basisFun, pDim, polyOrder, dir, i-1),
    printf(fh, "  ev_u_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(u_r); ~%", basisFun, pDim, polyOrder, dir, i-1),
    printf(fh, "  ev_q_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(q_l); ~%", basisFun, pDim, polyOrder, dir, i-1),
    printf(fh, "  ev_q_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(q_r); ~%", basisFun, pDim, polyOrder, dir, i-1),

    printf(fh, "  uQuad[~a] = fmax(fabs(ev_u_l), fabs(ev_u_r)); ~%", i-1),
    printf(fh, "  qQuad[~a] = fmax(fabs(ev_q_l), fabs(ev_q_r)); ~%", i-1)
  ),

  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uQuad, uMax); ~%", basisFun, pDim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(qQuad, qMax); ~%", basisFun, pDim, polyOrder),

  /* Evaluate distribution function at the interfaces, -1 (lower) or +1 (upper) */
  f_l : subst(cv=1, fl_e),
  f_r : subst(cv=-1, fr_e),

  /* Ghat = 1/2 * (alpha_l*f_l + alpha_r*f_r) - 1/2 * |max(alpha_l, alpha_r)| (f_r - f_l) */
  avg_rho_flux : 0.5*(u_l_bSurf_e*f_l + u_r_bSurf_e*f_r),
  avg_heat_flux : 0.5*(q_l_bSurf_e*f_l + q_r_bSurf_e*f_r),

  jump : 0.5*(f_r - f_l),

  /* Create expansions of u_max and q_max in the surface basis. */
  uMax_e : doExpand1(uMax, bSurf),
  qMax_e : doExpand1(qMax, bSurf),
  
  if (cdim = 1) then (
    rho_flux_e : calcInnerProdList(surfVars, 1, [1], avg_rho_flux - uMax_e*jump),
    heat_flux_e : calcInnerProdList(surfVars, 1, [1], avg_heat_flux - qMax_e*jump)
  )
  else (
    rho_flux_e : calcInnerProdList(surfVars, 1, bConfSurf, avg_rho_flux - uMax_e*jump),
    heat_flux_e : calcInnerProdList(surfVars, 1, bConfSurf, avg_heat_flux - qMax_e*jump)
  ),
  
  heat_flux_e : map(letsimp, heat_flux_e),

  clst : [volFact, mass],
  writeCIncrExprsCollect1(rho_flux, volFact*mass*rho_flux_e, clst),
  writeCIncrExprsCollect1(heat_flux, volFact*mass*heat_flux_e, clst),
  printf(fh, "} ~%")
)$
