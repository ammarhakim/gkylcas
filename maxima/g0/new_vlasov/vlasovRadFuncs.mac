/*  Generate kernels for velocity-space dependent radiation fields. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
load("new_vlasov/vlasov-basis");
fpprec : 24$

clabels : ["x","y","z"]$
vTrans  : [vx*dv1/2+wx1, vy*dv2/2+wx2, vz*dv3/2+wx3]$
calcRad(fh, funcNm, vdim, basisFun, polyOrder, compton, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NV, 
   varsV_p3,bV_p3,bV_vx,bV_vy,bV_vz,NV_p3,
   nodes_lobatto,num_nodes_lobatto,
   vx_e,vy_e,vz_e,vx_nodes,vy_nodes,vz_nodes,
   basis_nodal_lobatto,rad_nodal_vx_e,rad_nodal_vy_e,rad_nodal_vz_e,
   rad_vx_c,rad_vy_c,rad_vz_c],

  /* Load basis of dimensionality requested. 
     Only need velocity space basis, so just set cdim = 1. */
  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, 1, vdim, polyOrder), 
  NV : length(bV),

  /* Load cubic mapping for momentum-space coordinate 
     Only 1D because we have 3 1D mappings. But we need
     3 of them to obtain the correct variation in up to 3V. */
  [varsV_p3,bV_p3] : loadBasis(basisFun, 1, 3),
  bV_vx : subst(x=vx, copylist(bV_p3)), 
  bV_vy : subst(x=vy, copylist(bV_p3)), 
  bV_vz : subst(x=vz, copylist(bV_p3)), 
  NV_p3 : length(bV_p3),

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *vmap, 
  double t_cool, double p0, double* GKYL_RESTRICT rad) ~%{ ~%", funcNm),
  printf(fh, "  // w:   Cell-center coordinates of velocity grid.~%"),
  printf(fh, "  // dxv: Cell spacing of velocity grid.~%"),
  printf(fh, "  // vmap: Velocity-space map for nonuniform meshes.~%"),
  printf(fh, "  // t_cool: Cooling time.~%"),
  printf(fh, "  // p0: Momentum to relax to.~%"),
  printf(fh, "  // rad: Radiation field (-(p - p0)/tcool for Compton, -sign(p)*p^4 = -|p|*p^3 for curvature).~%"),
  printf(fh, " ~%"),  

  /* For p = 1, we use nodes (-1, 1) and 
     for p = 2, we use the nodes (-1, 0, 1) (Gauss-Lobatto nodes) */
  nodes_lobatto : getNodes(basisFun, vdim, polyOrder),
  num_nodes_lobatto : length(nodes_lobatto),
  if (vmap) then (
    for dir : 1 thru vdim do (
      printf(fh, "  const double *vmap_v~a = &vmap[~a]; ~%", clabels[dir], NV_p3*(dir-1)), 
      printf(fh, "  double *rad_v~a = &rad[~a];~%", clabels[dir], NV*(dir-1)), 
      printf(fh, "  double rad_nodal_v~a[~a] = {0.0};~%", clabels[dir], num_nodes_lobatto)
    ),

    vx_e : doExpand1(vmap_vx, bV_vx), 
    vy_e : doExpand1(vmap_vy, bV_vy), 
    vz_e : doExpand1(vmap_vz, bV_vz), 
    vx_nodes : expand(float(evAtNodes(vx_e, nodes_lobatto, varsV))), 
    vy_nodes : expand(float(evAtNodes(vy_e, nodes_lobatto, varsV))), 
    vz_nodes : expand(float(evAtNodes(vz_e, nodes_lobatto, varsV))) 
  )
  else (
    for dir : 1 thru vdim do (
      printf(fh, "  double wx~a = w[~a], dv~a = dxv[~a]; ~%", dir, dir-1, dir, dir-1),
      printf(fh, "  double *rad_v~a = &rad[~a];~%", clabels[dir], NV*(dir-1)), 
      printf(fh, "  double rad_nodal_v~a[~a] = {0.0};~%", clabels[dir], num_nodes_lobatto)
    ),
    vx_nodes : expand(float(evAtNodes(vTrans[1], nodes_lobatto, varsV))), 
    vy_nodes : expand(float(evAtNodes(vTrans[2], nodes_lobatto, varsV))), 
    vz_nodes : expand(float(evAtNodes(vTrans[3], nodes_lobatto, varsV))) 
  ),
  printf(fh, "~%"),

  for i : 1 thru num_nodes_lobatto do (
    if (compton) then (
      if (vdim = 1) then (
        printf(fh, "  rad_nodal_vx[~a] = -1.0/t_cool*(~a - p0);~%", i-1, vx_nodes[i])
      )
      else if (vdim = 2) then (
        printf(fh, "  rad_nodal_vx[~a] = -1.0/t_cool*(~a - p0);~%", i-1, vx_nodes[i]),
        printf(fh, "  rad_nodal_vy[~a] = -1.0/t_cool*(~a - p0);~%", i-1, vy_nodes[i])        
      )
      else (
        printf(fh, "  rad_nodal_vx[~a] = -1.0/t_cool*(~a - p0);~%", i-1, vx_nodes[i]),
        printf(fh, "  rad_nodal_vy[~a] = -1.0/t_cool*(~a - p0);~%", i-1, vy_nodes[i]), 
        printf(fh, "  rad_nodal_vz[~a] = -1.0/t_cool*(~a - p0);~%", i-1, vz_nodes[i])         
      ),
      printf(fh, "~%")
    )
    else (
      if (vdim = 1) then (
        printf(fh, "  rad_nodal_vx[~a] = -1.0/t_cool*(pow(~a, 3.0)*fabs(~a));~%", i-1, vx_nodes[i], vx_nodes[i])
      )
      else if (vdim = 2) then (
        printf(fh, "  rad_nodal_vx[~a] = -1.0/t_cool*(pow(~a, 3.0)*fabs(~a));~%", i-1, vx_nodes[i], vx_nodes[i]),
        printf(fh, "  rad_nodal_vy[~a] = -1.0/t_cool*(pow(~a, 3.0)*fabs(~a));~%", i-1, vy_nodes[i], vy_nodes[i])
      )
      else (
        printf(fh, "  rad_nodal_vx[~a] = -1.0/t_cool*(pow(~a, 3.0)*fabs(~a));~%", i-1, vx_nodes[i], vx_nodes[i]),
        printf(fh, "  rad_nodal_vy[~a] = -1.0/t_cool*(pow(~a, 3.0)*fabs(~a));~%", i-1, vy_nodes[i], vy_nodes[i]),
        printf(fh, "  rad_nodal_vz[~a] = -1.0/t_cool*(pow(~a, 3.0)*fabs(~a));~%", i-1, vz_nodes[i], vz_nodes[i])     
      ),
      printf(fh, "~%")
    )
  ),
  
  basis_nodal_lobatto : getVarsNodalBasisWithNodes(basisFun, vdim, polyOrder, varsV, nodes_lobatto), 
  rad_nodal_vx_e : doExpand1(rad_nodal_vx, basis_nodal_lobatto),
  rad_nodal_vy_e : doExpand1(rad_nodal_vy, basis_nodal_lobatto),
  rad_nodal_vz_e : doExpand1(rad_nodal_vz, basis_nodal_lobatto),
  rad_vx_c : calcInnerProdList(varsV, 1, bV, rad_nodal_vx_e), 
  rad_vy_c : calcInnerProdList(varsV, 1, bV, rad_nodal_vy_e), 
  rad_vz_c : calcInnerProdList(varsV, 1, bV, rad_nodal_vz_e),
  writeCExprs1(rad_vx, rad_vx_c), 
  printf(fh, "~%"), 
  flush_output(fh),
  if (vdim > 1) then (
    writeCExprs1(rad_vy, rad_vy_c), 
    printf(fh, "~%"), 
    flush_output(fh)
  ), 
  if (vdim = 3) then (
    writeCExprs1(rad_vz, rad_vz_c), 
    printf(fh, "~%"), 
    flush_output(fh)    
  ),

  printf(fh, "} ~%")
)$  

