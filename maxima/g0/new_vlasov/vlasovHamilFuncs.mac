/*  Generate kernels for 
    1. default Hamiltonian: v^2/2
    2. relativistic Hamiltonian = sqrt(1 + u^2),
    These quantities are derived from the grid and must be continuous, 
    so they are projected onto basis functions using Gauss-Lobatto nodes. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
load("new_vlasov/vlasov-basis");
fpprec : 24$

vTrans  : [vx*dv1/2+wx1, vy*dv2/2+wx2, vz*dv3/2+wx3]$
calcHamil(fh, funcNm, vdim, basisFun, polyOrder, relativistic) := block(
  [varsC,bC,varsV,bV,varsP,bP,NV],

  /* Load basis of dimensionality requested. 
     Only need velocity space basis, so just set cdim = 1. */
  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, 1, vdim, polyOrder), 
  NV : length(bV),

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, double* GKYL_RESTRICT hamil) ~%{ ~%", funcNm),
  printf(fh, "  // w:   Cell-center coordinates of velocity grid.~%"),
  printf(fh, "  // dxv: Cell spacing of velocity grid.~%"),
  printf(fh, "  // hamil: Particle Hamiltonian.~%"),
  printf(fh, " ~%"),  

  for i : 1 thru vdim do (
    printf(fh, "  double wx~a = w[~a], dv~a = dxv[~a]; ~%", i, i-1, i, i-1)
  ),

  /* For p = 1, we use nodes (-1, 1) and 
     for p = 2, we use the nodes (-1, 0, 1) (Gauss-Lobatto nodes) */
  nodes_lobatto : getNodes(basisFun, vdim, polyOrder),
  num_nodes_lobatto : length(nodes_lobatto),
  vx_nodes : expand(float(evAtNodes(vTrans[1], nodes_lobatto, varsV))), 
  vy_nodes : expand(float(evAtNodes(vTrans[2], nodes_lobatto, varsV))), 
  vz_nodes : expand(float(evAtNodes(vTrans[3], nodes_lobatto, varsV))), 

  printf(fh, "  double hamil_nodal[~a] = {0.0};~%", num_nodes_lobatto),  
  for i : 1 thru num_nodes_lobatto do (
    if (relativistic) then (
      if (vdim = 1) then (
        printf(fh, "  hamil_nodal[~a] = sqrt(1.0 + pow(~a, 2.0));~%", i-1, vx_nodes[i])
      )
      else if (vdim = 2) then (
        printf(fh, "  hamil_nodal[~a] = sqrt(1.0 + pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, vx_nodes[i], vy_nodes[i])        
      )
      else (
        printf(fh, "  hamil_nodal[~a] = sqrt(1.0 + pow(~a, 2.0) + pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, vx_nodes[i], vy_nodes[i], vz_nodes[i])         
      )
    )
    else (
      if (vdim = 1) then (
        printf(fh, "  hamil_nodal[~a] = 0.5*(pow(~a, 2.0));~%", i-1, vx_nodes[i])
      )
      else if (vdim = 2) then (
        printf(fh, "  hamil_nodal[~a] = 0.5*(pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, vx_nodes[i], vy_nodes[i])        
      )
      else (
        printf(fh, "  hamil_nodal[~a] = 0.5*(pow(~a, 2.0) + pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, vx_nodes[i], vy_nodes[i], vz_nodes[i])         
      )
    )
  ), 
  printf(fh, "~%"), 
  
  basis_nodal_lobatto : getVarsNodalBasisWithNodes(basisFun, vdim, polyOrder, varsV, nodes_lobatto), 
  hamil_nodal_e : doExpand1(hamil_nodal, basis_nodal_lobatto),
  hamil_c : calcInnerProdList(varsV, 1, bV, hamil_nodal_e), 
  writeCExprs1(hamil, hamil_c), 
  printf(fh, "~%"), 
  flush_output(fh),

  printf(fh, "} ~%")
)$  

