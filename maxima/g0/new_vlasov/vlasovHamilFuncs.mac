/*  Generate kernels for 
    1. default Hamiltonian: v^2/2
    2. relativistic Hamiltonian = sqrt(1 + u^2),
    These quantities are derived from the grid and must be continuous, 
    so they are projected onto basis functions using Gauss-Lobatto nodes. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
load("new_vlasov/vlasov-basis");
fpprec : 24$

clabels : ["x","y","z"]$
vTrans  : [vx*dv1/2+wx1, vy*dv2/2+wx2, vz*dv3/2+wx3]$
calcHamil(fh, funcNm, vdim, basisFun, polyOrder, relativistic, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NV, 
   varsV_p3,bV_p3,bV_vx,bV_vy,bV_vz,NV_p3,
   nodes_lobatto,num_nodes_lobatto,
   vx_e,vy_e,vz_e,vx_nodes,vy_nodes,vz_nodes,
   basis_nodal_lobatto,hamil_nodal_e,hamil_c,hamil_inv_nodal_e,hamil_inv_c],

  /* Load basis of dimensionality requested. 
     Only need velocity space basis, so just set cdim = 1. */
  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, 1, vdim, polyOrder), 
  NV : length(bV),

  /* Load cubic mapping for momentum-space coordinate 
     Only 1D because we have 3 1D mappings. But we need
     3 of them to obtain the correct variation in up to 3V. */
  [varsV_p3,bV_p3] : loadBasis(basisFun, 1, 3),
  bV_vx : subst(x=vx, copylist(bV_p3)), 
  bV_vy : subst(x=vy, copylist(bV_p3)), 
  bV_vz : subst(x=vz, copylist(bV_p3)), 
  NV_p3 : length(bV_p3),

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *vmap, double* GKYL_RESTRICT hamil, double* GKYL_RESTRICT hamil_inv) ~%{ ~%", funcNm),
  printf(fh, "  // w:   Cell-center coordinates of velocity grid.~%"),
  printf(fh, "  // dxv: Cell spacing of velocity grid.~%"),
  printf(fh, "  // vmap: Velocity-space map for nonuniform meshes.~%"),
  printf(fh, "  // hamil: Particle Hamiltonian.~%"),
  printf(fh, "  // hamil_inv: Inverse particle Hamiltonian. Utilized by relativistic simulations. ~%"),
  printf(fh, " ~%"),  

  /* For p = 1, we use nodes (-1, 1) and 
     for p = 2, we use the nodes (-1, 0, 1) (Gauss-Lobatto nodes) 
     for p = 3, we use the nodes (-1, -sqrt(1/5), sqrt(1/5), 1) */
  if (polyOrder = 3) then (
    if (vdim = 1) then (
      nodes_lobatto : matrix([-1],[-sqrt(1/5)],[sqrt(1/5)],[1])
    )
    else if (vdim = 2) then (
      if (basisFun = "ser") then (
        nodes_lobatto : matrix([-1,-1],[-sqrt(1/5),-1],[sqrt(1/5),-1],[1,-1], 
                              [-1,-sqrt(1/5)],[1,-sqrt(1/5)],[-1,sqrt(1/5)],[1,sqrt(1/5)],
                              [-1,1],[-sqrt(1/5),1],[sqrt(1/5),1],[1,1])
      )
      else (
        nodes_lobatto : matrix([-1,-1],[-sqrt(1/5),-1],[sqrt(1/5),-1],[1,-1], 
                              [-1,-sqrt(1/5)],[-sqrt(1/5),-sqrt(1/5)],[sqrt(1/5),-sqrt(1/5)],[1,-sqrt(1/5)],
                              [-1,sqrt(1/5)],[-sqrt(1/5),sqrt(1/5)],[sqrt(1/5),sqrt(1/5)],[1,sqrt(1/5)],
                              [-1,1],[-sqrt(1/5),1],[sqrt(1/5),1],[1,1])
      )
    )
  ) 
  else if (polyOrder = 1) and basisFun = "tensor" then (
    /* Choose hybrid tensor, p = 2 velocity space */
    nodes_lobatto : getNodes(basisFun, vdim, polyOrder + 1)
  ) 
  else (
    nodes_lobatto : getNodes(basisFun, vdim, polyOrder)
  ),
  num_nodes_lobatto : length(nodes_lobatto),
  if (vmap) then (
    for dir : 1 thru vdim do (
      printf(fh, "  const double *vmap_v~a = &vmap[~a]; ~%", clabels[dir], NV_p3*(dir-1))
    ),

    vx_e : doExpand1(vmap_vx, bV_vx), 
    vy_e : doExpand1(vmap_vy, bV_vy), 
    vz_e : doExpand1(vmap_vz, bV_vz), 
    vx_nodes : expand(float(evAtNodes(vx_e, nodes_lobatto, varsV))), 
    vy_nodes : expand(float(evAtNodes(vy_e, nodes_lobatto, varsV))), 
    vz_nodes : expand(float(evAtNodes(vz_e, nodes_lobatto, varsV))) 
  )
  else (
    for i : 1 thru vdim do (
      printf(fh, "  double wx~a = w[~a], dv~a = dxv[~a]; ~%", i, i-1, i, i-1)
    ),
    vx_nodes : expand(float(evAtNodes(vTrans[1], nodes_lobatto, varsV))), 
    vy_nodes : expand(float(evAtNodes(vTrans[2], nodes_lobatto, varsV))), 
    vz_nodes : expand(float(evAtNodes(vTrans[3], nodes_lobatto, varsV))) 
  ),

  printf(fh, "  double hamil_nodal[~a] = {0.0};~%", num_nodes_lobatto),  
  printf(fh, "  double hamil_inv_nodal[~a] = {0.0};~%", num_nodes_lobatto),  
  for i : 1 thru num_nodes_lobatto do (
    if (relativistic) then (
      if (vdim = 1) then (
        printf(fh, "  hamil_nodal[~a] = sqrt(1.0 + pow(~a, 2.0));~%", i-1, vx_nodes[i])
      )
      else if (vdim = 2) then (
        printf(fh, "  hamil_nodal[~a] = sqrt(1.0 + pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, vx_nodes[i], vy_nodes[i])        
      )
      else (
        printf(fh, "  hamil_nodal[~a] = sqrt(1.0 + pow(~a, 2.0) + pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, vx_nodes[i], vy_nodes[i], vz_nodes[i])         
      )
    )
    else (
      if (vdim = 1) then (
        printf(fh, "  hamil_nodal[~a] = 0.5*(pow(~a, 2.0));~%", i-1, vx_nodes[i])
      )
      else if (vdim = 2) then (
        printf(fh, "  hamil_nodal[~a] = 0.5*(pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, vx_nodes[i], vy_nodes[i])        
      )
      else (
        printf(fh, "  hamil_nodal[~a] = 0.5*(pow(~a, 2.0) + pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, vx_nodes[i], vy_nodes[i], vz_nodes[i])         
      )
    ),
    printf(fh, "  hamil_inv_nodal[~a] = 1.0/hamil_nodal[~a];~%", i-1, i-1) 
  ),
  printf(fh, "~%"), 
  
  if (polyOrder = 1) and basisFun = "tensor" then (
    basis_nodal_lobatto : getVarsNodalBasisWithNodes(basisFun, vdim, polyOrder+1, varsV, nodes_lobatto)
  ) 
  else (
    basis_nodal_lobatto : getVarsNodalBasisWithNodes(basisFun, vdim, polyOrder, varsV, nodes_lobatto)
  ),
  hamil_nodal_e : doExpand1(hamil_nodal, basis_nodal_lobatto),
  hamil_c : calcInnerProdList(varsV, 1, bV, hamil_nodal_e), 
  writeCExprs1(hamil, hamil_c), 
  printf(fh, "~%"), 
  flush_output(fh),

  hamil_inv_nodal_e : doExpand1(hamil_inv_nodal, basis_nodal_lobatto),
  hamil_inv_c : calcInnerProdList(varsV, 1, bV, hamil_inv_nodal_e), 
  writeCExprs1(hamil_inv, hamil_inv_c), 
  printf(fh, "~%"), 
  flush_output(fh),

  printf(fh, "} ~%")
)$  

