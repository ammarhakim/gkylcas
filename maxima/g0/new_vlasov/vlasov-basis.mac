load("modal-basis");
load("out-scripts");

loadVlasovBasis(basisType, cdim, vdim, polyOrder) := block(
  [varsSubV, varsSubP],
  
  [varsC,bC] : loadBasis(basisType, cdim, polyOrder),
  [varsV,bV] : loadBasis(basisType, vdim, polyOrder), 
  [varsP,bP] : loadBasis(basisType, cdim+vdim, polyOrder), 
  /* Do a variable substitution for the lower dimensional basis functions
     to construct the correct set of variables for the subsequent operations */
  if (cdim = 1) then (
    if (vdim = 1) then (
      varsSubV : [x=vx], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      varsSubP : [y=vx],
      bP : subst(varsSubP, copylist(bP)),  
      varsP : subst(varsSubP, copylist(varsP))
    )
    else if (vdim = 2) then (
      varsSubV : [x=vx, y=vy], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      varsSubP : [y=vx, z=vy],
      bP : subst(varsSubP, copylist(bP)),  
      varsP : subst(varsSubP, copylist(varsP))      
    )
  )
  else if (cdim = 2) then (
    if (vdim = 1) then (
      varsSubV : [x=vx], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      varsSubP : [z=vx],
      bP : subst(varsSubP, copylist(bP)),  
      varsP : subst(varsSubP, copylist(varsP))   
    )
    else if (vdim = 2) then (
      varsSubV : [x=vx, y=vy], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      varsSubP : [vx=y, vy=vx, vz=vy],
      bP : subst(varsSubP, copylist(bP)),  
      varsP : subst(varsSubP, copylist(varsP)) 
    )
  ), 

  if (vdim = 3) then (
    varsSubV : [x=vx, y=vy, z=vz], 
    bV : subst(varsSubV, copylist(bV)),  
    varsV : subst(varsSubV, copylist(varsV))
  ),
  return([varsC,bC,varsV,bV,varsP,bP])
)$

loadVlasovSurfBasis(basisType, polyOrder, surfVars) := block(
  bSurf : basisFromVars(basisType,surfVars,polyOrder),
  NSurf : length(bSurf), 

  if (polyOrder = 1) then (
    surfNodes : gaussOrd(2,length(surfVars)), 
    basisNodal  : getVarsNodalBasisWithNodes("Tensor", length(surfVars), 1, surfVars, surfNodes)
  )
  else if (polyOrder = 2) then (
    /* 4 quadrature points required for p=2, so nodal basis is a cubic. */
    surfNodes : gaussOrd(4,length(surfVars)), 
    basisNodal  : getVarsNodalBasisWithNodes("Tensor", length(surfVars), 3, surfVars, surfNodes)
  ), 
  numNodes : length(surfNodes),   
  return([bSurf,NSurf,surfNodes,basisNodal,numNodes])
)$

loadVlasovSurfBasisNew(basisType, polyOrder, surfVars, surfVVars, varsC) := block(
  bSurf : basisFromVars(basisType,surfVars,polyOrder),

    /* 4 quadrature points required for p=2, so nodal basis is a cubic. */
  if (polyOrder = 1) then (
    nodes_conf : gaussOrd(2, cdim), 
    basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(varsC), 1, varsC, nodes_conf)
  )
  else (
    nodes_conf : gaussOrd(4, cdim), 
    basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(varsC), 3, varsC, nodes_conf)
  ),

  if (vdim > 1) then (
    if (polyOrder = 1) then (
      nodes_vel : gaussOrd(2, vdim-1), 
      basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(surfVVars), 1, surfVVars, nodes_vel) 
    )
    else (
      nodes_vel : gaussOrd(4, vdim-1), 
      basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(surfVVars), 3, surfVVars, nodes_vel) 
    )
  )
  else (
    nodes_vel : [1], 
    basisNodalVel : [1] 
  ),


  if (polyOrder = 1) then (
    surfNodes : gaussOrd(2,length(surfVars))
  )
  else if (polyOrder = 2) then (
    surfNodes : gaussOrd(4,length(surfVars))
  ), 
  return([bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes])
)$

loadVelJacobianBasis() := block(
  /* Load basis sets for Jacobian in each direction, 
     which are p=2 in one velocity dimension (derivative of cubic C^1 mapping). */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 2), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 
  bV_vy : subst(x=vy, copylist(bV_1D)), 
  bV_vz : subst(x=vz, copylist(bV_1D)), 

  jacobNodes : gaussOrd(3,1), 
  numJacobNodes : length(jacobNodes), 
  basisNodal_vx  : getVarsNodalBasisWithNodes("Tensor", 1, 2, [vx], jacobNodes),
  basisNodal_vy  : getVarsNodalBasisWithNodes("Tensor", 1, 2, [vy], jacobNodes),
  basisNodal_vz  : getVarsNodalBasisWithNodes("Tensor", 1, 2, [vz], jacobNodes),
  jacobNodes_vx : [jacob_vx[0], jacob_vx[1], jacob_vx[2]],  
  jacobNodes_vy : [jacob_vy[0], jacob_vy[1], jacob_vy[2]],  
  jacobNodes_vz : [jacob_vz[0], jacob_vz[1], jacob_vz[2]], 
  bV_vi : [bV_vx, bV_vy, bV_vz], 
  NV_1D : length(bV_1D),   
  jacobNodes_vi : [jacobNodes_vx, jacobNodes_vy, jacobNodes_vz],
  basisNodal_vi : [basisNodal_vx, basisNodal_vy, basisNodal_vz], 
  return([bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi])
)$

/* Set the threshold for pruning terms in the surface Jacobian */
zero_threshold : 1.0e-14;

prune(expr) := block(
  [terms, result : [], coeff, term_args],
  terms : if op(expr) = "+" then args(expr) else [expr],

  for term in terms do (
    if op(term) = "*" then (
      term_args : args(term),
      coeff : first(term_args),
      if numberp(coeff) and float(abs(coeff)) < zero_threshold then (
        print("Dropping:", term)
      ) else (
        result : endcons(term, result)
      )
    )
    else if numberp(term) and float(abs(term)) < zero_threshold then (
      print("Dropping constant term:", term)
    )
    else if op(term) = "-" and length(args(term)) = 1 and op(first(args(term))) = "*" then (
      /* Handle unary minus before a product */
      term_args : args(first(args(term))),
      coeff : first(term_args),
      if numberp(coeff) and float(abs(coeff)) < zero_threshold then (
        print("Dropping negated term:", term)
      ) else (
        result : endcons(term, result)
      )
    )
    else (
      /* Anything else, keep */
      result : endcons(term, result)
    )
  ),

  return(if length(result) = 0 then 0 else apply("+", result))
);

/* Construct specific velocity-space surface velocity Jacobian terms. Returns: 
   1. jacob_edge (evaluation of velocity-space Jacobian at cell edge for time step estimate)
   2. jacob_vi_surf (array of velocity space Jacobian in each direction at larger number of
      quadrature points for use in magnetic Lorentz force 1/Jvi dH/dvi x B). 
   3. jacob_surf_tot (total velocity-space Jacobian at the velocity surface in direction dir, 
      e.g., jacob_vy in 2V at vx surfaces, or jacob_vy*jacob_vz in 3V at vx surfaces).
*/
loadSurfVelJacobian(vdim, dir, nodes_vel, surfVVars, surfNodes, surfVars, calc_surf_jacob) := block(
  surf_nodes_1v : gaussOrd(4, 1), 

  basisNodal_vx : getVarsNodalBasisWithNodes("Tensor", 1, 3, [vx], surf_nodes_1v),
  jacob_vx_surf : [jacob_vel_surf_vx[0], jacob_vel_surf_vx[1], jacob_vel_surf_vx[2], jacob_vel_surf_vx[3]], 
  jacob_vx_surf_ne : 0, 
  for i : 1 thru 4 do (
    jacob_vx_surf_ne : jacob_vx_surf_ne + jacob_vx_surf[i]*basisNodal_vx[i] 
  ), 

  basisNodal_vy : getVarsNodalBasisWithNodes("Tensor", 1, 3, [vy], surf_nodes_1v),
  jacob_vy_surf : [jacob_vel_surf_vy[0], jacob_vel_surf_vy[1], jacob_vel_surf_vy[2], jacob_vel_surf_vy[3]], 
  jacob_vy_surf_ne : 0, 
  for i : 1 thru 4 do (
    jacob_vy_surf_ne : jacob_vy_surf_ne + jacob_vy_surf[i]*basisNodal_vy[i] 
  ), 

  basisNodal_vz : getVarsNodalBasisWithNodes("Tensor", 1, 3, [vz], surf_nodes_1v),
  jacob_vz_surf : [jacob_vel_surf_vz[0], jacob_vel_surf_vz[1], jacob_vel_surf_vz[2], jacob_vel_surf_vz[3]], 
  jacob_vz_surf_ne : 0, 
  for i : 1 thru 4 do (
    jacob_vz_surf_ne : jacob_vz_surf_ne + jacob_vz_surf[i]*basisNodal_vz[i] 
  ), 

  /* Velocity-space Jacobian evaluated at edge for estimating time step. */
  jacob_vx_edge : subst(vx=-1, jacob_vx_surf_ne),
  jacob_vy_edge : subst(vy=-1, jacob_vy_surf_ne),
  jacob_vz_edge : subst(vz=-1, jacob_vz_surf_ne),
  jacob_edge : [jacob_vx_edge, jacob_vy_edge, jacob_vz_edge],  

  jacob_surf_tot : makelist(0, i, 1, length(surfNodes)),
  if (calc_surf_jacob) then (
    jacob_vx_surf_l_n : float(evAtNodes(jacob_vx_surf_ne, surfNodes, surfVars)), 
    jacob_vy_surf_l_n : float(evAtNodes(jacob_vy_surf_ne, surfNodes, surfVars)), 
    jacob_vz_surf_l_n : float(evAtNodes(jacob_vz_surf_ne, surfNodes, surfVars)), 
    for i : 1 thru length(jacob_vx_surf_l_n) do (
      jacob_vx_surf_l_n[i] : prune(jacob_vx_surf_l_n[i]),
      jacob_vy_surf_l_n[i] : prune(jacob_vy_surf_l_n[i]),
      jacob_vz_surf_l_n[i] : prune(jacob_vz_surf_l_n[i])
    ),  
    /* Construct the transverse velocity space Jacobian at surface quadrature points. */
    if (vdim = 1) then (
      for i : 1 thru length(surfNodes) do (
        jacob_surf_tot[i] : 1
      )
    )
    else if (vdim = 2) then (
      for i : 1 thru length(surfNodes) do (
        if (dir = 1) then (
          jacob_surf_tot[i] : jacob_vy_surf_l_n[i]
        )
        else (
          jacob_surf_tot[i] : jacob_vx_surf_l_n[i]
        )
      )
    )
    else (
      for i : 1 thru length(surfNodes) do (
        if (dir = 1) then (
          jacob_surf_tot[i] : jacob_vy_surf_l_n[i]*jacob_vz_surf_l_n[i]
        )
        else if (dir = 2) then (
          jacob_surf_tot[i] : jacob_vx_surf_l_n[i]*jacob_vz_surf_l_n[i]
        )
        else (
          jacob_surf_tot[i] : jacob_vx_surf_l_n[i]*jacob_vy_surf_l_n[i]
        )
      )    
    )       
  ) 
  else (
    jacob_vx_surf_l_n : float(evAtNodes(jacob_vx_surf_ne, nodes_vel, surfVVars)), 
    jacob_vy_surf_l_n : float(evAtNodes(jacob_vy_surf_ne, nodes_vel, surfVVars)), 
    jacob_vz_surf_l_n : float(evAtNodes(jacob_vz_surf_ne, nodes_vel, surfVVars)), 
    for i : 1 thru length(jacob_vx_surf_l_n) do (
      jacob_vx_surf_l_n[i] : prune(jacob_vx_surf_l_n[i]),
      jacob_vy_surf_l_n[i] : prune(jacob_vy_surf_l_n[i]),
      jacob_vz_surf_l_n[i] : prune(jacob_vz_surf_l_n[i])
    )    
  ),
  /* Velocity-space Jacobian at full velocity space surface nodes (2V surface in 3V). */
  jacob_vi_surf : [jacob_vx_surf_l_n, jacob_vy_surf_l_n, jacob_vz_surf_l_n],

  return([jacob_edge, jacob_vi_surf, jacob_surf_tot])
)$ 