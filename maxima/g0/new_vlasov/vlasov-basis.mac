load("modal-basis");
load("out-scripts");

loadVlasovBasis(basisType, cdim, vdim, polyOrder) := block(
  [varsSubV, varsSubP],
  
  [varsC,bC] : loadBasis(basisType, cdim, polyOrder),
  [varsV,bV] : loadBasis(basisType, vdim, polyOrder), 
  [varsP,bP] : loadBasis(basisType, cdim+vdim, polyOrder), 
  /* Do a variable substitution for the lower dimensional basis functions
     to construct the correct set of variables for the subsequent operations */
  if (cdim = 1) then (
    if (vdim = 1) then (
      varsSubV : [x=vx], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      varsSubP : [y=vx],
      bP : subst(varsSubP, copylist(bP)),  
      varsP : subst(varsSubP, copylist(varsP))
    )
    else if (vdim = 2) then (
      varsSubV : [x=vx, y=vy], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      varsSubP : [y=vx, z=vy],
      bP : subst(varsSubP, copylist(bP)),  
      varsP : subst(varsSubP, copylist(varsP))      
    )
  )
  else if (cdim = 2) then (
    if (vdim = 1) then (
      varsSubV : [x=vx], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      varsSubP : [z=vx],
      bP : subst(varsSubP, copylist(bP)),  
      varsP : subst(varsSubP, copylist(varsP))   
    )
    else if (vdim = 2) then (
      varsSubV : [x=vx, y=vy], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      varsSubP : [vx=y, vy=vx, vz=vy],
      bP : subst(varsSubP, copylist(bP)),  
      varsP : subst(varsSubP, copylist(varsP)) 
    )
  ), 

  if (vdim = 3) then (
    varsSubV : [x=vx, y=vy, z=vz], 
    bV : subst(varsSubV, copylist(bV)),  
    varsV : subst(varsSubV, copylist(varsV))
  ),
  return([varsC,bC,varsV,bV,varsP,bP])
)$

loadVlasovSurfBasis(basisType, polyOrder, surfVars) := block(
  bSurf : basisFromVars(basisType,surfVars,polyOrder),
  NSurf : length(bSurf), 

  if (polyOrder = 1) then (
    surfNodes : gaussOrd(2,length(surfVars)), 
    basisNodal  : getVarsNodalBasisWithNodes("Tensor", length(surfVars), 1, surfVars, surfNodes)
  )
  else if (polyOrder = 2) then (
    /* 4 quadrature points required for p=2, so nodal basis is a cubic. */
    surfNodes : gaussOrd(4,length(surfVars)), 
    basisNodal  : getVarsNodalBasisWithNodes("Tensor", length(surfVars), 3, surfVars, surfNodes)
  ), 
  numNodes : length(surfNodes),   
  return([bSurf,NSurf,surfNodes,basisNodal,numNodes])
)$

loadVelJacobianBasis() := block(
  /* Load basis sets for Jacobian in each direction, 
     which are p=2 in one velocity dimension (derivative of cubic C^1 mapping). */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 2), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 
  bV_vy : subst(x=vy, copylist(bV_1D)), 
  bV_vz : subst(x=vz, copylist(bV_1D)), 

  jacobNodes : gaussOrd(3,1), 
  numJacobNodes : length(jacobNodes), 
  basisNodal_vx  : getVarsNodalBasisWithNodes("Tensor", 1, 2, [vx], jacobNodes),
  basisNodal_vy  : getVarsNodalBasisWithNodes("Tensor", 1, 2, [vy], jacobNodes),
  basisNodal_vz  : getVarsNodalBasisWithNodes("Tensor", 1, 2, [vz], jacobNodes),
  jacobNodes_vx : [jacob_vx[0], jacob_vx[1], jacob_vx[2]],  
  jacobNodes_vy : [jacob_vy[0], jacob_vy[1], jacob_vy[2]],  
  jacobNodes_vz : [jacob_vz[0], jacob_vz[1], jacob_vz[2]], 
  bV_vi : [bV_vx, bV_vy, bV_vz], 
  NV_1D : length(bV_1D),   
  jacobNodes_vi : [jacobNodes_vx, jacobNodes_vy, jacobNodes_vz],
  basisNodal_vi : [basisNodal_vx, basisNodal_vy, basisNodal_vz], 
  return([bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi])
)$

/* Construct the modifications to the velocity-space Jacobian expansions at velocity-space surfaces. */
loadSurfVelJacobian(vdim, dir, jacobNodes_vi, basisNodal_vi, surfVars) := block(
  jacobNodes_vx : jacobNodes_vi[1],
  jacobNodes_vy : jacobNodes_vi[2],
  jacobNodes_vz : jacobNodes_vi[3], 

  basisNodal_vx : basisNodal_vi[1],
  basisNodal_vy : basisNodal_vi[2],
  basisNodal_vz : basisNodal_vi[3], 

  jacob_vx_e : 0, 
  jacob_vy_e : 0, 
  jacob_vz_e : 0, 
  for i : 1 thru length(bV_vx) do (
    jacob_vx_e : jacob_vx_e + jacobNodes_vx[i]*basisNodal_vx[i], 
    jacob_vy_e : jacob_vy_e + jacobNodes_vy[i]*basisNodal_vy[i],
    jacob_vz_e : jacob_vz_e + jacobNodes_vz[i]*basisNodal_vz[i]
  ),
  jacob_vx_edge : subst(vx=-1, jacob_vx_e),
  jacob_vy_edge : subst(vy=-1, jacob_vy_e),
  jacob_vz_edge : subst(vz=-1, jacob_vz_e),
  jacob_edge : [jacob_vx_edge, jacob_vy_edge, jacob_vz_edge],

  /* 4 quadrature points required for p=2, so nodal basis is a cubic. */
  surfNodes : gaussOrd(4,length(surfVars)), 
  basisNodalSurf  : getVarsNodalBasisWithNodes("Tensor", length(surfVars), 3, surfVars, surfNodes),
  jacob_vx_surf : evAtNodes(jacob_vx_e, surfNodes, surfVars), 
  jacob_vy_surf : evAtNodes(jacob_vy_e, surfNodes, surfVars), 
  jacob_vz_surf : evAtNodes(jacob_vz_e, surfNodes, surfVars), 
  jacob_vi_surf : [jacob_vx_surf, jacob_vy_surf, jacob_vz_surf],
  /* Construct the transverse velocity space Jacobian at surface quadrature points. */
  jacob_surf_tot : makelist(0, i, 1, length(surfNodes)),
  if (vdim = 1) then (
    for i : 1 thru length(surfNodes) do (
      jacob_surf_tot[i] : 1
    )
  )
  else if (vdim = 2) then (
    for i : 1 thru length(surfNodes) do (
      if (dir = 1) then (
        jacob_surf_tot[i] : jacob_vy_surf[i]
      )
      else (
        jacob_surf_tot[i] : jacob_vx_surf[i]
      )
    )
  )
  else (
    for i : 1 thru length(surfNodes) do (
      if (dir = 1) then (
        jacob_surf_tot[i] : jacob_vy_surf[i]*jacob_vz_surf[i]
      )
      else if (dir = 2) then (
        jacob_surf_tot[i] : jacob_vx_surf[i]*jacob_vz_surf[i]
      )
      else (
        jacob_surf_tot[i] : jacob_vx_surf[i]*jacob_vy_surf[i]
      )
    )    
  ), 
  return([jacob_edge, jacob_vi_surf, jacob_surf_tot])
)$ 