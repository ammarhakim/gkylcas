load("modal-basis");
load("out-scripts");

loadVlasovBasis(basisType, cdim, vdim, polyOrder) := block(
  [hybten, varsSubV, varsSubP],
  
  /* Select Hybrid basis for tensor p = 1. */
  hybten : (polyOrder = 1) and (basisType = "tensor"),
  if (hybten) then (
    [varsC,bC] : loadBasis(basisType, cdim, polyOrder),
    [varsV,bV] : loadBasis(basisType, vdim, polyOrder+1), 
    [varsP,bP] : loadTensorHybridBasis(basisType, cdim, vdim) 
  )
  else (
    [varsC,bC] : loadBasis(basisType, cdim, polyOrder),
    [varsV,bV] : loadBasis(basisType, vdim, polyOrder), 
    [varsP,bP] : loadBasis(basisType, cdim+vdim, polyOrder)
  ),

  /* Do a variable substitution for the lower dimensional basis functions
     to construct the correct set of variables for the subsequent operations */
  if (cdim = 1) then (
    if (vdim = 1) then (
      varsSubV : [x=vx], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      if not(hybten) then (
        varsSubP : [y=vx],
        bP : subst(varsSubP, copylist(bP)),  
        varsP : subst(varsSubP, copylist(varsP))
      )
    )
    else if (vdim = 2) then (
      varsSubV : [x=vx, y=vy], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      if not(hybten) then (
        varsSubP : [y=vx, z=vy],
        bP : subst(varsSubP, copylist(bP)),  
        varsP : subst(varsSubP, copylist(varsP))  
      ) 
    )
  )
  else if (cdim = 2) then (
    if (vdim = 1) then (
      varsSubV : [x=vx], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      if not(hybten) then (
        varsSubP : [z=vx],
        bP : subst(varsSubP, copylist(bP)),  
        varsP : subst(varsSubP, copylist(varsP))   
      )
    )
    else if (vdim = 2) then (
      varsSubV : [x=vx, y=vy], 
      bV : subst(varsSubV, copylist(bV)),  
      varsV : subst(varsSubV, copylist(varsV)), 

      if not(hybten) then (
        varsSubP : [vx=y, vy=vx, vz=vy],
        bP : subst(varsSubP, copylist(bP)),  
        varsP : subst(varsSubP, copylist(varsP)) 
      )
    )
  ), 

  if (vdim = 3) then (
    varsSubV : [x=vx, y=vy, z=vz], 
    bV : subst(varsSubV, copylist(bV)),  
    varsV : subst(varsSubV, copylist(varsV))
  ),
  return([varsC,bC,varsV,bV,varsP,bP])
)$

loadVlasovVelSurfBasis(vdim, basisType, polyOrder, surfVars, surfVVars, varsC) := block(
  [hybten, btype],
  hybten : (polyOrder = 1) and (basisType = "tensor"),
  if basisType="tensor" then btype : "TensorHybrid"
  else btype : basisType,

  bSurf : basisFromVars(btype,surfVars,polyOrder),

    /* 4 quadrature points required for p=2, so nodal basis is a cubic for p=2. 
       5 quadrature points required for p=3, no nodal basis is a quartic for p=3. */
  if (polyOrder = 1) then (
    nodes_conf : gaussOrd(2, cdim), 
    basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(varsC), 1, varsC, nodes_conf)
  )
  else if (polyOrder = 2) then (
    nodes_conf : gaussOrd(4, cdim), 
    basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(varsC), 3, varsC, nodes_conf)
  )
  else if (polyOrder = 3) then (
    nodes_conf : gaussOrd(5, cdim), 
    basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(varsC), 4, varsC, nodes_conf)    
  ),

  if (vdim > 1) then (
    if ((polyOrder = 1) and not(hybten)) then (
      nodes_vel : gaussOrd(2, vdim-1), 
      basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(surfVVars), 1, surfVVars, nodes_vel) 
    )
    else if ((polyOrder = 2) or hybten) then (
      nodes_vel : gaussOrd(4, vdim-1), 
      basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(surfVVars), 3, surfVVars, nodes_vel) 
    )
    else if (polyOrder = 3) then (
      nodes_vel : gaussOrd(5, vdim-1), 
      basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(surfVVars), 4, surfVVars, nodes_vel) 
    )
  )
  else (
    nodes_vel : [1], 
    basisNodalVel : [1] 
  ),

  if (hybten) then (
    surfNodes : gaussOrdTenHyb(2,4,cdim,vdim)
  ) else (
    if (polyOrder = 1) then (
      surfNodes : gaussOrd(2,length(surfVars))
    )
    else if (polyOrder = 2) then (
      surfNodes : gaussOrd(4,length(surfVars))
    )
    else if (polyOrder = 3) then (
      surfNodes : gaussOrd(5,length(surfVars))
    )
  ),
  return([bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes])
)$

loadVlasovConfSurfBasis(cdim, basisType, polyOrder, surfVars, surfCVars, varsV) := block(
  [hybten, btype],
  hybten : (polyOrder = 1) and (basisType = "tensor"),
  if basisType="tensor" then btype : "TensorHybrid"
  else btype : basisType,

  bSurf : basisFromVars(btype,surfVars,polyOrder),

    /* 4 quadrature points required for p=2, so nodal basis is a cubic for p=2. 
       5 quadrature points required for p=3, no nodal basis is a quartic for p=3. */
  if (cdim > 1) then (
    if (polyOrder = 1) then (
      nodes_conf : gaussOrd(2, cdim-1), 
      basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(surfCVars), 1, surfCVars, nodes_conf)
    )
    else if (polyOrder = 2) then (
      nodes_conf : gaussOrd(4, cdim-1), 
      basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(surfCVars), 3, surfCVars, nodes_conf)
    )
    else if (polyOrder = 3) then (
      nodes_conf : gaussOrd(5, cdim-1), 
      basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(surfCVars), 4, surfCVars, nodes_conf)
    )
  ) 
  else (
    nodes_conf : [1], 
    basisNodalConf : [1] 
  ),

  if ((polyOrder = 1) and not(hybten)) then (
    nodes_vel : gaussOrd(2, vdim), 
    basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(varsV), 1, varsV, nodes_vel) 
  )
  else if ((polyOrder = 2) or hybten) then (
    nodes_vel : gaussOrd(4, vdim), 
    basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(varsV), 3, varsV, nodes_vel) 
  )
  else if (polyOrder = 3) then (
    nodes_vel : gaussOrd(5, vdim), 
    basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(varsV), 4, varsV, nodes_vel) 
  ),

  if (hybten) then (
    surfNodes : gaussOrdTenHyb(2,4,cdim,vdim)
  ) else (
    if (polyOrder = 1) then (
      surfNodes : gaussOrd(2,length(surfVars))
    )
    else if (polyOrder = 2) then (
      surfNodes : gaussOrd(4,length(surfVars))
    )
    else if (polyOrder = 3) then (
      surfNodes : gaussOrd(5,length(surfVars))
    )
  ),
  return([bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes])
)$


loadVlasovConfBasis(cdim, basisType, polyOrder, volVars, volCVars, varsV) := block(
  [hybten, btype],
  hybten : (polyOrder = 1) and (basisType = "tensor"),
  if basisType="tensor" then btype : "TensorHybrid"
  else btype : basisType,

  /* 4 quadrature points required for p=2, so nodal basis is a cubic for p=2. 
      5 quadrature points required for p=3, no nodal basis is a quartic for p=3. */
  if (polyOrder = 1) then (
    nodes_conf : gaussOrd(2, cdim), 
    basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(volCVars), 1, volCVars, nodes_conf)
  )
  else if (polyOrder = 2) then (
    nodes_conf : gaussOrd(4, cdim), 
    basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(volCVars), 3, volCVars, nodes_conf)
  )
  else if (polyOrder = 3) then (
    nodes_conf : gaussOrd(5, cdim), 
    basisNodalConf  : getVarsNodalBasisWithNodes("Tensor", length(volCVars), 4, volCVars, nodes_conf)
  ),

  /* if ((polyOrder = 1) and not(hybten)) then (
    nodes_vel : gaussOrd(2, vdim), 
    basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(varsV), 1, varsV, nodes_vel) 
  )
  else if ((polyOrder = 2) or hybten) then (
    nodes_vel : gaussOrd(4, vdim), 
    basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(varsV), 3, varsV, nodes_vel) 
  )
  else if (polyOrder = 3) then (
    nodes_vel : gaussOrd(5, vdim), 
    basisNodalVel  : getVarsNodalBasisWithNodes("Tensor", length(varsV), 4, varsV, nodes_vel) 
  ),

  if (hybten) then (
    volNodes : gaussOrdTenHyb(2,4,cdim,vdim)
  ) else (
    if (polyOrder = 1) then (
      volNodes : gaussOrd(2,length(volVars))
    )
    else if (polyOrder = 2) then (
      volNodes : gaussOrd(4,length(volVars))
    )
    else if (polyOrder = 3) then (
      volNodes : gaussOrd(5,length(volVars))
    )
  ), */
  /* return([bvol,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,volNodes]) */
  return([nodes_conf,basisNodalConf])
)$


loadVelJacobianBasis(polyOrder) := block(
  /* Load basis sets for mapping, which are p=3. */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 3), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 
  bV_vy : subst(x=vy, copylist(bV_1D)), 
  bV_vz : subst(x=vz, copylist(bV_1D)), 

  /* Since we just need a 1D basis, if we are using p=3, use the actual analytic formulae, 
     which lead to less floating point error. Otherwise, see quadrature_functions.mac so the 
     floating point evaluation of certain quadrature rules. */
  if (polyOrder = 3) then (
    jacobNodes : matrix([-sqrt(3/7 + 2/7*sqrt(6/5))],[-sqrt(3/7 - 2/7*sqrt(6/5))],[sqrt(3/7 - 2/7*sqrt(6/5))],[sqrt(3/7 + 2/7*sqrt(6/5))])
  )
  else (
    jacobNodes : gaussOrd(polyOrder+1, 1)
  ),
  numJacobNodes : length(jacobNodes), 
  basisNodal_vx  : getVarsNodalBasisWithNodes("Tensor", 1, polyOrder, [vx], jacobNodes),
  basisNodal_vy  : getVarsNodalBasisWithNodes("Tensor", 1, polyOrder, [vy], jacobNodes),
  basisNodal_vz  : getVarsNodalBasisWithNodes("Tensor", 1, polyOrder, [vz], jacobNodes),
  jacobNodes_vx : [jacob_vx[0], jacob_vx[1], jacob_vx[2], jacob_vx[3]],  
  jacobNodes_vy : [jacob_vy[0], jacob_vy[1], jacob_vy[2], jacob_vy[3]],  
  jacobNodes_vz : [jacob_vz[0], jacob_vz[1], jacob_vz[2], jacob_vz[3]], 
  bV_vi : [bV_vx, bV_vy, bV_vz], 
  NV_1D : length(bV_1D),   
  jacobNodes_vi : [jacobNodes_vx, jacobNodes_vy, jacobNodes_vz],
  basisNodal_vi : [basisNodal_vx, basisNodal_vy, basisNodal_vz], 
  return([bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi])
)$

/* Set the threshold for pruning terms in the surface Jacobian */
zero_threshold : 1.0e-14;

prune(expr) := block(
  [terms, result : [], coeff, term_args],
  terms : if op(expr) = "+" then args(expr) else [expr],

  for term in terms do (
    if op(term) = "*" then (
      term_args : args(term),
      coeff : first(term_args),
      if numberp(coeff) and float(abs(coeff)) < zero_threshold then (
        print("Dropping:", term)
      ) else (
        result : endcons(term, result)
      )
    )
    else if numberp(term) and float(abs(term)) < zero_threshold then (
      print("Dropping constant term:", term)
    )
    else if op(term) = "-" and length(args(term)) = 1 and op(first(args(term))) = "*" then (
      /* Handle unary minus before a product */
      term_args : args(first(args(term))),
      coeff : first(term_args),
      if numberp(coeff) and float(abs(coeff)) < zero_threshold then (
        print("Dropping negated term:", term)
      ) else (
        result : endcons(term, result)
      )
    )
    else (
      /* Anything else, keep */
      result : endcons(term, result)
    )
  ),

  return(if length(result) = 0 then 0 else apply("+", result))
);

/* Construct specific velocity-space surface velocity Jacobian terms. Returns: 
   1. jacob_edge (evaluation of velocity-space Jacobian at cell edge for time step estimate)
   2. jacob_vi_surf (array of velocity space Jacobian in each direction at larger number of
      quadrature points for use in magnetic Lorentz force 1/Jvi dH/dvi x B). 
   3. jacob_surf_tot (total velocity-space Jacobian at the velocity surface in direction dir, 
      e.g., jacob_vy in 2V at vx surfaces, or jacob_vy*jacob_vz in 3V at vx surfaces).
*/
loadSurfVelJacobian(vdim, polyOrder, dir, nodes_vel, surfVVars, surfNodes, surfVars, calc_surf_jacob) := block(
  /* Since we just need a 1D basis, if we are using p=3, use the actual analytic formulae, 
     which lead to less floating point error. Otherwise, see quadrature_functions.mac so the 
     floating point evaluation of certain quadrature rules. */
  if (polyOrder = 2) then (
    surf_nodes_1v : matrix([-sqrt(3/7 + 2/7*sqrt(6/5))],[-sqrt(3/7 - 2/7*sqrt(6/5))],[sqrt(3/7 - 2/7*sqrt(6/5))],[sqrt(3/7 + 2/7*sqrt(6/5))]), 
    basisNodal_vx : getVarsNodalBasisWithNodes("Tensor", 1, 3, [vx], surf_nodes_1v),
    basisNodal_vy : getVarsNodalBasisWithNodes("Tensor", 1, 3, [vy], surf_nodes_1v),
    basisNodal_vz : getVarsNodalBasisWithNodes("Tensor", 1, 3, [vz], surf_nodes_1v)
  )
  else (
    surf_nodes_1v : matrix([-1/3*sqrt(5+2*sqrt(10/7))],[-1/3*sqrt(5-2*sqrt(10/7))],[0],[1/3*sqrt(5-2*sqrt(10/7))],[1/3*sqrt(5+2*sqrt(10/7))]), 
    basisNodal_vx : getVarsNodalBasisWithNodes("Tensor", 1, 4, [vx], surf_nodes_1v),
    basisNodal_vy : getVarsNodalBasisWithNodes("Tensor", 1, 4, [vy], surf_nodes_1v),
    basisNodal_vz : getVarsNodalBasisWithNodes("Tensor", 1, 4, [vz], surf_nodes_1v)
  ),

  jacob_vx_surf : [jacob_vel_surf_vx[0], jacob_vel_surf_vx[1], jacob_vel_surf_vx[2], jacob_vel_surf_vx[3], jacob_vel_surf_vx[4]], 
  jacob_vx_surf_ne : 0, 
  for i : 1 thru (polyOrder+2) do (
    jacob_vx_surf_ne : jacob_vx_surf_ne + jacob_vx_surf[i]*basisNodal_vx[i] 
  ), 

  jacob_vy_surf : [jacob_vel_surf_vy[0], jacob_vel_surf_vy[1], jacob_vel_surf_vy[2], jacob_vel_surf_vy[3], jacob_vel_surf_vy[4]], 
  jacob_vy_surf_ne : 0, 
  for i : 1 thru (polyOrder+2) do (
    jacob_vy_surf_ne : jacob_vy_surf_ne + jacob_vy_surf[i]*basisNodal_vy[i] 
  ), 

  jacob_vz_surf : [jacob_vel_surf_vz[0], jacob_vel_surf_vz[1], jacob_vel_surf_vz[2], jacob_vel_surf_vz[3], jacob_vel_surf_vz[4]], 
  jacob_vz_surf_ne : 0, 
  for i : 1 thru (polyOrder+2) do (
    jacob_vz_surf_ne : jacob_vz_surf_ne + jacob_vz_surf[i]*basisNodal_vz[i] 
  ), 

  /* Velocity-space Jacobian evaluated at edge for estimating time step. */
  jacob_vx_edge : subst(vx=-1, jacob_vx_surf_ne),
  jacob_vy_edge : subst(vy=-1, jacob_vy_surf_ne),
  jacob_vz_edge : subst(vz=-1, jacob_vz_surf_ne),
  jacob_edge : [jacob_vx_edge, jacob_vy_edge, jacob_vz_edge],  

  jacob_surf_tot : makelist(0, i, 1, length(surfNodes)),
  if (calc_surf_jacob) then (
    jacob_vx_surf_l_n : float(evAtNodes(jacob_vx_surf_ne, surfNodes, surfVars)), 
    jacob_vy_surf_l_n : float(evAtNodes(jacob_vy_surf_ne, surfNodes, surfVars)), 
    jacob_vz_surf_l_n : float(evAtNodes(jacob_vz_surf_ne, surfNodes, surfVars)), 
    for i : 1 thru length(jacob_vx_surf_l_n) do (
      jacob_vx_surf_l_n[i] : prune(jacob_vx_surf_l_n[i]),
      jacob_vy_surf_l_n[i] : prune(jacob_vy_surf_l_n[i]),
      jacob_vz_surf_l_n[i] : prune(jacob_vz_surf_l_n[i])
    ),  
    /* Construct the transverse velocity space Jacobian at surface quadrature points. */
    if (vdim = 1) then (
      for i : 1 thru length(surfNodes) do (
        jacob_surf_tot[i] : 1
      )
    )
    else if (vdim = 2) then (
      for i : 1 thru length(surfNodes) do (
        if (dir = 1) then (
          jacob_surf_tot[i] : jacob_vy_surf_l_n[i]
        )
        else (
          jacob_surf_tot[i] : jacob_vx_surf_l_n[i]
        )
      )
    )
    else (
      for i : 1 thru length(surfNodes) do (
        if (dir = 1) then (
          jacob_surf_tot[i] : jacob_vy_surf_l_n[i]*jacob_vz_surf_l_n[i]
        )
        else if (dir = 2) then (
          jacob_surf_tot[i] : jacob_vx_surf_l_n[i]*jacob_vz_surf_l_n[i]
        )
        else (
          jacob_surf_tot[i] : jacob_vx_surf_l_n[i]*jacob_vy_surf_l_n[i]
        )
      )    
    )       
  ) 
  else (
    jacob_vx_surf_l_n : float(evAtNodes(jacob_vx_surf_ne, nodes_vel, surfVVars)), 
    jacob_vy_surf_l_n : float(evAtNodes(jacob_vy_surf_ne, nodes_vel, surfVVars)), 
    jacob_vz_surf_l_n : float(evAtNodes(jacob_vz_surf_ne, nodes_vel, surfVVars)), 
    for i : 1 thru length(jacob_vx_surf_l_n) do (
      jacob_vx_surf_l_n[i] : prune(jacob_vx_surf_l_n[i]),
      jacob_vy_surf_l_n[i] : prune(jacob_vy_surf_l_n[i]),
      jacob_vz_surf_l_n[i] : prune(jacob_vz_surf_l_n[i])
    )    
  ),
  /* Velocity-space Jacobian at full velocity space surface nodes (2V surface in 3V). */
  jacob_vi_surf : [jacob_vx_surf_l_n, jacob_vy_surf_l_n, jacob_vz_surf_l_n],

  return([jacob_edge, jacob_vi_surf, jacob_surf_tot])
)$ 