/* Functions which compute the components of the surface flux in velocity space. 
   The procedure we utilize to generalize to the presence of different forces/different
   flavors of the Vlasov equation is a set of functions that compute the characteristics
   alpha_v at surface quadrature points of the needed order, accumulating each component, 
   e.g., Hamiltonian forces, the Lorentz force, or forces due to a scalar potential, 
   into a total alpha_v at the surface. 

   We then evaluate the Lax-Friedrichs flux G = alpha/2*(f^+ + f^-) - |alpha|/2*(f^+ - f^-)
   at each quadrature point, and then convert that back to a modal expansion of the 
   velocity-space flux for use in the final update in hyper_dg. 

   Note that we do not make any assumptions on the order of the phase space expansion
   and thus to evaluate G, we must utilize enough Gauss-Legendre quadrature points
   to integrate a 3*p polynomial (cubic for p=1, sixth order for p=2, ninth order for p=3). 
   We thus must use 2, 4, and 5 Gauss-Legendre points respectively. 

   In velocity space, certain Hamiltonians such as H = v^2/2 require fewer velocity space
   quadrature points since these Hamiltonians are "sparse." We separate the velocity space
   vs. configuration space quadrature loops and generate separate nodal configuration space
   and nodal velocity space surface bases. Since these quadrature rules are all tensor products
   of configuration space and velocity space, the final phase space basis is simply a tensor
   product of the configuration space and velocity space bases.  
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
dx1 : [dx10, dx11, dx12]$
dv1 : [dv10, dv11, dv12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Phase-space Hamiltonian forces at velocity-space surface quadrature points. */
calcHamilGenVelSurfForce(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,hamil,cv,vv,surfVars,surfVVars,bSurf,NSurf,
   nodes_conf,basisNodalConf,num_nodes_conf,nodes_vel,basisNodalVel,num_nodes_vel,
   surfNodes,numNodes,dH_dx_l_n],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, 
  const double *hamil, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  cid : cidx(cdim),
  printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "~%"),
  hamil : doExpand1(hamil, bP), /* Hamiltonian is a function of phase space. */

  cv : varsC[dir],
  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  surfVVars : delete(vv,varsV), /* Remaining variables in v. */
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars, surfVVars, varsC),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  /* Each cells owns its *lower* edge fluxes, so we evaluate the derivative of the 
     Hamiltonian at vv = -1. Note that the flux is -grad_x(H). */
  dH_dx_l_n : float(evAtNodes(subst(vv=-1,diff(hamil,cv)),surfNodes,surfVars)), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_quad[~a] += -~a*(~a); ~%", i-1, dx1[dir], dH_dx_l_n[i]) 
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 

/* Scalar potential forces at velocity-space surface quadrature points. */
calcPhiVelSurfForce(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,phi,vv,surfVars,surfVVars,bSurf,NSurf,
   nodes_conf,basisNodalConf,num_nodes_conf,nodes_vel,basisNodalVel,num_nodes_vel,
   surfNodes,numNodes,dphi_dx_l_n],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, const double *phi, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  cid : cidx(cdim),
  printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "~%"),
  phi : doExpand1(phi, bC), /* Scalar potential is only a function of configuration space. */

  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  surfVVars : delete(vv,varsV), /* Remaining variables in v. */
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars, surfVVars, varsC),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  dphi_dx_l_n : float(evAtNodes(diff(phi,varsC[dir]),nodes_conf,varsC)), 
  printf(fh, "  double force_quad = 0.0;~%"), 
  for i : 1 thru num_nodes_conf do (
    printf(fh, "  force_quad = ~a;~%", dphi_dx_l_n[i]),
    for j : 1 thru num_nodes_vel do (
      printf(fh, "  alpha_quad[~a] -= ~a*force_quad;~%", j-1 + num_nodes_vel*(i-1), dx1[dir])
    ), 
    printf(fh, "~%")
  ),
  printf(fh, "} ~%")
)$ 

/* Total bulk forces, i.e., forces which are only a function of configuration space
   (electric fields, external acceleration), at velocity-space surface quadrature points. */
calcEVelSurfForce(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,NC,Ex_e,Ey_e,Ez_e,E_e,vv,surfVars,surfVVars,bSurf,NSurf,
   nodes_conf,basisNodalConf,num_nodes_conf,nodes_vel,basisNodalVel,num_nodes_vel,
   surfNodes,numNodes,E_l_n],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, const double *qmem, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  printf(fh, "  const double *E~a = &qmem[~a]; ~%", clabels[dir], NC*(dir-1)), 
  printf(fh, "~%"),
  /* Electric field/external forces are only a function of configuration space. */
  Ex_e : doExpand1(Ex, bC), 
  Ey_e : doExpand1(Ey, bC), 
  Ez_e : doExpand1(Ez, bC), 
  E_e : [Ex_e, Ey_e, Ez_e], 

  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  surfVVars : delete(vv,varsV), /* Remaining variables in v. */
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars, surfVVars, varsC),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  E_l_n : float(evAtNodes(E_e[dir],nodes_conf,varsC)), 
  printf(fh, "  double force_quad = 0.0;~%"), 
  for i : 1 thru num_nodes_conf do (
    printf(fh, "  force_quad = ~a;~%", E_l_n[i]),
    for j : 1 thru num_nodes_vel do (
      printf(fh, "  alpha_quad[~a] += force_quad;~%", j-1 + num_nodes_vel*(i-1))
    ), 
    printf(fh, "~%")
  ),
  printf(fh, "} ~%")
)$ 

/* Magnetic force with velocity-space Hamiltonian at velocity-space surface quadrature points. */
calcBHamilVelSurfForce(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NC,vid,hamil,Bx_e,By_e,Bz_e,vv,surfVars,surfVVars,bSurf,NSurf,
   nodes_conf,basisNodalConf,num_nodes_conf,nodes_vel,basisNodalVel,num_nodes_vel,
   Bx_l_n,By_l_n,Bz_l_n,dH_dvx_l_n,dH_dvy_l_n,dH_dvz_l_n,
   jacob_edge,jacob_vi_surf,jacob_surf_tot,jacob_vx_surf_l_n,jacob_vy_surf_l_n,jacob_vz_surf_l_n],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, const double *jacob_vel_surf, 
  const double *hamil, const double *qmem, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  printf(fh, "~%"),
  hamil : doExpand1(hamil, bV), /* Hamiltonian only a function of velocity space. */
  vid : vidx(cdim,vdim),   
  Bx_e : doExpand1(Bx, bC), 
  By_e : doExpand1(By, bC), 
  Bz_e : doExpand1(Bz, bC), 

  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  surfVVars : delete(vv,varsV), /* Remaining variables in v. */
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars, surfVVars, varsC),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  Bx_l_n : float(evAtNodes(Bx_e,nodes_conf,varsC)), 
  By_l_n : float(evAtNodes(By_e,nodes_conf,varsC)), 
  Bz_l_n : float(evAtNodes(Bz_e,nodes_conf,varsC)), 

  if (vdim = 2) then (
    printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
    if (vmap) then (
      if (dir = 1) then (
        printf(fh, "  const double *jacob_vel_surf_vy = &jacob_vel_surf[4]; ~%")
      )
      else if (dir = 2) then (
        printf(fh, "  const double *jacob_vel_surf_vx = &jacob_vel_surf[0]; ~%")
      )
    ),
    dH_dvx_l_n : float(evAtNodes(subst(vv=-1,diff(hamil, varsV[1])),nodes_vel,surfVVars)), 
    dH_dvy_l_n : float(evAtNodes(subst(vv=-1,diff(hamil, varsV[2])),nodes_vel,surfVVars)),
    printf(fh, "  double Bz_quad = 0.0;~%"), 
    for i : 1 thru num_nodes_conf do (
      printf(fh, "  Bz_quad = ~a;~%", Bz_l_n[i]), 
      for j : 1 thru num_nodes_vel do (
        if (vmap) then (
          if (dir = 1) then (
            printf(fh, "  alpha_quad[~a] += 2.0/(dxv[~a]*jacob_vel_surf_vy[~a])*(~a)*Bz_quad;~%", j-1 + num_nodes_vel*(i-1), vid[2], j-1, dH_dvy_l_n[j])
          )
          else (
            printf(fh, "  alpha_quad[~a] -= 2.0/(dxv[~a]*jacob_vel_surf_vx[~a])*(~a)*Bz_quad;~%", j-1 + num_nodes_vel*(i-1), vid[1], j-1, dH_dvx_l_n[j])
          )
        )
        else (
          if (dir = 1) then (
            printf(fh, "  alpha_quad[~a] += 2.0/dxv[~a]*(~a)*Bz_quad;~%", j-1 + num_nodes_vel*(i-1), vid[2], dH_dvy_l_n[j])
          )
          else (
            printf(fh, "  alpha_quad[~a] -= 2.0/dxv[~a]*(~a)*Bz_quad;~%", j-1 + num_nodes_vel*(i-1), vid[1], dH_dvx_l_n[j])
          )
        )
      ),
      printf(fh, "~%")
    )
  )
  else if (vdim = 3) then (
    if (vmap) then (
      [jacob_edge, jacob_vi_surf, jacob_surf_tot] : loadSurfVelJacobian(vdim, dir, nodes_vel, surfVVars, nodes_vel, surfVars, false), 
      if (dir = 1) then (
        printf(fh, "  const double *jacob_vel_surf_vy = &jacob_vel_surf[4]; ~%"), 
        printf(fh, "  const double *jacob_vel_surf_vz = &jacob_vel_surf[8]; ~%"), 
        jacob_vy_surf_l_n : jacob_vi_surf[2], 
        jacob_vz_surf_l_n : jacob_vi_surf[3]
      )
      else if (dir = 2) then (
        printf(fh, "  const double *jacob_vel_surf_vx = &jacob_vel_surf[0]; ~%"), 
        printf(fh, "  const double *jacob_vel_surf_vz = &jacob_vel_surf[8]; ~%"), 
        jacob_vx_surf_l_n : jacob_vi_surf[1], 
        jacob_vz_surf_l_n : jacob_vi_surf[3]        
      )
      else (
        printf(fh, "  const double *jacob_vel_surf_vx = &jacob_vel_surf[0]; ~%"), 
        printf(fh, "  const double *jacob_vel_surf_vy = &jacob_vel_surf[4]; ~%"), 
        jacob_vx_surf_l_n : jacob_vi_surf[1], 
        jacob_vy_surf_l_n : jacob_vi_surf[2]           
      )
    ), 
    dH_dvx_l_n : float(evAtNodes(subst(vv=-1,diff(hamil, varsV[1])),nodes_vel,surfVVars)), 
    dH_dvy_l_n : float(evAtNodes(subst(vv=-1,diff(hamil, varsV[2])),nodes_vel,surfVVars)), 
    dH_dvz_l_n : float(evAtNodes(subst(vv=-1,diff(hamil, varsV[3])),nodes_vel,surfVVars)),
    if (dir = 1) then (
      printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
      printf(fh, "  double dv12 = 2.0/dxv[~a]; ~%", vid[3]),
      printf(fh, "  const double *By = &qmem[~a]; ~%", NC*4),
      printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
      printf(fh, "  double By_quad = 0.0;~%"), 
      printf(fh, "  double Bz_quad = 0.0;~%"), 
      for i : 1 thru num_nodes_conf do (
        printf(fh, "  By_quad = ~a;~%", By_l_n[i]), 
        printf(fh, "  Bz_quad = ~a;~%", Bz_l_n[i]), 
        for j : 1 thru num_nodes_vel do (
          if (vmap) then (
            printf(fh, "  alpha_quad[~a] += dv11*(~a)*Bz_quad/(~a) - dv12*(~a)*By_quad/(~a);~%", j-1 + num_nodes_vel*(i-1), dH_dvy_l_n[j], jacob_vy_surf_l_n[j], dH_dvz_l_n[j], jacob_vz_surf_l_n[j])
          )
          else (
            printf(fh, "  alpha_quad[~a] += dv11*(~a)*Bz_quad - dv12*(~a)*By_quad;~%", j-1 + num_nodes_vel*(i-1), dH_dvy_l_n[j], dH_dvz_l_n[j])
          )
        ),
        printf(fh, "~%")
      )
    )
    else if (dir = 2) then (
      printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
      printf(fh, "  double dv12 = 2.0/dxv[~a]; ~%", vid[3]),
      printf(fh, "  const double *Bx = &qmem[~a]; ~%", NC*3),
      printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
      printf(fh, "  double Bx_quad = 0.0;~%"), 
      printf(fh, "  double Bz_quad = 0.0;~%"), 
      for i : 1 thru num_nodes_conf do (
        printf(fh, "  Bx_quad = ~a;~%", Bx_l_n[i]), 
        printf(fh, "  Bz_quad = ~a;~%", Bz_l_n[i]), 
        for j : 1 thru num_nodes_vel do (
          if (vmap) then (
            printf(fh, "  alpha_quad[~a] += dv12*(~a)*Bx_quad/(~a) - dv10*(~a)*Bz_quad/(~a);~%", j-1 + num_nodes_vel*(i-1), dH_dvz_l_n[j], jacob_vz_surf_l_n[j], dH_dvx_l_n[j], jacob_vx_surf_l_n[j])
          )
          else (
            printf(fh, "  alpha_quad[~a] += dv12*(~a)*Bx_quad - dv10*(~a)*Bz_quad;~%", j-1 + num_nodes_vel*(i-1), dH_dvz_l_n[j], dH_dvx_l_n[j])
          )
        ),
        printf(fh, "~%")
      )
    )
    else (
      printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
      printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
      printf(fh, "  const double *Bx = &qmem[~a]; ~%", NC*3),
      printf(fh, "  const double *By = &qmem[~a]; ~%", NC*4),
      printf(fh, "  double Bx_quad = 0.0;~%"), 
      printf(fh, "  double By_quad = 0.0;~%"), 
      for i : 1 thru num_nodes_conf do (
        printf(fh, "  Bx_quad = ~a;~%", Bx_l_n[i]), 
        printf(fh, "  By_quad = ~a;~%", By_l_n[i]), 
        for j : 1 thru num_nodes_vel do (
          if (vmap) then (
            printf(fh, "  alpha_quad[~a] += dv10*(~a)*By_quad/(~a) - dv11*(~a)*Bx_quad/(~a);~%", j-1 + num_nodes_vel*(i-1), dH_dvx_l_n[j], jacob_vx_surf_l_n[j], dH_dvy_l_n[j], jacob_vy_surf_l_n[j])
          )
          else (
            printf(fh, "  alpha_quad[~a] += dv10*(~a)*By_quad - dv11*(~a)*Bx_quad;~%", j-1 + num_nodes_vel*(i-1), dH_dvx_l_n[j], dH_dvy_l_n[j])
          )
        ),
        printf(fh, "~%")
      )
    )
  ), 
  printf(fh, "} ~%")
)$ 

/* Radiation drag force, F_rad(v) where F_rad(v) is only a function of velocity space,
   at velocity-space surface quadrature points. */
calcRadVelSurfForce(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,NV,rad_vx_e,rad_vy_e,rad_vz_e,rad_v_e,
   vv,surfVars,surfVVars,bSurf,NSurf,
   nodes_conf,basisNodalConf,num_nodes_conf,nodes_vel,basisNodalVel,num_nodes_vel,
   surfNodes,numNodes,rad_l_n],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NV : length(bV), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, 
  const double *rad, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  printf(fh, "  const double *rad_v~a = &rad[~a]; ~%", clabels[dir], NV*(dir-1)), 
  printf(fh, "~%"),
  rad_vx_e : doExpand1(rad_vx, bV), 
  rad_vy_e : doExpand1(rad_vy, bV), 
  rad_vz_e : doExpand1(rad_vz, bV),
  rad_v_e : [rad_vx_e, rad_vy_e, rad_vz_e], 

  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  surfVVars : delete(vv,varsV), 
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars, surfVVars, varsC),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  /* Each cells owns its *lower* edge fluxes, so we evaluate the 
     radiation drag force at vv = -1. */
  rad_l_n : float(evAtNodes(subst(vv=-1,rad_v_e[dir]),surfNodes,surfVars)), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_quad[~a] += ~a; ~%", i-1, rad_l_n[i]) 
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 

/* Nodal Lax-Friedrichs to modal velocity-space flux. */
calcNodalLaxToModalVelFlux(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,vid,
   vv,surfVars,surfVVars,bSurf,NSurf,
   nodes_conf,basisNodalConf,num_nodes_conf,nodes_vel,basisNodalVel,num_nodes_vel,
   surfNodes,numNodes,jacob_edge,jacob_vi_surf,jacob_surf_tot,
   f_l_e,f_r_e,f_l_n,f_r_n,lax_list,lax_e,Ghat_c],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double *dxv, const double *jacob_vel_surf, 
  const double *alpha_quad, const double *f_l, const double *f_r, 
  double *lax, double* GKYL_RESTRICT vel_flux_surf) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  vid : vidx(cdim,vdim),
  printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
  printf(fh, "~%"),

  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  surfVVars : delete(vv,varsV), 
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars, surfVVars, varsC),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 
  printf(fh, "  double *Ghat = &vel_flux_surf[~a]; ~%", (dir-1)*NSurf),

  if (vmap) then (
    [jacob_edge, jacob_vi_surf, jacob_surf_tot] : loadSurfVelJacobian(vdim, dir, nodes_vel, surfVVars, surfNodes, surfVars, true), 
    printf(fh, "  const double *jacob_vel_surf_vx = &jacob_vel_surf[0]; ~%"),
    if (vdim > 1) then (
      printf(fh, "  const double *jacob_vel_surf_vy = &jacob_vel_surf[4]; ~%")
    ),
    if (vdim = 3) then (
      printf(fh, "  const double *jacob_vel_surf_vz = &jacob_vel_surf[8]; ~%")
    )
  ), 
  /* Create expansions of f_left and f_right on volume basis. */
  f_l_e : doExpand1(f_l, bP),
  f_r_e : doExpand1(f_r, bP),
  f_l_n : float(evAtNodes(subst(vv=1,f_l_e),surfNodes,surfVars)), 
  f_r_n : float(evAtNodes(subst(vv=-1,f_r_e),surfNodes,surfVars)), 
  printf(fh, "  double alpha_max = 0.0; ~%"), 
  printf(fh, "  double f_l_quad = 0.0; ~%"), 
  printf(fh, "  double f_r_quad = 0.0; ~%"), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_max = fmax(alpha_max, fabs(alpha_quad[~a])); ~%", i-1), 
    printf(fh, "  f_l_quad = ~a; ~%", f_l_n[i]), 
    printf(fh, "  f_r_quad = ~a; ~%", f_r_n[i]), 
    if (vmap) then (
      printf(fh, "  lax[~a] = 0.5*(~a)*(alpha_quad[~a]*(f_r_quad + f_l_quad) - fabs(alpha_quad[~a])*(f_r_quad - f_l_quad)); ~%", i-1, jacob_surf_tot[i], i-1, i-1)
    )
    else (
      printf(fh, "  lax[~a] = 0.5*(alpha_quad[~a]*(f_r_quad + f_l_quad) - fabs(alpha_quad[~a])*(f_r_quad - f_l_quad)); ~%", i-1, i-1, i-1) 
    ),
    printf(fh, "~%")    
  ), 
  /* Construct the nodal expansion from a tensor product of the configuration-space nodal basis 
     and velocity-space nodal basis. We do this separation to accommodate the fact that we may 
     require fewer quadrature points in velocity space than configuration space. */
  lax_list : makelist(lax[i], i, 0, numNodes-1), 
  lax_e : 0, 
  for i : 1 thru num_nodes_conf do (
    for j : 1 thru num_nodes_vel do (
      lax_e : lax_e + lax_list[j + (i-1)*num_nodes_vel]*basisNodalVel[j]*basisNodalConf[i]
    )
  ),
  /* Project nodal basis back onto modal basis */
  Ghat_c : calcInnerProdList(surfVars, 1, bSurf, lax_e),
  writeCExprs1(Ghat, Ghat_c), 
  printf(fh, "~%"),
  flush_output(fh),

  /* Estimate stable time step from the maximum quadrature point evaluation. */
  if (vmap) then (
    printf(fh, "  return ~a*~a*alpha_max/(~a);~%", float(0.5*(2*polyOrder+1)), dv1[dir], float(expand(jacob_edge[dir])))
  )
  else (
    printf(fh, "  return ~a*~a*alpha_max;~%", float(0.5*(2*polyOrder+1)), dv1[dir])
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 