/* Functions which compute the components of the surface flux in velocity space. 
   The procedure we utilize to generalize to the presence of different forces/different
   flavors of the Vlasov equation is a set of functions that compute the characteristics
   alpha_v at surface quadrature points of the needed order, accumulating each component, 
   e.g., Hamiltonian forces, the Lorentz force, or forces due to a scalar potential, 
   into a total alpha_v at the surface. 

   We then evaluate the Lax-Friedrichs flux G = alpha/2*(f^+ + f^-) - |alpha|/2*(f^+ - f^-)
   at each quadrature point, and then convert that back to a modal expansion of the 
   velocity-space flux for use in the final update in hyper_dg. 

   Note that we do not make any assumptions on the order of the phase space expansion
   and thus to evaluate G, we must utilize enough Gauss-Legendre quadrature points
   to integrate a 3*p polynomial (cubic for p=1, sixth order for p=2, ninth order for p=3). 
   We thus must use 2, 4, and 5 Gauss-Legendre points respectively.    
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
dx11 : [dx10, dx11, dx12]$
dv11 : [dv10, dv11, dv12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Phase-space Hamiltonian forces at velocity-space surface quadrature points. */
calcHamilGenVelSurfForce(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,hamil,cv,vv,surfVars,bSurf,NSurf,
   surfNodes,basisNodal,numNodes,dH_dx_l_n],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, 
  const double *hamil, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  cid : cidx(cdim),
  printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "~%"),
  hamil : doExpand1(hamil, bP), /* Hamiltonian is a function of phase space. */

  cv : varsC[dir],
  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  [bSurf,NSurf,surfNodes,basisNodal,numNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars),

  /* Each cells owns its *lower* edge fluxes, so we evaluate the derivative of the 
     Hamiltonian at vv = -1. Note that the flux is -grad_x(H). */
  dH_dx_l_n : float(evAtNodes(subst(vv=-1,diff(hamil,cv)),surfNodes,surfVars)), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_quad[~a] += -~a*(~a); ~%", i-1, dx11[dir], dH_dx_l_n[i]) 
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 

/* Lorentz force with velocity-space Hamiltonian at velocity-space surface quadrature points. */
calcEBHamilVelSurfForce(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,NC,vid,hamil,
   Ex_e,Ey_e,Ez_e,Bx_e,By_e,Bz_e,ax,ay,az,accel,
   vv,surfVars,bSurf,NSurf,surfNodes,basisNodal,numNodes,EB_l_n],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, 
  const double *hamil, const double *qmem, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  printf(fh, "  const double *E~a = &qmem[~a]; ~%", clabels[dir], NC*(dir-1)), 
  printf(fh, "~%"),
  hamil : doExpand1(hamil, bV), /* Hamiltonian only a function of velocity space. */

  Ex_e : doExpand1(Ex, bC), 
  Ey_e : doExpand1(Ey, bC), 
  Ez_e : doExpand1(Ez, bC), 
  Bx_e : doExpand1(Bx, bC), 
  By_e : doExpand1(By, bC), 
  Bz_e : doExpand1(Bz, bC), 
  if (vdim = 1) then (
    ax : Ex_e, 
    accel : [ax]
  )
  else if (vdim = 2) then (
    /* If vdim = 2, only need Bz. Also load dv components for derivatives of Hamiltonian. */
    vid : vidx(cdim,vdim),
    printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
    printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
    printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
    ax : Ex_e + dv11[2]*diff(hamil, varsV[2])*Bz_e,
    ay : Ey_e - dv11[1]*diff(hamil, varsV[1])*Bz_e, 
    accel : [ax, ay]
  )
  else (
    /* Load all components of magnetic field and dv components for derivatives of Hamiltonian. */
    vid : vidx(cdim,vdim),
    printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
    printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
    printf(fh, "  double dv12 = 2.0/dxv[~a]; ~%", vid[3]),
    printf(fh, "  const double *Bx = &qmem[~a]; ~%", NC*3),
    printf(fh, "  const double *By = &qmem[~a]; ~%", NC*4),
    printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
    ax : Ex_e + dv11[2]*diff(hamil, varsV[2])*Bz_e - dv11[3]*diff(hamil, varsV[3])*By_e,
    ay : Ey_e + dv11[3]*diff(hamil, varsV[3])*Bx_e - dv11[1]*diff(hamil, varsV[1])*Bz_e, 
    az : Ez_e + dv11[1]*diff(hamil, varsV[1])*By_e - dv11[2]*diff(hamil, varsV[2])*Bx_e, 
    accel : [ax, ay, az]
  ), 

  vv : varsV[dir],
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  [bSurf,NSurf,surfNodes,basisNodal,numNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars),

  /* Each cells owns its *lower* edge fluxes, so we evaluate the Lorentz force at vv = -1. */
  EB_l_n : float(evAtNodes(subst(vv=-1,accel[dir]),surfNodes,surfVars)), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_quad[~a] += ~a; ~%", i-1, EB_l_n[i]) 
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 

/* Scalar potential forces at velocity-space surface quadrature points. */
calcPhiVelSurfForce(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,phi,cv,vv,surfVars,bSurf,NSurf,
   surfNodes,basisNodal,numNodes,dphi_dx_l_n],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, 
  const double *phi, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  cid : cidx(cdim),
  printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "~%"),
  phi : doExpand1(phi, bC), /* Scalar potential is only a function of configuration space. */

  cv : varsC[dir],
  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  [bSurf,NSurf,surfNodes,basisNodal,numNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars),

  /* Each cells owns its *lower* edge fluxes, so we evaluate the derivative of the 
     the potential at vv = -1 (although in this case the potential only depends on 
     configuration space). Note that the flux is -grad_x(phi). */
  dphi_dx_l_n : float(evAtNodes(subst(vv=-1,diff(phi,cv)),surfNodes,surfVars)), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_quad[~a] += -~a*(~a); ~%", i-1, dx11[dir], dphi_dx_l_n[i]) 
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 

/* Scalar potential forces at velocity-space surface quadrature points. */
calcNodalLaxToModalVelFlux(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,vid,vv,surfVars,bSurf,NSurf,
   surfNodes,basisNodal,numNodes,
   f_l_e,f_r_e,f_l_n,f_r_n,lax_nodal_quad_e,Ghat_c],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double *dxv, const double *alpha_quad, 
  const double *f_l, const double *f_r, double *lax_nodal_quad, 
  double* GKYL_RESTRICT vel_flux_surf) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  vid : vidx(cdim,vdim),
  printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
  printf(fh, "~%"),

  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  [bSurf,NSurf,surfNodes,basisNodal,numNodes] : loadVlasovSurfBasis(basisFun, polyOrder, surfVars),
  printf(fh, "  double *Ghat = &vel_flux_surf[~a]; ~%", (dir-1)*NSurf),

  /* Create expansions of f_left and f_right on volume basis. */
  f_l_e : doExpand1(f_l, bP),
  f_r_e : doExpand1(f_r, bP),
  f_l_n : float(evAtNodes(subst(vv=1,f_l_e),surfNodes,surfVars)), 
  f_r_n : float(evAtNodes(subst(vv=-1,f_r_e),surfNodes,surfVars)), 
  printf(fh, "  double alpha_max = 0.0; ~%"), 
  printf(fh, "  double f_l_quad = 0.0; ~%"), 
  printf(fh, "  double f_r_quad = 0.0; ~%"), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_max = fmax(alpha_max, fabs(alpha_quad[~a])); ~%", i-1), 
    printf(fh, "  f_l_quad = ~a; ~%", f_l_n[i]), 
    printf(fh, "  f_r_quad = ~a; ~%", f_r_n[i]), 
    printf(fh, "  lax_nodal_quad[~a] = 0.5*(alpha_quad[~a]*(f_r_quad + f_l_quad) - fabs(alpha_quad[~a])*(f_r_quad - f_l_quad)); ~%", i-1, i-1, i-1), 
    printf(fh, "~%")    
  ), 
  lax_nodal_quad_e : doExpand1(lax_nodal_quad,basisNodal),
  /* Project nodal basis back onto modal basis */
  Ghat_c : calcInnerProdList(surfVars, 1, bSurf, lax_nodal_quad_e),
  writeCExprs1(Ghat, Ghat_c), 
  printf(fh, "~%"),
  flush_output(fh),

  /* Estimate stable time step from the maximum quadrature point evaluation. */
  printf(fh, "  return ~a*~a*alpha_max;~%", float(0.5*(2*polyOrder+1)), dv11[dir]), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 