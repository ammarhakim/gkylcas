load("new_vlasov/vlasovVelFluxSurfFuncs")$
load(stringproc)$
/* This script calls the functions which calculate the
   components of the modal DG expansion of the velocity space 
   flux, first accumulating different forces into an array
   storing the phase space characteristics alpha_v at quadrature
   points, and then constructing a nodal Lax-Friedrichs flux,
   G = alpha/2*(f^+ + f^-) - |alpha|/2*(f^+ - f^-)
   and converting that back to a modal expansion. */

/* ...... USER INPUTS........ */

/* Serendipity basis. */
minPolyOrder_Ser : 2$
maxPolyOrder_Ser : 2$
minCdim_Ser : 2$
minVdim_Ser : 3$    /* see begining of v loop below though. */
maxCdim_Ser : 2$
maxVdim_Ser : 3$

/* Tensor product basis. */
minPolyOrder_Tensor : 2$
maxPolyOrder_Tensor : 2$
minCdim_Tensor : 2$
minVdim_Tensor : 3$    /* see begining of v loop below though. */
maxCdim_Tensor : 2$
maxVdim_Tensor : 3$

/* ...... END OF USER INPUTS........ */

bName        : ["ser","tensor"]$
minPolyOrder : [minPolyOrder_Ser, minPolyOrder_Tensor]$
maxPolyOrder : [maxPolyOrder_Ser, maxPolyOrder_Tensor]$
minCdim      : [minCdim_Ser, minCdim_Tensor]$
minVdim      : [minVdim_Ser, minVdim_Tensor]$
maxCdim      : [maxCdim_Ser, maxCdim_Tensor]$
maxVdim      : [maxVdim_Ser, maxVdim_Tensor]$
useHigherOrderList : [false, true]$

clabels : ["x","y","z"]$
vlabels : ["vx","vy","vz"]$

for bInd : 1 thru length(bName) do (
  for c : minCdim[bInd] thru maxCdim[bInd] do (
    minVdimB : max(c,minVdim[bInd]), 
    maxVdimB : maxVdim[bInd], 
    if (c = 2) then minVdimB : 1, /* We support 2x1v. */
    for v : minVdimB thru maxVdimB do (

      minPolyOrderB : minPolyOrder[bInd],
      maxPolyOrderB : maxPolyOrder[bInd],
      if (v=1) then maxPolyOrderB : 3, /* Generate p=3 kernels if vdim = 1 */
      if (c+v>5 and maxPolyOrderB > 1) then maxPolyOrderB : 1,

      for polyOrder : minPolyOrderB thru maxPolyOrderB do (
        disp(printf(false,sconcat("Creating velocity flux ",bName[bInd]," ~ax~av_p~a"),c,v,polyOrder)),
        /* Can only have scalar potential force in directions where we can take configuration space gradients. */
        maxC : c, /* Which directions are we generating surface kernels for? */
        if (v < c) then maxC : v, /* In 2x1v, only generate the vx surface kernel. */
        for dir : 1 thru maxC do (
          if (0) then (
          fname : sconcat("~/max-out/phi_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
          fh : openw(fname),
          funcName : sconcat("phi_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
          calcPhiVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder, false), 
          close(fh) 
          )           
        ),
        for dir : 1 thru v do (
          if (0) then (
          fname : sconcat("~/max-out/E_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
          fh : openw(fname),
          funcName : sconcat("E_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
          calcEVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder, false), 
          close(fh), 

          /* Magnetic force with velocity-space Hamiltonian volume component. Only valid for vdim > 1. */
          if (v > 1) then (
            fname : sconcat("~/max-out/B_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
            fh : openw(fname),
            funcName : sconcat("B_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
            if (bName[bInd] = "tensor" and polyOrder > 1) then (
              calcBHamilVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder, true, false)
            )
            else (
              calcBHamilVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder, false, false)
            ), 
            close(fh)
          ),

          fname : sconcat("~/max-out/rad_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
          fh : openw(fname),
          funcName : sconcat("rad_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
          calcRadVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder, false), 
          close(fh)
          ),
          for hoInd : 1 thru length(useHigherOrderList) do (
            useHigherOrder : useHigherOrderList[hoInd],
            if useHigherOrder then si : "ho_" else si : "",
            if not((bName[bInd] = "ser")and (polyOrder = 1) and (useHigherOrder = true)) then (
              if ((bName[bInd] = "ser")and (polyOrder = 1) and (useHigherOrder = false)) then si : "",

              if (bName[bInd] = "tensor" and polyOrder > 1) then (
                fname : sconcat("~/max-out/",si,"lax_flux_nodal_to_modal_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
                fh : openw(fname),
                funcName : sconcat(si,"lax_flux_nodal_to_modal_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
                calcNodalLaxToModalVelFlux(dir, fh, funcName, c, v, bName[bInd], polyOrder, true, useHigherOrder), 
                close(fh)  
              )
              else (
                fname : sconcat("~/max-out/",si,"lax_flux_nodal_to_modal_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
                fh : openw(fname),
                funcName : sconcat(si,"lax_flux_nodal_to_modal_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
                calcNodalLaxToModalVelFlux(dir, fh, funcName, c, v, bName[bInd], polyOrder, false, useHigherOrder), 
                close(fh)  
              )   
            )  
          )       
        )
      ),
      if (v=1) then maxPolyOrderB : 3, /* Generate p=3 kernels if vdim = 1 */
      /* We do not generate 5D and 6D p>1 phase-space Hamiltonian kernels. */
      if (c+v>5 and maxPolyOrderB > 1) then maxPolyOrderB : 1,
      for polyOrder : minPolyOrderB thru maxPolyOrderB do (
        disp(printf(false,sconcat("Creating hamiltonian force velocity flux ",bName[bInd]," ~ax~av_p~a"),c,v,polyOrder)),
        /* Can only have Hamiltonian force in directions where we can take configuration space gradients. */
        maxC : c, /* Which directions are we generating surface kernels for? */
        if (v < c) then maxC : v, /* In 2x1v, only generate the vx surface kernel. */
        for dir : 1 thru maxC do (
          /* Phase-space Hamiltonian surface component. Only generate with Serendipity basis for now. */
          if (bName[bInd] = "ser") then (
            if (0) then (
            fname : sconcat("~/max-out/hamil_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
            fh : openw(fname),
            funcName : sconcat("hamil_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
            calcHamilGenVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder, false), 
            close(fh)
            )
          )
        )
      )
    )
  )
);
