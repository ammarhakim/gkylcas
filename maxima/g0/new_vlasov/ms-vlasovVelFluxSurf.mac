load("new_vlasov/vlasovVelFluxSurfFuncs")$
load(stringproc)$
/* This script calls the functions which calculate the
   components of the modal DG expansion of the velocity space 
   flux, first accumulating different forces into an array
   storing the phase space characteristics alpha_v at quadrature
   points, and then constructing a nodal Lax-Friedrichs flux,
   G = alpha/2*(f^+ + f^-) - |alpha|/2*(f^+ - f^-)
   and converting that back to a modal expansion. */

/* ...... USER INPUTS........ */

/* Serendipity basis. */
minPolyOrder_Ser : 1$
maxPolyOrder_Ser : 2$
minCdim_Ser : 1$
minVdim_Ser : 1$    /* see begining of v loop below though. */
maxCdim_Ser : 3$
maxVdim_Ser : 3$

/* Tensor product basis. */
minPolyOrder_Tensor : 2$
maxPolyOrder_Tensor : 2$
minCdim_Tensor : 1$
minVdim_Tensor : 1$    /* see begining of v loop below though. */
maxCdim_Tensor : 3$
maxVdim_Tensor : 3$

/* ...... END OF USER INPUTS........ */

bName        : ["ser","tensor"]$
minPolyOrder : [minPolyOrder_Ser, minPolyOrder_Tensor]$
maxPolyOrder : [maxPolyOrder_Ser, maxPolyOrder_Tensor]$
minCdim      : [minCdim_Ser, minCdim_Tensor]$
minVdim      : [minVdim_Ser, minVdim_Tensor]$
maxCdim      : [maxCdim_Ser, maxCdim_Tensor]$
maxVdim      : [maxVdim_Ser, maxVdim_Tensor]$

clabels : ["x","y","z"]$
vlabels : ["vx","vy","vz"]$

for bInd : 1 thru length(bName) do (
  for c : minCdim[bInd] thru maxCdim[bInd] do (
    minVdimB : max(c,minVdim[bInd]), 
    maxVdimB : maxVdim[bInd], 
    if (c = 2) then minVdimB : 1, /* We support 2x1v. */
    for v : minVdimB thru maxVdimB do (

      minPolyOrderB : minPolyOrder[bInd],
      maxPolyOrderB : maxPolyOrder[bInd],
      if (c+v>4 and maxPolyOrderB > 1) then maxPolyOrderB : 1,

      for polyOrder : minPolyOrderB thru maxPolyOrderB do (
        disp(printf(false,sconcat("Creating velocity flux ",bName[bInd]," ~ax~av_p~a"),c,v,polyOrder)),
        /* Can only have Hamiltonian force or scalar potential force in directions where we can take 
           configuration space gradients. */
        maxC : c, /* Which directions are we generating surface kernels for? */
        if (v < c) then maxC : v, /* In 2x1v, only generate the vx surface kernel. */
        for dir : 1 thru maxC do (
          /* Phase-space Hamiltonian surface component. Only generate with uniform grids and Serendipity basis for now. */
          if (bName[bInd] = "ser") then (
            fname : sconcat("~/max-out/hamil_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
            fh : openw(fname),
            funcName : sconcat("hamil_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
            calcHamilGenVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder), 
            close(fh)
          ),

          fname : sconcat("~/max-out/phi_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
          fh : openw(fname),
          funcName : sconcat("phi_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
          calcPhiVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder), 
          close(fh)            
        ),
        for dir : 1 thru v do (
          fname : sconcat("~/max-out/E_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
          fh : openw(fname),
          funcName : sconcat("E_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
          calcEVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder), 
          close(fh), 

          /* Magnetic force with velocity-space Hamiltonian volume component. 
             Only valid for vdim > 1. */
          if (v > 1) then (
            fname : sconcat("~/max-out/B_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
            fh : openw(fname),
            funcName : sconcat("B_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
            if (bName[bInd] = "tensor" and polyOrder > 1) then (
              calcBHamilVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder, true)
            )
            else (
              calcBHamilVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder, false)
            ), 
            close(fh)
          ),

          fname : sconcat("~/max-out/rad_alpha_quad_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
          fh : openw(fname),
          funcName : sconcat("rad_alpha_quad_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
          calcRadVelSurfForce(dir, fh, funcName, c, v, bName[bInd], polyOrder), 
          close(fh), 

          if (bName[bInd] = "tensor" and polyOrder > 1) then (
            fname : sconcat("~/max-out/lax_flux_nodal_to_modal_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
            fh : openw(fname),
            funcName : sconcat("lax_flux_nodal_to_modal_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
            calcNodalLaxToModalVelFlux(dir, fh, funcName, c, v, bName[bInd], polyOrder, true), 
            close(fh)  
          )
          else (
            fname : sconcat("~/max-out/lax_flux_nodal_to_modal_", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
            fh : openw(fname),
            funcName : sconcat("lax_flux_nodal_to_modal_",vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
            calcNodalLaxToModalVelFlux(dir, fh, funcName, c, v, bName[bInd], polyOrder, false), 
            close(fh)  
          )            
        )
      )
    )
  )
);
