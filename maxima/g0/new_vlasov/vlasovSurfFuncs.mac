/* Functions which compute the components of the surface update of the Vlasov 
   equation using a discontinuous Galerkin (DG) method. Advection in
   configuration space is computed as velocity gradients of a Hamiltonian. 
   In the case when the Hamiltonian that only depends on velocity space,
   **we assume the origin (v=0) is at a velocity-space cell edge** and thus
   we can just check the sign of the cell center value for the upwind 
   direction. In the case when the Hamiltonian depends on phase space
   we utilize a standard Lax-Friedrichs flux for continuous characteristics: 
   G = alpha/2*(f^+ + f^-) - |alpha|/2*(f^+ - f^-)
   evaluated at nodes and converted back to a modal expansion. Note that 
   we do not make any assumptions on the order of the phase space expansion
   and thus to evaluate G, we must utilize enough Gauss-Legendre quadrature points
   to integrate a 3*p polynomial (cubic for p=1, sixth order for p=2, ninth order for p=3). 
   We thus must use 2, 4, and 5 Gauss-Legendre points respectively. 

   We do similar evaluations for the velocity-space update, but for the velocity-space
   update, we pre-compute the modal expansion of the flux to allow for ease of 
   accumulation of different forces (Hamiltonian, electromagnetic, scalar potentials, etc.). 
   Thus, the velocity-space update simply evaluates the final surface integral with the
   computed modal expansion of the flux at that interface. 
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
dx11 : [dx10, dx11, dx12]$
dv11 : [dv10, dv11, dv12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Velocity-space Hamiltonian surface streaming */
calcHamilVelSurfStream(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,
   bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi,
   cid,vid,hamil,cv,vv,surfVars,bSurf,NSurf,fl_e,fc_e,fr_e,
   jacob_vi,f_l_v,f_l_v_ne,f_c_v,f_c_v_ne,f_r_v,f_r_v_ne,
   dH_dv_nodes,dH_dv_ne,fUpwind_r_e,fUpwind_l_e,fUpwind_r_c,fUpwind_l_c,
   Ghat_r_c,Ghat_l_c,Ghat_l_e,Ghat_r_e,incr_l,incr_r,stream],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  [bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi] = loadVelJacobianBasis(polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, 
  const double *jacob_vel, const double *poisson_tensor_conf, const double *hamil, 
  const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
  printf(fh, "  double wv = w[~a]; ~%", vid[dir], vid[dir]),
  printf(fh, "~%"),
  hamil : doExpand1(hamil, bV), /* Hamiltonian only a function of velocity space. */

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */
  /* cv = variable in direction of surface update. */
  cv : varsP[dir],
  vv : varsV[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsP),
  bSurf : basisFromVars(basisFun,surfVars,polyOrder),
  NSurf : length(bSurf), 

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  if (vmap) then (
    printf(fh, "  const double *jacob_v~a = &jacob_vel[~a]; ~%", clabels[dir], NV_1D*(dir-1)), 
    /* Fetch Jacobian and nodal basis in surface direction */
    jacob_vi : jacobNodes_vi[dir], 
    basisJacobNodal : basisNodal_vi[dir], 

    /* Project the distribution function in each cell onto the nodal basis 
       to divide out the Jacobian in direction dir. We will only write to a 
       temporary variables the evaluations we need based on the sign of the cell center. */
    f_l_v : evAtNodes(fl_e,jacobNodes,[varsV[dir]]), 
    f_l_v_ne : 0, 
    for i : 1 thru numJacobNodes do (
      f_l_v_ne : f_l_v_ne + f_l_v[i]/jacob_vi[i]*basisJacobNodal[i]
    ), 

    f_c_v : evAtNodes(fc_e,jacobNodes,[varsV[dir]]), 
    f_c_v_ne : 0, 
    for i : 1 thru numJacobNodes do (
      f_c_v_ne : f_c_v_ne + f_c_v[i]/jacob_vi[i]*basisJacobNodal[i]
    ), 

    f_r_v : evAtNodes(fr_e,jacobNodes,[varsV[dir]]), 
    f_r_v_ne : 0, 
    for i : 1 thru numJacobNodes do (
      f_r_v_ne : f_r_v_ne + f_r_v[i]/jacob_vi[i]*basisJacobNodal[i]
    ), 

    /* Estimate the stable time step size from the streaming term at nodes */
    dH_dv_nodes : evAtNodes(diff(hamil, vv),jacobNodes,[varsV[dir]]), 
    dH_dv_ne : 0, 
    for i : 1 thru numJacobNodes do (
      dH_dv_ne : dH_dv_ne + dH_dv_nodes[i]/jacob_vi[i]*basisJacobNodal[i]
    ) 
  )
  else (
    f_l_v_ne : fl_e, 
    f_c_v_ne : fc_e, 
    f_r_v_ne : fr_e, 
    dH_dv_ne : diff(hamil, vv)
  ), 
  clst : [jacob_vx[0], jacob_vx[1], jacob_vx[2], jacob_vx[3], jacob_vy[0], jacob_vy[1], jacob_vy[2], jacob_vy[3], jacob_vz[0], jacob_vz[1], jacob_vz[2], jacob_vz[3]],
  fUpwind_r_e : doExpand1(fUpwind_r, bSurf), 
  fUpwind_l_e : doExpand1(fUpwind_l, bSurf),

  printf(fh, "  double fUpwind_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double fUpwind_l[~a] = {0.0}; ~%", NSurf), 
  printf(fh, "  double Ghat_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_l[~a] = {0.0}; ~%", NSurf),
  
  printf(fh, "  if (~a>0) { ~%~%",wv),

  /* Because dH/dv > 0, need left edge value */
  fUpwind_r_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, f_c_v_ne)), 
  writeCExprsCollect1(fUpwind_r, fUpwind_r_c, clst),
  printf(fh, "~%"),
  flush_output(fh),

  fUpwind_l_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, f_l_v_ne)), 
  writeCExprsCollect1(fUpwind_l, fUpwind_l_c, clst),
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "  } else { ~%~%"),
  
  /* Because dH/dv < 0, need right edge value */
  fUpwind_r_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1, f_r_v_ne)), 
  writeCExprsCollect1(fUpwind_r, fUpwind_r_c, clst),
  printf(fh, "~%"),
  flush_output(fh),

  fUpwind_l_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1, f_c_v_ne)), 
  writeCExprsCollect1(fUpwind_l, fUpwind_l_c, clst),
  printf(fh, "~%"),
  flush_output(fh),
  
  printf(fh, "  } ~%"),

  Ghat_l_c : calcInnerProdList(surfVars, diff(hamil, vv), bSurf, fUpwind_l_e),
  writeCExprsCollect1lhsc(Ghat_l, Ghat_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  Ghat_r_c : calcInnerProdList(surfVars, diff(hamil, vv), bSurf, fUpwind_r_e),
  writeCExprsCollect1lhsc(Ghat_r, Ghat_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Compute surface contribution integral(phi^- Ghat) on the left and right. */
  Ghat_l_e : doExpand1(Ghat_l, bSurf),
  Ghat_r_e : doExpand1(Ghat_r, bSurf),
  incr_l : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Ghat_l_e),
  incr_r : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Ghat_r_e),
  writeCIncrExprsCollect1lhsc(out, dv11[dir]*dx11[dir]*incr_l + dv11[dir]*dx11[dir]*incr_r),    
  printf(fh, "~%"),

  /* Estimate stable time step from the cell average of the derivative of the Hamiltonian. */
  stream : calcInnerProdList(varsV, 1, bV, dH_dv_ne), 
  printf(fh, "  return fabs(~a*~a*~a*(~a));~%", float(0.5*(2*polyOrder+1)*2.0^(-0.5*(vdim))), dv11[dir], dx11[dir], float(expand(stream[1]))), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$  

/* Phase-space Hamiltonian surface streaming */
calcHamilGenSurfStream(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, useHigherOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,vid,hamil,cv,vv,surfVars,surfCVars, 
   bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes, 
   NSurf,num_nodes_conf,num_nodes_vel,numNodes,fl_e,fc_e,fr_e,
   dH_dv_l_n,dH_dv_r_n,f_lr_n,f_cl_n,f_cr_n,f_rl_n,
   Ghat_r_nodal_e,Ghat_l_nodal_e,Ghat_r_c,Ghat_l_c,Ghat_l_e,Ghat_r_e,incr_l,incr_r],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, 
  const double *jacob_vel, const double *poisson_tensor_conf, const double *hamil, 
  const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
  printf(fh, "~%"),
  hamil : doExpand1(hamil, bP), /* Hamiltonian a function of the full phase space. */

  /* Surface contribution is defined as integral(phi^- Fhat) over the surface. */
  /* cv = variable in direction of surface update. */
  cv : varsP[dir],
  vv : varsV[dir], 
  surfVars : delete(cv,varsP), /* Surface variables at constant cv surface. */
  surfCVars : delete(cv,varsC), /* Remaining configuration space variables at cv surface. */
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovConfSurfBasis(cdim, vdim, basisFun, polyOrder, surfVars, surfCVars, varsV, useHigherOrder),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  printf(fh, "  double Fhat_l_nodal[~a] = {0.0}; ~%", numNodes),
  printf(fh, "  double Fhat_r_nodal[~a] = {0.0}; ~%", numNodes),
  dH_dv_l_n : float(evAtNodes(subst(cv=-1,diff(hamil,vv)),surfNodes,surfVars)), 
  dH_dv_r_n : float(evAtNodes(subst(cv=1,diff(hamil,vv)),surfNodes,surfVars)), 
  f_lr_n : float(evAtNodes(subst(cv=1,fl_e),surfNodes,surfVars)), 
  f_cl_n : float(evAtNodes(subst(cv=-1,fc_e),surfNodes,surfVars)), 
  f_cr_n : float(evAtNodes(subst(cv=1,fc_e),surfNodes,surfVars)), 
  f_rl_n : float(evAtNodes(subst(cv=-1,fr_e),surfNodes,surfVars)), 
  printf(fh, "  double alpha_l_quad = 0.0; ~%"), 
  printf(fh, "  double alpha_r_quad = 0.0; ~%"), 
  printf(fh, "  double alpha_max = 0.0; ~%"), 
  printf(fh, "  double f_lr_quad = 0.0; ~%"), 
  printf(fh, "  double f_cl_quad = 0.0; ~%"), 
  printf(fh, "  double f_cr_quad = 0.0; ~%"), 
  printf(fh, "  double f_rl_quad = 0.0; ~%"), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_l_quad = ~a; ~%", dH_dv_l_n[i]), 
    printf(fh, "  alpha_r_quad = ~a; ~%", dH_dv_r_n[i]), 
    printf(fh, "  alpha_max = fmax(alpha_max, fmax(fabs(alpha_l_quad), fabs(alpha_r_quad))); ~%"), 
    printf(fh, "  f_lr_quad = ~a; ~%", f_lr_n[i]), 
    printf(fh, "  f_cl_quad = ~a; ~%", f_cl_n[i]), 
    printf(fh, "  f_cr_quad = ~a; ~%", f_cr_n[i]), 
    printf(fh, "  f_rl_quad = ~a; ~%", f_rl_n[i]), 
    printf(fh, "  Fhat_l_nodal[~a] = 0.5*(alpha_l_quad*(f_cl_quad + f_lr_quad) - fabs(alpha_l_quad)*(f_cl_quad - f_lr_quad)); ~%", i-1), 
    printf(fh, "  Fhat_r_nodal[~a] = 0.5*(alpha_r_quad*(f_rl_quad + f_cr_quad) - fabs(alpha_r_quad)*(f_rl_quad - f_cr_quad)); ~%", i-1), 
    printf(fh, "~%")    
  ), 
  /* Construct the nodal expansion from a tensor product of the configuration-space nodal basis 
     and velocity-space nodal basis. We do this separation because Maxima struggles to make
     high dimensional nodal bases and we know the basis we need is a tensor product of two
     lower dimensional basis sets. */
  Fhat_l_nodal_list : makelist(Fhat_l_nodal[i], i, 0, numNodes-1), 
  Fhat_r_nodal_list : makelist(Fhat_r_nodal[i], i, 0, numNodes-1), 
  Fhat_l_nodal_e : 0, 
  Fhat_r_nodal_e : 0, 
  for i : 1 thru num_nodes_conf do (
    for j : 1 thru num_nodes_vel do (
      Fhat_l_nodal_e : ratsimp(Fhat_l_nodal_e + Fhat_l_nodal_list[j + (i-1)*num_nodes_vel]*basisNodalVel[j]*basisNodalConf[i]),
      Fhat_r_nodal_e : ratsimp(Fhat_r_nodal_e + Fhat_r_nodal_list[j + (i-1)*num_nodes_vel]*basisNodalVel[j]*basisNodalConf[i])
    )
  ),

  /* Compute surface contribution integral(phi^- Fhat) on the left and right. */
  incr_l : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Fhat_l_nodal_e),
  incr_r : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Fhat_r_nodal_e),
  writeCIncrExprsCollect1lhsc(out, dv11[dir]*dx11[dir]*incr_l + dv11[dir]*dx11[dir]*incr_r),    
  printf(fh, "~%"),

  /* Estimate stable time step from the maximum quadrature point evaluation. */
  printf(fh, "  return fabs(~a*~a*~a*alpha_max);~%", float(0.5*(2*polyOrder+1)), dv11[dir], dx11[dir]), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$  

/* Velocity-space surface update from pre-computed flux. */
calcVelSurf(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, useHigherOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP, vid,vv, surfVars,surfVVars,
   bSurf,NSurf, nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,
   surfNodes, num_nodes_conf,num_nodes_vel,numNodes,Fhat_l_nodal_c,
   Fhat_r_nodal_c,Fhat_l_nodal_list,Fhat_r_nodal_list,
   Fhat_l_nodal_e,Fhat_r_nodal_e, Ghat_l_d,Ghat_r_d,Ghat_l,Ghat_r,
   Ghat_l_e,Ghat_r_e,incr_l,incr_r],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv,
  const double *Fhat_l_nodal, const double *Fhat_r_nodal, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  vid : vidx(cdim,vdim),
  printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
  printf(fh, "~%"),

  /* Surface contribution is defined as integral(phi^- Fhat) over the surface. */
  vv : varsV[dir], 
  surfVars : delete(vv,varsP), /* Surface variables at constant vv surface. */
  surfVVars : delete(vv,varsV), 
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovVelSurfBasis(cdim, vdim, basisFun, polyOrder, surfVars, surfVVars, varsC, useHigherOrder),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  printf(fh, "  double Ghat_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  const double *Fhat_l_nodal_c = &Fhat_l_nodal[~a]; ~%", (dir-1)*numNodes),
  printf(fh, "  const double *Fhat_r_nodal_c = &Fhat_r_nodal[~a]; ~%", (dir-1)*numNodes),

  Fhat_l_nodal_list : makelist(Fhat_l_nodal_c[i], i, 0, numNodes-1), 
  Fhat_r_nodal_list : makelist(Fhat_r_nodal_c[i], i, 0, numNodes-1), 
  Fhat_l_nodal_e : 0, 
  Fhat_r_nodal_e : 0, 
  for i : 1 thru num_nodes_conf do (
    for j : 1 thru num_nodes_vel do (
      Fhat_l_nodal_e : Fhat_l_nodal_e + Fhat_l_nodal_list[j + (i-1)*num_nodes_vel]*basisNodalVel[j]*basisNodalConf[i],
      Fhat_r_nodal_e : Fhat_r_nodal_e + Fhat_r_nodal_list[j + (i-1)*num_nodes_vel]*basisNodalVel[j]*basisNodalConf[i]
    )
  ),

  Ghat_l_d : calcInnerProdList(surfVars, 1, bSurf, Fhat_l_nodal_e),
  Ghat_r_d : calcInnerProdList(surfVars, 1, bSurf, Fhat_r_nodal_e),
  writeCExprs1(Ghat_l, Ghat_l_d), 
  writeCExprs1(Ghat_r, Ghat_r_d), 

  Ghat_l_e : doExpand1(Ghat_l, bSurf),
  Ghat_r_e : doExpand1(Ghat_r, bSurf),

  incr_l : calcInnerProdList(surfVars, 1, subst(vv=-1.0, bP), Ghat_l_e),
  incr_r : calcInnerProdList(surfVars, -1, subst(vv=1.0, bP), Ghat_r_e),

  writeCIncrExprsCollect1lhsc(out, dv11[dir]*incr_l + dv11[dir]*incr_r),    
  printf(fh, "~%"),

  /* Stable time step obtained from flux computation at nodes earlier. */
  printf(fh, "  return 0.0;~%"), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$    