/* Functions which compute the components of the volume update of the Vlasov 
   equation using a discontinuous Galerkin (DG) method. Different 
   component include: 
   1. Streaming in configuration space via velocity-space derivatives of 
      the Hamiltonian, with either a velocity-space only Hamiltonian such as
      H = p^2/2m or H = mc^2*sqrt(1 + p^2), or a full phase-space Hamiltonian
      including geometric terms, H = g^ij p_i p_j/2m. 
   2. Forces in velocity space due to geometric terms in the Hamiltonian, -grad_x(H)
   3. Forces in velocity space due to the Lorentz force, q/m (E + grad_v(H) x B)
   4. Forces in velocity space due to a scalar potential, -grad_x(phi) where phi
      can be electrostatic, gravitational, or external. 
   5. Forces in velocity space due to a vector potential, q/m (-dA/dt + grad_v(H) x curl(A))
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
dx11 : [dx10, dx11, dx12]$
dv11 : [dv10, dv11, dv12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
PB_vol(f,g,x,y) := diff(f,x)*diff(g,y) - diff(g,x)*diff(f,y)$

/* Hamiltonian volume contribution, either just streaming, 
   grad_x(w) . grad_v(H) f, if Hamiltonian only depends on velocity space, or, 
   grad_x(w) . grad_v(H) f - grad_v(w) . grad_x(H) f */
calcHamilVol(fh, funcNm, cdim, vdim, basisFun, polyOrder, hamil_vel) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,vid,pb_dim,hamil,f_e,pb,pbBasis,clst],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *hamil, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  if (hamil_vel) then (
    hamil : doExpand1(hamil, bV)
  )
  else (
    hamil : doExpand1(hamil, bP)    
  ),
  f_e : doExpand1(f, bP),
  
  cid : cidx(cdim),
  vid : vidx(cdim,vdim),  
  pb_dim : min(cdim,vdim), 
  for dir : 1 thru pb_dim do (
    printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]), 
    printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir])
  ),

  /* For cdim /= vdim, we assume the ignorable coordinates are the last pairs.
     For instance if we have varsC = [x,y,z] with:
     - 1 ignorable coordinate: [x, y, \dot{x}, \dot{y}] are all that show up in {f,H} 
     - 2 ignorable coordinates: [x, \dot{x},] are all that show up in {f,H} 
     It is assumed that H does not depend on these ignorable coordinates. */
  pb : (pb : 0, for dir : 1 thru pb_dim do (
     pbBasis : dx11[dir]*dv11[dir]*(PB_vol(bP,hamil,varsC[dir],varsV[dir])),
     pb : pb + fullratsimp(calcInnerProdList(varsP, 1, pbBasis, f_e))
     ),
  pb),
  clst : [dx10, dx11, dx12, dv10, dv11, dv12],
  writeCIncrExprsCollect1(out, pb, clst),

  printf(fh, "} ~%")
)$  

calcEBVol(fh, funcNm, cdim, vdim, basisFun, polyOrder, hamil_vel) := block(
  [varsC,bC,varsV,bV,varsP,bP,NC,NV,NP,hamil,f_e,vid,
   Ex_e,Ey_e,Ez_e,Bx_e,By_e,Bz_e,ax,ay,az,accel,
   alpha_vdim_c,exprs,alpha_vdim_NoZero,alpha_vdim_NoZero_e,incr_vdim],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 
  NV : length(bV), 
  NP : length(bP), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *hamil, const double *qmem, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  if (hamil_vel) then (
    hamil : doExpand1(hamil, bV)
  )
  else (
    hamil : doExpand1(hamil, bP)    
  ),
  f_e : doExpand1(f, bP),
  
  vid : vidx(cdim,vdim), 
  for dir : 1 thru vdim do (
    printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]), 
    printf(fh, "  const double *E~a = &qmem[~a]; ~%", clabels[dir], NC*(dir-1))
  ),

  Ex_e : doExpand1(Ex, bC), 
  Ey_e : doExpand1(Ey, bC), 
  Ez_e : doExpand1(Ez, bC), 
  Bx_e : doExpand1(Bx, bC), 
  By_e : doExpand1(By, bC), 
  Bz_e : doExpand1(Bz, bC), 
  if (vdim = 1) then (
    ax : Ex_e, 
    accel : [ax]
  )
  else if (vdim = 2) then (
    /* If vdim = 2, only need Bz. */
    printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
    ax : Ex_e + dv11[2]*diff(hamil, varsV[2])*Bz_e,
    ay : Ey_e - dv11[1]*diff(hamil, varsV[1])*Bz_e, 
    accel : [ax, ay]
  )
  else (
    printf(fh, "  const double *Bx = &qmem[~a]; ~%", NC*3),
    printf(fh, "  const double *By = &qmem[~a]; ~%", NC*4),
    printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
    ax : Ex_e + dv11[2]*diff(hamil, varsV[2])*Bz_e - dv11[3]*diff(hamil, varsV[3])*By_e,
    ay : Ey_e + dv11[3]*diff(hamil, varsV[3])*Bx_e - dv11[1]*diff(hamil, varsV[1])*Bz_e, 
    az : Ez_e + dv11[1]*diff(hamil, varsV[1])*By_e - dv11[2]*diff(hamil, varsV[2])*Bx_e, 
    accel : [ax, ay, az]
  ), 

  printf(fh, "  double alpha_vdim[~a] = {0.0}; ~%~%", NP),
  for dir : 1 thru vdim do (
    alpha_vdim_c : calcInnerProdList(varsP, 1, bP, accel[dir]),
    expr : float(expand(alpha_vdim_c)),

    /* Write out the component of alpha_vdim's phase space expansion */
    for i : 1 thru NP do (
      if expr[i] # 0.0 then printf(fh, "  alpha_vdim[~a] = ~a*(~a); ~%", i-1, dv11[dir], expr[i])
    ),

    /* zero out components of alpha which are empty */
    alpha_vdim_NoZero : makelistNoZeros1(alpha_vdim_c, alpha_vdim),
    alpha_vdim_NoZero_e : doExpand(alpha_vdim_NoZero, bP),

    incr_vdim : calcInnerProdList(varsP, 1, diff(bP, varsV[dir]), alpha_vdim_NoZero_e*f_e), 
    writeCIncrExprs1(out, incr_vdim),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
)$  

/* Scalar potential contribution -grad_v(w) . grad_x(phi) f. */
calcPhiVol(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,vid,pb_dim,phi_e,f_e,pb,pbBasis,clst],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *phi, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  phi_e : doExpand1(phi, bC), 
  f_e : doExpand1(f, bP),
  
  cid : cidx(cdim),
  vid : vidx(cdim,vdim),  
  pb_dim : min(cdim,vdim), 
  for dir : 1 thru pb_dim do (
    printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]), 
    printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir])
  ),

  /* Utilize the same Poisson bracket structure for computing the update due to a
     scalar potential (like a Hamiltonian that only depends on configuration space) 
     and thus contributes a -grad_v(w) . grad_x(phi) f term to the volume. */
  pb : (pb : 0, for dir : 1 thru pb_dim do (
     pbBasis : dx11[dir]*dv11[dir]*(PB_vol(bP,phi_e,varsC[dir],varsV[dir])),
     pb : pb + fullratsimp(calcInnerProdList(varsP, 1, pbBasis, f_e))
     ),
  pb),
  clst : [dx10, dx11, dx12, dv10, dv11, dv12],
  writeCIncrExprsCollect1(out, pb, clst),

  printf(fh, "} ~%")
)$  