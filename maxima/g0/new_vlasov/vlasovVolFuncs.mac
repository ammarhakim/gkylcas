/* Functions which compute the components of the volume update of the Vlasov 
   equation using a discontinuous Galerkin (DG) method. Different 
   component include: 
   1. Streaming in configuration space via velocity-space derivatives of 
      the Hamiltonian, with either a velocity-space only Hamiltonian such as
      H = p^2/2m or H = mc^2*sqrt(1 + p^2), or a full phase-space Hamiltonian
      including geometric terms, H = g^ij p_i p_j/2m. 
   2. Forces in velocity space due to geometric terms in the Hamiltonian, -grad_x(H)
   3. Forces in velocity space due to the Lorentz force, q/m (E + grad_v(H) x B)
   4. Forces in velocity space due to a scalar potential, -grad_x(phi) where phi
      can be electrostatic, gravitational, or external. 
   5. Forces in velocity space due to a vector potential, q/m (-dA/dt + grad_v(H) x curl(A))
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
dx1 : [dx10, dx11, dx12]$
dv1 : [dv10, dv11, dv12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
PB_vol(f,g,x,y) := diff(f,x)*diff(g,y) - diff(g,x)*diff(f,y)$

/* Hamiltonian volume contribution, either just streaming, 
   grad_x(w) . grad_v(H) f, if Hamiltonian only depends on velocity space, or, 
   grad_x(w) . grad_v(H) f - grad_v(w) . grad_x(H) f 
   If using mapped velocity grids, we divide out J_vi in the direction of the update, e.g., 
   grad_x(w) . (grad_v(H)/Jv_i) Jf, where the division by J_vi in direction i is done
   nodally and then the resulting expansion is projected back onto modes. */
calcHamilVol(fh, funcNm, cdim, vdim, basisFun, polyOrder, hamil_vel, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NP,
   bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi,
   cid,vid,pb_dim,hamil,f_e,
   fl_v,jacob_vi,basisNodal,fl_v_ne,f_no_J_c,clst_J,f_vol_e,
   pb,pbBasis,clst_vol,varsPFull],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NP : length(bP), 
  [bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi] = loadVelJacobianBasis(polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *jacob_vel, const double *poisson_tensor_conf, const double *hamil, 
  const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  if (vmap) then printf(fh, "  double f_no_J[~a] = {0.0}; ~%", NP),
  if (hamil_vel) then (
    hamil : doExpand1(hamil, bV)
  )
  else (
    hamil : doExpand1(hamil, bP)    
  ),
  f_e : doExpand1(f, bP),
  
  cid : cidx(cdim),
  vid : vidx(cdim,vdim),  
  pb_dim : min(cdim,vdim), 
  for dir : 1 thru pb_dim do (
    printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]), 
    printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
    if (vmap) then (
      printf(fh, "  const double *jacob_v~a = &jacob_vel[~a]; ~%", clabels[dir], NV_1D*(dir-1)), 
      fl_v : evAtNodes(f_e,jacobNodes,[varsV[dir]]), 
      jacob_vi : jacobNodes_vi[dir], 
      basisNodal : basisNodal_vi[dir], 
      fl_v_ne : 0, 
      for i : 1 thru numJacobNodes do (
        fl_v_ne : fl_v_ne + fl_v[i]/jacob_vi[i]*basisNodal[i]
      ), 
      f_no_J_c : calcInnerProdList(varsP, 1, bP, fl_v_ne), 
      clst_J : [jacob_vx[0], jacob_vx[1], jacob_vx[2], jacob_vx[3], jacob_vy[0], jacob_vy[1], jacob_vy[2], jacob_vy[3], jacob_vz[0], jacob_vz[1], jacob_vz[2], jacob_vz[3]],
      writeCExprsCollect1(f_no_J, f_no_J_c, clst_J),
      f_vol_e : doExpand1(f_no_J, bP), 
      printf(fh, "~%") 
    ) 
    else (
      f_vol_e : f_e
    ), 
    /* For cdim /= vdim, we assume the ignorable coordinates are the last pairs.
       For instance if we have varsC = [x,y,z] with:
       - 1 ignorable coordinate: [x, y, \dot{x}, \dot{y}] are all that show up in {f,H} 
       - 2 ignorable coordinates: [x, \dot{x},] are all that show up in {f,H} 
       It is assumed that H does not depend on these ignorable coordinates. */
    pbBasis : dx1[dir]*dv1[dir]*(PB_vol(bP,hamil,varsC[dir],varsV[dir])), 
    pb : fullratsimp(calcInnerProdList(varsP, 1, pbBasis, f_vol_e)), 
    clst_vol : [dx10, dx11, dx12, dv10, dv11, dv12],
    writeCIncrExprsCollect1(out, pb, clst_vol), 
    printf(fh, "~%") 
  ),

  printf(fh, "} ~%")
)$  

/* Scalar potential contribution -grad_v(w) . grad_x(phi) f. */
calcPhiVol(fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NP,
   bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi,
   cid,vid,pb_dim,phi_e,f_e,
   fl_v,jacob_vi,basisNodal,fl_v_ne,f_no_J_c,clst_J,f_vol_e,
   pb,pbBasis,clst_vol],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 
  NP : length(bP), 
  [bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi] = loadVelJacobianBasis(polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *jacob_vel, const double *phi, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  if (vmap) then printf(fh, "  double f_no_J[~a] = {0.0}; ~%", NP),
  phi_e : doExpand1(phi, bC), 
  f_e : doExpand1(f, bP),
  
  cid : cidx(cdim),
  vid : vidx(cdim,vdim),  
  pb_dim : min(cdim,vdim), 
  for dir : 1 thru pb_dim do (
    printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]), 
    printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
    if (vmap) then (
      printf(fh, "  const double *jacob_v~a = &jacob_vel[~a]; ~%", clabels[dir], NV_1D*(dir-1)), 
      fl_v : evAtNodes(f_e,jacobNodes,[varsV[dir]]), 
      jacob_vi : jacobNodes_vi[dir], 
      basisNodal : basisNodal_vi[dir], 
      fl_v_ne : 0, 
      for i : 1 thru numJacobNodes do (
        fl_v_ne : fl_v_ne + fl_v[i]/jacob_vi[i]*basisNodal[i]
      ), 
      f_no_J_c : calcInnerProdList(varsP, 1, bP, fl_v_ne), 
      clst_J : [jacob_vx[0], jacob_vx[1], jacob_vx[2], jacob_vx[3], jacob_vy[0], jacob_vy[1], jacob_vy[2], jacob_vy[3], jacob_vz[0], jacob_vz[1], jacob_vz[2], jacob_vz[3]],
      writeCExprsCollect1(f_no_J, f_no_J_c, clst_J),
      f_vol_e : doExpand1(f_no_J, bP) 
    ) 
    else (
      f_vol_e : f_e
    ), 
    incr_vol : calcInnerProdList(varsP, 1, diff(bP, varsV[dir]), -diff(phi_e,varsC[dir])*f_vol_e),
    clst_vol : [phi[0], phi[1], phi[2], phi[3], phi[4], phi[5], phi[6], phi[7], phi[8]],
    writeCIncrExprsCollectFactordx1(out, incr_vol, clst_vol, dx1[dir]*dv1[dir]), 
    printf(fh, "~%") 
  ),

  printf(fh, "} ~%")
)$ 

/* Bulk force contribution, i.e., sum of all forces that do not depend 
   on velocity space (combination of electric field, and other external 
   contributions such as applied accelerations) grad_v(w) . (q/m*E + F_ext) f. */
calcEVol(fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NP,
   bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi,
   cid,vid,pb_dim,phi_e,f_e,
   fl_v,jacob_vi,basisNodal,fl_v_ne,f_no_J_c,clst_J,f_vol_e,
   pb,pbBasis,clst_vol],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 
  NP : length(bP), 
  [bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi] = loadVelJacobianBasis(polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *jacob_vel, const double *qmem, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  if (vmap) then printf(fh, "  double f_no_J[~a] = {0.0}; ~%", NP),
  Ex_e : doExpand1(Ex, bC), 
  Ey_e : doExpand1(Ey, bC), 
  Ez_e : doExpand1(Ez, bC), 
  E_e : [Ex_e, Ey_e, Ez_e],  
  f_e : doExpand1(f, bP),
  
  vid : vidx(cdim,vdim),   
  for dir : 1 thru vdim do (
    printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
    printf(fh, "  const double *E~a = &qmem[~a]; ~%", clabels[dir], NC*(dir-1)),
    if (vmap) then (
      printf(fh, "  const double *jacob_v~a = &jacob_vel[~a]; ~%", clabels[dir], NV_1D*(dir-1)), 
      fl_v : evAtNodes(f_e,jacobNodes,[varsV[dir]]), 
      jacob_vi : jacobNodes_vi[dir], 
      basisNodal : basisNodal_vi[dir], 
      fl_v_ne : 0, 
      for i : 1 thru numJacobNodes do (
        fl_v_ne : fl_v_ne + fl_v[i]/jacob_vi[i]*basisNodal[i]
      ), 
      f_no_J_c : calcInnerProdList(varsP, 1, bP, fl_v_ne), 
      clst_J : [jacob_vx[0], jacob_vx[1], jacob_vx[2], jacob_vx[3], jacob_vy[0], jacob_vy[1], jacob_vy[2], jacob_vy[3], jacob_vz[0], jacob_vz[1], jacob_vz[2], jacob_vz[3]],
      writeCExprsCollect1(f_no_J, f_no_J_c, clst_J),
      f_vol_e : doExpand1(f_no_J, bP), 
      printf(fh, "~%") 
    ) 
    else (
      f_vol_e : f_e
    ), 
    /* Accumulate contribution from electric field/other external bulk forces. */
    incr_vol : calcInnerProdList(varsP, 1, diff(bP, varsV[dir]), E_e[dir]*f_vol_e),
    if (dir = 1) then (
      clst_vol : [Ex[0], Ex[1], Ex[2], Ex[3], Ex[4], Ex[5], Ex[6], Ex[7], Ex[8]]
    )
    else if (dir = 2) then (
      clst_vol : [Ey[0], Ey[1], Ey[2], Ey[3], Ey[4], Ey[5], Ey[6], Ey[7], Ey[8]]
    )
    else (
      clst_vol : [Ez[0], Ez[1], Ez[2], Ez[3], Ez[4], Ez[5], Ez[6], Ez[7], Ez[8]]
    ),
    writeCIncrExprsCollectFactordx1(out, incr_vol, clst_vol, dv1[dir]), 
    printf(fh, "~%") 
  ),
  printf(fh, "} ~%")
)$  

/* Force arising due to a magnetic field grad_v(w) . (grad_v(H) x q/m*B) f 
   We separate the kernels based on the magnetic field direction to nicely group 
   the terms for factorizing the final product. */
calcBVol(fh, funcNm, cdim, vdim, basisFun, polyOrder, hamil_vel, Bdir, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NC,NV,NP,
   bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi,
   hamil,f_e,vid,
   Ex_e,Ey_e,Ez_e,Bx_e,By_e,Bz_e,ax,ay,az,accel,
   fl_v,jacob_vi,basisNodal,fl_v_ne,f_no_J_c,clst_J,f_vol_e,
   alpha_vdim_c,exprs,alpha_vdim_NoZero,alpha_vdim_NoZero_e,incr_vdim],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 
  NV : length(bV), 
  NP : length(bP), 
  [bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi] = loadVelJacobianBasis(polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *jacob_vel, const double *poisson_tensor_conf, const double *hamil,
  const double *qmem, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  if (hamil_vel) then (
    hamil : doExpand1(hamil, bV)
  )
  else (
    hamil : doExpand1(hamil, bP)    
  ),
  f_e : doExpand1(f, bP),
  
  vid : vidx(cdim,vdim), 
  Bx_e : doExpand1(Bx, bC), 
  By_e : doExpand1(By, bC), 
  Bz_e : doExpand1(Bz, bC), 
  if (vdim = 2 and Bdir = 3) then (
    /* If vdim = 2, only need Bz. */
    printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
    printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
    printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
    ax : diff(hamil, varsV[2])*Bz_e,
    ay : -diff(hamil, varsV[1])*Bz_e, 
    
    clst_vol : [Bz[0], Bz[1], Bz[2], Bz[3], Bz[4], Bz[5], Bz[6], Bz[7], Bz[8]],
    incr_vx : calcInnerProdList(varsP, 1, diff(bP, varsV[1]), ax*f_e), 
    incr_vy : calcInnerProdList(varsP, 1, diff(bP, varsV[2]), ay*f_e), 
    writeCIncrExprsCollectFactordxSplit1(out, incr_vx + incr_vy, clst_vol, dv1[1]*dv1[2]), 
    printf(fh, "~%")
  )
  else if (vdim = 3) then (
    if (vmap) then (
      printf(fh, "  double f_Jvi[~a] = {0.0}; ~%", NP),
      f_vol_e : doExpand1(f_Jvi, bP),   
      
      if (Bdir = 1) then (
        /* Common update with Bx factor */
        printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
        printf(fh, "  double dv12 = 2.0/dxv[~a]; ~%", vid[3]),
        printf(fh, "  const double *Bx = &qmem[~a]; ~%", NC*3),
        printf(fh, "  const double *jacob_vx = &jacob_vel[~a]; ~%", NV_1D*0),
        ay_1 : diff(hamil, varsV[3])*Bx_e, 
        az_2 : -diff(hamil, varsV[2])*Bx_e, 
        fl_vx : evAtNodes(f_e,jacobNodes,[varsV[1]]), 
        fl_vx_ne : 0, 
        for i : 1 thru numJacobNodes do (
          fl_vx_ne : fl_vx_ne + fl_vx[i]*jacobNodes_vi[1][i]*basisNodal_vi[1][i]
        ), 
        f_Jvx_c : calcInnerProdList(varsP, 1, bP, fl_vx_ne), 
        clst_J : [jacob_vx[0], jacob_vx[1], jacob_vx[2]],
        writeCExprsCollect1(f_Jvi, f_Jvx_c, clst_J),   
        clst_Bx_vol : [Bx[0], Bx[1], Bx[2], Bx[3], Bx[4], Bx[5], Bx[6], Bx[7], Bx[8]],
        incr_Bx_1 : calcInnerProdList(varsP, 1, diff(bP, varsV[2]), ay_1*f_vol_e), 
        incr_Bx_2 : calcInnerProdList(varsP, 1, diff(bP, varsV[3]), az_2*f_vol_e),
        writeCIncrExprsCollectFactordxSplit1(out, incr_Bx_1 + incr_Bx_2, clst_Bx_vol, dv1[2]*dv1[3]), 
        printf(fh, "~%")
      )
      else if (Bdir = 2) then (
        /* Common update with By factor */
        printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
        printf(fh, "  double dv12 = 2.0/dxv[~a]; ~%", vid[3]),
        printf(fh, "  const double *By = &qmem[~a]; ~%", NC*4),
        printf(fh, "  const double *jacob_vy = &jacob_vel[~a]; ~%", NV_1D*1),
        az_1 : diff(hamil, varsV[1])*By_e, 
        ax_2 : -diff(hamil, varsV[3])*By_e,
        fl_vy : evAtNodes(f_e,jacobNodes,[varsV[2]]), 
        fl_vy_ne : 0, 
        for i : 1 thru numJacobNodes do (
          fl_vy_ne : fl_vy_ne + fl_vy[i]*jacobNodes_vi[2][i]*basisNodal_vi[2][i]
        ), 
        f_Jvy_c : calcInnerProdList(varsP, 1, bP, fl_vy_ne), 
        clst_J : [jacob_vy[0], jacob_vy[1], jacob_vy[2]],
        writeCExprsCollect1(f_Jvi, f_Jvy_c, clst_J),   
        clst_By_vol : [By[0], By[1], By[2], By[3], By[4], By[5], By[6], By[7], By[8]],
        incr_By_1 : calcInnerProdList(varsP, 1, diff(bP, varsV[3]), az_1*f_vol_e), 
        incr_By_2 : calcInnerProdList(varsP, 1, diff(bP, varsV[1]), ax_2*f_vol_e),
        writeCIncrExprsCollectFactordxSplit1(out, incr_By_1 + incr_By_2, clst_By_vol, dv1[1]*dv1[3]), 
        printf(fh, "~%")
      )
      else (
        /* Common update with Bz factor */
        printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
        printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
        printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
        printf(fh, "  const double *jacob_vz = &jacob_vel[~a]; ~%", NV_1D*2),
        ax_1 : diff(hamil, varsV[2])*Bz_e, 
        ay_2 : -diff(hamil, varsV[1])*Bz_e,
        fl_vz : evAtNodes(f_e,jacobNodes,[varsV[3]]), 
        fl_vz_ne : 0, 
        for i : 1 thru numJacobNodes do (
          fl_vz_ne : fl_vz_ne + fl_vz[i]*jacobNodes_vi[3][i]*basisNodal_vi[3][i]
        ), 
        f_Jvz_c : calcInnerProdList(varsP, 1, bP, fl_vz_ne), 
        clst_J : [jacob_vz[0], jacob_vz[1], jacob_vz[2]],
        writeCExprsCollect1(f_Jvi, f_Jvz_c, clst_J),   
        clst_Bz_vol : [Bz[0], Bz[1], Bz[2], Bz[3], Bz[4], Bz[5], Bz[6], Bz[7], Bz[8]],
        incr_Bz_1 : calcInnerProdList(varsP, 1, diff(bP, varsV[1]), ax_1*f_vol_e), 
        incr_Bz_2 : calcInnerProdList(varsP, 1, diff(bP, varsV[2]), ay_2*f_vol_e),
        writeCIncrExprsCollectFactordxSplit1(out, incr_Bz_1 + incr_Bz_2, clst_Bz_vol, dv1[1]*dv1[2]), 
        printf(fh, "~%")
      )
    )
    else (
      if (Bdir = 1) then (
        /* Common update with Bx factor */
        printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
        printf(fh, "  double dv12 = 2.0/dxv[~a]; ~%", vid[3]),
        printf(fh, "  const double *Bx = &qmem[~a]; ~%", NC*3),
        ay_1 : diff(hamil, varsV[3])*Bx_e, 
        az_2 : -diff(hamil, varsV[2])*Bx_e, 
        clst_Bx_vol : [Bx[0], Bx[1], Bx[2], Bx[3], Bx[4], Bx[5], Bx[6], Bx[7]],
        incr_Bx_1 : calcInnerProdList(varsP, 1, diff(bP, varsV[2]), ay_1*f_e), 
        incr_Bx_2 : calcInnerProdList(varsP, 1, diff(bP, varsV[3]), az_2*f_e),
        writeCIncrExprsCollectFactordxSplit1(out, incr_Bx_1 + incr_Bx_2, clst_Bx_vol, dv1[2]*dv1[3]), 
        printf(fh, "~%")
      )
      else if (Bdir = 2) then (
        /* Common update with By factor */
        printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
        printf(fh, "  double dv12 = 2.0/dxv[~a]; ~%", vid[3]),
        printf(fh, "  const double *By = &qmem[~a]; ~%", NC*4),
        az_1 : diff(hamil, varsV[1])*By_e, 
        ax_2 : -diff(hamil, varsV[3])*By_e,
        clst_By_vol : [By[0], By[1], By[2], By[3], By[4], By[5], By[6], By[7]],
        incr_By_1 : calcInnerProdList(varsP, 1, diff(bP, varsV[3]), az_1*f_e), 
        incr_By_2 : calcInnerProdList(varsP, 1, diff(bP, varsV[1]), ax_2*f_e),
        writeCIncrExprsCollectFactordxSplit1(out, incr_By_1 + incr_By_2, clst_By_vol, dv1[1]*dv1[3]), 
        printf(fh, "~%")
      )
      else (
        /* Common update with Bz factor */
        printf(fh, "  double dv10 = 2.0/dxv[~a]; ~%", vid[1]),
        printf(fh, "  double dv11 = 2.0/dxv[~a]; ~%", vid[2]),
        printf(fh, "  const double *Bz = &qmem[~a]; ~%", NC*5),
        ax_1 : diff(hamil, varsV[2])*Bz_e, 
        ay_2 : -diff(hamil, varsV[1])*Bz_e, 
        clst_Bz_vol : [Bz[0], Bz[1], Bz[2], Bz[3], Bz[4], Bz[5], Bz[6], Bz[7]],
        incr_Bz_1 : calcInnerProdList(varsP, 1, diff(bP, varsV[1]), ax_1*f_e), 
        incr_Bz_2 : calcInnerProdList(varsP, 1, diff(bP, varsV[2]), ay_2*f_e),
        writeCIncrExprsCollectFactordxSplit1(out, incr_Bz_1 + incr_Bz_2, clst_Bz_vol, dv1[1]*dv1[2]), 
        printf(fh, "~%") 
      ) 
    )
  ), 

  printf(fh, "} ~%")
)$  

/* Radiation drag force grad_v(w) . F_rad(v) f where F_rad(v) is only a function of velocity space. */
calcRadVelVol(fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NV,NP,
   bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi,
   rad_vx_e,rad_vy_e,rad_vz_e,rad_v_e,f_e,vid,
   fl_v,jacob_vi,basisNodal,fl_v_ne,f_no_J_c,clst_J,f_vol_e,
   incr_vol,clst_vol],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NV : length(bV), 
  NP : length(bP), 
  [bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi] = loadVelJacobianBasis(polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *jacob_vel, const double *rad, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  if (vmap) then printf(fh, "  double f_no_J[~a] = {0.0}; ~%", NP),
  rad_vx_e : doExpand1(rad_vx, bV), 
  rad_vy_e : doExpand1(rad_vy, bV), 
  rad_vz_e : doExpand1(rad_vz, bV),
  rad_v_e : [rad_vx_e, rad_vy_e, rad_vz_e], 
  f_e : doExpand1(f, bP),
  
  vid : vidx(cdim,vdim),  
  for dir : 1 thru vdim do (
    printf(fh, "  double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
    printf(fh, "  const double *rad_v~a = &rad[~a]; ~%", clabels[dir], NV*(dir-1)),
    if (vmap) then (
      printf(fh, "  const double *jacob_v~a = &jacob_vel[~a]; ~%", clabels[dir], NV_1D*(dir-1)), 
      fl_v : evAtNodes(f_e,jacobNodes,[varsV[dir]]), 
      jacob_vi : jacobNodes_vi[dir], 
      basisNodal : basisNodal_vi[dir], 
      fl_v_ne : 0, 
      for i : 1 thru numJacobNodes do (
        fl_v_ne : fl_v_ne + fl_v[i]/jacob_vi[i]*basisNodal[i]
      ), 
      f_no_J_c : calcInnerProdList(varsP, 1, bP, fl_v_ne), 
      clst_J : [jacob_vx[0], jacob_vx[1], jacob_vx[2], jacob_vx[3], jacob_vy[0], jacob_vy[1], jacob_vy[2], jacob_vy[3], jacob_vz[0], jacob_vz[1], jacob_vz[2], jacob_vz[3]],
      writeCExprsCollect1(f_no_J, f_no_J_c, clst_J),
      f_vol_e : doExpand1(f_no_J, bP) 
    ) 
    else (
      f_vol_e : f_e
    ), 
    incr_vol : calcInnerProdList(varsP, 1, diff(bP, varsV[dir]), rad_v_e[dir]*f_vol_e),  
    clst_vol : [dv10, dv11, dv12],
    writeCIncrExprsCollect1(out, dv1[dir]*incr_vol, clst_vol), 
    printf(fh, "~%") 
  ),

  printf(fh, "} ~%")
)$  