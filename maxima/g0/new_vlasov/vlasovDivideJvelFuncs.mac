/* Function which divides out the velocity space Jacobian at velocity quadrature points
   and converts the resulting nodal expansion back to a modal representations. 
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

divideJvel(fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NP,
   nodes_vel,num_nodes_vel,basisNodal_vel,
   Jf_e,Jf_n,Jf_ne,f_c],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NP : length(bP), 
  nodes_conf : gaussOrd(polyOrder+1, cdim), 
  num_nodes_conf : length(nodes_conf), 
  basisNodal_conf  : getVarsNodalBasisWithNodes("Tensor", cdim, polyOrder, varsC, nodes_conf),

  nodes_vel : gaussOrd(polyOrder+1, vdim), 
  num_nodes_vel : length(nodes_vel), 
  basisNodal_vel  : getVarsNodalBasisWithNodes("Tensor", vdim, polyOrder, varsV, nodes_vel),

  nodes_phase : gaussOrd(polyOrder+1, cdim+vdim), 
  num_nodes_phase : length(nodes_phase), 
  basisNodal_phase  : getVarsNodalBasisWithNodes("Tensor", cdim+vdim, polyOrder, varsP, nodes_phase),

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *jacob_vel_gauss, const double *Jf, double* GKYL_RESTRICT f_no_J) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  Jf_e : doExpand1(Jf, bP), 
  if (vmap) then (
    printf(fh, "  double f_no_J_nodal[~a] = {0.0};~%", NP),
    printf(fh, "~%"), 
    Jf_n : evAtNodes(Jf_e, nodes_phase, varsP), 
    for i : 1 thru num_nodes_conf do (
      for j : 1 thru num_nodes_vel do (
        printf(fh, "  f_no_J_nodal[~a] = 1.0/jacob_vel_gauss[~a]*(~a);~%", j-1 + num_nodes_vel*(i-1), j-1, float(expand(Jf_n[j + num_nodes_vel*(i-1)])))
      )
    ),
    printf(fh, "~%"),
    Jf_ne : doExpand1(f_no_J_nodal, basisNodal_phase)
  )
  else (
    /* If we're not using nonuniform meshes, updater does a simple copy. */
    Jf_ne : Jf_e
  ),
  f_c : calcInnerProdList(varsP, 1, bP, Jf_ne), 
  writeCExprs1(f_no_J, f_c), 

  printf(fh, "} ~%")
)$  

rescaleJvel(fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NP,
   nodes_vel,num_nodes_vel,basisNodal_vel,
   f_no_J_e,f_no_J_n,Jf_ne,f_c],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NP : length(bP), 
  nodes_conf : gaussOrd(polyOrder+1, cdim), 
  num_nodes_conf : length(nodes_conf), 
  basisNodal_conf  : getVarsNodalBasisWithNodes("Tensor", cdim, polyOrder, varsC, nodes_conf),

  nodes_vel : gaussOrd(polyOrder+1, vdim), 
  num_nodes_vel : length(nodes_vel), 
  basisNodal_vel  : getVarsNodalBasisWithNodes("Tensor", vdim, polyOrder, varsV, nodes_vel),

  nodes_phase : gaussOrd(polyOrder+1, cdim+vdim), 
  num_nodes_phase : length(nodes_phase), 
  basisNodal_phase  : getVarsNodalBasisWithNodes("Tensor", cdim+vdim, polyOrder, varsP, nodes_phase),

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *jacob_vel_gauss, const double *f_no_J, double* GKYL_RESTRICT Jf) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  f_no_J_e : doExpand1(f_no_J, bP), 
  if (vmap) then (
    printf(fh, "  double Jf_nodal[~a] = {0.0};~%", NP),
    printf(fh, "~%"), 
    f_no_J_n : evAtNodes(f_no_J_e, nodes_phase, varsP), 
    for i : 1 thru num_nodes_conf do (
      for j : 1 thru num_nodes_vel do (
        printf(fh, "  Jf_nodal[~a] = jacob_vel_gauss[~a]*(~a);~%", j-1 + num_nodes_vel*(i-1), j-1, float(expand(f_no_J_n[j + num_nodes_vel*(i-1)])))
      )
    ),
    printf(fh, "~%"),
    Jf_ne : doExpand1(Jf_nodal, basisNodal_phase)
  )
  else (
    /* If we're not using nonuniform meshes, updater does a simple copy. */
    Jf_ne : f_no_J_e
  ),
  f_c : calcInnerProdList(varsP, 1, bP, Jf_ne), 
  writeCExprs1(Jf, f_c), 

  printf(fh, "} ~%")
)$  