/*  Generate kernels for constructing the cubic velocity mapping and
    corresponding quadratic representation of the Jacobian. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
fpprec : 24$

calcVmap(fh, funcNm, vdim, polyOrder) := block(
  [bV_p3, varsV_p3, NV_p3, bV_p2, varsV_p2, NV_p2],

  kill(varsV_p2, bV_p2, varsV_p3, bV_p3),

  /* Load cubic mapping for momentum-space coordinate 
     Only 1D because we have 3 1D mappings. But we need
     3 of them to obtain the correct variation in up to 3V. */
  [varsV_p3,bV_p3] : loadBasis("Tensor", 1, 3),
  NV_p3 : length(bV_p3),

  /* Quadratic mapping for the Jacobian (derivative of the cubic mapping) */
  [varsV_p2,bV_p2] : loadBasis("Tensor", 1, 2),
  NV_p2 : length(bV_p2),

  /* Specific bases for computing Jacobian */
  bV_vx_p3 : subst(x=x, copylist(bV_p3)), 
  bV_vy_p3 : subst(x=y, copylist(bV_p3)), 
  bV_vz_p3 : subst(x=z, copylist(bV_p3)), 
  bV_vx_p2 : subst(x=x, copylist(bV_p2)), 
  bV_vy_p2 : subst(x=y, copylist(bV_p2)), 
  bV_vz_p2 : subst(x=z, copylist(bV_p2)), 
  [varsV_vdim_p3,bV_vdim_p3] : loadBasis("Ser", vdim, 3),
  NV_vdim_p3 : length(bV_vdim_p3), 

  /* Function declaration with input/output variables. */
  printf(fh, "static void ~a(const double *dv, const double *v_cubic_dir[GKYL_MAX_VDIM], 
    double* GKYL_RESTRICT vmap, double* GKYL_RESTRICT jacob_vel, double* GKYL_RESTRICT jacob_vel_surf,  
    double* GKYL_RESTRICT vmap_pgkyl, double* GKYL_RESTRICT vmap_avg_pgkyl, double* GKYL_RESTRICT jacob_vel_gauss) ~%{ ~%", funcNm),
  printf(fh, "  // v_cubic_dir: Cubic C^1 representation of the velocity mapping.~%"),
  printf(fh, "  // vmap: Velocity-space nonuniform mapping in each dimension.~%"),
  printf(fh, "  // jacob_vel: Velocity-space Jacobian in each dimension at 1V Gauss-Legendre quadrature points.~%"),
  printf(fh, "  // jacob_vel_surf: Velocity-space Jacobian evaluated at number of quadrature points needed for surface updates.~%"),
  printf(fh, "  // vmap_pgkyl: Velocity-space nonuniform mapping for I/O (defined in full 1V, 2V, or 3V).~%"),
  printf(fh, "  // vmap_avg_pgkyl: Cell average of velocity-space nonuniform mapping for I/O (defined in full 1V, 2V, or 3V).~%"),
  printf(fh, "  // jacob_vel_gauss: Velocity space Jacobian at Gauss-Legendre quadrature points.~%"),
  printf(fh, " ~%"),  

  printf(fh, "  double dv_tot = 1.0; ~%"),
  for dir : 1 thru vdim do (
    printf(fh, "  const double dv~a = 2.0/dv[~a]; ~%", dir-1, dir-1),
    printf(fh, "  dv_tot *= 2.0/dv[~a]; ~%", dir-1, dir-1),
    printf(fh, "  const double *v_cubic_dir~a = &v_cubic_dir[~a][0]; ~%", dir-1, dir-1),
    printf(fh, "  double *p~a = &vmap[~a]; ~%", dir-1, NV_p3*(dir-1)),
    printf(fh, "  double *vmap_pgkyl~a = &vmap_pgkyl[~a]; ~%", dir-1, NV_vdim_p3*(dir-1)),
    printf(fh, "  double *jacob_vel~a = &jacob_vel[~a]; ~%", dir-1, NV_p2*(dir-1)), 
    printf(fh, "  double *jacob_vel~a_surf = &jacob_vel_surf[~a]; ~%", dir-1, 4*(dir-1))
  ),

  px_e : doExpand1(p0, bV_p3), 
  py_e : doExpand1(p1, bV_p3), 
  pz_e : doExpand1(p2, bV_p3), 

  /* Evaluate the derivative at (polyOrder + 1) nodes for use in update to perform
     operations like Jf/J at Gauss-Legendre quadrature points (equivalence between the
     polyOrder + 1 Gauss-Legendre nodal basis and our modal basis). */
  nodes_gauss_1v : gaussOrd(polyOrder+1, 1),
  num_nodes_gauss_1v : length(nodes_gauss_1v), 
  jacob_velx_nodes : expand(float(evAtNodes(diff(px_e,x),nodes_gauss_1v,varsV_p3))),  
  jacob_vely_nodes : expand(float(evAtNodes(diff(py_e,x),nodes_gauss_1v,varsV_p3))),  
  jacob_velz_nodes : expand(float(evAtNodes(diff(pz_e,x),nodes_gauss_1v,varsV_p3))),  
  jacob_vel_nodes : [jacob_velx_nodes, jacob_vely_nodes, jacob_velz_nodes], 

  /* Evaluate derivative at larger number of nodes for use in surface terms (polyOrder + 2). */
  nodes_gauss_surf : gaussOrd(polyOrder+2, 1),
  num_nodes_gauss_surf : length(nodes_gauss_surf), 
  jacob_velx_surf_nodes : expand(float(evAtNodes(diff(px_e,x),nodes_gauss_surf,varsV_p3))),  
  jacob_vely_surf_nodes : expand(float(evAtNodes(diff(py_e,x),nodes_gauss_surf,varsV_p3))),  
  jacob_velz_surf_nodes : expand(float(evAtNodes(diff(pz_e,x),nodes_gauss_surf,varsV_p3))),  
  jacob_vel_surf_nodes : [jacob_velx_surf_nodes, jacob_vely_surf_nodes, jacob_velz_surf_nodes],   

  for i : 1 thru vdim do (
    printf(fh, "  p~a[0] = v_cubic_dir~a[0];~%", i-1, i-1), 
    printf(fh, "  p~a[1] = v_cubic_dir~a[1];~%", i-1, i-1),
    printf(fh, "  p~a[2] = v_cubic_dir~a[2];~%", i-1, i-1),
    printf(fh, "  p~a[3] = v_cubic_dir~a[3];~%", i-1, i-1), 
    printf(fh, "~%"),

    jacob_vel_nodes_dir : jacob_vel_nodes[i], 
    for j : 1 thru num_nodes_gauss_1v do (
      printf(fh, "  jacob_vel~a[~a] = dv~a*(~a);~%", i-1, j-1, i-1, jacob_vel_nodes_dir[j])
    ), 
    printf(fh, "~%"),

    jacob_vel_surf_nodes_dir : jacob_vel_surf_nodes[i], 
    for j : 1 thru num_nodes_gauss_surf do (
      printf(fh, "  jacob_vel~a_surf[~a] = dv~a*(~a);~%", i-1, j-1, i-1, jacob_vel_surf_nodes_dir[j])
    ),     
    printf(fh, "~%")
  ), 

  /* Expand vmap and Jacobian in high dimensional basis for I/O
     along with full Jacobian at Gauss-Legendre quadrature nodes */
  nodes_gauss : gaussOrd(polyOrder+1, vdim),
  num_nodes_gauss : length(nodes_gauss), 
  px_gauss_e : doExpand1(p0, bV_vx_p3), 
  py_gauss_e : doExpand1(p1, bV_vy_p3), 
  pz_gauss_e : doExpand1(p2, bV_vz_p3), 
  /* Evaluate the derivative at nodes */
  if (vdim = 1) then (
    vmap_vx_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, px_gauss_e),  
    writeCExprs1(vmap_pgkyl0, vmap_vx_c), 
    printf(fh, "~%"), 
    printf(fh, "  vmap_avg_pgkyl[0] = vmap_pgkyl0[0]/~a;~%", float(2.0^(0.5*vdim))),
    printf(fh, "~%"), 
    jacob_vel_gauss_nodes : evAtNodes(diff(px_gauss_e,x), nodes_gauss, varsV_vdim_p3)
  )
  else if (vdim = 2) then(
    vmap_vx_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, px_gauss_e), 
    vmap_vy_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, py_gauss_e), 
    writeCExprs1(vmap_pgkyl0, vmap_vx_c), 
    writeCExprs1(vmap_pgkyl1, vmap_vy_c), 
    printf(fh, "~%"),   
    printf(fh, "  vmap_avg_pgkyl[0] = vmap_pgkyl0[0]/~a;~%", float(2.0^(0.5*vdim))),
    printf(fh, "  vmap_avg_pgkyl[1] = vmap_pgkyl1[0]/~a;~%", float(2.0^(0.5*vdim))),
    printf(fh, "~%"),  
    jacob_vel_gauss_nodes : evAtNodes(diff(px_gauss_e,x)*diff(py_gauss_e,y), nodes_gauss, varsV_vdim_p3)
  )
  else (
    vmap_vx_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, px_gauss_e), 
    vmap_vy_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, py_gauss_e), 
    vmap_vz_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, pz_gauss_e), 
    writeCExprs1(vmap_pgkyl0, vmap_vx_c), 
    writeCExprs1(vmap_pgkyl1, vmap_vy_c), 
    writeCExprs1(vmap_pgkyl2, vmap_vz_c), 
    printf(fh, "~%"),  
    printf(fh, "  vmap_avg_pgkyl[0] = vmap_pgkyl0[0]/~a;~%", float(2.0^(0.5*vdim))),
    printf(fh, "  vmap_avg_pgkyl[1] = vmap_pgkyl1[0]/~a;~%", float(2.0^(0.5*vdim))),
    printf(fh, "  vmap_avg_pgkyl[2] = vmap_pgkyl2[0]/~a;~%", float(2.0^(0.5*vdim))),
    printf(fh, "~%"), 
    jacob_vel_gauss_nodes : evAtNodes(diff(px_gauss_e,x)*diff(py_gauss_e,y)*diff(pz_gauss_e,z), nodes_gauss, varsV_vdim_p3)
  ),
  for i : 1 thru num_nodes_gauss do (
    printf(fh, "  jacob_vel_gauss[~a] = dv_tot*(~a);~%", i-1, float(expand(jacob_vel_gauss_nodes[i])))
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$  

