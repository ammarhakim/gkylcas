/* This script generates the kernels for the surface term of Euler's equations */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx10, dx11, dx12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$

statevec : [rho, rhou0, rhou1, rhou2, energy]$
lhs : [outrho, outrhou0, outrhou1, outrhou2, outenergy]$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

/* 1D Euler special since only involves evaluations */
calcEuler1xUpdateInDir(dir, fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC,NC,cid,cv,surfVars,
  ul_0_e,uc_0_e,ur_0_e,
  ul_1_e,uc_1_e,ur_1_e,
  ul_2_e,uc_2_e,ur_2_e,
  pl_e,pc_e,pr_e,
  rhol_e,rhouxl_e,rhouyl_e,rhouzl_e,energyl_e,
  rhoc_e,rhouxc_e,rhouyc_e,rhouzc_e,energyc_e,
  rhor_e,rhouxr_e,rhouyr_e,rhouzr_e,energyr_e,
  rhol_r,rhouxl_r,rhouyl_r,rhouzl_r,energyl_r,ul_0_r,ul_1_r,ul_2_r,pl_r,
  rhoc_l,rhouxc_l,rhouyc_l,rhouzc_l,energyc_l,uc_0_l,uc_1_l,uc_2_l,pc_l,
  rhoc_r,rhouxc_r,rhouyc_r,rhouzc_r,energyc_r,uc_0_r,uc_1_r,uc_2_r,pc_r,
  rhor_l,rhouxr_l,rhouyr_l,rhouzr_l,energyr_l,ur_0_l,ur_1_l,ur_2_l,pr_l,
  avg_rho_l,avg_rho_r,jump_rho_l,jump_rho_r,Ghat_rho_l_exp,Ghat_rho_r_exp,Ghat_energy_l_exp,Ghat_energy_r_exp,
  avg_u_0_l,avg_u_0_r,avg_u_1_l,avg_u_1_r,avg_u_2_l,avg_u_2_r,avg_p_l,avg_p_r,
  incr_rho_l,incr_rho_r,incr_rhoux_l,incr_rhoux_r,incr_rhouy_l,incr_rhouy_r,incr_rhouz_l,incr_rhouz_r,incr_energy_l,incr_energy_r],

  kill(varsC, basisC),

  load(sconcat("basis-precalc/basis", basisFun, cdim, "x")),

  bC : basisC[polyOrder],
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax_~a_p~a(const double *w, const double *dxv, const double gas_gamma, const double *ul, const double *uc, const double *ur, const double *pl, const double *pc, const double *pr, const double *statevecl, const double *statevecc, const double *statevecr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // gas_gamma: Adiabatic index.~%"),
  printf(fh, "  // ul/uc/ur: [ux, uy, uz] Fluid flow in left/center/right cells.~%"),
  printf(fh, "  // pl/pc/pr: Fluid pressure in left/center/right cells.~%"),
  printf(fh, "  // statevecl/statevecc/statevecr: [rho, rho ux, rho uy, rho uz, energy], Fluid input state vector in left/center/right cells.~%"),
  printf(fh, "  // out: Incremented output.~%"),

  cid : cidx(cdim),

  /* cv = variable in direction of surface update. */
  cv : varsC[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "  const double *rho_l = &statevecl[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhou0_l = &statevecl[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhou1_l = &statevecl[~a]; ~%", 2*NC),
  printf(fh, "  const double *rhou2_l = &statevecl[~a]; ~%", 3*NC),
  printf(fh, "  const double *energy_l = &statevecl[~a]; ~%", 4*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *rho_c = &statevecc[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhou0_c = &statevecc[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhou1_c = &statevecc[~a]; ~%", 2*NC),
  printf(fh, "  const double *rhou2_c = &statevecc[~a]; ~%", 3*NC),
  printf(fh, "  const double *energy_c = &statevecc[~a]; ~%", 4*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *rho_r = &statevecr[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhou0_r = &statevecr[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhou1_r = &statevecr[~a]; ~%", 2*NC),
  printf(fh, "  const double *rhou2_r = &statevecr[~a]; ~%", 3*NC),
  printf(fh, "  const double *energy_r = &statevecr[~a]; ~%", 4*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *ul_0 = &ul[~a]; ~%", 0*NC),
  printf(fh, "  const double *uc_0 = &uc[~a]; ~%", 0*NC),
  printf(fh, "  const double *ur_0 = &ur[~a]; ~%", 0*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *ul_1 = &ul[~a]; ~%", 1*NC),
  printf(fh, "  const double *uc_1 = &uc[~a]; ~%", 1*NC),
  printf(fh, "  const double *ur_1 = &ur[~a]; ~%", 1*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *ul_2 = &ul[~a]; ~%", 2*NC),
  printf(fh, "  const double *uc_2 = &uc[~a]; ~%", 2*NC),
  printf(fh, "  const double *ur_2 = &ur[~a]; ~%", 2*NC),

  printf(fh, "~%"),

  printf(fh, "  double *outrho = &out[~a]; ~%", 0*NC),
  printf(fh, "  double *outrhou0 = &out[~a]; ~%", 1*NC),
  printf(fh, "  double *outrhou1 = &out[~a]; ~%", 2*NC),
  printf(fh, "  double *outrhou2 = &out[~a]; ~%", 3*NC),
  printf(fh, "  double *outenergy = &out[~a]; ~%", 4*NC),

  printf(fh, "~%"),

  rhol_e : doExpand1(rho_l, bC),
  rhouxl_e : doExpand1(rhou0_l, bC),
  rhouyl_e : doExpand1(rhou1_l, bC),
  rhouzl_e : doExpand1(rhou2_l, bC),
  energyl_e : doExpand1(energy_l, bC),

  rhoc_e : doExpand1(rho_c, bC),
  rhouxc_e : doExpand1(rhou0_c, bC),
  rhouyc_e : doExpand1(rhou1_c, bC),
  rhouzc_e : doExpand1(rhou2_c, bC),
  energyc_e : doExpand1(energy_c, bC),

  rhor_e : doExpand1(rho_r, bC),
  rhouxr_e : doExpand1(rhou0_r, bC),
  rhouyr_e : doExpand1(rhou1_r, bC),
  rhouzr_e : doExpand1(rhou2_r, bC),
  energyr_e : doExpand1(energy_r, bC),

  ul_0_e : doExpand1(ul_0,bC),
  uc_0_e : doExpand1(uc_0,bC),
  ur_0_e : doExpand1(ur_0,bC),

  ul_1_e : doExpand1(ul_1,bC),
  uc_1_e : doExpand1(uc_1,bC),
  ur_1_e : doExpand1(ur_1,bC),

  ul_2_e : doExpand1(ul_2,bC),
  uc_2_e : doExpand1(uc_2,bC),
  ur_2_e : doExpand1(ur_2,bC),

  pl_e : doExpand1(pl,bC),
  pc_e : doExpand1(pc,bC),
  pr_e : doExpand1(pr,bC),

  rhol_r : subst(cv=1, rhol_e),
  rhouxl_r : subst(cv=1, rhouxl_e),
  rhouyl_r : subst(cv=1, rhouyl_e),
  rhouzl_r : subst(cv=1, rhouzl_e),
  energyl_r : subst(cv=1, energyl_e),
  ul_0_r : subst(cv=1, ul_0_e),
  ul_1_r : subst(cv=1, ul_1_e),
  ul_2_r : subst(cv=1, ul_2_e),
  pl_r : subst(cv=1, pl_e),

  rhoc_l : subst(cv=-1, rhoc_e),
  rhouxc_l : subst(cv=-1, rhouxc_e),
  rhouyc_l : subst(cv=-1, rhouyc_e),
  rhouzc_l : subst(cv=-1, rhouzc_e),
  energyc_l : subst(cv=-1, energyc_e),
  uc_0_l : subst(cv=-1, uc_0_e),
  uc_1_l : subst(cv=-1, uc_1_e),
  uc_2_l : subst(cv=-1, uc_2_e),
  pc_l : subst(cv=-1, pc_e),

  rhoc_r : subst(cv=1, rhoc_e),
  rhouxc_r : subst(cv=1, rhouxc_e),
  rhouyc_r : subst(cv=1, rhouyc_e),
  rhouzc_r : subst(cv=1, rhouzc_e),
  energyc_r : subst(cv=1, energyc_e),
  uc_0_r : subst(cv=1, uc_0_e),
  uc_1_r : subst(cv=1, uc_1_e),
  uc_2_r : subst(cv=1, uc_2_e),
  pc_r : subst(cv=1, pc_e),

  rhor_l : subst(cv=-1, rhor_e),
  rhouxr_l : subst(cv=-1, rhouxr_e),
  rhouyr_l : subst(cv=-1, rhouyr_e),
  rhouzr_l : subst(cv=-1, rhouzr_e),
  energyr_l : subst(cv=-1, energyr_e),
  ur_0_l : subst(cv=-1, ur_0_e),
  ur_1_l : subst(cv=-1, ur_1_e),
  ur_2_l : subst(cv=-1, ur_2_e),
  pr_l : subst(cv=-1, pr_e),

  /* Ghat_rho = 1/2 * (u_l*rho_l + u_r*rho_r) - 1/2 * |max(u_l, u_r)| (rho_r - rho_l) */
  avg_rho_l : 0.5*(ul_0_r*rhol_r + uc_0_l*rhoc_l),
  avg_rho_r : 0.5*(uc_0_r*rhoc_r + ur_0_l*rhor_l),
  jump_rho_l : 0.5*(rhoc_l - rhol_r),
  jump_rho_r : 0.5*(rhor_l - rhoc_r),

  /* average of u and p for computation of momentum fluxes */
  avg_u_0_l : 0.5*(ul_0_r + uc_0_l),
  avg_u_1_l : 0.5*(ul_1_r + uc_1_l),
  avg_u_2_l : 0.5*(ul_2_r + uc_2_l),
  avg_p_l : 0.5*(pl_r + pc_l),

  avg_u_0_r : (uc_0_r + ur_0_l),
  avg_u_1_r : (uc_1_r + ur_1_l),
  avg_u_2_r : (uc_2_r + ur_2_l),
  avg_p_r : 0.5*(pc_r + pr_l),

  /* Ghat_energy = 1/2 * (u_l*(E_l+p_l) + u_r*(E_r+p_r)) - 1/2 * |max(u_l, u_r)| ((E_r + p_r) - (E_l+p_l)) */
  avg_energy_l : 0.5*(ul_0_r*(energyl_r+pl_r) + uc_0_l*(energyc_l+pc_l)),
  avg_energy_r : 0.5*(uc_0_r*(energyc_r+pc_r) + ur_0_l*(energyr_l+pr_l)),
  jump_energy_l : 0.5*((energyl_r+pl_r) - (energyc_l+pc_l)),
  jump_energy_r : 0.5*((energyc_r+pc_r) - (energyr_l+pr_l)),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */
  /* evaluate u at surface interfaces to find max */
  printf(fh, "  double u_l_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(ul_0); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double u_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uc_0); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double u_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uc_0); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double u_r_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(ur_0); ~%", basisFun, cdim, polyOrder),

  printf(fh, "  double u_max_l = fabs(fmax(u_l_r, u_c_l)); ~%"),
  printf(fh, "  double u_max_r= fabs(fmax(u_c_r, u_r_l)); ~%"),

  printf(fh, "~%"),

  /* Expanded Ghat for re-use */
  /* Momentum flux is Ghat_rho*u_avg + p_avg, where u_avg and p_avg are common values on the interface */
  Ghat_rho_l_exp : avg_rho_l - u_max_l*jump_rho_l,
  Ghat_rho_r_exp : avg_rho_r - u_max_r*jump_rho_r,

  Ghat_energy_l_exp : avg_energy_l - u_max_l*jump_energy_l,
  Ghat_energy_r_exp : avg_energy_r - u_max_r*jump_energy_r,

  printf(fh, "  double Ghat_rho_l = ~a; ~%", float(expand(Ghat_rho_l_exp))),
  printf(fh, "  double Ghat_rho_r = ~a; ~%", float(expand(Ghat_rho_r_exp))),
  printf(fh, "  double Ghat_energy_l = ~a; ~%", float(expand(Ghat_energy_l_exp))),
  printf(fh, "  double Ghat_energy_r = ~a; ~%", float(expand(Ghat_energy_r_exp))),

  printf(fh, "~%"),

  incr_rho_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rho_l),
  incr_rho_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rho_r),

  incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rho_l*avg_u_0_l + avg_p_l),
  incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rho_r*avg_u_0_r + avg_p_r),

  incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rho_l*avg_u_1_l),
  incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rho_r*avg_u_1_r),

  incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rho_l*avg_u_2_l),
  incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rho_r*avg_u_2_r),

  incr_energy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_energy_l),
  incr_energy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_energy_r),

  surfTerms : [incr_rho_l + incr_rho_r,incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r,incr_energy_l + incr_energy_r],
  for m : 1 thru 5 do (
    surf : surfTerms[m],
    writeCIncrExprs1(lhs[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);