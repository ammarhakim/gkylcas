/* This script generates the kernels for the surface term of Euler's equations
   for the parallel-kinetic-perpendicular-moment (pkpm) model */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
load("recovery")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx10, dx11, dx12]$

statevec : [rhou0, rhou1, rhou2, energy]$
lhs : [outrhou0, outrhou1, outrhou2, outenergy]$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

/* 1D Euler special since only involves evaluations */
calcEulerPKPM1xUpdateInDir(dir, fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC,NC,cid,cv,surfVars,
  energyl_e, energyc_e, energyr_e,
  uxl_e,uxc_e,uxr_e,
  uyl_e,uyc_e,uyr_e,
  uzl_e,uzc_e,uzr_e,
  Pxxl_e,Pxxc_e,Pxxr_e,
  Pxyl_e,Pxyc_e,Pxyr_e,
  Pxzl_e,Pxzc_e,Pxzr_e,
  energyl_r, uxl_r, uyl_r, uzl_r, Pxxl_r, Pxyl_r, Pxzl_r,
  energyc_l, uxc_l, uyc_l, uzc_l, Pxxc_l, Pxyc_l, Pxzc_l,
  energyc_r, uxc_r, uyc_r, uzc_r, Pxxc_r, Pxyc_r, Pxzc_r,
  energyr_l, uxr_l, uyr_l, uzr_l, Pxxr_l, Pxyr_l, Pxzr_l,
  lst_ux_l, lst_ux_c, lst_ux_r, lst_uy_l, lst_uy_c, lst_uy_r, lst_uz_l, lst_uz_c, lst_uz_r, 
  lst_Pxx_l, lst_Pxx_c, lst_Pxx_r, lst_Pxy_l, lst_Pxy_c, lst_Pxy_r, lst_Pxz_l, lst_Pxz_c, lst_Pxz_r, 
  ux_rec_l, ux_rec_r, uy_rec_l, uy_rec_r, uz_rec_l, uz_rec_r, 
  Pxx_rec_l, Pxx_rec_r, Pxy_rec_l, Pxy_rec_r, Pxz_rec_l, Pxz_rec_r, 
  avg_energy_l,avg_energy_r,
  jump_energyx_l,jump_energyx_r,jump_energyy_l,jump_energyy_r,jump_energyz_l,jump_energyz_r,
  Ghat_energy_l_exp,Ghat_energy_r_exp,
  incr_rhoux_l,incr_rhoux_r,incr_rhouy_l,incr_rhouy_r,incr_rhouz_l,incr_rhouz_r,incr_energy_l,incr_energy_r],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax_~a_p~a(const double *w, const double *dxv, 
  const double *u_il, const double *u_ic, const double *u_ir,
  const double *p_ijl, const double *p_ijc, const double *p_ijr,
  const double *vlasov_pkpm_surf_momsl, const double *vlasov_pkpm_surf_momsr, 
  const double *statevecl, const double *statevecc, const double *statevecr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // u_il/u_ic/u_ir: [ux, uy, uz] Fluid flow in left/center/right cells.~%"),
  printf(fh, "  // p_ijl/p_ijc/p_ijr: Pressure tensor in left/center/right cells.~%"),
  printf(fh, "  // vlasov_pkpm_surf_momsl/vlasov_pkpm_surf_momsr: Mass flux and heat flux at left edge and right edge (computed externally) .~%"),
  printf(fh, "  // statevecl/statevecc/statevecr: [rho ux, rho uy, rho uz, energy], Fluid input state vector in left/center/right cells.~%"),
  printf(fh, "  // out: Incremented output.~%"),
  printf(fh, "~%"),

  /* cv = variable in direction of surface update. */
  cv : varsC[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "  // Only need to fetch input energy variable, other fluxes are computed from input flow and pressure tensor.~%"),
  printf(fh, "  const double *energy_l = &statevecl[~a]; ~%", 3*NC),
  printf(fh, "  const double *energy_c = &statevecc[~a]; ~%", 3*NC),
  printf(fh, "  const double *energy_r = &statevecr[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *ux_l = &u_il[~a]; ~%", 0*NC),
  printf(fh, "  const double *ux_c = &u_ic[~a]; ~%", 0*NC),
  printf(fh, "  const double *ux_r = &u_ir[~a]; ~%", 0*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *uy_l = &u_il[~a]; ~%", 1*NC),
  printf(fh, "  const double *uy_c = &u_ic[~a]; ~%", 1*NC),
  printf(fh, "  const double *uy_r = &u_ir[~a]; ~%", 1*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *uz_l = &u_il[~a]; ~%", 2*NC),
  printf(fh, "  const double *uz_c = &u_ic[~a]; ~%", 2*NC),
  printf(fh, "  const double *uz_r = &u_ir[~a]; ~%", 2*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxx_l = &p_ijl[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxx_c = &p_ijc[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxx_r = &p_ijr[~a]; ~%", 0*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxy_l = &p_ijl[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxy_c = &p_ijc[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxy_r = &p_ijr[~a]; ~%", 1*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxz_l = &p_ijl[~a]; ~%", 2*NC),
  printf(fh, "  const double *Pxz_c = &p_ijc[~a]; ~%", 2*NC),
  printf(fh, "  const double *Pxz_r = &p_ijr[~a]; ~%", 2*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *rho_flux_l = &vlasov_pkpm_surf_momsl[~a]; ~%", 0),
  printf(fh, "  const double *heat_flux_l = &vlasov_pkpm_surf_momsl[~a]; ~%", 1),
  printf(fh, "  const double *rho_flux_r = &vlasov_pkpm_surf_momsr[~a]; ~%", 0),
  printf(fh, "  const double *heat_flux_r = &vlasov_pkpm_surf_momsr[~a]; ~%", 1),

  printf(fh, "  double *outrhou0 = &out[~a]; ~%", 0*NC),
  printf(fh, "  double *outrhou1 = &out[~a]; ~%", 1*NC),
  printf(fh, "  double *outrhou2 = &out[~a]; ~%", 2*NC),
  printf(fh, "  double *outenergy = &out[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  energyl_e : doExpand1(energy_l, bC),
  energyc_e : doExpand1(energy_c, bC),
  energyr_e : doExpand1(energy_r, bC),

  ux_l_e : doExpand1(ux_l,bC),
  ux_c_e : doExpand1(ux_c,bC),
  ux_r_e : doExpand1(ux_r,bC),

  uy_l_e : doExpand1(uy_l,bC),
  uy_c_e : doExpand1(uy_c,bC),
  uy_r_e : doExpand1(uy_r,bC),

  uz_l_e : doExpand1(uz_l,bC),
  uz_c_e : doExpand1(uz_c,bC),
  uz_r_e : doExpand1(uz_r,bC),

  Pxx_l_e : doExpand1(Pxx_l,bC),
  Pxx_c_e : doExpand1(Pxx_c,bC),
  Pxx_r_e : doExpand1(Pxx_r,bC),

  Pxy_l_e : doExpand1(Pxy_l,bC),
  Pxy_c_e : doExpand1(Pxy_c,bC),
  Pxy_r_e : doExpand1(Pxy_r,bC),

  Pxz_l_e : doExpand1(Pxz_l,bC),
  Pxz_c_e : doExpand1(Pxz_c,bC),
  Pxz_r_e : doExpand1(Pxz_r,bC),

  energyl_r : subst(cv=1, energyl_e),
  ux_l_r : subst(cv=1, ux_l_e),
  uy_l_r : subst(cv=1, uy_l_e),
  uz_l_r : subst(cv=1, uz_l_e),
  Pxx_l_r : subst(cv=1, Pxx_l_e),
  Pxy_l_r : subst(cv=1, Pxy_l_e),
  Pxz_l_r : subst(cv=1, Pxz_l_e),

  energyc_l : subst(cv=-1, energyc_e),
  ux_c_l : subst(cv=-1, ux_c_e),
  uy_c_l : subst(cv=-1, uy_c_e),
  uz_c_l : subst(cv=-1, uz_c_e),
  Pxx_c_l : subst(cv=-1, Pxx_c_e),
  Pxy_c_l : subst(cv=-1, Pxy_c_e),
  Pxz_c_l : subst(cv=-1, Pxz_c_e),

  energyc_r : subst(cv=1, energyc_e),
  ux_c_r : subst(cv=1, ux_c_e),
  uy_c_r : subst(cv=1, uy_c_e),
  uz_c_r : subst(cv=1, uz_c_e),
  Pxx_c_r : subst(cv=1, Pxx_c_e),
  Pxy_c_r : subst(cv=1, Pxy_c_e),
  Pxz_c_r : subst(cv=1, Pxz_c_e),

  energyr_l : subst(cv=-1, energyr_e),
  ux_r_l : subst(cv=-1, ux_r_e),
  uy_r_l : subst(cv=-1, uy_r_e),
  uz_r_l : subst(cv=-1, uz_r_e),
  Pxx_r_l : subst(cv=-1, Pxx_r_e),
  Pxy_r_l : subst(cv=-1, Pxy_r_e),
  Pxz_r_l : subst(cv=-1, Pxz_r_e),

  /* We use recovery to compute the interface u_i and p_ij values for momentum fluxes */
  /* Create safety lists for recovery */
  lst_ux_l : makelist(ux_l[i], i, 0, NC-1),
  lst_ux_c : makelist(ux_c[i], i, 0, NC-1),
  lst_ux_r : makelist(ux_r[i], i, 0, NC-1),

  lst_uy_l : makelist(uy_l[i], i, 0, NC-1),
  lst_uy_c : makelist(uy_c[i], i, 0, NC-1),
  lst_uy_r : makelist(uy_r[i], i, 0, NC-1),

  lst_uz_l : makelist(uz_l[i], i, 0, NC-1),
  lst_uz_c : makelist(uz_c[i], i, 0, NC-1),
  lst_uz_r : makelist(uz_r[i], i, 0, NC-1),

  lst_Pxx_l : makelist(Pxx_l[i], i, 0, NC-1),
  lst_Pxx_c : makelist(Pxx_c[i], i, 0, NC-1),
  lst_Pxx_r : makelist(Pxx_r[i], i, 0, NC-1),

  lst_Pxy_l : makelist(Pxy_l[i], i, 0, NC-1),
  lst_Pxy_c : makelist(Pxy_c[i], i, 0, NC-1),
  lst_Pxy_r : makelist(Pxy_r[i], i, 0, NC-1),

  lst_Pxz_l : makelist(Pxz_l[i], i, 0, NC-1),
  lst_Pxz_c : makelist(Pxz_c[i], i, 0, NC-1),
  lst_Pxz_r : makelist(Pxz_r[i], i, 0, NC-1),

  /* Recovery */
  ux_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_ux_l), dg(lst_ux_c)),
  ux_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_ux_c), dg(lst_ux_r)),

  uy_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_uy_l), dg(lst_uy_c)),
  uy_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_uy_c), dg(lst_uy_r)),

  uz_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_uz_l), dg(lst_uz_c)),
  uz_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_uz_c), dg(lst_uz_r)),

  Pxx_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxx_l), dg(lst_Pxx_c)),
  Pxx_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxx_c), dg(lst_Pxx_r)),

  Pxy_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxy_l), dg(lst_Pxy_c)),
  Pxy_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxy_c), dg(lst_Pxy_r)),

  Pxz_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxz_l), dg(lst_Pxz_c)),
  Pxz_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxz_c), dg(lst_Pxz_r)),

  /* evaluate u at surface interfaces to find max 
     Need ux, uy, and uz because of off-diagonal pressure tensor components */
  printf(fh, "  double ux_l_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(ux_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double ux_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(ux_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double ux_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(ux_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double ux_r_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(ux_r); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),

  printf(fh, "  double uy_l_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uy_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uy_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uy_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uy_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uy_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uy_r_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uy_r); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),

  printf(fh, "  double uz_l_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uz_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uz_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uz_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uz_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uz_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uz_r_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uz_r); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),

  printf(fh, "  double ux_max_l = fmax(fabs(ux_l_r), fabs(ux_c_l)); ~%"),
  printf(fh, "  double ux_max_r = fmax(fabs(ux_c_r), fabs(ux_r_l)); ~%"),
  printf(fh, "  double uy_max_l = fmax(fabs(uy_l_r), fabs(uy_c_l)); ~%"),
  printf(fh, "  double uy_max_r = fmax(fabs(uy_c_r), fabs(uy_r_l)); ~%"),
  printf(fh, "  double uz_max_l = fmax(fabs(uz_l_r), fabs(uz_c_l)); ~%"),
  printf(fh, "  double uz_max_r = fmax(fabs(uz_c_r), fabs(uz_r_l)); ~%"),

  printf(fh, "~%"),

  /* Ghat_energy = 1/2 * (ux_l*(E_l + Pxx_l) + uy_l*Pxy_l + uz_l*P_xz_l + ux_r*(E_r + Pxx_r) + uy_r*Pxy_r + uz_r*Pxz_r) 
                 - 1/2 * max(|ux_l|, |ux_r|)| ((E_r + Pxx_r) - (E_l + Pxx_l))
                 - 1/2 * max(|uy_l|, |uy_r|)| (Pxy_r - Pxy_l)
                 - 1/2 * max(|uz_l|, |uz_r|)| (Pxz_r - Pxz_l) */

  avg_energy_l : 0.5*(ux_l_r*(energyl_r + Pxx_l_r) + uy_l_r*Pxy_l_r + uz_l_r*Pxz_l_r + ux_c_l*(energyc_l + Pxx_c_l) + uy_c_l*Pxy_c_l + uz_c_l*Pxz_c_l),
  avg_energy_r : 0.5*(ux_c_r*(energyc_r + Pxx_c_r) + uy_c_r*Pxy_c_r + uz_c_r*Pxz_c_r + ux_r_l*(energyr_l + Pxx_r_l) + uy_r_l*Pxy_r_l + uz_r_l*Pxz_r_l),

  jump_energyx_l : 0.5*((energyl_r + Pxx_l_r) - (energyc_l + Pxx_c_l)),
  jump_energyx_r : 0.5*((energyc_r + Pxx_c_r) - (energyr_l + Pxx_r_l)),

  jump_energyy_l : 0.5*(Pxy_l_r - Pxy_c_l),
  jump_energyy_r : 0.5*(Pxy_c_r - Pxy_r_l),

  jump_energyz_l : 0.5*(Pxz_l_r - Pxz_c_l),
  jump_energyz_r : 0.5*(Pxz_c_r - Pxz_r_l),

  Ghat_energy_l_exp : avg_energy_l - ux_max_l*jump_energyx_l - uy_max_l*jump_energyy_l - uz_max_l*jump_energyz_l,
  Ghat_energy_r_exp : avg_energy_r - ux_max_r*jump_energyx_r - uy_max_r*jump_energyy_r - uz_max_r*jump_energyz_r,

  printf(fh, "  double Ghat_energy_l = ~a; ~%", float(expand(Ghat_energy_l_exp))),
  printf(fh, "  double Ghat_energy_r = ~a; ~%", float(expand(Ghat_energy_r_exp))),

  printf(fh, "~%"),

  printf(fh, "  double uxrec_l = ~a; ~%", float(expand(subst(cv=0, ux_rec_l)))),
  printf(fh, "  double uxrec_r = ~a; ~%", float(expand(subst(cv=0, ux_rec_r)))),
  printf(fh, "  double uyrec_l = ~a; ~%", float(expand(subst(cv=0, uy_rec_l)))),
  printf(fh, "  double uyrec_r = ~a; ~%", float(expand(subst(cv=0, uy_rec_r)))),
  printf(fh, "  double uzrec_l = ~a; ~%", float(expand(subst(cv=0, uz_rec_l)))),
  printf(fh, "  double uzrec_r = ~a; ~%", float(expand(subst(cv=0, uz_rec_r)))),

  printf(fh, "~%"),

  printf(fh, "  double Pxxrec_l = ~a; ~%", float(expand(subst(cv=0, Pxx_rec_l)))),
  printf(fh, "  double Pxxrec_r = ~a; ~%", float(expand(subst(cv=0, Pxx_rec_r)))),
  printf(fh, "  double Pxyrec_l = ~a; ~%", float(expand(subst(cv=0, Pxy_rec_l)))),
  printf(fh, "  double Pxyrec_r = ~a; ~%", float(expand(subst(cv=0, Pxy_rec_r)))),
  printf(fh, "  double Pxzrec_l = ~a; ~%", float(expand(subst(cv=0, Pxz_rec_l)))),
  printf(fh, "  double Pxzrec_r = ~a; ~%", float(expand(subst(cv=0, Pxz_rec_r)))),

  printf(fh, "~%"),

  incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), rho_flux_l[0]*uxrec_l + Pxxrec_l),
  incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), rho_flux_r[0]*uxrec_r + Pxxrec_r),

  incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), rho_flux_l[0]*uyrec_l + Pxyrec_l),
  incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), rho_flux_r[0]*uyrec_r + Pxyrec_r),

  incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), rho_flux_l[0]*uzrec_l + Pxyrec_l),
  incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), rho_flux_r[0]*uzrec_r + Pxzrec_r),

  incr_energy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_energy_l + heat_flux_l[0]),
  incr_energy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_energy_r + heat_flux_r[0]),

  surfTerms : [incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r,incr_energy_l + incr_energy_r],
  for m : 1 thru 4 do (
    surf : surfTerms[m],
    writeCIncrExprs1(lhs[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);

calcEulerPKPMUpdateInDir(dir, fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC,NC,cid,cv,surfVars,
  energyl_e, energyc_e, energyr_e,
  uxl_e,uxc_e,uxr_e,
  uyl_e,uyc_e,uyr_e,
  uzl_e,uzc_e,uzr_e,
  Pxxl_e,Pxxc_e,Pxxr_e,
  Pxyl_e,Pxyc_e,Pxyr_e,
  Pxzl_e,Pxzc_e,Pxzr_e,
  Pyyl_e,Pyyc_e,Pyyr_e,
  Pyzl_e,Pyzc_e,Pyzr_e,
  Pzzl_e,Pzzc_e,Pzzr_e,
  energyl_r, uxl_r, uyl_r, uzl_r, Pxxl_r, Pxyl_r, Pxzl_r, Pyyl_r, Pyzl_r, Pzzl_r,
  energyc_l, uxc_l, uyc_l, uzc_l, Pxxc_l, Pxyc_l, Pxzc_l, Pyyc_l, Pyzc_l, Pzzc_l,
  energyc_r, uxc_r, uyc_r, uzc_r, Pxxc_r, Pxyc_r, Pxzc_r, Pyyc_r, Pyzc_r, Pzzc_r,
  energyr_l, uxr_l, uyr_l, uzr_l, Pxxr_l, Pxyr_l, Pxzr_l, Pyyr_l, Pyzr_l, Pzzr_l,
  lst_ux_l, lst_ux_c, lst_ux_r, lst_uy_l, lst_uy_c, lst_uy_r, lst_uz_l, lst_uz_c, lst_uz_r, 
  lst_Pxx_l, lst_Pxx_c, lst_Pxx_r, lst_Pxy_l, lst_Pxy_c, lst_Pxy_r, lst_Pxz_l, lst_Pxz_c, lst_Pxz_r, 
  lst_Pyy_l, lst_Pyy_c, lst_Pyy_r, lst_Pyz_l, lst_Pyz_c, lst_Pyz_r, lst_Pzz_l, lst_Pzz_c, lst_Pzz_r, 
  ux_rec_l, ux_rec_r, uy_rec_l, uy_rec_r, uz_rec_l, uz_rec_r, 
  Pxx_rec_l, Pxx_rec_r, Pxy_rec_l, Pxy_rec_r, Pxz_rec_l, Pxz_rec_r, 
  Pyy_rec_l, Pyy_rec_r, Pyz_rec_l, Pyz_rec_r, Pzz_rec_l, Pzz_rec_r, 
  avg_energy_l,avg_energy_r,
  jump_energyx_l,jump_energyx_r,jump_energyy_l,jump_energyy_r,jump_energyz_l,jump_energyz_r,
  uxMax_l_e, uxMax_r_e, uyMax_l_e, uyMax_r_e, uzMax_l_e, uzMax_r_e, 
  Ghat_energy_l_c, Ghat_energy_l_e, Ghat_energy_r_c, Ghat_energy_r_e,
  uxrec_l_c, uyrec_l_c, uzrec_l_c, uxrec_r_c, uyrec_r_c, uzrec_r_c,
  uxrec_l_e, uyrec_l_e, uzrec_l_e, uxrec_r_e, uyrec_r_e, uzrec_r_e,
  Pixrec_l_c, Piyrec_l_c, Pizrec_l_c, Pixrec_r_c, Piyrec_r_c, Pizrec_r_c,
  Pixrec_l_e, Piyrec_l_e, Pizrec_l_e, Pixrec_r_e, Piyrec_r_e, Pizrec_r_e,
  incr_rhoux_l,incr_rhoux_r,incr_rhouy_l,incr_rhouy_r,incr_rhouz_l,incr_rhouz_r,incr_energy_l,incr_energy_r],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax_~a_p~a(const double *w, const double *dxv, 
  const double *u_il, const double *u_ic, const double *u_ir,
  const double *p_ijl, const double *p_ijc, const double *p_ijr,
  const double *vlasov_pkpm_surf_momsl, const double *vlasov_pkpm_surf_momsr, 
  const double *statevecl, const double *statevecc, const double *statevecr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // u_il/u_ic/u_ir: [ux, uy, uz] Fluid flow in left/center/right cells.~%"),
  printf(fh, "  // p_ijl/p_ijc/p_ijr: Pressure tensor in left/center/right cells.~%"),
  printf(fh, "  // vlasov_pkpm_surf_momsl/vlasov_pkpm_surf_momsr: Mass flux and heat flux at left edge and right edge (computed externally) .~%"),
  printf(fh, "  // statevecl/statevecc/statevecr: [rho ux, rho uy, rho uz, energy], Fluid input state vector in left/center/right cells.~%"),
  printf(fh, "  // out: Incremented output.~%"),
  printf(fh, "~%"),

  /* cv = variable in direction of surface update. */
  cv : varsC[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),

  bSurf : basisFromVars(basisFun,surfVars,polyOrder),
  NSurf : length(bSurf),

  /* Surface nodes given by tensor product of Gauss-Legendre quadrature points */
  surfNodes : gaussOrd(polyOrder+1, cdim-1),
  numNodes : length(surfNodes),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "  // Only need to fetch input energy variable, other fluxes are computed from input flow and pressure tensor.~%"),
  printf(fh, "  const double *energy_l = &statevecl[~a]; ~%", 3*NC),
  printf(fh, "  const double *energy_c = &statevecc[~a]; ~%", 3*NC),
  printf(fh, "  const double *energy_r = &statevecr[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *ux_l = &u_il[~a]; ~%", 0*NC),
  printf(fh, "  const double *ux_c = &u_ic[~a]; ~%", 0*NC),
  printf(fh, "  const double *ux_r = &u_ir[~a]; ~%", 0*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *uy_l = &u_il[~a]; ~%", 1*NC),
  printf(fh, "  const double *uy_c = &u_ic[~a]; ~%", 1*NC),
  printf(fh, "  const double *uy_r = &u_ir[~a]; ~%", 1*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *uz_l = &u_il[~a]; ~%", 2*NC),
  printf(fh, "  const double *uz_c = &u_ic[~a]; ~%", 2*NC),
  printf(fh, "  const double *uz_r = &u_ir[~a]; ~%", 2*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxx_l = &p_ijl[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxx_c = &p_ijc[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxx_r = &p_ijr[~a]; ~%", 0*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxy_l = &p_ijl[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxy_c = &p_ijc[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxy_r = &p_ijr[~a]; ~%", 1*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxz_l = &p_ijl[~a]; ~%", 2*NC),
  printf(fh, "  const double *Pxz_c = &p_ijc[~a]; ~%", 2*NC),
  printf(fh, "  const double *Pxz_r = &p_ijr[~a]; ~%", 2*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pyy_l = &p_ijl[~a]; ~%", 3*NC),
  printf(fh, "  const double *Pyy_c = &p_ijc[~a]; ~%", 3*NC),
  printf(fh, "  const double *Pyy_r = &p_ijr[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pyz_l = &p_ijl[~a]; ~%", 4*NC),
  printf(fh, "  const double *Pyz_c = &p_ijc[~a]; ~%", 4*NC),
  printf(fh, "  const double *Pyz_r = &p_ijr[~a]; ~%", 4*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pzz_l = &p_ijl[~a]; ~%", 5*NC),
  printf(fh, "  const double *Pzz_c = &p_ijc[~a]; ~%", 5*NC),
  printf(fh, "  const double *Pzz_r = &p_ijr[~a]; ~%", 5*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *rho_flux_l = &vlasov_pkpm_surf_momsl[~a]; ~%", 0*NSurf),
  printf(fh, "  const double *heat_flux_l = &vlasov_pkpm_surf_momsl[~a]; ~%", 1*NSurf),
  printf(fh, "  const double *rho_flux_r = &vlasov_pkpm_surf_momsr[~a]; ~%", 0*NSurf),
  printf(fh, "  const double *heat_flux_r = &vlasov_pkpm_surf_momsr[~a]; ~%", 1*NSurf),

  printf(fh, "  double *outrhou0 = &out[~a]; ~%", 0*NC),
  printf(fh, "  double *outrhou1 = &out[~a]; ~%", 1*NC),
  printf(fh, "  double *outrhou2 = &out[~a]; ~%", 2*NC),
  printf(fh, "  double *outenergy = &out[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  /* Create expansions of variables we need: E, u_i, P_ij */
  energyl_e : doExpand1(energy_l, bC),
  energyc_e : doExpand1(energy_c, bC),
  energyr_e : doExpand1(energy_r, bC),

  ux_l_e : doExpand1(ux_l,bC),
  ux_c_e : doExpand1(ux_c,bC),
  ux_r_e : doExpand1(ux_r,bC),

  uy_l_e : doExpand1(uy_l,bC),
  uy_c_e : doExpand1(uy_c,bC),
  uy_r_e : doExpand1(uy_r,bC),

  uz_l_e : doExpand1(uz_l,bC),
  uz_c_e : doExpand1(uz_c,bC),
  uz_r_e : doExpand1(uz_r,bC),

  Pxx_l_e : doExpand1(Pxx_l,bC),
  Pxx_c_e : doExpand1(Pxx_c,bC),
  Pxx_r_e : doExpand1(Pxx_r,bC),

  Pxy_l_e : doExpand1(Pxy_l,bC),
  Pxy_c_e : doExpand1(Pxy_c,bC),
  Pxy_r_e : doExpand1(Pxy_r,bC),

  Pxz_l_e : doExpand1(Pxz_l,bC),
  Pxz_c_e : doExpand1(Pxz_c,bC),
  Pxz_r_e : doExpand1(Pxz_r,bC),

  Pyy_l_e : doExpand1(Pyy_l,bC),
  Pyy_c_e : doExpand1(Pyy_c,bC),
  Pyy_r_e : doExpand1(Pyy_r,bC),

  Pyz_l_e : doExpand1(Pyz_l,bC),
  Pyz_c_e : doExpand1(Pyz_c,bC),
  Pyz_r_e : doExpand1(Pyz_r,bC),

  Pzz_l_e : doExpand1(Pzz_l,bC),
  Pzz_c_e : doExpand1(Pzz_c,bC),
  Pzz_r_e : doExpand1(Pzz_r,bC),

  /* Create surface expansions of mass flux and heat flux (coefficients computed externally from kinetic equation) */
  rho_flux_l_e : doExpand1(rho_flux_l, bSurf),
  rho_flux_r_e : doExpand1(rho_flux_r, bSurf),
  heat_flux_l_e : doExpand1(heat_flux_l, bSurf),
  heat_flux_r_e : doExpand1(heat_flux_r, bSurf),

  /* Evaluate expansions at surfaces to compute full energy flux with upwinding */
  energyl_r : subst(cv=1, energyl_e),
  ux_l_r : subst(cv=1, ux_l_e),
  uy_l_r : subst(cv=1, uy_l_e),
  uz_l_r : subst(cv=1, uz_l_e),
  Pxx_l_r : subst(cv=1, Pxx_l_e),
  Pxy_l_r : subst(cv=1, Pxy_l_e),
  Pxz_l_r : subst(cv=1, Pxz_l_e),
  Pyy_l_r : subst(cv=1, Pyy_l_e),
  Pyz_l_r : subst(cv=1, Pyz_l_e),
  Pzz_l_r : subst(cv=1, Pzz_l_e),

  energyc_l : subst(cv=-1, energyc_e),
  ux_c_l : subst(cv=-1, ux_c_e),
  uy_c_l : subst(cv=-1, uy_c_e),
  uz_c_l : subst(cv=-1, uz_c_e),
  Pxx_c_l : subst(cv=-1, Pxx_c_e),
  Pxy_c_l : subst(cv=-1, Pxy_c_e),
  Pxz_c_l : subst(cv=-1, Pxz_c_e),
  Pyy_c_l : subst(cv=-1, Pyy_c_e),
  Pyz_c_l : subst(cv=-1, Pyz_c_e),
  Pzz_c_l : subst(cv=-1, Pzz_c_e),

  energyc_r : subst(cv=1, energyc_e),
  ux_c_r : subst(cv=1, ux_c_e),
  uy_c_r : subst(cv=1, uy_c_e),
  uz_c_r : subst(cv=1, uz_c_e),
  Pxx_c_r : subst(cv=1, Pxx_c_e),
  Pxy_c_r : subst(cv=1, Pxy_c_e),
  Pxz_c_r : subst(cv=1, Pxz_c_e),
  Pyy_c_r : subst(cv=1, Pyy_c_e),
  Pyz_c_r : subst(cv=1, Pyz_c_e),
  Pzz_c_r : subst(cv=1, Pzz_c_e),

  energyr_l : subst(cv=-1, energyr_e),
  ux_r_l : subst(cv=-1, ux_r_e),
  uy_r_l : subst(cv=-1, uy_r_e),
  uz_r_l : subst(cv=-1, uz_r_e),
  Pxx_r_l : subst(cv=-1, Pxx_r_e),
  Pxy_r_l : subst(cv=-1, Pxy_r_e),
  Pxz_r_l : subst(cv=-1, Pxz_r_e),
  Pyy_r_l : subst(cv=-1, Pyy_r_e),
  Pyz_r_l : subst(cv=-1, Pyz_r_e),
  Pzz_r_l : subst(cv=-1, Pzz_r_e),

  /* We use recovery to compute the interface u_i and p_ij values for momentum fluxes */
  /* Create safety lists for recovery */
  lst_ux_l : makelist(ux_l[i], i, 0, NC-1),
  lst_ux_c : makelist(ux_c[i], i, 0, NC-1),
  lst_ux_r : makelist(ux_r[i], i, 0, NC-1),

  lst_uy_l : makelist(uy_l[i], i, 0, NC-1),
  lst_uy_c : makelist(uy_c[i], i, 0, NC-1),
  lst_uy_r : makelist(uy_r[i], i, 0, NC-1),

  lst_uz_l : makelist(uz_l[i], i, 0, NC-1),
  lst_uz_c : makelist(uz_c[i], i, 0, NC-1),
  lst_uz_r : makelist(uz_r[i], i, 0, NC-1),

  lst_Pxx_l : makelist(Pxx_l[i], i, 0, NC-1),
  lst_Pxx_c : makelist(Pxx_c[i], i, 0, NC-1),
  lst_Pxx_r : makelist(Pxx_r[i], i, 0, NC-1),

  lst_Pxy_l : makelist(Pxy_l[i], i, 0, NC-1),
  lst_Pxy_c : makelist(Pxy_c[i], i, 0, NC-1),
  lst_Pxy_r : makelist(Pxy_r[i], i, 0, NC-1),

  lst_Pxz_l : makelist(Pxz_l[i], i, 0, NC-1),
  lst_Pxz_c : makelist(Pxz_c[i], i, 0, NC-1),
  lst_Pxz_r : makelist(Pxz_r[i], i, 0, NC-1),

  lst_Pyy_l : makelist(Pyy_l[i], i, 0, NC-1),
  lst_Pyy_c : makelist(Pyy_c[i], i, 0, NC-1),
  lst_Pyy_r : makelist(Pyy_r[i], i, 0, NC-1),

  lst_Pyz_l : makelist(Pyz_l[i], i, 0, NC-1),
  lst_Pyz_c : makelist(Pyz_c[i], i, 0, NC-1),
  lst_Pyz_r : makelist(Pyz_r[i], i, 0, NC-1),

  lst_Pzz_l : makelist(Pzz_l[i], i, 0, NC-1),
  lst_Pzz_c : makelist(Pzz_c[i], i, 0, NC-1),
  lst_Pzz_r : makelist(Pzz_r[i], i, 0, NC-1),

  /* Recovery of u_i and P_ij */
  ux_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_ux_l), dg(lst_ux_c)),
  ux_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_ux_c), dg(lst_ux_r)),

  uy_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_uy_l), dg(lst_uy_c)),
  uy_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_uy_c), dg(lst_uy_r)),

  uz_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_uz_l), dg(lst_uz_c)),
  uz_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_uz_c), dg(lst_uz_r)),

  Pxx_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxx_l), dg(lst_Pxx_c)),
  Pxx_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxx_c), dg(lst_Pxx_r)),

  Pxy_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxy_l), dg(lst_Pxy_c)),
  Pxy_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxy_c), dg(lst_Pxy_r)),

  Pxz_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxz_l), dg(lst_Pxz_c)),
  Pxz_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pxz_c), dg(lst_Pxz_r)),

  Pyy_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pyy_l), dg(lst_Pyy_c)),
  Pyy_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pyy_c), dg(lst_Pyy_r)),

  Pyz_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pyz_l), dg(lst_Pyz_c)),
  Pyz_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pyz_c), dg(lst_Pyz_r)),

  Pzz_rec_l : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pzz_l), dg(lst_Pzz_c)),
  Pzz_rec_r : calcRecov2CellGen(basisFun, cv, varsC, polyOrder,
    dg(lst_Pzz_c), dg(lst_Pzz_r)),

  printf(fh, "  double uxQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double uxQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double uxMax_l[~a] = {0.0};;~%", NSurf),
  printf(fh, "  double uxMax_r[~a] = {0.0};~%", NSurf),

  printf(fh, "  double uyQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double uyQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double uyMax_l[~a] = {0.0};;~%", NSurf),
  printf(fh, "  double uyMax_r[~a] = {0.0};~%", NSurf),

  printf(fh, "  double uzQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double uzQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double uzMax_l[~a] = {0.0};;~%", NSurf),
  printf(fh, "  double uzMax_r[~a] = {0.0};~%", NSurf),

  printf(fh, "  double Ghat_energy_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_energy_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),
  printf(fh, "  double uxrec_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uxrec_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uyrec_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uyrec_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uzrec_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uzrec_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),
  printf(fh, "  double Pixrec_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Pixrec_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Piyrec_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Piyrec_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Pizrec_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Pizrec_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),
  printf(fh, "  double ux_l_r = 0.0; ~%"),
  printf(fh, "  double ux_c_l = 0.0; ~%"),
  printf(fh, "  double ux_c_r = 0.0; ~%"),
  printf(fh, "  double ux_r_l = 0.0; ~%"),

  printf(fh, "  double uy_l_r = 0.0; ~%"),
  printf(fh, "  double uy_c_l = 0.0; ~%"),
  printf(fh, "  double uy_c_r = 0.0; ~%"),
  printf(fh, "  double uy_r_l = 0.0; ~%"),

  printf(fh, "  double uz_l_r = 0.0; ~%"),
  printf(fh, "  double uz_c_l = 0.0; ~%"),
  printf(fh, "  double uz_c_r = 0.0; ~%"),
  printf(fh, "  double uz_r_l = 0.0; ~%"),
  printf(fh, "~%"),
  for i : 1 thru numNodes do (
    printf(fh, "  ux_l_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(ux_l); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  ux_c_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(ux_c); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  ux_c_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(ux_c); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  ux_r_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(ux_r); ~%", basisFun, cdim, polyOrder, dir, i-1),

    printf(fh, "  uxQuad_l[~a] = fmax(fabs(ux_l_r), fabs(ux_c_l)); ~%", i-1),
    printf(fh, "  uxQuad_r[~a] = fmax(fabs(ux_c_r), fabs(ux_r_l)); ~%", i-1),
    printf(fh, "~%"),

    printf(fh, "  uy_l_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(uy_l); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  uy_c_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(uy_c); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  uy_c_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(uy_c); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  uy_r_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(uy_r); ~%", basisFun, cdim, polyOrder, dir, i-1),

    printf(fh, "  uyQuad_l[~a] = fmax(fabs(uy_l_r), fabs(uy_c_l)); ~%", i-1),
    printf(fh, "  uyQuad_r[~a] = fmax(fabs(uy_c_r), fabs(uy_r_l)); ~%", i-1),
    printf(fh, "~%"),

    printf(fh, "  uz_l_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(uz_l); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  uz_c_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(uz_c); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  uz_c_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(uz_c); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  uz_r_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(uz_r); ~%", basisFun, cdim, polyOrder, dir, i-1),

    printf(fh, "  uzQuad_l[~a] = fmax(fabs(uz_l_r), fabs(uz_c_l)); ~%", i-1),
    printf(fh, "  uzQuad_r[~a] = fmax(fabs(uz_c_r), fabs(uz_r_l)); ~%", i-1),
    printf(fh, "~%")
  ),

  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uxQuad_l, uxMax_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uxQuad_r, uxMax_r); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),

  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uyQuad_l, uyMax_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uyQuad_r, uyMax_r); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),

  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uzQuad_l, uzMax_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uzQuad_r, uzMax_r); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),

  /* Create expansions of u_i_max (|u_i_max| evaluated at the surface) on the left and right in the surface basis. 
     All three components of u required at the interface because of off-diagonal pressure tensor components. */
  uxMax_l_e : doExpand1(uxMax_l, bSurf),
  uxMax_r_e : doExpand1(uxMax_r, bSurf),

  uyMax_l_e : doExpand1(uyMax_l, bSurf),
  uyMax_r_e : doExpand1(uyMax_r, bSurf),

  uzMax_l_e : doExpand1(uzMax_l, bSurf),
  uzMax_r_e : doExpand1(uzMax_r, bSurf),

  if (dir = 1) then (
    /* Ghat_energy = 1/2 * (ux_l*(E_l + Pxx_l) + uy_l*Pxy_l + uz_l*P_xz_l + ux_r*(E_r + Pxx_r) + uy_r*Pxy_r + uz_r*Pxz_r) 
		   - 1/2 * max(|ux_l|, |ux_r|)| ((E_r + Pxx_r) - (E_l + Pxx_l))
		   - 1/2 * max(|uy_l|, |uy_r|)| (Pxy_r - Pxy_l)
		   - 1/2 * max(|uz_l|, |uz_r|)| (Pxz_r - Pxz_l) */

    avg_energy_l : 0.5*(ux_l_r*(energyl_r + Pxx_l_r) + uy_l_r*Pxy_l_r + uz_l_r*Pxz_l_r + ux_c_l*(energyc_l + Pxx_c_l) + uy_c_l*Pxy_c_l + uz_c_l*Pxz_c_l),
    avg_energy_r : 0.5*(ux_c_r*(energyc_r + Pxx_c_r) + uy_c_r*Pxy_c_r + uz_c_r*Pxz_c_r + ux_r_l*(energyr_l + Pxx_r_l) + uy_r_l*Pxy_r_l + uz_r_l*Pxz_r_l),

    jump_energyx_l : 0.5*((energyl_r + Pxx_l_r) - (energyc_l + Pxx_c_l)),
    jump_energyx_r : 0.5*((energyc_r + Pxx_c_r) - (energyr_l + Pxx_r_l)),

    jump_energyy_l : 0.5*(Pxy_l_r - Pxy_c_l),
    jump_energyy_r : 0.5*(Pxy_c_r - Pxy_r_l),

    jump_energyz_l : 0.5*(Pxz_l_r - Pxz_c_l),
    jump_energyz_r : 0.5*(Pxz_c_r - Pxz_r_l)
  )
  elseif (dir = 2) then (
    /* Ghat_energy = 1/2 * (uy_l*(E_l + Pyy_l) + ux_l*Pxy_l + uz_l*P_yz_l + uy_r*(E_r + Pyy_r) + ux_r*Pxy_r + uz_r*Pyz_r) 
                   - 1/2 * max(|ux_l|, |ux_r|)| (Pxy_r - Pxy_l)
		   - 1/2 * max(|uy_l|, |uy_r|)| ((E_r + Pyy_r) - (E_l + Pyy_l))
		   - 1/2 * max(|uz_l|, |uz_r|)| (Pyz_r - Pyz_l) */

    avg_energy_l : 0.5*(uy_l_r*(energyl_r + Pyy_l_r) + ux_l_r*Pxy_l_r + uz_l_r*Pyz_l_r + uy_c_l*(energyc_l + Pyy_c_l) + ux_c_l*Pxy_c_l + uz_c_l*Pyz_c_l),
    avg_energy_r : 0.5*(uy_c_r*(energyc_r + Pyy_c_r) + ux_c_r*Pxy_c_r + uz_c_r*Pyz_c_r + uy_r_l*(energyr_l + Pyy_r_l) + ux_r_l*Pxy_r_l + uz_r_l*Pyz_r_l),

    jump_energyx_l : 0.5*(Pxy_l_r - Pxy_c_l),
    jump_energyx_r : 0.5*(Pxy_c_r - Pxy_r_l),

    jump_energyy_l : 0.5*((energyl_r + Pyy_l_r) - (energyc_l + Pyy_c_l)),
    jump_energyy_r : 0.5*((energyc_r + Pyy_c_r) - (energyr_l + Pyy_r_l)),

    jump_energyz_l : 0.5*(Pyz_l_r - Pyz_c_l),
    jump_energyz_r : 0.5*(Pyz_c_r - Pyz_r_l)
  )
  elseif (dir = 3) then (
    /* Ghat_energy = 1/2 * (uz_l*(E_l + Pzz_l) + ux_l*Pxz_l + uy_l*P_yz_l + uz_r*(E_r + Pzz_r) + ux_r*Pxz_r + uy_r*Pyz_r) 
                   - 1/2 * max(|ux_l|, |ux_r|)| (Pxz_r - Pxz_l)
                   - 1/2 * max(|uy_l|, |uy_r|)| (Pyz_r - Pyz_l)
		   - 1/2 * max(|uz_l|, |uz_r|)| ((E_r + Pzz_r) - (E_l + Pzz_l)) */

    avg_energy_l : 0.5*(uz_l_r*(energyl_r + Pzz_l_r) + ux_l_r*Pxz_l_r + uy_l_r*Pyz_l_r + uz_c_l*(energyc_l + Pzz_c_l) + ux_c_l*Pxz_c_l + uy_c_l*Pyz_c_l),
    avg_energy_r : 0.5*(uz_c_r*(energyc_r + Pzz_c_r) + ux_c_r*Pxz_c_r + uy_c_r*Pyz_c_r + uz_r_l*(energyr_l + Pzz_r_l) + ux_r_l*Pxz_r_l + uy_r_l*Pyz_r_l),

    jump_energyx_l : 0.5*(Pxz_l_r - Pxz_c_l),
    jump_energyx_r : 0.5*(Pxz_c_r - Pxz_r_l),

    jump_energyy_l : 0.5*(Pyz_l_r - Pyz_c_l),
    jump_energyy_r : 0.5*(Pyz_c_r - Pyz_r_l),

    jump_energyz_l : 0.5*((energyl_r + Pzz_l_r) - (energyc_l + Pzz_c_l)),
    jump_energyz_r : 0.5*((energyc_r + Pzz_c_r) - (energyr_l + Pzz_r_l))
  ),

  Ghat_energy_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, avg_energy_l - uxMax_l_e*jump_energyx_l - uyMax_l_e*jump_energyy_l - uzMax_l_e*jump_energyz_l)),
  Ghat_energy_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, avg_energy_r - uxMax_r_e*jump_energyx_r - uyMax_r_e*jump_energyy_r - uzMax_r_e*jump_energyz_r)),

  writeCExprs1(Ghat_energy_l, Ghat_energy_l_c),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of Ghat which are empty. */
  Ghat_energy_l_e : doExpandLst(doMakeExprLst(Ghat_energy_l_c, Ghat_energy_l), bSurf),

  writeCExprs1(Ghat_energy_r, Ghat_energy_r_c),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of Ghat which are empty. */
  Ghat_energy_r_e : doExpandLst(doMakeExprLst(Ghat_energy_r_c, Ghat_energy_r), bSurf),

  /* Print C exprs for the recovery of u_i across surface boundary, (l = LEFT BOUNDARY, r = RIGHT BOUNDARY) */
  uxrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, ux_rec_l))),
  uyrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, uy_rec_l))),
  uzrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, uz_rec_l))),

  uxrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, ux_rec_r))),
  uyrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, uy_rec_r))),
  uzrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, uz_rec_r))),

  writeCExprs1(uxrec_l, uxrec_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(uyrec_l, uyrec_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(uzrec_l, uzrec_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(uxrec_r, uxrec_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(uyrec_r, uyrec_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(uzrec_r, uzrec_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of recovered functions which are empty and make new expansions. */
  uxrec_l_e : doExpandLst(doMakeExprLst(uxrec_l_c, uxrec_l), bSurf),
  uyrec_l_e : doExpandLst(doMakeExprLst(uyrec_l_c, uyrec_l), bSurf),
  uzrec_l_e : doExpandLst(doMakeExprLst(uzrec_l_c, uzrec_l), bSurf),

  uxrec_r_e : doExpandLst(doMakeExprLst(uxrec_r_c, uxrec_r), bSurf),
  uyrec_r_e : doExpandLst(doMakeExprLst(uyrec_r_c, uyrec_r), bSurf),
  uzrec_r_e : doExpandLst(doMakeExprLst(uzrec_r_c, uzrec_r), bSurf),

  /* Print C exprs for the recovery of P_ij across surface boundary, (l = LEFT BOUNDARY, r = RIGHT BOUNDARY) */
  if (dir = 1) then (
    Pixrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxx_rec_l))),
    Piyrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxy_rec_l))),
    Pizrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxz_rec_l))),

    Pixrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxx_rec_r))),
    Piyrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxy_rec_r))),
    Pizrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxz_rec_r)))
  )
  elseif (dir = 2) then (
    Pixrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxy_rec_l))),
    Piyrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pyy_rec_l))),
    Pizrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pyz_rec_l))),

    Pixrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxy_rec_r))),
    Piyrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pyy_rec_r))),
    Pizrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pyz_rec_r)))
  )
  elseif (dir = 3) then (
    Pixrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxz_rec_l))),
    Piyrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pyz_rec_l))),
    Pizrec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pzz_rec_l))),

    Pixrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pxz_rec_r))),
    Piyrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pyz_rec_r))),
    Pizrec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, Pzz_rec_r)))
  ),

  writeCExprs1(Pixrec_l, Pixrec_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(Piyrec_l, Piyrec_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(Pizrec_l, Pizrec_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(Pixrec_r, Pixrec_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(Piyrec_r, Piyrec_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(Pizrec_r, Pizrec_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of recovered functions which are empty and make new expansions. */
  Pixrec_l_e : doExpandLst(doMakeExprLst(Pixrec_l_c, Pixrec_l), bSurf),
  Piyrec_l_e : doExpandLst(doMakeExprLst(Piyrec_l_c, Piyrec_l), bSurf),
  Pizrec_l_e : doExpandLst(doMakeExprLst(Pizrec_l_c, Pizrec_l), bSurf),

  Pixrec_r_e : doExpandLst(doMakeExprLst(Pixrec_r_c, Pixrec_r), bSurf),
  Piyrec_r_e : doExpandLst(doMakeExprLst(Piyrec_r_c, Piyrec_r), bSurf),
  Pizrec_r_e : doExpandLst(doMakeExprLst(Pizrec_r_c, Pizrec_r), bSurf),

  incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), rho_flux_l_e*uxrec_l_e + Pixrec_l_e),
  incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), rho_flux_r_e*uxrec_r_e + Pixrec_r_e),

  incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), rho_flux_l_e*uyrec_l_e + Piyrec_l_e),
  incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), rho_flux_r_e*uyrec_r_e + Piyrec_r_e),

  incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), rho_flux_l_e*uzrec_l_e + Piyrec_l_e),
  incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), rho_flux_r_e*uzrec_r_e + Pizrec_r_e),

  incr_energy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_energy_l_e + heat_flux_l_e),
  incr_energy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_energy_r_e + heat_flux_r_e),

  surfTerms : [incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r,incr_energy_l + incr_energy_r],
  for m : 1 thru 4 do (
    surf : surfTerms[m],
    writeCIncrExprs1(lhs[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);