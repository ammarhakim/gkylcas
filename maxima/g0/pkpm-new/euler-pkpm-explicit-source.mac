/* This script generates the kernels for an explicit update of the source terms 
   in the fluid equations of the parallel-kinetic-perpendicular-moment (pkpm) model,
   For fluid equation, momentum sources are rho*E + rho*u x B 
   Note E and B are the total EM fields and E includes external acceleration components if present. */

load("modal-basis")$
load("out-scripts")$
fpprec : 24$

calc_pkpm_explicit_em_source(fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, bC_2p, NC, NC_2p, rho_e, Ex_e, Ey_e, Ez_e, Bx_e, By_e, Bz_e, 
   rhoux_e, rhouy_e, rhouz_e, 
   incr_rhoux, incr_rhouy, incr_rhouz],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, polyOrder),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, 2*polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *qmem, const double *vlasov_pkpm_moms, const double *euler_pkpm, double* out) ~%{ ~%", funcNm),
  printf(fh, "  // qmem:             q/m*EM fields.~%"),
  printf(fh, "  // vlasov_pkpm_moms: [rho, p_parallel, p_perp], Moments computed from kinetic equation in pkpm model.~%"),
  printf(fh, "  // euler_pkpm:       Input fluid variables.~%"),
  printf(fh, "  // out:              Output increment"),
  printf(fh, "~%"),

  printf(fh, "  const double *rho = &vlasov_pkpm_moms[~a]; ~%", 0),
  printf(fh, "~%"),
  printf(fh, "  const double *Ex = &qmem[~a]; ~%", 0*NC_2p),
  printf(fh, "  const double *Ey = &qmem[~a]; ~%", 1*NC_2p),
  printf(fh, "  const double *Ez = &qmem[~a]; ~%", 2*NC_2p),
  printf(fh, "  const double *Bx = &qmem[~a]; ~%", 3*NC_2p),
  printf(fh, "  const double *By = &qmem[~a]; ~%", 4*NC_2p),
  printf(fh, "  const double *Bz = &qmem[~a]; ~%", 5*NC_2p),
  printf(fh, "~%"),
  printf(fh, "  const double *rhoux = &euler_pkpm[~a]; ~%", 0*NC_2p),
  printf(fh, "  const double *rhouy = &euler_pkpm[~a]; ~%", 1*NC_2p),
  printf(fh, "  const double *rhouz = &euler_pkpm[~a]; ~%", 2*NC_2p),  
  printf(fh, "~%"),

  printf(fh, "  double *outrhoux = &out[~a]; ~%", 0*NC_2p),
  printf(fh, "  double *outrhouy = &out[~a]; ~%", 1*NC_2p),
  printf(fh, "  double *outrhouz = &out[~a]; ~%", 2*NC_2p),
  printf(fh, "~%"),

  rho_e : doExpand1(rho, bC_2p),
  Ex_e : doExpand1(Ex, bC_2p),
  Ey_e : doExpand1(Ey, bC_2p),
  Ez_e : doExpand1(Ez, bC_2p),  
  Bx_e : doExpand1(Bx, bC_2p),
  By_e : doExpand1(By, bC_2p),
  Bz_e : doExpand1(Bz, bC_2p),  

  rhoux_e : doExpand1(rhoux, bC_2p),
  rhouy_e : doExpand1(rhouy, bC_2p),
  rhouz_e : doExpand1(rhouz, bC_2p),

  incr_rhoux : calcInnerProdList(varsC, 1, bC_2p, rho_e*Ex_e + rhouy_e*Bz_e - rhouz_e*By_e),
  writeCIncrExprs1(outrhoux, incr_rhoux),
  printf(fh, "~%"),
  flush_output(fh),

  incr_rhouy : calcInnerProdList(varsC, 1, bC_2p, rho_e*Ey_e + rhouz_e*Bx_e - rhoux_e*Bz_e),
  writeCIncrExprs1(outrhouy, incr_rhouy),
  printf(fh, "~%"),
  flush_output(fh),

  incr_rhouz : calcInnerProdList(varsC, 1, bC_2p, rho_e*Ez_e + rhoux_e*By_e - rhouy_e*Bx_e),
  writeCIncrExprs1(outrhouz, incr_rhouz),
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "} ~%")
)$
