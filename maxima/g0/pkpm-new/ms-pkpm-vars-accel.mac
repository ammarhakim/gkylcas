load("pkpm-new/pkpm-vars-accel")$
load(stringproc)$
/* This script calls the functions which generate the kernels for calculating the 
   acceleration variables required to update the PKPM system. 

   Acceleration variables are computed with averaging (grad_i u_j) 
   where averaging is chosen to ensure phase space incompressibility in the weak sense. 
   Full acceleration variable list: 
   1. p_perp_div_b (p_perp/rho*div(b) = T_perp/m*div(b))
   2. b_grad_u (bb : grad(u))
   3. p_force (total pressure forces in kinetic equation 1/rho div(p_parallel b_hat) - T_perp/m*div(b)
   4. p_perp_source (pressure source for higher Laguerre moments -> bb : grad(u) - div(u) - 2 nu) */


/* ...... USER INPUTS........ */

/* Tensor product basis. 
   Kinetic variables are p=2 */
minPolyOrder_Tensor : 2$
maxPolyOrder_Tensor : 2$
minCdim_Tensor : 1$
maxCdim_Tensor : 3$

/* ...... END OF USER INPUTS........ */
clabels : ["x","y","z"]$
for d : minCdim_Tensor thru maxCdim_Tensor do (
  for polyOrder : minPolyOrder_Tensor thru maxPolyOrder_Tensor do (
    disp(printf(false,sconcat("Creating pkpm accel vars funcs ",bName[bInd]," ~axp~a"),d,polyOrder)),
    for dir : 1 thru d do ( 
      fname : sconcat("~/max-out/pkpm_vars_accel_", clabels[dir], "_", d, "x_", "tensor_p", polyOrder, ".c"),
      fh : openw(fname),
      funcName : sconcat("pkpm_vars_accel_", clabels[dir], "_", d, "x_", "tensor_p", polyOrder),
      pkpm_accel_vars(dir, fh, funcName, d, polyOrder),
      close(fh)
    )
  )
);
