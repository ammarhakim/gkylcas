/* This script generates the kernels for calculating the acceleration
   variables required to update the PKPM system. 

   Acceleration variables are computed with averaging for the gradients (grad_i u_j) 
   where averaging is chosen to ensure phase space incompressibility in the weak sense. 

   Full acceleration variable list: 
   1. p_perp_div_b (p_perp/rho*div(b) = T_perp/m*div(b))
   2. b_grad_u (bb : grad(u))
   3. p_force (total pressure forces in kinetic equation 1/rho div(p_parallel b_hat) - T_perp/m*div(b)
   4. p_perp_source (pressure source for higher Laguerre moments -> bb : grad(u) - div(u) - 2 nu) */

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("recovery")$
load("nodal_operations/nodal_functions")$
fpprec : 24$
cvars : [x, y, z]$

pkpm_accel_vars(dir, fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, bC_2p, NC, NC_2p, cv, surfVars, bSurf, NSurf, surfConfNodes, numConfNodes, 
   ux_surf_lr_e, ux_surf_cl_e, ux_surf_cr_e, ux_surf_rl_e, 
   uy_surf_lr_e, uy_surf_cl_e, uy_surf_cr_e, uy_surf_rl_e, 
   uz_surf_lr_e, uz_surf_cl_e, uz_surf_cr_e, uz_surf_rl_e, 
   Tii_surf_lr_e, Tii_surf_cl_e, Tii_surf_cr_e, Tii_surf_rl_e, 
   Tii_quad_surf_lr, Tii_quad_surf_cl, Tii_quad_surf_cr, Tii_quad_surf_rl, 
   u_quad_surf_lr, u_quad_surf_cl, u_quad_surf_cr, u_quad_surf_rl, 
   surf_ux_l, surf_uy_l, surf_uz_l, 
   surf_ux_r, surf_uy_r, surf_uz_r, 
   uxc_e, uyc_e, uzc_e, vol_ux_c, vol_uy_c, vol_uz_c, 
   bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e,  
   grad_u_x_e, grad_u_y_e, grad_u_z_e,
   bb_grad_u_comp_c, bb_grad_u_e, bb_grad_u_c, 
   nu_e, p_perp_source_c],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, 1),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  /* cv = variable to compute gradients in. */
  cv : varsC[dir],
  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),
  if (cdim = 1) then (
    NSurf : 1, 
    NSurf_2p : 1
  )
  else (
    bSurf : basisFromVars("Tensor", surfVars, 1),
    NSurf : length(bSurf), 
    bSurf_2p : basisFromVars("Tensor", surfVars, polyOrder),
    NSurf_2p : length(bSurf_2p), 
    /* Quadrature evaluation only utilizes a p=1 basis */
    surfConfNodes : gaussOrd(polyOrder+1, cdim-1),
    numConfNodes : length(surfConfNodes)
  ), 

  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  if (cdim > 1) then (
    printf(fh, "#include <gkyl_basis_tensor_~ax_p~a_upwind_quad_to_modal.h> ~%", cdim, polyOrder)
  ),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, 
  const double *u_surf_l, const double *u_surf_c, const double *u_surf_r, 
  const double *prim_surf_l, const double *prim_surf_c, const double *prim_surf_r, 
  const double *pkpm_u_c, const double *bb_c, const double *nu_c, 
  double* GKYL_RESTRICT pkpm_lax, double* GKYL_RESTRICT pkpm_accel) ~%{ ~%", funcNm),
  printf(fh, "  // dxv[NDIM]:       Cell spacing.~%"),
  printf(fh, "  // u_surf_l/c/r: Input surface flow velocity expansion in left/center/right cells in each direction.~%"),
  printf(fh, "  //               [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, ~%"),
  printf(fh, "  //                ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, ~%"),
  printf(fh, "  //                ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr]  ~%"),
  printf(fh, "  // prim_surf_l/c/r: Input surface primitive variables [3*T_ii/m] in left/center/right cells in each direction.~%"),
  printf(fh, "  // pkpm_u_c:     Input volume expansion of flow velocity in center cell.~%"),
  printf(fh, "  // bb_c:         Input volume expansion of magnetic field unit tensor in center cell.~%"),
  printf(fh, "  // nu_c:         Input volume expansion of collisionality in center cell.~%"),
  printf(fh, "  // pkpm_lax:     Surface expansion of pkpm Lax penalization: lambda_i = |u_i| + sqrt(3.0*T_ii/m).~%"),
  printf(fh, "  // pkpm_accel:   Volume expansion of pkpm acceleration variables.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),

  /* prim, b, and bb in center cell for div(b) and bb : grad(u). */
  printf(fh, "  const double *ux_c = &pkpm_u_c[~a]; ~%", 0*NC),
  printf(fh, "  const double *uy_c = &pkpm_u_c[~a]; ~%", 1*NC),
  printf(fh, "  const double *uz_c = &pkpm_u_c[~a]; ~%", 2*NC),
  printf(fh, "~%"),
  printf(fh, "  const double *bxbx = &bb_c[~a]; ~%", 0*NC_2p),
  printf(fh, "  const double *bxby = &bb_c[~a]; ~%", 1*NC_2p),
  printf(fh, "  const double *bxbz = &bb_c[~a]; ~%", 2*NC_2p),
  printf(fh, "  const double *byby = &bb_c[~a]; ~%", 3*NC_2p),
  printf(fh, "  const double *bybz = &bb_c[~a]; ~%", 4*NC_2p),
  printf(fh, "  const double *bzbz = &bb_c[~a]; ~%", 5*NC_2p),
  printf(fh, "~%"),

  /* Surface flow velocity is organized as:
     [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, 
      ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, 
      ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr] */
  printf(fh, "  const double *ux_surf_lr = &u_surf_l[~a]; ~%", (1 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uy_surf_lr = &u_surf_l[~a]; ~%", (3 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uz_surf_lr = &u_surf_l[~a]; ~%", (5 + (dir-1)*6)*NSurf),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_surf_cl = &u_surf_c[~a]; ~%", (0 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uy_surf_cl = &u_surf_c[~a]; ~%", (2 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uz_surf_cl = &u_surf_c[~a]; ~%", (4 + (dir-1)*6)*NSurf),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_surf_cr = &u_surf_c[~a]; ~%", (1 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uy_surf_cr = &u_surf_c[~a]; ~%", (3 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uz_surf_cr = &u_surf_c[~a]; ~%", (5 + (dir-1)*6)*NSurf),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_surf_rl = &u_surf_r[~a]; ~%", (0 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uy_surf_rl = &u_surf_r[~a]; ~%", (2 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uz_surf_rl = &u_surf_r[~a]; ~%", (4 + (dir-1)*6)*NSurf),
  printf(fh, "~%"),

  /* Volume expansion of 3*Tii/m for Lax penalization */
  printf(fh, "  const double *Tii_surf_lr = &prim_surf_l[~a]; ~%", (1 + (dir-1)*2)*NSurf_2p),
  printf(fh, "  const double *Tii_surf_cl = &prim_surf_c[~a]; ~%", (0 + (dir-1)*2)*NSurf_2p),
  printf(fh, "  const double *Tii_surf_cr = &prim_surf_c[~a]; ~%", (1 + (dir-1)*2)*NSurf_2p),
  printf(fh, "  const double *Tii_surf_rl = &prim_surf_r[~a]; ~%", (0 + (dir-1)*2)*NSurf_2p),
  printf(fh, "~%"),

  /* Surface Lax penalization organized as (note T_ii = 3*P_ii/rho, includes necessary factors) : 
     [|ux_xl| + sqrt(Txx_xl), |ux_xr| + sqrt(Txx_xr), 
      |uy_yl| + sqrt(Tyy_yl), |uy_yr| + sqrt(Tyy_yr),
      |uz_zl| + sqrt(Tzz_zl), |uz_zr| + sqrt(Tzz_zr)] */
  printf(fh, "  double *pkpm_lax_l = &pkpm_lax[~a]; ~%", (0 + (dir-1)*2)*NSurf_2p),
  printf(fh, "  double *pkpm_lax_r = &pkpm_lax[~a]; ~%", (1 + (dir-1)*2)*NSurf_2p),
  printf(fh, "~%"),

  printf(fh, "  double *bb_grad_u = &pkpm_accel[~a]; ~%", 1*NC_2p),
  printf(fh, "  double *p_perp_source = &pkpm_accel[~a]; ~%", 3*NC_2p),
  printf(fh, "~%"),

  /* if cdim = 1, then the surface evaluations are just numbers, not expansions */
  if (cdim = 1) then (
    /* Surface component of gradient expansion of u */
    surf_ux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), 0.5*(ux_surf_cl[0] + ux_surf_lr[0])),
    surf_ux_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), 0.5*(ux_surf_rl[0] + ux_surf_cr[0])),

    surf_uy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), 0.5*(uy_surf_cl[0] + uy_surf_lr[0])),
    surf_uy_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), 0.5*(uy_surf_rl[0] + uy_surf_cr[0])),

    surf_uz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), 0.5*(uz_surf_cl[0] + uz_surf_lr[0])),
    surf_uz_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), 0.5*(uz_surf_rl[0] + uz_surf_cr[0])),

    printf(fh, "  double max_u_l = fmax(fabs(ux_surf_lr[0]), fabs(ux_surf_cl[0])); ~%"),
    printf(fh, "  double max_u_r = fmax(fabs(ux_surf_cr[0]), fabs(ux_surf_rl[0])); ~%"),
    printf(fh, "  double max_vth_l = fmax(sqrt(fabs(Tii_surf_lr[0])), sqrt(fabs(Tii_surf_cl[0]))); ~%"),
    printf(fh, "  double max_vth_r = fmax(sqrt(fabs(Tii_surf_cr[0])), sqrt(fabs(Tii_surf_rl[0]))); ~%"),  
    printf(fh, "  pkpm_lax_l[0] = max_u_l + max_vth_l; ~%"),
    printf(fh, "  pkpm_lax_r[0] = max_u_r + max_vth_r; ~%") 
  )
  else (
    ux_surf_lr_e : doExpand1(ux_surf_lr, bSurf),
    ux_surf_cl_e : doExpand1(ux_surf_cl, bSurf),
    ux_surf_cr_e : doExpand1(ux_surf_cr, bSurf),
    ux_surf_rl_e : doExpand1(ux_surf_rl, bSurf),

    uy_surf_lr_e : doExpand1(uy_surf_lr, bSurf),
    uy_surf_cl_e : doExpand1(uy_surf_cl, bSurf),
    uy_surf_cr_e : doExpand1(uy_surf_cr, bSurf),
    uy_surf_rl_e : doExpand1(uy_surf_rl, bSurf),

    uz_surf_lr_e : doExpand1(uz_surf_lr, bSurf),
    uz_surf_cl_e : doExpand1(uz_surf_cl, bSurf),
    uz_surf_cr_e : doExpand1(uz_surf_cr, bSurf),
    uz_surf_rl_e : doExpand1(uz_surf_rl, bSurf),

    /* Surface component of gradient expansion of u */
    surf_ux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), 0.5*(ux_surf_cl_e + ux_surf_lr_e)),
    surf_ux_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), 0.5*(ux_surf_rl_e + ux_surf_cr_e)),

    surf_uy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), 0.5*(uy_surf_cl_e + uy_surf_lr_e)),
    surf_uy_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), 0.5*(uy_surf_rl_e + uy_surf_cr_e)),

    surf_uz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), 0.5*(uz_surf_cl_e + uz_surf_lr_e)),
    surf_uz_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), 0.5*(uz_surf_rl_e + uz_surf_cr_e)),

    /* Compute surface expansion of pkpm Lax penalization by evaluating u_i, T_ii
       at quadrature points and finding max(|u_i_l|, |u_i_r|) + max(sqrt(T_ii_l, T_ii_r)) */
    Tii_surf_lr_e : doExpand1(Tii_surf_lr, bSurf_2p),
    Tii_surf_cl_e : doExpand1(Tii_surf_cl, bSurf_2p),
    Tii_surf_cr_e : doExpand1(Tii_surf_cr, bSurf_2p),
    Tii_surf_rl_e : doExpand1(Tii_surf_rl, bSurf_2p),

    Tii_quad_surf_lr : expand(float(evAtNodes(Tii_surf_lr_e,surfConfNodes,surfVars))),
    Tii_quad_surf_cl : expand(float(evAtNodes(Tii_surf_cl_e,surfConfNodes,surfVars))),
    Tii_quad_surf_cr : expand(float(evAtNodes(Tii_surf_cr_e,surfConfNodes,surfVars))),
    Tii_quad_surf_rl : expand(float(evAtNodes(Tii_surf_rl_e,surfConfNodes,surfVars))),
    if (dir = 1) then (
      u_quad_surf_lr : expand(float(evAtNodes(ux_surf_lr_e,surfConfNodes,surfVars))),
      u_quad_surf_cl : expand(float(evAtNodes(ux_surf_cl_e,surfConfNodes,surfVars))),
      u_quad_surf_cr : expand(float(evAtNodes(ux_surf_cr_e,surfConfNodes,surfVars))),
      u_quad_surf_rl : expand(float(evAtNodes(ux_surf_rl_e,surfConfNodes,surfVars)))
    )
    else if (dir = 2) then (
      u_quad_surf_lr : expand(float(evAtNodes(uy_surf_lr_e,surfConfNodes,surfVars))),
      u_quad_surf_cl : expand(float(evAtNodes(uy_surf_cl_e,surfConfNodes,surfVars))),
      u_quad_surf_cr : expand(float(evAtNodes(uy_surf_cr_e,surfConfNodes,surfVars))),
      u_quad_surf_rl : expand(float(evAtNodes(uy_surf_rl_e,surfConfNodes,surfVars)))
    )
    else (
      u_quad_surf_lr : expand(float(evAtNodes(uz_surf_lr_e,surfConfNodes,surfVars))),
      u_quad_surf_cl : expand(float(evAtNodes(uz_surf_cl_e,surfConfNodes,surfVars))),
      u_quad_surf_cr : expand(float(evAtNodes(uz_surf_cr_e,surfConfNodes,surfVars))),
      u_quad_surf_rl : expand(float(evAtNodes(uz_surf_rl_e,surfConfNodes,surfVars)))
    ),

    printf(fh, "  double ul_r = 0.0; ~%"),
    printf(fh, "  double uc_l = 0.0; ~%"),
    printf(fh, "  double uc_r = 0.0; ~%"),
    printf(fh, "  double ur_l = 0.0; ~%"),
    printf(fh, "  double uQuad_l = 0.0; ~%"),
    printf(fh, "  double uQuad_r = 0.0; ~%"),
    printf(fh, "  double Tiil_r = 0.0; ~%"),
    printf(fh, "  double Tiic_l = 0.0; ~%"),
    printf(fh, "  double Tiic_r = 0.0; ~%"),
    printf(fh, "  double Tiir_l = 0.0; ~%"),
    printf(fh, "  double TiiQuad_l = 0.0; ~%"),
    printf(fh, "  double TiiQuad_r = 0.0; ~%"),
    printf(fh, "  double pkpm_lax_quad_l[~a] = {0.0}; ~%", NSurf_2p),
    printf(fh, "  double pkpm_lax_quad_r[~a] = {0.0}; ~%", NSurf_2p),
    printf(fh, "~%"),
    for i : 1 thru numConfNodes do (
      printf(fh, "  ul_r = ~a; ~%", u_quad_surf_lr[i]),
      printf(fh, "  uc_l = ~a; ~%", u_quad_surf_cl[i]),
      printf(fh, "  uc_r = ~a; ~%", u_quad_surf_cr[i]),
      printf(fh, "  ur_l = ~a; ~%", u_quad_surf_rl[i]),
      printf(fh, "  uQuad_l = fmax(fabs(ul_r), fabs(uc_l)); ~%"),
      printf(fh, "  uQuad_r = fmax(fabs(uc_r), fabs(ur_l)); ~%"),

      printf(fh, "  Tiil_r = ~a; ~%", Tii_quad_surf_lr[i]),
      printf(fh, "  Tiic_l = ~a; ~%", Tii_quad_surf_cl[i]),
      printf(fh, "  Tiic_r = ~a; ~%", Tii_quad_surf_cr[i]),
      printf(fh, "  Tiir_l = ~a; ~%", Tii_quad_surf_rl[i]),      
      printf(fh, "  TiiQuad_l = fmax(sqrt(fabs(Tiil_r)), sqrt(fabs(Tiic_l))); ~%"),
      printf(fh, "  TiiQuad_r = fmax(sqrt(fabs(Tiic_r)), sqrt(fabs(Tiir_l))); ~%"),

      printf(fh, "  pkpm_lax_quad_l[~a] = uQuad_l + TiiQuad_l; ~%", i-1),
      printf(fh, "  pkpm_lax_quad_r[~a] = uQuad_r + TiiQuad_r; ~%", i-1),
      printf(fh, "~%")
    ),
    printf(fh, "  tensor_~ax_p~a_upwind_quad_to_modal(pkpm_lax_quad_l, pkpm_lax_l); ~%", cdim, polyOrder),
    printf(fh, "  tensor_~ax_p~a_upwind_quad_to_modal(pkpm_lax_quad_r, pkpm_lax_r); ~%", cdim, polyOrder)
  ),
  printf(fh, "~%"),

  /* Volume component of gradient expansion of u 
     Solved in the strong form, so includes an evaluation of the volume expansion at surface. */
  uxc_e : doExpand1(ux_c, bC),
  uyc_e : doExpand1(uy_c, bC),
  uzc_e : doExpand1(uz_c, bC),

  uxc_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), subst(cv=-1, uxc_e)),
  uyc_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), subst(cv=-1, uyc_e)),
  uzc_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC_2p), subst(cv=-1, uzc_e)),

  uxc_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), subst(cv=1, uxc_e)),
  uyc_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), subst(cv=1, uyc_e)),
  uzc_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC_2p), subst(cv=1, uzc_e)),

  vol_ux_c : calcInnerProdList(varsC, 1, bC_2p, diff(uxc_e, cv)),
  vol_uy_c : calcInnerProdList(varsC, 1, bC_2p, diff(uyc_e, cv)),
  vol_uz_c : calcInnerProdList(varsC, 1, bC_2p, diff(uzc_e, cv)),

  /* Need bb : grad(u), write out grad(u) for each component of u */
  printf(fh, "  double grad_u_x[~a] = {0.0}; ~%", NC_2p),
  printf(fh, "  double grad_u_y[~a] = {0.0}; ~%", NC_2p),
  printf(fh, "  double grad_u_z[~a] = {0.0}; ~%", NC_2p),

  /* Use collect write expression to factor the dx and reduce number of multiplications 
     Note minus sign on surface terms from left interface due to direction of normal vector */
  writeCExprsCollect1lhsc(grad_u_x, dx1*(vol_ux_c - (surf_ux_l - uxc_l) + (surf_ux_r - uxc_r))),
  printf(fh, "~%"),

  writeCExprsCollect1lhsc(grad_u_y, dx1*(vol_uy_c - (surf_uy_l - uyc_l) + (surf_uy_r - uyc_r))),
  printf(fh, "~%"),

  writeCExprsCollect1lhsc(grad_u_z, dx1*(vol_uz_c - (surf_uz_l - uzc_l) + (surf_uz_r - uzc_r))),
  printf(fh, "~%"),

  /* Expand bb and grad(u) for each component of u */
  bxbx_e : doExpand1(bxbx, bC_2p),
  bxby_e : doExpand1(bxby, bC_2p),
  bxbz_e : doExpand1(bxbz, bC_2p),
  byby_e : doExpand1(byby, bC_2p),
  bybz_e : doExpand1(bybz, bC_2p),
  bzbz_e : doExpand1(bzbz, bC_2p),

  /* Zero out components of grad(u) which are empty. */
  grad_u_x_NoZero : doMakeExprLst(vol_ux_c - (surf_ux_l - uxc_l) + (surf_ux_r - uxc_r), grad_u_x),
  grad_u_x_e : doExpand(grad_u_x_NoZero, bC_2p),

  grad_u_y_NoZero : doMakeExprLst(vol_uy_c - (surf_uy_l - uyc_l) + (surf_uy_r - uyc_r), grad_u_y),
  grad_u_y_e : doExpand(grad_u_y_NoZero, bC_2p),

  grad_u_z_NoZero : doMakeExprLst(vol_uz_c - (surf_uz_l - uzc_l) + (surf_uz_r - uzc_r), grad_u_z),
  grad_u_z_e : doExpand(grad_u_z_NoZero, bC_2p),

  printf(fh, "  double bb_grad_u_comp[~a] = {0.0}; ~%", NC_2p),
  if (dir = 1) then (  
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC_2p, bxbx_e*grad_u_x_e + bxby_e*grad_u_y_e + bxbz_e*grad_u_z_e)
  )
  elseif (dir = 2) then (
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC_2p, bxby_e*grad_u_x_e + byby_e*grad_u_y_e + bybz_e*grad_u_z_e)
  )
  elseif (dir = 3) then (
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC_2p, bxbz_e*grad_u_x_e + bybz_e*grad_u_y_e + bzbz_e*grad_u_z_e)
  ),
  writeCExprs1(bb_grad_u_comp, bb_grad_u_comp_c),
  printf(fh, "~%"),
  flush_output(fh),
  bb_grad_u_e : doExpand1(bb_grad_u_comp, bC_2p),
  bb_grad_u_c : calcInnerProdList(varsC, 1, bC_2p, bb_grad_u_e),
  writeCIncrExprsCollect1lhsc(bb_grad_u, bb_grad_u_c),  
  printf(fh, "~%"),

  nu_e : doExpand1(nu_c, bC_2p),
  /* Configuration space components of vperp characteristics source: bb : grad(u) - div(u) - 2 nu */
  if (dir = 1) then (  
    p_perp_source_c : calcInnerProdList(varsC, 1, bC_2p, bb_grad_u_e - grad_u_x_e - 2.0/cdim*nu_e)
  )
  elseif (dir = 2) then (
    p_perp_source_c : calcInnerProdList(varsC, 1, bC_2p, bb_grad_u_e - grad_u_y_e - 2.0/cdim*nu_e)
  )
  elseif (dir = 3) then (
    p_perp_source_c : calcInnerProdList(varsC, 1, bC_2p, bb_grad_u_e - grad_u_z_e - 2.0/cdim*nu_e)
  ),  
  writeCIncrExprsCollect1lhsc(p_perp_source, p_perp_source_c), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$
