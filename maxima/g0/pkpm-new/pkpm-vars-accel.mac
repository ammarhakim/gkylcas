/* This script generates the kernels for calculating the acceleration
   variables required to update the PKPM system. 

   Acceleration variables are computed with averaging for the gradients (grad_i u_j) 
   where averaging is chosen to ensure phase space incompressibility in the weak sense. 

   Full acceleration variable list: 
   1. p_perp_div_b (p_perp/rho*div(b) = T_perp/m*div(b))
   2. b_grad_u (bb : grad(u))
   3. p_force (total pressure forces in kinetic equation 1/rho div(p_parallel b_hat) - T_perp/m*div(b)
   4. p_perp_source (pressure source for higher Laguerre moments -> bb : grad(u) - div(u) - 2 nu) */

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("recovery")$
load("nodal_operations/nodal_functions")$
fpprec : 24$
cvars : [x, y, z]$

pkpm_p_force(fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, bC_2p, NC, NC_2p, 
   pkpm_div_ppar_e, p_perp_div_b_e, p_force_c],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, 1),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *prim_c, const double *div_b, 
  double* GKYL_RESTRICT pkpm_accel) ~%{ ~%", funcNm),
  printf(fh, "  // prim_c:     Input volume expansion of primitive variables in center cell. ~%"),
  printf(fh, "  //             [1/rho div(p_par b), T_perp/m, m/T_perp, 3*Txx/m, 3*Tyy/m, 3*Tzz/m]. ~%"),
  printf(fh, "  // div_b:      Input volume expansion of div(b) in center cell. ~%"),
  printf(fh, "  // pkpm_accel: Output volume expansion of pkpm acceleration variables. ~%"),
  printf(fh, "~%"),

  /* For computing p_force = 1/rho div(p_par b) - T_perp/m*div(b) */
  printf(fh, "  const double *pkpm_div_ppar = &prim_c[~a]; ~%", 0*NC_2p),
  printf(fh, "  const double *T_perp_over_m = &prim_c[~a]; ~%", 1*NC_2p),
  printf(fh, "~%"),

  printf(fh, "  double *p_perp_div_b = &pkpm_accel[~a]; ~%", 0*NC_2p),
  printf(fh, "  double *p_force = &pkpm_accel[~a]; ~%", 2*NC_2p),
  printf(fh, "~%"),

  printf(fh, "  binop_mul_~ad_tensor_p~a(T_perp_over_m, div_b, p_perp_div_b); ~%", cdim, polyOrder),
  printf(fh, "~%"),

  pkpm_div_ppar_e : doExpand1(pkpm_div_ppar, bC_2p),
  p_perp_div_b_e : doExpand1(p_perp_div_b, bC_2p),

  /* 1/rho div(p_par b) already included in p_force from linear solve */
  p_force_c : calcInnerProdList(varsC, 1, bC_2p, pkpm_div_ppar_e-p_perp_div_b_e),
  writeCIncrExprsCollect1lhsc(p_force, p_force_c),   
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$

pkpm_accel_vars(dir, fh, funcNm, cdim, polyOrder) := block(
  [varsC, bC, bC_2p, NC, NC_2p, cv, surfVars, bSurf, NSurf, surfConfNodes, numConfNodes, 
   ux_surf_lr_e, ux_surf_cl_e, ux_surf_cr_e, ux_surf_rl_e, 
   uy_surf_lr_e, uy_surf_cl_e, uy_surf_cr_e, uy_surf_rl_e, 
   uz_surf_lr_e, uz_surf_cl_e, uz_surf_cr_e, uz_surf_rl_e, 
   Tii_surf_lr_e, Tii_surf_cl_e, Tii_surf_cr_e, Tii_surf_rl_e, 
   Tii_quad_surf_lr, Tii_quad_surf_cl, Tii_quad_surf_cr, Tii_quad_surf_rl, 
   u_quad_surf_lr, u_quad_surf_cl, u_quad_surf_cr, u_quad_surf_rl, 
   surf_ux_l, surf_uy_l, surf_uz_l, 
   surf_ux_r, surf_uy_r, surf_uz_r, 
   uxc_e, uyc_e, uzc_e, vol_ux_c, vol_uy_c, vol_uz_c, 
   bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e,  
   grad_u_x_e, grad_u_y_e, grad_u_z_e,
   bb_grad_u_comp_c, bb_grad_u_e, bb_grad_u_c, 
   nu_e, p_perp_source_c],

  kill(varsC, bC),
  kill(varsC, bC_2p),

  /* Load basis of dimensionality requested. Loads a basis of order p and p/2*/
  [varsC,bC] : loadBasis("Tensor", cdim, 1),
  [varsC,bC_2p] : loadBasis("Tensor", cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  NC_2p : length(bC_2p),

  /* cv = variable to compute gradients in. */
  cv : varsC[dir],
  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),
  if (cdim = 1) then (
    NSurf : 1, 
    NSurf_2p : 1
  )
  else (
    bSurf : basisFromVars("Tensor", surfVars, 1),
    NSurf : length(bSurf), 
    bSurf_2p : basisFromVars("Tensor", surfVars, polyOrder),
    NSurf_2p : length(bSurf_2p), 
    surfConfNodes : gaussOrd(polyOrder+1, cdim-1),
    numConfNodes : length(surfConfNodes)
  ), 

  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_tensor_~ax_p~a_surfx~a_eval_quad.h> ~%", cdim, polyOrder, dir),
  if (cdim > 1) then (
    printf(fh, "#include <gkyl_basis_tensor_~ax_p~a_upwind_quad_to_modal.h> ~%", cdim, polyOrder)
  ),
  printf(fh, "GKYL_CU_DH void ~a(const double *dxv, 
  const double *u_surf_l, const double *u_surf_c, const double *u_surf_r, 
  const double *prim_l, const double *prim_c, const double *prim_r, 
  const double *pkpm_u_c, const double *bvar_c, const double *nu_c, 
  double* GKYL_RESTRICT pkpm_lax, double* GKYL_RESTRICT pkpm_accel) ~%{ ~%", funcNm),
  printf(fh, "  // dxv[NDIM]:       Cell spacing.~%"),
  printf(fh, "  // u_surf_l/c/r: Input surface flow velocity expansion in left/center/right cells in each direction.~%"),
  printf(fh, "  //               [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, ~%"),
  printf(fh, "  //                ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, ~%"),
  printf(fh, "  //                ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr]  ~%"),
  printf(fh, "  // prim_l/c/r:   Input volume expansion of primitive variables [1/rho div(p_par b), T_perp/m, m/T_perp, 3*Txx/m, 3*Tyy/m, 3*Tzz/m] in left/center/right cells.~%"),
  printf(fh, "  // pkpm_u_c:     Input volume expansion of flow velocity in center cell.~%"),
  printf(fh, "  // bvar_c:       Input volume expansion of magnetic field unit vector and tensor in center cell.~%"),
  printf(fh, "  // nu_c:         Input volume expansion of collisionality in center cell.~%"),
  printf(fh, "  // pkpm_lax:     Surface expansion of pkpm Lax penalization: lambda_i = |u_i| + sqrt(3.0*T_ii/m).~%"),
  printf(fh, "  // pkpm_accel:   Volume expansion of pkpm acceleration variables.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),

  /* prim, b, and bb in center cell for div(b) and bb : grad(u). */
  printf(fh, "  const double *ux_c = &pkpm_u_c[~a]; ~%", 0*NC),
  printf(fh, "  const double *uy_c = &pkpm_u_c[~a]; ~%", 1*NC),
  printf(fh, "  const double *uz_c = &pkpm_u_c[~a]; ~%", 2*NC),
  printf(fh, "~%"),
  printf(fh, "  const double *bxbx = &bvar_c[~a]; ~%", 3*NC_2p),
  printf(fh, "  const double *bxby = &bvar_c[~a]; ~%", 4*NC_2p),
  printf(fh, "  const double *bxbz = &bvar_c[~a]; ~%", 5*NC_2p),
  printf(fh, "  const double *byby = &bvar_c[~a]; ~%", 6*NC_2p),
  printf(fh, "  const double *bybz = &bvar_c[~a]; ~%", 7*NC_2p),
  printf(fh, "  const double *bzbz = &bvar_c[~a]; ~%", 8*NC_2p),
  printf(fh, "~%"),

  /* Surface flow velocity is organized as:
     [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, 
      ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, 
      ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr] */
  printf(fh, "  const double *ux_surf_lr = &u_surf_l[~a]; ~%", (1 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uy_surf_lr = &u_surf_l[~a]; ~%", (3 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uz_surf_lr = &u_surf_l[~a]; ~%", (5 + (dir-1)*6)*NSurf),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_surf_cl = &u_surf_c[~a]; ~%", (0 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uy_surf_cl = &u_surf_c[~a]; ~%", (2 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uz_surf_cl = &u_surf_c[~a]; ~%", (4 + (dir-1)*6)*NSurf),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_surf_cr = &u_surf_c[~a]; ~%", (1 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uy_surf_cr = &u_surf_c[~a]; ~%", (3 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uz_surf_cr = &u_surf_c[~a]; ~%", (5 + (dir-1)*6)*NSurf),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_surf_rl = &u_surf_r[~a]; ~%", (0 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uy_surf_rl = &u_surf_r[~a]; ~%", (2 + (dir-1)*6)*NSurf),
  printf(fh, "  const double *uz_surf_rl = &u_surf_r[~a]; ~%", (4 + (dir-1)*6)*NSurf),
  printf(fh, "~%"),

  /* Volume expansion of 3*Tii/m for Lax penalization */
  printf(fh, "  const double *Tii_l = &prim_l[~a]; ~%", (3 + (dir-1))*NC_2p),
  printf(fh, "  const double *Tii_c = &prim_c[~a]; ~%", (3 + (dir-1))*NC_2p),
  printf(fh, "  const double *Tii_r = &prim_r[~a]; ~%", (3 + (dir-1))*NC_2p),
  printf(fh, "~%"),

  /* Surface Lax penalization organized as (note T_ii = 3*P_ii/rho, includes necessary factors) : 
     [|ux_xl| + sqrt(Txx_xl), |ux_xr| + sqrt(Txx_xr), 
      |uy_yl| + sqrt(Tyy_yl), |uy_yr| + sqrt(Tyy_yr),
      |uz_zl| + sqrt(Tzz_zl), |uz_zr| + sqrt(Tzz_zr)] */
  printf(fh, "  double *pkpm_lax_l = &pkpm_lax[~a]; ~%", (0 + (dir-1)*2)*NSurf_2p),
  printf(fh, "  double *pkpm_lax_r = &pkpm_lax[~a]; ~%", (1 + (dir-1)*2)*NSurf_2p),
  printf(fh, "~%"),

  printf(fh, "  double *bb_grad_u = &pkpm_accel[~a]; ~%", 1*NC_2p),
  printf(fh, "  double *p_perp_source = &pkpm_accel[~a]; ~%", 3*NC_2p),
  printf(fh, "~%"),

  /* if cdim = 1, then the surface evaluations are just numbers, not expansions */
  if (cdim = 1) then (
    /* Surface component of gradient expansion of u */
    surf_ux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), 0.5*(ux_surf_cl[0] + ux_surf_lr[0])),
    surf_ux_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), 0.5*(ux_surf_rl[0] + ux_surf_cr[0])),

    surf_uy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), 0.5*(uy_surf_cl[0] + uy_surf_lr[0])),
    surf_uy_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), 0.5*(uy_surf_rl[0] + uy_surf_cr[0])),

    surf_uz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), 0.5*(uz_surf_cl[0] + uz_surf_lr[0])),
    surf_uz_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), 0.5*(uz_surf_rl[0] + uz_surf_cr[0])),

    printf(fh, "  double max_u_l = fmax(fabs(ux_surf_lr[0]), fabs(ux_surf_cl[0])); ~%"),
    printf(fh, "  double max_u_r = fmax(fabs(ux_surf_cr[0]), fabs(ux_surf_rl[0])); ~%"),

    printf(fh, "  double Tiil_r = tensor_1x_p~a_surfx1_eval_quad_node_0_r(Tii_l); ~%", polyOrder),
    printf(fh, "  double Tiic_l = tensor_1x_p~a_surfx1_eval_quad_node_0_l(Tii_c); ~%", polyOrder),  
    printf(fh, "  double Tiic_r = tensor_1x_p~a_surfx1_eval_quad_node_0_r(Tii_c); ~%", polyOrder),
    printf(fh, "  double Tiir_l = tensor_1x_p~a_surfx1_eval_quad_node_0_l(Tii_r); ~%", polyOrder),  

    printf(fh, "  double max_vth_l = fmax(sqrt(fabs(Tiil_r)), sqrt(fabs(Tiic_l))); ~%"),
    printf(fh, "  double max_vth_r = fmax(sqrt(fabs(Tiic_r)), sqrt(fabs(Tiir_l))); ~%"),  
    printf(fh, "  pkpm_lax_l[0] = max_u_l + max_vth_l; ~%"),
    printf(fh, "  pkpm_lax_r[0] = max_u_r + max_vth_r; ~%")  
  )
  else (
    ux_surf_lr_e : doExpand1(ux_surf_lr, bSurf),
    ux_surf_cl_e : doExpand1(ux_surf_cl, bSurf),
    ux_surf_cr_e : doExpand1(ux_surf_cr, bSurf),
    ux_surf_rl_e : doExpand1(ux_surf_rl, bSurf),

    uy_surf_lr_e : doExpand1(uy_surf_lr, bSurf),
    uy_surf_cl_e : doExpand1(uy_surf_cl, bSurf),
    uy_surf_cr_e : doExpand1(uy_surf_cr, bSurf),
    uy_surf_rl_e : doExpand1(uy_surf_rl, bSurf),

    uz_surf_lr_e : doExpand1(uz_surf_lr, bSurf),
    uz_surf_cl_e : doExpand1(uz_surf_cl, bSurf),
    uz_surf_cr_e : doExpand1(uz_surf_cr, bSurf),
    uz_surf_rl_e : doExpand1(uz_surf_rl, bSurf),

    /* Surface component of gradient expansion of u */
    surf_ux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), 0.5*(ux_surf_cl_e + ux_surf_lr_e)),
    surf_ux_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), 0.5*(ux_surf_rl_e + ux_surf_cr_e)),

    surf_uy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), 0.5*(uy_surf_cl_e + uy_surf_lr_e)),
    surf_uy_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), 0.5*(uy_surf_rl_e + uy_surf_cr_e)),

    surf_uz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), 0.5*(uz_surf_cl_e + uz_surf_lr_e)),
    surf_uz_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), 0.5*(uz_surf_rl_e + uz_surf_cr_e)),

    /* Compute surface expansion of pkpm Lax penalization by evaluating u_i, T_ii
       at quadrature points and finding max(|u_i_l|, |u_i_r|) + max(sqrt(T_ii_l, T_ii_r)) */
    if (dir = 1) then (
      u_quad_surf_lr : expand(float(evAtNodes(ux_surf_lr_e,surfConfNodes,surfVars))),
      u_quad_surf_cl : expand(float(evAtNodes(ux_surf_cl_e,surfConfNodes,surfVars))),
      u_quad_surf_cr : expand(float(evAtNodes(ux_surf_cr_e,surfConfNodes,surfVars))),
      u_quad_surf_rl : expand(float(evAtNodes(ux_surf_rl_e,surfConfNodes,surfVars)))
    )
    else if (dir = 2) then (
      u_quad_surf_lr : expand(float(evAtNodes(uy_surf_lr_e,surfConfNodes,surfVars))),
      u_quad_surf_cl : expand(float(evAtNodes(uy_surf_cl_e,surfConfNodes,surfVars))),
      u_quad_surf_cr : expand(float(evAtNodes(uy_surf_cr_e,surfConfNodes,surfVars))),
      u_quad_surf_rl : expand(float(evAtNodes(uy_surf_rl_e,surfConfNodes,surfVars)))
    )
    else (
      u_quad_surf_lr : expand(float(evAtNodes(uz_surf_lr_e,surfConfNodes,surfVars))),
      u_quad_surf_cl : expand(float(evAtNodes(uz_surf_cl_e,surfConfNodes,surfVars))),
      u_quad_surf_cr : expand(float(evAtNodes(uz_surf_cr_e,surfConfNodes,surfVars))),
      u_quad_surf_rl : expand(float(evAtNodes(uz_surf_rl_e,surfConfNodes,surfVars)))
    ),

    printf(fh, "  double ul_r = 0.0; ~%"),
    printf(fh, "  double uc_l = 0.0; ~%"),
    printf(fh, "  double uc_r = 0.0; ~%"),
    printf(fh, "  double ur_l = 0.0; ~%"),
    printf(fh, "  double uQuad_l = 0.0; ~%"),
    printf(fh, "  double uQuad_r = 0.0; ~%"),
    printf(fh, "  double Tiil_r = 0.0; ~%"),
    printf(fh, "  double Tiic_l = 0.0; ~%"),
    printf(fh, "  double Tiic_r = 0.0; ~%"),
    printf(fh, "  double Tiir_l = 0.0; ~%"),
    printf(fh, "  double TiiQuad_l = 0.0; ~%"),
    printf(fh, "  double TiiQuad_r = 0.0; ~%"),
    printf(fh, "  double pkpm_lax_quad_l[~a] = {0.0}; ~%", NSurf_2p),
    printf(fh, "  double pkpm_lax_quad_r[~a] = {0.0}; ~%", NSurf_2p),
    printf(fh, "~%"),
    for i : 1 thru numConfNodes do (
      printf(fh, "  ul_r = ~a; ~%", u_quad_surf_lr[i]),
      printf(fh, "  uc_l = ~a; ~%", u_quad_surf_cl[i]),
      printf(fh, "  uc_r = ~a; ~%", u_quad_surf_cr[i]),
      printf(fh, "  ur_l = ~a; ~%", u_quad_surf_rl[i]),
      printf(fh, "  uQuad_l = fmax(fabs(ul_r), fabs(uc_l)); ~%"),
      printf(fh, "  uQuad_r = fmax(fabs(uc_r), fabs(ur_l)); ~%"),

      printf(fh, "  Tiil_r = tensor_~ax_p~a_surfx~a_eval_quad_node_~a_r(Tii_l); ~%", cdim, polyOrder, dir, i-1),
      printf(fh, "  Tiic_l = tensor_~ax_p~a_surfx~a_eval_quad_node_~a_l(Tii_c); ~%", cdim, polyOrder, dir, i-1),
      printf(fh, "  Tiic_r = tensor_~ax_p~a_surfx~a_eval_quad_node_~a_r(Tii_c); ~%", cdim, polyOrder, dir, i-1),
      printf(fh, "  Tiir_l = tensor_~ax_p~a_surfx~a_eval_quad_node_~a_l(Tii_r); ~%", cdim, polyOrder, dir, i-1),      
      printf(fh, "  TiiQuad_l = fmax(sqrt(fabs(Tiil_r)), sqrt(fabs(Tiic_l))); ~%"),
      printf(fh, "  TiiQuad_r = fmax(sqrt(fabs(Tiic_r)), sqrt(fabs(Tiir_l))); ~%"),

      printf(fh, "  pkpm_lax_quad_l[~a] = uQuad_l + TiiQuad_l; ~%", i-1),
      printf(fh, "  pkpm_lax_quad_r[~a] = uQuad_r + TiiQuad_r; ~%", i-1),
      printf(fh, "~%")
    ),
    printf(fh, "  tensor_~ax_p~a_upwind_quad_to_modal(pkpm_lax_quad_l, pkpm_lax_l); ~%", cdim, polyOrder),
    printf(fh, "  tensor_~ax_p~a_upwind_quad_to_modal(pkpm_lax_quad_r, pkpm_lax_r); ~%", cdim, polyOrder)
  ),
  printf(fh, "~%"),

  /* Volume component of gradient expansion of u 
     Solved in the strong form, so includes an evaluation of the volume expansion at surface. */
  uxc_e : doExpand1(ux_c, bC),
  uyc_e : doExpand1(uy_c, bC),
  uzc_e : doExpand1(uz_c, bC),

  uxc_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), subst(cv=-1, uxc_e)),
  uyc_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), subst(cv=-1, uyc_e)),
  uzc_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), subst(cv=-1, uzc_e)),

  uxc_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), subst(cv=1, uxc_e)),
  uyc_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), subst(cv=1, uyc_e)),
  uzc_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), subst(cv=1, uzc_e)),

  vol_ux_c : calcInnerProdList(varsC, 1, bC, diff(uxc_e, cv)),
  vol_uy_c : calcInnerProdList(varsC, 1, bC, diff(uyc_e, cv)),
  vol_uz_c : calcInnerProdList(varsC, 1, bC, diff(uzc_e, cv)),

  /* Need bb : grad(u), write out grad(u) for each component of u */
  printf(fh, "  double grad_u_x[~a] = {0.0}; ~%", NC),
  printf(fh, "  double grad_u_y[~a] = {0.0}; ~%", NC),
  printf(fh, "  double grad_u_z[~a] = {0.0}; ~%", NC),

  /* Use collect write expression to factor the dx and reduce number of multiplications 
     Note minus sign on surface terms from left interface due to direction of normal vector */
  writeCExprsCollect1lhsc(grad_u_x, dx1*(vol_ux_c - (surf_ux_l - uxc_l) + (surf_ux_r - uxc_r))),
  printf(fh, "~%"),

  writeCExprsCollect1lhsc(grad_u_y, dx1*(vol_uy_c - (surf_uy_l - uyc_l) + (surf_uy_r - uyc_r))),
  printf(fh, "~%"),

  writeCExprsCollect1lhsc(grad_u_z, dx1*(vol_uz_c - (surf_uz_l - uzc_l) + (surf_uz_r - uzc_r))),
  printf(fh, "~%"),

  /* Expand bb and grad(u) for each component of u */
  bxbx_e : doExpand1(bxbx, bC_2p),
  bxby_e : doExpand1(bxby, bC_2p),
  bxbz_e : doExpand1(bxbz, bC_2p),
  byby_e : doExpand1(byby, bC_2p),
  bybz_e : doExpand1(bybz, bC_2p),
  bzbz_e : doExpand1(bzbz, bC_2p),

  grad_u_x_e : doExpand1(grad_u_x, bC),
  grad_u_y_e : doExpand1(grad_u_y, bC),
  grad_u_z_e : doExpand1(grad_u_z, bC),

  printf(fh, "  double bb_grad_u_comp[~a] = {0.0}; ~%", NC_2p),
  if (dir = 1) then (  
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC_2p, bxbx_e*grad_u_x_e + bxby_e*grad_u_y_e + bxbz_e*grad_u_z_e)
  )
  elseif (dir = 2) then (
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC_2p, bxby_e*grad_u_x_e + byby_e*grad_u_y_e + bybz_e*grad_u_z_e)
  )
  elseif (dir = 3) then (
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC_2p, bxbz_e*grad_u_x_e + bybz_e*grad_u_y_e + bzbz_e*grad_u_z_e)
  ),
  writeCExprs1(bb_grad_u_comp, bb_grad_u_comp_c),
  printf(fh, "~%"),
  flush_output(fh),
  bb_grad_u_e : doExpand1(bb_grad_u_comp, bC_2p),
  bb_grad_u_c : calcInnerProdList(varsC, 1, bC_2p, bb_grad_u_e),
  writeCIncrExprsCollect1lhsc(bb_grad_u, bb_grad_u_c),  
  printf(fh, "~%"),

  nu_e : doExpand1(nu_c, bC_2p),
  /* Configuration space components of vperp characteristics source: bb : grad(u) - div(u) - 2 nu */
  if (dir = 1) then (  
    p_perp_source_c : calcInnerProdList(varsC, 1, bC_2p, bb_grad_u_e - grad_u_x_e - 2.0/cdim*nu_e)
  )
  elseif (dir = 2) then (
    p_perp_source_c : calcInnerProdList(varsC, 1, bC_2p, bb_grad_u_e - grad_u_y_e - 2.0/cdim*nu_e)
  )
  elseif (dir = 3) then (
    p_perp_source_c : calcInnerProdList(varsC, 1, bC_2p, bb_grad_u_e - grad_u_z_e - 2.0/cdim*nu_e)
  ),  
  writeCIncrExprsCollect1lhsc(p_perp_source, p_perp_source_c), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$
