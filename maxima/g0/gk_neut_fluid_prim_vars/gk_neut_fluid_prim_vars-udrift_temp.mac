/* This script generates the kernels for calculating the flow velocity udrift_i
   and the temperature using weak division. */

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

/* Special set of kernels which analytically invert the matrix for 1/rho 
   for p=1 using the basis_inv operator. Significantly faster than the bin_op operator,
   but only works for p=1 */
gk_neut_fluid_prim_vars_udrift_temp_set_prob_p1(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, rho_e, expr_ux, expr_uy, expr_uz, expr_temp, i],

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, 
    const double *moms, double gas_gamma, double mass) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count: integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A: preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs: preallocated RHS vector. ~%"),
  printf(fh, "  // moms: moments (rho, rho ux, rho uy, rho uz, totalE).~%"),
  printf(fh, "  // gas_gamma: Adiabatic index. ~%"),
  printf(fh, "  // mass: Species mass. ~%"),
  printf(fh, "~%"),

  printf(fh, "  // For poly_order = 1, we can analytically invert the matrix and just store the solution ~%"),
  printf(fh, "  struct gkyl_mat rhs_ux = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_temp = gkyl_nmat_get(rhs, count+3); ~%"),

  printf(fh, "  // Clear rhs for each component of flow velocity being solved for ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_ux, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uy, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uz, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_temp, 0.0); ~%"),

  printf(fh, "  const double *rho   = &moms[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhoux = &moms[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouy = &moms[~a]; ~%", 2*NC),
  printf(fh, "  const double *rhouz = &moms[~a]; ~%", 3*NC),
  printf(fh, "  const double *totE  = &moms[~a]; ~%", 4*NC),
  printf(fh, "~%"),

  /* Terms in sum rhou . rhou */
  printf(fh, "  double rhouxSq[~a] = {0.0}; ~%", NC),
  printf(fh, "  binop_mul_~ad_~a_p~a(rhoux, rhoux, rhouxSq); ~%", cdim, basisFun, polyOrder),
  printf(fh, " ~%"),
  printf(fh, "  double rhouySq[~a] = {0.0}; ~%", NC),
  printf(fh, "  binop_mul_~ad_~a_p~a(rhouy, rhouy, rhouySq); ~%", cdim, basisFun, polyOrder),
  printf(fh, " ~%"),
  printf(fh, "  double rhouzSq[~a] = {0.0}; ~%", NC),
  printf(fh, "  binop_mul_~ad_~a_p~a(rhouz, rhouz, rhouzSq); ~%", cdim, basisFun, polyOrder),
  printf(fh, " ~%"),

  /* Expand rho. */
  rho_e : doExpand1(rho, bC),

  /* Arrays for storing inverse of rho */
  printf(fh, "  double rho_inv[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_inv(rho, rho_inv); ~%", basisFun, cdim, polyOrder),

  printf(fh, "  // Calculate expansions of flow velocity. ~%"),
  printf(fh, "  double ux[~a] = {0.0}; ~%", NC),
  printf(fh, "  double uy[~a] = {0.0}; ~%", NC),
  printf(fh, "  double uz[~a] = {0.0}; ~%", NC),
  printf(fh, " ~%"),

  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv, rhoux, ux); ~%", cdim, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv, rhouy, uy); ~%", cdim, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv, rhouz, uz); ~%", cdim, basisFun, polyOrder),
  printf(fh, " ~%"),

  /* Compute mass density times temperature. */
  /*   rho T = (gas_gamma - 1)*(mass * E - 1/2 (rho u)^2) */
  printf(fh, "  double rho_temp[~a]; ~%", NC),
  for i : 1 thru NC do (
    printf(fh, "  rho_temp[~a] = (gas_gamma - 1.0)*(mass * totE[~a] - 0.5*(rhouxSq[~a] + rhouySq[~a] + rhouzSq[~a])); ~%", i-1, i-1, i-1, i-1, i-1)
  ),
  printf(fh, "~%"),

  printf(fh, "  // Calculate expansions of temperature. ~%"),
  printf(fh, "  double temp[~a] = {0.0}; ~%", NC),
  printf(fh, " ~%"),

  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv, rho_temp, temp); ~%", cdim, basisFun, polyOrder),

  expr_ux : float(expand(makelist(ux[i],i,0,NC-1))),
  expr_uy : float(expand(makelist(uy[i],i,0,NC-1))),
  expr_uz : float(expand(makelist(uz[i],i,0,NC-1))),
  expr_temp : float(expand(makelist(temp[i],i,0,NC-1))),

  for i : 1 thru length(expr_ux) do (
    printf(fh,"  gkyl_mat_set(&rhs_ux,~a,0,~a); ~%", i-1, expr_ux[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uy,~a,0,~a); ~%", i-1, expr_uy[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uz,~a,0,~a); ~%", i-1, expr_uz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_temp,~a,0,~a); ~%", i-1, expr_temp[i])
  ),
  printf(fh, " ~%"),
  printf(fh, "} ~%")
)$

gk_neut_fluid_prim_vars_udrift_temp_set_prob(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, rho_e, expr_ux, expr_uy, expr_uz, expr_temp, i, u_e, u_c, eq_rho, E_rho, j],

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, 
    const double *moms, double gas_gamma, double mass) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count: integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A: preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs: preallocated RHS vector. ~%"),
  printf(fh, "  // moms: Moments [rho, rho ux, rho uy, rho uz, totalE].~%"),
  printf(fh, "  // gas_gamma: Adiabatic index. ~%"),
  printf(fh, "  // mass: Species mass. ~%"),
  printf(fh, "~%"),

  printf(fh, "  struct gkyl_mat A_ux = gkyl_nmat_get(A, count); ~%"),
  printf(fh, "  struct gkyl_mat A_uy = gkyl_nmat_get(A, count+1); ~%"),
  printf(fh, "  struct gkyl_mat A_uz = gkyl_nmat_get(A, count+2); ~%"),
  printf(fh, "  struct gkyl_mat A_temp = gkyl_nmat_get(A, count+3); ~%"),

  printf(fh, "  struct gkyl_mat rhs_ux = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_temp = gkyl_nmat_get(rhs, count+3); ~%"),

  printf(fh, "  // Clear matrix and rhs for each component of flow velocity being solved for ~%"),
  printf(fh, "  gkyl_mat_clear(&A_ux, 0.0); gkyl_mat_clear(&rhs_ux, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uy, 0.0); gkyl_mat_clear(&rhs_uy, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uz, 0.0); gkyl_mat_clear(&rhs_uz, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_temp, 0.0); gkyl_mat_clear(&rhs_temp, 0.0); ~%"),

  printf(fh, "  const double *rho   = &moms[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhoux = &moms[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouy = &moms[~a]; ~%", 2*NC),
  printf(fh, "  const double *rhouz = &moms[~a]; ~%", 3*NC),
  printf(fh, "  const double *totE  = &moms[~a]; ~%", 4*NC),

  printf(fh, "~%"),
  /* Terms in sum rhou . rhou */
  printf(fh, "  double rhouxSq[~a] = {0.0}; ~%", NC),
  printf(fh, "  binop_mul_~ad_~a_p~a(rhoux, rhoux, rhouxSq); ~%", cdim, basisFun, polyOrder),
  printf(fh, " ~%"),
  printf(fh, "  double rhouySq[~a] = {0.0}; ~%", NC),
  printf(fh, "  binop_mul_~ad_~a_p~a(rhouy, rhouy, rhouySq); ~%", cdim, basisFun, polyOrder),
  printf(fh, " ~%"),
  printf(fh, "  double rhouzSq[~a] = {0.0}; ~%", NC),
  printf(fh, "  binop_mul_~ad_~a_p~a(rhouz, rhouz, rhouzSq); ~%", cdim, basisFun, polyOrder),
  printf(fh, " ~%"),

  /* Compute mass density times temperature. */
  /*   rho T = (gas_gamma - 1)*(mass * E - 1/2 (rho u)^2) */
  printf(fh, "  double rho_temp[~a]; ~%", NC),
  for i : 1 thru NC do (
    printf(fh, "  rho_temp[~a] = (gas_gamma - 1.0)*(mass * totE[~a] - 0.5*(rhouxSq[~a] + rhouySq[~a] + rhouzSq[~a])); ~%", i-1, i-1, i-1, i-1, i-1)
  ),
  printf(fh, "~%"),

  /* Expand rho. */
  rho_e : doExpand1(rho, bC),

  expr_ux : float(expand(makelist(rhoux[i],i,0,NC-1))),
  expr_uy : float(expand(makelist(rhouy[i],i,0,NC-1))),
  expr_uz : float(expand(makelist(rhouz[i],i,0,NC-1))),
  expr_temp : float(expand(makelist(rho_temp[i],i,0,NC-1))),

  for i : 1 thru length(expr_ux) do (
    printf(fh,"  gkyl_mat_set(&rhs_ux,~a,0,~a); ~%", i-1, expr_ux[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uy,~a,0,~a); ~%", i-1, expr_uy[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uz,~a,0,~a); ~%", i-1, expr_uz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_temp,~a,0,~a); ~%", i-1, expr_temp[i])
  ),
  printf(fh, " ~%"),

  /* Generate matrix of unknown coefficients */
  u_e : doExpand1(u,bC),
  u_c : makelist(u[i],i,0,NC-1),
  eq_rho : calcInnerProdList(varsC,u_e,bC,rho_e),
  E_rho : fullratsimp(coefmatrix(eq_rho,u_c)),

  /* declare tmp_rho since matrix entries in A are the same for all operations */
  printf(fh, "  double tmp_rho = 0.0; ~%"),
  /* Matrix is dense so just do a simple write routine */
  for i : 1 thru NC do (
    for j : 1 thru NC do (
      printf(fh,"  tmp_rho = ~a; ~%", float(expand(E_rho[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_ux,~a,~a,~a); ~%", i-1, j-1, tmp_rho),
      printf(fh,"  gkyl_mat_set(&A_uy,~a,~a,~a); ~%", i-1, j-1, tmp_rho),
      printf(fh,"  gkyl_mat_set(&A_uz,~a,~a,~a); ~%", i-1, j-1, tmp_rho),
      printf(fh,"  gkyl_mat_set(&A_temp,~a,~a,~a); ~%", i-1, j-1, tmp_rho),
      printf(fh, " ~%")
    )
  ),
  printf(fh, "} ~%")
)$

gk_neut_fluid_prim_vars_udrift_temp_get_sol(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, i],

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *xsol, 
    double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // count: integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // xsol: Input solution vector. ~%"),
  printf(fh, "  // out: Output volume expansion of flow velocity and temperature;~%"),
  printf(fh, " ~%"),

  printf(fh, "  struct gkyl_mat x_ux = gkyl_nmat_get(xsol, count); ~%"),
  printf(fh, "  struct gkyl_mat x_uy = gkyl_nmat_get(xsol, count+1); ~%"),
  printf(fh, "  struct gkyl_mat x_uz = gkyl_nmat_get(xsol, count+2); ~%"),
  printf(fh, "  struct gkyl_mat x_temp = gkyl_nmat_get(xsol, count+3); ~%"),

  printf(fh, "  double *ux = &out[~a]; ~%", 0*NC),
  printf(fh, "  double *uy = &out[~a]; ~%", 1*NC),
  printf(fh, "  double *uz = &out[~a]; ~%", 2*NC),
  printf(fh, "  double *temp = &out[~a]; ~%", 3*NC),
  printf(fh, "~%"),

  /* Fetch volume expansion solution from linear solve */
  for i : 1 thru NC do (
    printf(fh,"  ux[~a] = gkyl_mat_get(&x_ux,~a,0); ~%", i-1, i-1),
    printf(fh,"  uy[~a] = gkyl_mat_get(&x_uy,~a,0); ~%", i-1, i-1),
    printf(fh,"  uz[~a] = gkyl_mat_get(&x_uz,~a,0); ~%", i-1, i-1),
    printf(fh,"  temp[~a] = gkyl_mat_get(&x_temp,~a,0); ~%", i-1, i-1)
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$

