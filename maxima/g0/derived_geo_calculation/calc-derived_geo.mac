load("modal-basis")$
load("recovery")$
load("nodal_operations/nodal_functions")$
load(stringproc)$
load("out-scripts")$

/* Taking DG fields g_ij and |B| as inputs, this kernel will calculate the other geometric quantities
J = det(g_ij))
b_i = g_iz/sqrt(g_zz)
*/

/*calcDerivedGeo(fh, ndim,basisName, polyOrder) := block(*/
  /* Get nodes and nodal basis */
fh:openw("~/max-out/derived_geo_Ser_3x_p1.c");
ndim:3;
basisName:"Ser";
polyOrder:1;

  evNodes : getNodes(basisName, ndim, polyOrder);
  numCoeffs : length(evNodes);


  kill(varsC, varsP, basisC, basisP);
  load(sconcat("basis-precalc/basis", basisName, ndim, "x"));
  [vars,basis] : [varsC, basisC[polyOrder]];


  N2M : calcNodToModWithNodes(basisName, ndim, polyOrder, evNodes);

  calcModCoeff(gij) := float(
    N2M. transpose( makelist(gij[k] , k, 1, numCoeffs))
    );

  zc_all : [x,y,z];
  zc : makelist(zc_all[k],k,1,ndim);

  mkzlist(S,N) := makelist(S[i],i,0,N-1);


  for i : 1 thru ndim do (
    for j : i  thru ndim do (
      gij_zl: mkzlist(concat(g,i,j), numCoeffs),
      gij_e[i,j]: doExpand(gij_zl, basis)
    )
  );



  sublist : makelist(makelist(zc[m] = evNodes[k][m], m,1,ndim),k,1,numCoeffs);

  numEvNodes : matrix_size(evNodes)[1];

  trimfloat(flt) := if abs(flt) < 1e-15 then 0 else flt ;
  flt(expr) := float(expand(expr));

  disp("defined initial lists");

  /*Construct g matrix for calculation*/
  /*symmetric_sublist : [[g12_n,g21_n], [g13_n,g31_n], [g23_n,g32_n]];*/
  for n : 1 thru numEvNodes do(
    gmat : zeromatrix (3, 3),
    for i:1 thru 3 do(
      for j:1 thru 3 do(
        gmat[i, j] : concat(g,i,j, "_n")[n-1]
      )
    ),
    /*for i : 1 thru length(symmetric_sublist) do(
      gij : subst(symmetric_sublist[i][1], symmetric_sublist[i][2],gij)
    ),*/
    /*gij_n[n] : gij,*/
    J_ne[n] : determinant(gmat),
    for i:1 thru 3 do(
      for j:1 thru 3 do(
        gr_ne[n,i,j] : fullratsimp(invert(gmat)*determinant(gmat))[i,j]
      )
    )
  );
  J_ne : makelist(J_ne[i], i, 1, numEvNodes);
  disp("constructed g matrix");



  /*printf(fh, "GKYL_CU_DH void derived_geo_~ax_~a_p~a(const double *gij, const double *bmag, double *J, double *Jinv, double *grij, double *bi, double *cmag) ~%{ ~%", ndim, basisName, polyOrder);*/
  printf(fh, "#include \"gkyl_calc_derived_geo_kernels.h\"~%~%");
  printf(fh, "GKYL_CU_DH void derived_geo_~ax_~a_p~a(const double *gij, double *J) ~%{ ~%", ndim, basisName, polyOrder);

  disp("printed function signature");

  /*separate gFld*/
  counter : 0;
  for i : 1 thru ndim do (
    for j : i  thru ndim do (
      printf(fh, "const double *g~a~a  = &gij[~a * ~a];~%", i,j, counter, numCoeffs),
      counter : counter + 1
    )
  );
  disp ("separated gFld");

  /*separate grFld*/
  counter : 0;
  for i : 1 thru ndim do (
    for j : i  thru ndim do (
      /*printf(fh, "double *gr~a~a  = &grij[~a * ~a];~%", i,j, counter, numCoeffs),*/
      counter : counter + 1
    )
  );
  disp ("separated grFld");

  /*separate bi*/
  for i : 1 thru ndim do (
      /*printf(fh, "double *b~a  = &bi[~a * ~a];~%", i, i, numCoeffs)*/
      lapd:1
  );
  disp ("separated bi");

  /*allocate nodal bi, g_ij and g^ij*/
  for i : 1 thru ndim do (
    /*printf(fh, "double bi~a_n[~a]; ~%", i, numEvNodes),*/
    for j : i  thru ndim do (
      printf(fh, "double g~a~a_n[~a]; ~%", i, j, numEvNodes)
      /*printf(fh, "double gr~a~a_n[~a]; ~%", i, j, numEvNodes)*/
    )
  );
  disp ("allocated nodal gij");

  /*allocate other nodal quantities*/
  printf(fh, "double J_n[~a]; ~%", numEvNodes);
  /*printf(fh, "double Jinv_n[~a]; ~%", numEvNodes);
  printf(fh, "double cmag_n[~a]; ~%", numEvNodes);*/

  disp ("allocated other nodal quantities");

  /* Now make off diagnoal metric coeffs point to their counterpart*/
  for i : 1 thru ndim do (
    for j : 1  thru i do (
      if not(i=j) then(
        printf(fh, "double *g~a~a_n = g~a~a_n; ~%", i, j, j, i)
      )
    )
  );
  disp ("fixed off diagnoal");

  /*Calculate g at nodes*/
  printf(fh, "// Calculate g_ij at nodes ~%");
  for i : 1 thru ndim do (
    for j : i  thru ndim do (
      for n : 1 thru numEvNodes do (
        printf(fh, " g~a~a_n[~a] = ~a; ~%", i,j,n-1, flt(subst(sublist[n], gij_e[i,j])))
      )
    )
  );



  /*Now calculate J at nodes*/
  /*J_ne[1] : subst ("^"=lambda([a, b], pow(a, b)), J_ne[1]);*/
  /*for n : 1 thru numEvNodes do(
    for i : 1 thru length(symmetric_sublist) do(
      J_ne[n] : subst(symmetric_sublist[i][1], symmetric_sublist[i][2],J_ne[n])
    )
  );*/
  printf(fh, "// Calculate Jsq at nodes ~%");
  writeCExprsNoExpand1(J_n, J_ne);
  printf(fh, "// Jsq at nodes cannot be less than 0 ~%");
  printf(fh, "for (int k=0; k<~a; k++){ J_n[k] =fmax(J_n[k],0); } ~%", numEvNodes);
  /* Take the square root*/
  printf(fh, "// Take the square root ~%");
  for n : 1 thru numEvNodes do(
    printf(fh, "J_n[~a] = sqrt(J_n[~a]); ~%", n-1, n-1)
  );
  printf(fh, "// Convert nodal to modal for J ~%");
  temp:calcModCoeff(mkzlist(J_n,numEvNodes));
  temp2 : makelist(temp[k][1],k,1,numEvNodes);
  writeCExprs1(concat(J),temp2);


  printf(fh, "// Calculate g^ij at nodes ~%");
  for n : 1 thru numEvNodes do(
    /*printf(fh, "gr~a~a_n[~a] = sqrt(J_n[~a]); ~%",i,j, n-1, n-1)*/
    lapd:1
  );

  /*
  printf(fh, "// Convert nodal to modal for gij ~%"),
  for i : 1 thru ndim do (
    for j : i thru ndim do (
      temp :  calcModCoeff(mkzlist(concat(g,i,j,"_n"),numCoeffs)),
      temp2 : makelist(temp[k][1],k,1,numCoeffs),
      writeCExprs1(concat(g,i,j), temp2),
      printf(fh, "~%")
    )
  ),*/

  printf(fh, " ~%");
  printf(fh, "}~%");
/*)$*/
