/* This script generates the kernels for the boundary surface terms from 
   the Boltzmann equation for photons in a reduced 1x2v (z, kpar, kperp) 
   geometry, where z is the motion of the photon along the field line, 
   kpar is the momentum of the photon along the field line, and kperp
   is the momentum of the photon perpendicular to the field. */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

varsV : [vx, vy, vz]$
cvars : [x, y, z]$
vvars : [vx, vy, vz]$

pVsub : [x=vx,y=vy,z=vz]$

dvdx  : [dv0dx0, dv1dx1, dv2dx2]$
wdx   : [w0dx0, w1dx1, w2dx2]$
dx11 : [dx10, dx11, dx12]$
dv11 : [dv10, dv11, dv12]$

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

calcBoltzmannPhotonBoundarySurfStreamUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV, 
   cid, vid, cv, vv, surfVars, bSurf, NSurf,
   gamma_e, p_over_gamma_c, p_over_gamma_NoZero, p_over_gamma_NoZero_e, 
   alpha_c, alphaNoZero, alpha_e, fl_e, fc_e, fr_e, 
   Ghat_r_c, GhatNoZero_r, Ghat_r_e, Ghat_l_c, GhatNoZero_l, Ghat_l_e,  
   incr_l, incr_r],

  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),

  /* polyOrder in velocity space is p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  /* Load 1D basis set for |kpar|, assume piecewise quadratic for now
     the kpar velocity coordinate is the same as the "vx" coordinate 
     (the first velocity coordinate) */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 2), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 

  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv,  double light_speed, double rho_curv, 
  const double *jacob_vel_inv, const double *kpar_abs, const int edge, const double *fEdge, const double *fSkin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]:             Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:           Cell spacing.~%"),
  printf(fh, "  // light_speed:         Speed of light.~%"),
  printf(fh, "  // rho_curv:            Curvature of the magnetic field.~%"),
  printf(fh, "  // jacob_vel_inv[VDIM]: Inverse velocity space Jacobian in each direction.~%"),
  printf(fh, "  // kpar_abs:            Continuous expansion of |kpar| on the grid.~%"),
  printf(fh, "  // edge:                Determines if the update is for the left edge (-1) or right edge (+1).~%"),
  printf(fh, "  // fSkin/fEdge:         Input photon distribution function in skin cell/last edge cell ~%"),
  printf(fh, "  // out:                 Output photon distribution function in skin cell ~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  printf(fh, "  const double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "  const double wv = w[~a]; ~%", vid[dir], vid[dir]),
  printf(fh, "~%"),
  /* Fetch the sign of kpar for the streaming in configuration space */
  printf(fh, "  double sign_kpar = 1.0; ~%"),
  printf(fh, "  if (wv < 0.0) sign_kpar = -1.0; ~%"),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */
  /* cv = variable in direction of surface update. */
  cv : varsP[dir],
  vv : varsV[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vv dependence. */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),
  NSurf : length(bSurf), 

  /* Create expansions of fSkin and fEdge on volume basis. */
  fSkin_e : doExpand1(fSkin, bP),
  fEdge_e : doExpand1(fEdge, bP),
  Ghat_e : doExpand1(Ghat, bSurf), 
  printf(fh, "  double Ghat[~a]; ~%", NSurf),
  /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evauluated at +1 */
  /* In addition we need the drag term evaluated at +1 (so alphaDr evaluated on the right) */
  printf(fh, "  if (edge == -1) { ~%"),  
  printf(fh, "    if (~a>0) { ~%",wv),

  /* Because v > 0, need left edge value */
  /* Evaluate surface projection of Ghat = c fSkin. */
  Ghat_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, fSkin_e)),
  for i : 1 thru NSurf do (
    printf(fh, "      Ghat[~a] = ~a; ~%", i-1, float(expand(Ghat_c[i])))
  ), 
  flush_output(fh),

  printf(fh, "    } ~%"),
  printf(fh, "    else { ~%"),
  
  /* Because v < 0, need right edge value */
  /* Evaluate surface projection of Ghat = -c fEdge. */
  Ghat_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1, fEdge_e)),
  for i : 1 thru NSurf do (
    printf(fh, "      Ghat[~a] = ~a; ~%", i-1, float(expand(Ghat_c[i])))
  ), 
  flush_output(fh),
  
  printf(fh, "    } ~%"),
  /* Compute surface contribution integral(phi^- Ghat) on the right for left edge boundary. */
  incr : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Ghat_e),
  for i : 1 thru NSurf do (
    printf(fh, "    out[~a] += light_speed*sign_kpar*~a*(~a); ~%", i-1, dx11[dir], float(expand(incr[i])))
  ), 
  flush_output(fh),

  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "  } ~%"),
  printf(fh, "  else { ~%"),
  printf(fh, "    if (~a>0) { ~%",wv),

  /* Because v > 0, need left edge value */
  /* Evaluate surface projection of Ghat = c fEdge. */
  Ghat_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, fEdge_e)),
  for i : 1 thru NSurf do (
    printf(fh, "      Ghat[~a] = ~a; ~%", i-1, float(expand(Ghat_c[i])))
  ), 
  flush_output(fh),

  printf(fh, "    } ~%"),
  printf(fh, "    else { ~%"),
  
  /* Because v < 0, need right edge value */
  /* Evaluate surface projection of Ghat = -c fSkin. */
  Ghat_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1, fSkin_e)),
  for i : 1 thru NSurf do (
    printf(fh, "      Ghat[~a] = ~a; ~%", i-1, float(expand(Ghat_c[i])))
  ), 
  flush_output(fh),
  
  printf(fh, "    } ~%"),
  /* Compute surface contribution integral(phi^- Ghat) on the left for right edge boundary. */
  incr : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Ghat_e),
  for i : 1 thru NSurf do (
    printf(fh, "    out[~a] += light_speed*sign_kpar*~a*(~a); ~%", i-1, dx11[dir], float(expand(incr[i])))
  ), 
  flush_output(fh),
  printf(fh, "  } ~%"),

  /* Extra 1/2 factor is because we are multiplying by 2/dx and we only need 1/dx */
  pOrderCFL : polyOrder,
  printf(fh, "  double cflFreq = light_speed; ~%"),
  printf(fh, "  return ~a*cflFreq; ~%",float(0.5*(2*pOrderCFL+1)*dx11[dir])),
  printf(fh, "~%"),

  printf(fh, "} ~%")
);

calcBoltzmannPhotonBoundarySurfMomentumUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV],

  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  /* Load 1D basis set for |kpar|, assume piecewise quadratic for now
     the kpar velocity coordinate is the same as the "vx" coordinate 
     (the first velocity coordinate) */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 2), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 

  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv,  double light_speed, double rho_curv, 
  const double *jacob_vel_inv, const double *kpar_abs, const int edge, const double *fEdge, const double *fSkin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]:             Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:           Cell spacing.~%"),
  printf(fh, "  // light_speed:         Speed of light.~%"),
  printf(fh, "  // rho_curv:            Curvature of the magnetic field.~%"),
  printf(fh, "  // jacob_vel_inv[VDIM]: Inverse velocity space Jacobian in each direction.~%"),
  printf(fh, "  // kpar_abs:            Continuous expansion of |kpar| on the grid.~%"),
  printf(fh, "  // edge:                Determines if the update is for the left edge (-1) or right edge (+1).~%"),
  printf(fh, "  // fSkin/fEdge:         Input photon distribution function in skin cell/last edge cell ~%"),
  printf(fh, "  // out:                 Output photon distribution function in skin cell ~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* vv = variable in direction of surface update. */
  vv : varsV[dir],
  /* Surface variables to integrate over. */
  surfVars : delete(vv,varsP),
  surfVarsV : delete(vv,varsV),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vv dependence. */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),
  NSurf : length(bSurf), 

  /* Load basis sets for inverse Jacobian in corresponding surface direction, 
     which is p=2 in that one velocity dimension (derivative of cubic C^1 mapping)
     also make a 1D basis for |kpar| */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 2), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 
  bV_dir : subst(x=vv, copylist(bV_1D)), 
  NV_1D : length(bV_dir),
  /* Expand |kpar| in first velocity coordinate and 
     inverse velocity space Jacobian in corresponding surface coordinate */
  kpar_abs_e : doExpand1(kpar_abs, bV_vx), 
  jacob_vel_inv_e : doExpand1(jacob_vel_inv_dir, bV_dir), 

  for i : 1 thru vdim do (
    printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i])
  ),
  printf(fh, "  const double *jacob_vel_inv_dir = &jacob_vel_inv[~a]; ~%", NV_1D*(dir-1)),

  if (dir = 2) then (
    printf(fh, "  double alpha[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double Ghat[~a] = {0.0}; ~%", NSurf),
    /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evauluated at +1 */
    /* In addition we need the drag term evaluated at +1 (so alphaDr evaluated on the right) */
    printf(fh, "  if (edge == -1) { ~%~%"),

    alpha_c : calcInnerProdList(surfVars, 1, bSurf, subst(vv=1, jacob_vel_inv_e)*kpar_abs_e), 
    writeCExprs1(alpha, alpha_c), 
    printf(fh, "~%"),
    flush_output(fh),
    /* Zero out components of alpha which are empty. */
    alphaNoZero : makelistNoZeros1(alpha_c, alpha),
    alpha_e     : doExpand(alphaNoZero, bSurf),

    /* Because kpar_abs*light_speed/rho_curv is positive definite, need left edge value */
    /* Evaluate surface projection of Ghat_r = kpar_abs f_c. */
    fSkin_e : doExpand1(fSkin, bP),
    Ghat_c : calcInnerProdList(surfVars, alpha_e, bSurf, subst(vv=1, fSkin_e)),

    writeCExprs1(Ghat, Ghat_c),
    printf(fh, "~%"),
    flush_output(fh), 
    /* Zero out components of Ghat which are empty. */
    Ghat_c : makelistNoZeros1(Ghat_c, Ghat),
    Ghat_e : doExpand(Ghat_c, bSurf),
    
    /* Compute surface contribution integral(phi^- Ghat) on the right for left edge boundary. */
    incr : calcInnerProdList(surfVars, -1, subst(vv=1.0, bP), Ghat_e),
    writeCIncrExprsCollect1lhsc(out, dv11[dir]*(light_speed/rho_curv)*incr),
    printf(fh, "~%"),

    /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "    } ~%"),
  printf(fh, "    else { ~%"),

    alpha_c : calcInnerProdList(surfVars, 1, bSurf, subst(vv=-1, jacob_vel_inv_e)*kpar_abs_e), 
    writeCExprs1(alpha, alpha_c), 
    printf(fh, "~%"),
    flush_output(fh),
    /* Zero out components of alpha which are empty. */
    alphaNoZero : makelistNoZeros1(alpha_c, alpha),
    alpha_e     : doExpand(alphaNoZero, bSurf),

    /* Evaluate surface projection of Ghat_l = kpar_abs f_l. */
    fEdge_e : doExpand1(fEdge, bP),
    Ghat_c : calcInnerProdList(surfVars, alpha_e, bSurf, subst(vv=1, fEdge_e)),

    writeCExprs1(Ghat, Ghat_c),
    printf(fh, "~%"),
    flush_output(fh), 
    /* Zero out components of Ghat which are empty. */
    Ghat_c : makelistNoZeros1(Ghat_c, Ghat),
    Ghat_e : doExpand(Ghat_c, bSurf),
    
    /* Compute surface contribution integral(phi^- Ghat) on the left for right edge boundary. */
    incr : calcInnerProdList(surfVars, 1, subst(vv=-1.0, bP), Ghat_e),
    writeCIncrExprsCollect1lhsc(out, dv11[dir]*(light_speed/rho_curv)*incr),
    printf(fh, "~%"), 
    printf(fh, "  } ~%")
  ),
  /* In the kpar direction, there is no update */
  if (dir = 1) then (
    printf(fh, "  return 0.0; ~%")    
  )
  else (
    /* Extra 1/2 factor is because we are multiplying by 2/dx and we only need 1/dx 
        Also need to divide out 1/sqrt(2^(pDim-1)) to convert 0th component of |kpar|
        expansion to cell average (so we take the surface averaged |kpar| as our estimate of the
        maximum acceleration to compute the largest frequency) */
    pOrderCFL : polyOrder,
    printf(fh, "  double cflFreq = light_speed/rho_curv*alpha[0]; ~%"),
    printf(fh, "  return ~a*cflFreq; ~%",float(0.5*(2*pOrderCFL+1)*dv11[dir]*2.0^(-0.5*(pDim-1))))
  ), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
);
