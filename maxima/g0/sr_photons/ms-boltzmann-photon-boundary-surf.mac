load("sr_photons/boltzmann-photon-boundary-surf")$
load(stringproc)$
/* This script calls the functions which calculate the boundary surface
   updates from the Boltzmann equation for photons in a reduced 1x2v (z, kpar, kperp) 
   geometry, where z is the motion of the photon along the field line, 
   kpar is the momentum of the photon along the field line, and kperp
   is the momentum of the photon perpendicular to the field. 
   In this reduced geometry, we only have a boundary surface term due to advection in 
  kperp (light_speed/rho_curv*|kpar|*df/dkperp) */

/* ...... USER INPUTS........ */

/* Serendipity basis. */
minPolyOrder_Ser : 1$
maxPolyOrder_Ser : 2$
minCdim_Ser : 1$
minVdim_Ser : 2$    /* see begining of v loop below though. */
maxCdim_Ser : 1$
maxVdim_Ser : 2$

/* Tensor product basis. */
/* Note that Serendipity, p = 1, is equivalent to Tensor */
/* Thus no need to calculate p = 1 Tensor basis */
minPolyOrder_Tensor : 2$
maxPolyOrder_Tensor : 2$
minCdim_Tensor : 1$
minVdim_Tensor : 2$    /* see begining of v loop below though. */
maxCdim_Tensor : 1$
maxVdim_Tensor : 2$

/* ...... END OF USER INPUTS........ */

bName        : ["ser","tensor"]$
minPolyOrder : [minPolyOrder_Ser, minPolyOrder_Tensor]$
maxPolyOrder : [maxPolyOrder_Ser, maxPolyOrder_Tensor]$
minCdim      : [minCdim_Ser, minCdim_Tensor]$
minVdim      : [minVdim_Ser, minVdim_Tensor]$
maxCdim      : [maxCdim_Ser, maxCdim_Tensor]$
maxVdim      : [maxVdim_Ser, maxVdim_Tensor]$

clabels : ["x","y","z"]$
vlabels : ["vx","vy","vz"]$

/* Compute the surface contribution in velocity space from the acceleration term */
for bInd : 1 thru length(bName) do (
  for c : minCdim[bInd] thru maxCdim[bInd] do (
    for v : max(c,minVdim[bInd]) thru maxVdim[bInd] do (

      minPolyOrderB : minPolyOrder[bInd],
      maxPolyOrderB : maxPolyOrder[bInd],
      if (c+v>5 and maxPolyOrderB > 1) then maxPolyOrderB : 1,

      for polyOrder : minPolyOrderB thru maxPolyOrderB do (
        disp(printf(false,sconcat("Creating surface Boltzmann photon",bName[bInd]," ~ax~av_p~a"),c,v,polyOrder)),
        for dir : 1 thru c do ( 
          fname : sconcat("~/max-out/boltzmann_photon_boundary_surf", clabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
          fh : openw(fname),
          funcName : sconcat("boltzmann_photon_boundary_surf", clabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
          printf(fh, "#include <gkyl_boltzmann_photon_kernels.h> ~%"),
          calcBoltzmannPhotonBoundarySurfStreamUpdateInDir(dir, fh, funcName, c, v, bName[bInd], polyOrder), 
          close(fh)
        ),
        for dir : 1 thru v do ( 
          fname : sconcat("~/max-out/boltzmann_photon_boundary_surf", vlabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
          fh : openw(fname),
          funcName : sconcat("boltzmann_photon_boundary_surf", vlabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
          printf(fh, "#include <gkyl_boltzmann_photon_kernels.h> ~%"),
          calcBoltzmannPhotonBoundarySurfMomentumUpdateInDir(dir, fh, funcName, c, v, bName[bInd], polyOrder), 
          close(fh)
        )
      )
    )
  )
);