/* This script generates the kernels for the surface terms from 
   the Boltzmann equation for photons in a reduced 1x2v (z, kpar, kperp) 
   geometry, where z is the motion of the photon along the field line, 
   kpar is the momentum of the photon along the field line, and kperp
   is the momentum of the photon perpendicular to the field. 
   In this reduced geometry, we only have a surface term due to advection in 
   z (light_speed*sign(kpar)*df/dz) and advection in kperp (light_speed/rho_curv*|kpar|*df/dkperp) */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

varsV : [vx, vy, vz]$
cvars : [x, y, z]$
vvars : [vx, vy, vz]$

pVsub : [x=vx,y=vy,z=vz]$

dvdx  : [dv0dx0, dv1dx1, dv2dx2]$
wdx   : [w0dx0, w1dx1, w2dx2]$
dx11 : [dx10, dx11, dx12]$
dv11 : [dv10, dv11, dv12]$

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

calcBoltzmannPhotonSurfStreamUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV, 
   cid, vid, cv, vv, surfVars, bSurf, NSurf,
   gamma_e, p_over_gamma_c, p_over_gamma_NoZero, p_over_gamma_NoZero_e, 
   alpha_c, alphaNoZero, alpha_e, fl_e, fc_e, fr_e, 
   Ghat_r_c, GhatNoZero_r, Ghat_r_e, Ghat_l_c, GhatNoZero_l, Ghat_l_e,  
   incr_l, incr_r],

  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),

  /* polyOrder in velocity space is p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  /* Load 1D basis set for |kpar|, assume piecewise quadratic for now
     the kpar velocity coordinate is the same as the "vx" coordinate 
     (the first velocity coordinate) */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 2), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 

  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv,  double light_speed, double rho_curv, 
  const double *jacob_vel_inv, const double *kpar_abs, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]:     Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:   Cell spacing.~%"),
  printf(fh, "  // light_speed: Speed of light.~%"),
  printf(fh, "  // rho_cuv:     Curvature of the magnetic field.~%"),
  printf(fh, "  // jacob_vel_inv[VDIM]: Inverse velocity space Jacobian in each direction.~%"),
  printf(fh, "  // kpar_abs:    Continuous expansion of |kpar| on the grid.~%"),
  printf(fh, "  // fl/fc/fr:    Input photon distribution function in left/center/right cells.~%"),
  printf(fh, "  // out:         Incremented photon distribution function in center cell.~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  printf(fh, "  const double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
  printf(fh, "  const double wv = w[~a]; ~%", vid[dir], vid[dir]),
  printf(fh, "~%"),
  /* Fetch the sign of kpar for the streaming in configuration space */
  printf(fh, "  double sign_kpar = 1.0; ~%"),
  printf(fh, "  if (wv < 0.0) sign_kpar = -1.0; ~%"),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */
  /* cv = variable in direction of surface update. */
  cv : varsP[dir],
  vv : varsV[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vv dependence. */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),
  NSurf : length(bSurf), 

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),
  printf(fh, "  double Ghat_r[~a]; ~%", NSurf),
  printf(fh, "  double Ghat_l[~a]; ~%", NSurf),
  
  printf(fh, "  if (~a>0) { ~%~%",wv),

  /* Because v > 0, need left edge value */
  /* Evaluate surface projection of Ghat_r = v f_c. */
  Ghat_r_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, fc_e)),
  writeCExprsCollect1lhsc(Ghat_r, Ghat_r_c),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero_r : makelistNoZeros1(Ghat_r_c, Ghat_r),
  Ghat_r_e     : doExpand(GhatNoZero_r, bSurf),

  /* Evaluate surface projection of Ghat_l = v f_l. */
  Ghat_l_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, fl_e)),
  writeCExprsCollect1lhsc(Ghat_l, Ghat_l_c),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero_l : makelistNoZeros1(Ghat_l_c, Ghat_l),
  Ghat_l_e     : doExpand(GhatNoZero_l, bSurf),

  printf(fh, "  } else { ~%~%"),
  
  /* Because v < 0, need right edge value */
  /* Evaluate surface projection of Ghat_r = v f_r. */
  Ghat_r_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1, fr_e)),
  writeCExprs1(Ghat_r, Ghat_r_c), 
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of Ghat which are empty. */
  GhatNoZero_r : makelistNoZeros1(Ghat_r_c, Ghat_r),
  Ghat_r_e     : doExpand(GhatNoZero_r, bSurf),

  /* Evaluate surface projection of Ghat_l = v f_c. */
  Ghat_l_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1, fc_e)),
  writeCExprs1(Ghat_l, Ghat_l_c), 
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of Ghat which are empty. */
  GhatNoZero_l : makelistNoZeros1(Ghat_l_c, Ghat_l),
  Ghat_l_e     : doExpand(GhatNoZero_l, bSurf),
  
  printf(fh, "  } ~%"),
  /* Compute surface contribution integral(phi^- Ghat) on the right. */
  incr_l : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Ghat_l_e),
  incr_r : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Ghat_r_e),
  writeCIncrExprsCollect1lhsc(out, dx11[dir]*light_speed*sign_kpar*incr_l + dx11[dir]*light_speed*sign_kpar*incr_r),    
  printf(fh, "~%"),

  /* Extra 1/2 factor is because we are multiplying by 2/dx and we only need 1/dx */
  pOrderCFL : polyOrder,
  printf(fh, "  double cflFreq = light_speed; ~%"),
  printf(fh, "  return ~a*cflFreq; ~%",float(0.5*(2*pOrderCFL+1)*dx11[dir])),
  printf(fh, "~%"),

  printf(fh, "} ~%")
);

calcBoltzmannPhotonSurfMomentumUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV],

  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv,  double light_speed, double rho_curv, 
  const double *jacob_vel_inv, const double *kpar_abs, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]:             Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:           Cell spacing.~%"),
  printf(fh, "  // light_speed:         Speed of light.~%"),
  printf(fh, "  // rho_curv:            Curvature of the magnetic field.~%"),
  printf(fh, "  // jacob_vel_inv[VDIM]: Inverse velocity space Jacobian in each direction.~%"),
  printf(fh, "  // kpar_abs:            Continuous expansion of |kpar| on the grid.~%"),
  printf(fh, "  // fl/fc/fr:            Input photon distribution function in left/center/right cells.~%"),
  printf(fh, "  // out:                 Incremented photon distribution function in center cell.~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* vv = variable in direction of surface update. */
  vv : varsV[dir],
  /* Surface variables to integrate over. */
  surfVars : delete(vv,varsP),
  surfVarsV : delete(vv,varsV),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vv dependence. */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),
  NSurf : length(bSurf), 

  /* Load basis sets for inverse Jacobian in corresponding surface direction, 
     which is p=2 in that one velocity dimension (derivative of cubic C^1 mapping)
     also make a 1D basis for |kpar| */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 2), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 
  bV_dir : subst(x=vv, copylist(bV_1D)), 
  NV_1D : length(bV_dir),
  /* Expand |kpar| in first velocity coordinate and 
     inverse velocity space Jacobian in corresponding surface coordinate */
  kpar_abs_e : doExpand1(kpar_abs, bV_vx), 
  jacob_vel_inv_e : doExpand1(jacob_vel_inv_dir, bV_dir), 

  for i : 1 thru vdim do (
    printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i])
  ),
  printf(fh, "  const double *jacob_vel_inv_dir = &jacob_vel_inv[~a]; ~%", NV_1D*(dir-1)),

  /* In the kpar direction, there is no update */
  if (dir = 1) then (
    printf(fh, "  return 0.0; ~%")    
  )
  else (
    printf(fh, "  double alpha_r[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double alpha_l[~a] = {0.0}; ~%", NSurf), 
    alpha_r_c : calcInnerProdList(surfVars, 1, bSurf, subst(vv=1, jacob_vel_inv_e)*kpar_abs_e), 
    writeCExprs1(alpha_r, alpha_r_c), 
    printf(fh, "~%"),
    flush_output(fh),
    /* Zero out components of alpha which are empty. */
    alphaNoZero_r : makelistNoZeros1(alpha_r_c, alpha_r),
    alpha_r_e     : doExpand(alphaNoZero_r, bSurf),

    alpha_l_c : calcInnerProdList(surfVars, 1, bSurf, subst(vv=-1, jacob_vel_inv_e)*kpar_abs_e), 
    writeCExprs1(alpha_l, alpha_l_c), 
    printf(fh, "~%"),
    flush_output(fh),
    /* Zero out components of alpha which are empty. */
    alphaNoZero_l : makelistNoZeros1(alpha_l_c, alpha_l),
    alpha_l_e     : doExpand(alphaNoZero_l, bSurf),

    printf(fh, "  double Ghat_r[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double Ghat_l[~a] = {0.0}; ~%", NSurf),

    /* Because kpar_abs*light_speed/rho_curv is positive definite, need left edge value */
    /* Evaluate surface projection of Ghat_r = kpar_abs f_c. */
    fc_e : doExpand1(fc, bP),
    Ghat_r_c : calcInnerProdList(surfVars, alpha_r_e, bSurf, subst(vv=1, fc_e)),

    /* Evaluate surface projection of Ghat_l = kpar_abs f_l. */
    fl_e : doExpand1(fl, bP),
    Ghat_l_c : calcInnerProdList(surfVars, alpha_l_e, bSurf, subst(vv=1, fl_e)),

    writeCExprs1(Ghat_l, Ghat_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(Ghat_r, Ghat_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    /* Zero out components of Ghat which are empty. */
    Ghat_r_c : makelistNoZeros1(Ghat_r_c, Ghat_r),
    Ghat_l_c : makelistNoZeros1(Ghat_l_c, Ghat_l),
    Ghat_r_e : doExpand(Ghat_r_c, bSurf),
    Ghat_l_e : doExpand(Ghat_l_c, bSurf),
    
    /* Compute surface contribution integral(phi^- Ghat) on the right. */
    incr_l : calcInnerProdList(surfVars, 1, subst(vv=-1.0, bP), Ghat_l_e),
    incr_r : calcInnerProdList(surfVars, -1, subst(vv=1.0, bP), Ghat_r_e),
    writeCIncrExprsCollect1lhsc(out, dv11[dir]*(light_speed/rho_curv)*incr_l + dv11[dir]*(light_speed/rho_curv)*incr_r),
    printf(fh, "~%"),

    /* Extra 1/2 factor is because we are multiplying by 2/dx and we only need 1/dx 
        Also need to divide out 1/sqrt(2^(pDim-1)) to convert 0th component of |kpar|
        expansion to cell average (so we take the surface averaged |kpar| as our estimate of the
        maximum acceleration to compute the largest frequency) */
    pOrderCFL : polyOrder,
    printf(fh, "  double cflFreq = light_speed/rho_curv*fmax(fabs(alpha_l[0]), fabs(alpha_r[0])); ~%"),
    printf(fh, "  return ~a*cflFreq; ~%",float(0.5*(2*pOrderCFL+1)*dv11[dir]*2.0^(-0.5*(pDim-1))))
  ), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
);
