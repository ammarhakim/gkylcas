load("modal-basis")$
load("recovery")$
load("nodal_operations/nodal_functions")$
load(stringproc)$
load("out-scripts")$

load("bvp_utilities/bvp-util");
load("fem/fem-util");


/* Edges and dirs indicate which skin cells we are in*/
calcMetricCoeffsSkin(fh, ndim,basisName, polyOrder, stencilLoc) := block(
  /* Get nodes and nodal basis */
  evNodes : getNodes(basisName, ndim, polyOrder),
  numCoeffs : length(evNodes),
  N2M : calcNodToModWithNodes(basisName, ndim, polyOrder, evNodes),

  calcModCoeff(gij) := float(
    N2M. transpose( makelist(gij[k] , k, 1, numCoeffs))
    ),

  zc_all : [x,y,z],
  zc : makelist(zc_all[k],k,1,ndim),

  mkzlist(S,N) := makelist(S[i],i,0,N-1),
  /*x_zl will be an array indexed with [var, position]
    order of vars is of course x,y,z
    oder of positions is [I, L, R, B, T]*/
  /* Extra cells needed corresponds to number of 2*ndim*/


  dirNames : [charlist("LIR"), charlist("BIT"), charlist("DIU")] ,
  for i : 1 thru ndim do (
    for j : 1 thru ndim do (
      for k : 1 thru 3 do (
        x_zl[i,j,k] : mkzlist(eval_string(concat("x",i,dirNames[j][k])), numCoeffs)
      )
    )
  ),

  newDirNames : charlist("ILRBTDU"),
  for i : 1 thru ndim do (
    for j : 1 thru 2*ndim+1 do (
        xList[i,j] : concat("x",i,newDirNames[j])
    )
  ),

  for i : 1 thru 2*ndim+1 do (
    xyzList[i] : concat("xyz",newDirNames[i])
  ),

  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisName, ndim, "x")),
  [vars,basis] : [varsC, basisC[polyOrder]],
  /*disp(x_zl[1,1,1]),*/
  /*disp(x_zl[1,1,2]),*/
  /* xp[1,2] means recovery of xp[1] in direction 2 */
  /*x1I is expansion coeffs of X component of mapc2p, x2I is expansion coeffs of Y component*/
  /* 5th argument is continuity*/
  for i : 1 thru ndim do (
    for j : 1 thru ndim do (
      /*disp("i j = ",i,j),*/
      /*disp(zc[j]),*/
      /*disp(doExpand(x_zl[i,j,2], basis)),*/
      /*disp(tempval),*/
         /* Use a one sided stencil in this direction*/
         /* Want to pass val as edge value in recovery dir at node. This is tempval*/
         if stencilLoc[j]=1 then(
           /* Set value*/
           /*tempval : subst(zc[j]=1, doExpand(x_zl[i,j,2], basis)),
           xp[i,j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, dg(x_zl[i,j,1]), dg(x_zl[i,j,2]), bc(D=1,N=0, val=tempval))*/
           /* Set Derivative instead*/
           tempval : subst(zc[j]=1, diff(doExpand(x_zl[i,j,2], basis), zc[j])),
           xp[i,j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, dg(x_zl[i,j,1]), dg(x_zl[i,j,2]), bc(D=0, N=1, val=tempval))

           /*try 2 cell*/
           /*xp[i,j] : calcRecov2CellGen(basisName, zc[j], zc, polyOrder, dg(x_zl[i,j,1]), dg(x_zl[i,j,2]))*/
         ),
         if stencilLoc[j]=-1 then(
           /*tempval : subst(zc[j]=-1, doExpand(x_zl[i,j,2], basis)),
           xp[i,j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, bc(D=1,N=0,val=tempval), dg(x_zl[i,j,2]), dg(x_zl[i,j,3]))*/
           tempval : subst(zc[j]=-1, diff(doExpand(x_zl[i,j,2], basis), zc[j])),
           xp[i,j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, bc(D=0, N=1, val=tempval), dg(x_zl[i,j,2]), dg(x_zl[i,j,3]))

           /*try 2 cell*/
           /*xp[i,j] : calcRecov2CellGen(basisName, zc[j], zc, polyOrder, dg(x_zl[i,j,2]), dg(x_zl[i,j,3]))*/
         ),
         if stencilLoc[j]=0 then(
           /*Regular 2 sided stencil*/
           xp[i,j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, dg(x_zl[i,j,1]), dg(x_zl[i,j,2]), dg(x_zl[i,j,3]))
         )

    )
  ),

  /* Compute the tangent vectors */
  /* dxdz[i,j] = dx[i]/dz[j] */
  for i : 1 thru ndim do (
    for j : 1 thru ndim do (
      dxdz[i,j] : diff(xp[i,j],zc[j])
    )
  ),

  sublist : makelist(makelist(zc[m] = evNodes[k][m], m,1,ndim),k,1,numCoeffs),

  numEvNodes : matrix_size(evNodes)[1],

  trimfloat(flt) := if abs(flt) < 1e-15 then 0 else flt ,
  flt(expr) := float(expand(expr)),


  sig_modifier : sconcat("_"),
  sloc_namelist : ["lo", "in", "up"],
  for i : 1 thru ndim do(
     sig_modifier : sconcat(sig_modifier, sloc_namelist[stencilLoc[i]+2], zc[i], "_")
  ),


  printf(fh, "GKYL_CU_DH void gij~a~ax_~a_p~a( const double **xyz, double *gij) ~%{ ~%", sig_modifier, ndim, basisName, polyOrder),

  for i : 1 thru 2*ndim+1 do (
     printf(fh, "const double *xyz~a = xyz[~a];~%", newDirNames[i], i-1 )
  ),

  for i : 1 thru ndim do (
    for j : 1 thru 2*ndim+1 do (
      printf(fh, "const double *~a  = &~a[~a * ~a];~%", xList[i,j], xyzList[j], i-1, numCoeffs)
    )
  ),


  counter : 0,
  for i : 1 thru ndim do (
    for j : i  thru ndim do (
      printf(fh, "double *g~a~a  = &gij[~a * ~a];~%", i,j, counter, numCoeffs),
      counter : counter + 1
    )
  ),

  printf(fh, "double g11_n[~a], g12_n[~a], g13_n[~a], g22_n[~a], g23_n[~a], g33_n[~a]; ~%",
    numEvNodes, numEvNodes, numEvNodes, numEvNodes, numEvNodes, numEvNodes),

  /* Compute tangent vectors at each node */
  for n : 1 thru numEvNodes do (
    printf(fh, "do { ~%"),
    printf(fh, "  double dxdz[~a][~a]; ~%", ndim, ndim),
    for i : 1 thru ndim do (
      for j : 1 thru ndim do (
        printf(fh, "  dxdz[~a][~a] = ~a; ~%", i-1, j-1, flt(subst(sublist[n], dxdz[i,j])))
        )
      ),
    printf(fh, "  g11_n[~a] = calc_metric(dxdz, 1, 1); ~%", n-1),
    if ndim > 1 then printf(fh, "  g12_n[~a] = calc_metric(dxdz, 1, 2); ~%", n-1),
    if ndim > 2 then printf(fh, "  g13_n[~a] = calc_metric(dxdz, 1, 3); ~%", n-1),
    if ndim > 1 then printf(fh, "  g22_n[~a] = calc_metric(dxdz, 2, 2); ~%", n-1),
    if ndim > 2 then printf(fh, "  g23_n[~a] = calc_metric(dxdz, 2, 3); ~%", n-1),
    if ndim > 2 then printf(fh, "  g33_n[~a] = calc_metric(dxdz, 3, 3); ~%", n-1),
    printf(fh, " } while (0); ~%")
    ),

  printf(fh, "// Convert nodal to modal for gij ~%"),

  for i : 1 thru ndim do (
    for j : i thru ndim do (
      /*writeCExprs1(concat(g,i,j), calcModCoeff(concat(g,i,j,"_n"))),*/
      temp :  calcModCoeff(mkzlist(concat(g,i,j,"_n"),numCoeffs)),
      temp2 : makelist(temp[k][1],k,1,numCoeffs),
      writeCExprs1(concat(g,i,j), temp2),
      printf(fh, "~%")

    )
  ),

  printf(fh, " ~%"),
  printf(fh, "}~%")
)$
