load("modal-basis")$
load("recovery")$
load("nodal_operations/nodal_functions")$
load(stringproc)$
load("out-scripts")$

load("bvp_utilities/bvp-util");
load("fem/fem-util");


/* Edges and dirs indicate which skin cells we are in*/
calcMetricCoeffs(fh, ndim,basisName, polyOrder) := block(
  /* Get nodes and nodal basis */
  evNodes : getNodes(basisName, ndim, polyOrder),
  numCoeffs : length(evNodes),
  N2M : calcNodToModWithNodes(basisName, ndim, polyOrder, evNodes),

  calcModCoeff(gij) := float(
    N2M. transpose( makelist(gij[k] , k, 1, numCoeffs))
    ),

  zc_all : [x,y,z],
  zc : makelist(zc_all[k],k,1,ndim),

  mkzlist(S,N) := makelist(S[i],i,0,N-1),
  /*x_zl will be an array indexed with [var, position]
    order of vars is of course x,y,z
    oder of positions is [I, L, R, B, T]*/
  /* Extra cells needed corresponds to number of 2*ndim*/


  dirNames : [charlist("LIR"), charlist("BIT"), charlist("DIU")] ,
  for i : 1 thru ndim do (
    for j : 1 thru ndim do (
      for k : 1 thru 3 do (
        x_zl[i,j,k] : mkzlist(eval_string(concat("x",i,dirNames[j][k])), numCoeffs)
      )
    )
  ),

  newDirNames : charlist("ILRBTDU"),
  for i : 1 thru ndim do (
    for j : 1 thru 2*ndim+1 do (
        xList[i,j] : concat("x",i,newDirNames[j])
    )
  ),

  for i : 1 thru 2*ndim+1 do (
    xyzList[i] : concat("xyz",newDirNames[i])
  ),

  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisName, ndim, "x")),
  [vars,basis] : [varsC, basisC[polyOrder]],

  /* Begin loop through stencil locations*/
  stencilLocs : getStencilCoords(ndim),
  coordVarS : getCoordVarS(varsC),
  for sI : 1 thru length(stencilLocs) do(
    stencilLoc : stencilLocs[sI],
    /*disp("stencilLoc :" , stencilLoc),*/

    bcTypes : [0, 1],
    bcStrs  : ["periodic", "nonperiodic"],
    bcKey   : makelist([bcTypes[i],bcStrs[i]],i,1,length(bcTypes)),

    bcCombos : [[0]],
    if stencilLoc[1] # 0 then ( bcCombos : makelist([bcTypes[i]],i,1,length(bcTypes)) ),
    for d : 2 thru ndim do (
      bcsInDir : [[0]],
      if stencilLoc[d] # 0 then ( bcsInDir : makelist([bcTypes[i]],i,1,length(bcTypes)) ),
      bcCombos : listify(cartesian_product(setify(bcCombos),setify(bcsInDir))),
      for i : 1 thru length(bcCombos) do ( bcCombos[i] : flatten(bcCombos[i]) )
    ),
    /*disp("bcCombos", bcCombos)*/

      /* Begin BC Loop*/
      for bcI : 1 thru length(bcCombos) do (
        currBC : copylist(bcCombos[bcI]),

        stencilStr : "",
        for d : 1 thru ndim do (
          stencilStr : sconcat(stencilStr,"_",assoc(stencilLoc[d],[[-1,"lo"],[0,"in"],[1,"up"]]),
                       assoc(stencilLoc[d],coordVarS)[d],"_",assoc(currBC[d],bcKey),string(varsC[d]))
        ),
        disp("currBC", currBC),
        disp("stencilStr", stencilStr),

        /*disp(x_zl[1,1,1]),*/
        /*disp(x_zl[1,1,2]),*/
        /* xp[1,2] means recovery of xp[1] in direction 2 */
        /*x1I is expansion coeffs of X component of mapc2p, x2I is expansion coeffs of Y component*/
        /* 5th argument is continuity*/
        for i : 1 thru ndim do (
          for j : 1 thru ndim do (
               if stencilLoc[j]=1 then(
                 if currBC[j] = 0 then (
                   /* Regular 2 sided stencil if it is periodic in this dir*/
                   xp[i,j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, dg(x_zl[i,j,1]), dg(x_zl[i,j,2]), dg(x_zl[i,j,3]))
                 )
                 else (
                   /* two cell recovery using center and right if nonperiodic in this dir*/
                   xp[i,j] : calcRecov2CellGen(basisName, zc[j], zc, polyOrder, dg(x_zl[i,j,1]), dg(x_zl[i,j,2]))
                 )

               ),
               if stencilLoc[j]=-1 then(
                 if currBC[j] = 0 then (
                   /* Regular 2 sided stencil if it is periodic in this dir*/
                   xp[i,j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, dg(x_zl[i,j,1]), dg(x_zl[i,j,2]), dg(x_zl[i,j,3]))
                 )
                 else (
                   /* two cell recovery using left and center if nonperiodic in this dir*/
                   xp[i,j] : calcRecov2CellGen(basisName, zc[j], zc, polyOrder, dg(x_zl[i,j,2]), dg(x_zl[i,j,3]))
                 )
               ),
               if stencilLoc[j]=0 then(
                 /*Regular 2 sided stencil*/
                 xp[i,j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, dg(x_zl[i,j,1]), dg(x_zl[i,j,2]), dg(x_zl[i,j,3]))
               )

          )
        ),

        /* Compute the tangent vectors */
        /* dxdz[i,j] = dx[i]/dz[j] */
        /* last index is lower then upper*/
        for i : 1 thru ndim do (
          for j : 1 thru ndim do (
            dxdz[i,j] : diff(xp[i,j],zc[j])
          )
        ),

        sublist : makelist(makelist(zc[m] = evNodes[k][m], m,1,ndim),k,1,numCoeffs),

        numEvNodes : matrix_size(evNodes)[1],

        trimfloat(flt) := if abs(flt) < 1e-15 then 0 else flt ,
        flt(expr) := float(expand(expr)),


        sig_modifier : sconcat("_"),
        sloc_namelist : ["lo", "in", "up"],
        for i : 1 thru ndim do(
           sig_modifier : sconcat(sig_modifier, sloc_namelist[stencilLoc[i]+2], zc[i], "_")
        ),


        printf(fh, "GKYL_CU_DH void gij_~ax_~a_p~a~a( const double **xyz, double *gij) ~%{ ~%", ndim, basisName, polyOrder, stencilStr),

        for i : 1 thru 2*ndim+1 do (
           printf(fh, "const double *xyz~a = xyz[~a];~%", newDirNames[i], i-1 )
        ),

        for i : 1 thru ndim do (
          for j : 1 thru 2*ndim+1 do (
            printf(fh, "const double *~a  = &~a[~a * ~a];~%", xList[i,j], xyzList[j], i-1, numCoeffs)
          )
        ),


        counter : 0,
        for i : 1 thru ndim do (
          for j : i  thru ndim do (
            printf(fh, "double *g~a~a  = &gij[~a * ~a];~%", i,j, counter, numCoeffs),
            counter : counter + 1
          )
        ),

        printf(fh, "double g11_n[~a], g12_n[~a], g13_n[~a], g22_n[~a], g23_n[~a], g33_n[~a]; ~%",
          numEvNodes, numEvNodes, numEvNodes, numEvNodes, numEvNodes, numEvNodes),

        /* Compute tangent vectors at each node */
        for n : 1 thru numEvNodes do (
          printf(fh, "do { ~%"),
          printf(fh, "  double dxdz[~a][~a]; ~%", ndim, ndim),
          for i : 1 thru ndim do (
            for j : 1 thru ndim do (
              /*disp(sublist[n])*/
              /*disp(rhs(sublist[n][1]))*/
              /* [i, j ] indicates phys, comp coord*/
              /* based on node of comp coord  */
              if stencilLoc[j]=0 then(
                /* Interior cell in this dir, just do substitution*/
                printf(fh, "  dxdz[~a][~a] = ~a; ~%", i-1, j-1, flt(subst(sublist[n], dxdz[i,j])))
              ),
              if stencilLoc[j]=-1 then(
                /* Lower boundary*/
                if currBC[j] = 0 then ( 
                  /* just like interior cell in this dir, just do substitution*/
                  printf(fh, "  dxdz[~a][~a] = ~a; ~%", i-1, j-1, flt(subst(sublist[n], dxdz[i,j])))
                )
                else(/* nonperiodic, do special 2 cell stuff*/
                  if rhs(sublist[n][j])=-1 then (
                    sublist[n][j]: lhs(sublist[n][j]) = -2,
                    printf(fh, "  dxdz[~a][~a] = ~a; ~%", i-1, j-1, flt(subst(sublist[n], dxdz[i,j]))),
                    sublist[n][j]: lhs(sublist[n][j]) = -1
                  ),
                  if rhs(sublist[n][j])=1 then (
                    sublist[n][j] : lhs(sublist[n][j]) = 0,
                    printf(fh, "  dxdz[~a][~a] = ~a; ~%", i-1, j-1, flt(subst(sublist[n], dxdz[i,j]))),
                    sublist[n][j] : lhs(sublist[n][j]) = 1
                  )
                )
              ),
              if stencilLoc[j]=1 then(
                /* Upper boundary*/
                if currBC[j] = 0 then ( 
                  /* just like interior cell in this dir, just do substitution*/
                  printf(fh, "  dxdz[~a][~a] = ~a; ~%", i-1, j-1, flt(subst(sublist[n], dxdz[i,j])))
                )
                else(/* nonperiodic, do special 2 cell stuff*/
                  if rhs(sublist[n][j])=-1 then (
                    sublist[n][j]: lhs(sublist[n][j]) = 0,
                    printf(fh, "  dxdz[~a][~a] = ~a; ~%", i-1, j-1, flt(subst(sublist[n], dxdz[i,j]))),
                    sublist[n][j]: lhs(sublist[n][j]) = -1
                  ),
                  if rhs(sublist[n][j])=1 then (
                    sublist[n][j] : lhs(sublist[n][j]) = 2,
                    printf(fh, "  dxdz[~a][~a] = ~a; ~%", i-1, j-1, flt(subst(sublist[n], dxdz[i,j]))),
                    sublist[n][j] : lhs(sublist[n][j]) = 1
                  )
                )
              )
            )
          ),
          printf(fh, "  g11_n[~a] = calc_metric(dxdz, 1, 1); ~%", n-1),
          if ndim > 1 then printf(fh, "  g12_n[~a] = calc_metric(dxdz, 1, 2); ~%", n-1),
          if ndim > 2 then printf(fh, "  g13_n[~a] = calc_metric(dxdz, 1, 3); ~%", n-1),
          if ndim > 1 then printf(fh, "  g22_n[~a] = calc_metric(dxdz, 2, 2); ~%", n-1),
          if ndim > 2 then printf(fh, "  g23_n[~a] = calc_metric(dxdz, 2, 3); ~%", n-1),
          if ndim > 2 then printf(fh, "  g33_n[~a] = calc_metric(dxdz, 3, 3); ~%", n-1),
          printf(fh, " } while (0); ~%")
          ),

        printf(fh, "// Convert nodal to modal for gij ~%"),

        for i : 1 thru ndim do (
          for j : i thru ndim do (
            /*writeCExprs1(concat(g,i,j), calcModCoeff(concat(g,i,j,"_n"))),*/
            temp :  calcModCoeff(mkzlist(concat(g,i,j,"_n"),numCoeffs)),
            temp2 : makelist(temp[k][1],k,1,numCoeffs),
            writeCExprs1(concat(g,i,j), temp2),
            printf(fh, "~%")

          )
        ),

        printf(fh, " ~%"),
        printf(fh, "}~%")



      )
      /* End BC Loop*/



  /* End StencilLoc Loop*/
  )
)$
