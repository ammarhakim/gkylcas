/* Functions which compute the components of the surface update of the Vlasov 
   equation using a discontinuous Galerkin (DG) method. Advection in
   configuration space is computed as velocity gradients of a Hamiltonian. 
   In the case when the Hamiltonian that only depends on velocity space,
   **we assume the origin (v=0) is at a velocity-space cell edge** and thus
   we can just check the sign of the cell center value for the upwind 
   direction. In the case when the Hamiltonian depends on phase space
   we utilize a standard Lax-Friedrichs flux for continuous characteristics: 
   G = alpha/2*(f^+ + f^-) - |alpha|/2*(f^+ - f^-)
   evaluated at nodes and converted back to a modal expansion. Note that 
   we do not make any assumptions on the order of the phase space expansion
   and thus to evaluate G, we must utilize enough Gauss-Legendre quadrature points
   to integrate a 3*p polynomial (cubic for p=1, sixth order for p=2, ninth order for p=3). 
   We thus must use 2, 4, and 5 Gauss-Legendre points respectively. 

   We do similar evaluations for the velocity-space update, but for the velocity-space
   update, we pre-compute the modal expansion of the flux to allow for ease of 
   accumulation of different forces (Hamiltonian, electromagnetic, scalar potentials, etc.). 
   Thus, the velocity-space update simply evaluates the final surface integral with the
   computed modal expansion of the flux at that interface. 
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
dx11 : [dx10, dx11, dx12]$
dv11 : [dv10, dv11, dv12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Phase-space Hamiltonian surface streaming */
calcHamilGenSurfStreamNonCanonicalHelper(dir, fh, funcNm, cdim, vdim, basisFun, nodeNum, polyOrder, useHigherOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,vid,hamil,cv,vv,surfVars,surfCVars, 
   bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes, 
   NSurf,num_nodes_conf,num_nodes_vel,numNodes,fl_e,fc_e,fr_e,
   Pi_dH_dv_l_n,Pi_dH_dv_r_n,f_lr_n,f_cl_n,f_cr_n,f_rl_n,
   Fhat_r_nodal_e,Fhat_l_nodal_e,Fhat_r_c,Fhat_l_c,Fhat_l_e,Fhat_r_e,incr_l,incr_r],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bC),  

  printf(fh, "#include <gkyl_nc_hamil_surf_comps_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
   const double *poisson_tensor_conf, const double *hamil, const double *fl, 
   const double *fc, const double *fr, double* GKYL_RESTRICT alpha_max, double* GKYL_RESTRICT Fhat_l_nodal,
   double* GKYL_RESTRICT Fhat_r_nodal) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  for i : 1 thru vdim do printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i]),
  printf(fh, "~%"),
  hamil : doExpand1(hamil, bV), /* Hamiltonian a function of the *velocity* phase space. */

  /* Save enough names for 3D */
  poissonTensorConf : [poisson_tensor_conf_0, poisson_tensor_conf_1, poisson_tensor_conf_2],

  /* Surface contribution is defined as integral(phi^- Fhat) over the surface. */
  /* cv = variable in direction of surface update. */
  cv : varsP[dir],
  vv : varsV[dir], 
  surfVars : delete(cv,varsP), /* Surface variables at constant cv surface. */
  surfCVars : delete(cv,varsC), /* Remaining configuration space variables at cv surface. */
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovConfSurfBasis(cdim, vdim, basisFun, polyOrder, surfVars, surfCVars, varsV, useHigherOrder),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  /* Compute the charateristic for the NC Poisson Tensor */
  Pi_dH_dv : 0,
  for j : 1 thru vdim do (

    /* Offset the row by NC*(dir - 1)*vdim components */
    printf(fh, "  const double *poisson_tensor_conf_~a = &poisson_tensor_conf[~a]; ~%", j - 1, NC*(dir-1)*vdim + NC*(j-1)),

    poissonTensorConf_local : doExpand1(poissonTensorConf[j],bC),
    v_diff : varsV[j],
    Pi_dH_dv : Pi_dH_dv + poissonTensorConf_local*diff(hamil,v_diff)*dv11[j]
  ),

  Pi_dH_dv_l_n : float(evAtNodes(subst(cv=-1,Pi_dH_dv),[surfNodes[nodeNum]],surfVars)), 
  Pi_dH_dv_r_n : float(evAtNodes(subst(cv=1,Pi_dH_dv),[surfNodes[nodeNum]],surfVars)), 
  f_lr_n : float(evAtNodes(subst(cv=1,fl_e),[surfNodes[nodeNum]],surfVars)), 
  f_cl_n : float(evAtNodes(subst(cv=-1,fc_e),[surfNodes[nodeNum]],surfVars)), 
  f_cr_n : float(evAtNodes(subst(cv=1,fc_e),[surfNodes[nodeNum]],surfVars)), 
  f_rl_n : float(evAtNodes(subst(cv=-1,fr_e),[surfNodes[nodeNum]],surfVars)), 
  printf(fh, "  double alpha_l_quad = 0.0; ~%"), 
  printf(fh, "  double alpha_r_quad = 0.0; ~%"), 
  printf(fh, "  double f_lr_quad = 0.0; ~%"), 
  printf(fh, "  double f_cl_quad = 0.0; ~%"), 
  printf(fh, "  double f_cr_quad = 0.0; ~%"), 
  printf(fh, "  double f_rl_quad = 0.0; ~%"), 
  printf(fh, "  alpha_l_quad = ~a; ~%", Pi_dH_dv_l_n[1]), 
  printf(fh, "  alpha_r_quad = ~a; ~%", Pi_dH_dv_r_n[1]), 
  printf(fh, "  alpha_max[0] = fmax(alpha_max[0], fmax(fabs(alpha_l_quad), fabs(alpha_r_quad))); ~%"), 
  printf(fh, "  f_lr_quad = ~a; ~%", f_lr_n[1]), 
  printf(fh, "  f_cl_quad = ~a; ~%", f_cl_n[1]), 
  printf(fh, "  f_cr_quad = ~a; ~%", f_cr_n[1]), 
  printf(fh, "  f_rl_quad = ~a; ~%", f_rl_n[1]), 
  printf(fh, "  double Fhat_l_nodal = 0.5*(alpha_l_quad*(f_cl_quad + f_lr_quad) - fabs(alpha_l_quad)*(f_cl_quad - f_lr_quad)); ~%"), 
  printf(fh, "  double Fhat_r_nodal = 0.5*(alpha_r_quad*(f_rl_quad + f_cr_quad) - fabs(alpha_r_quad)*(f_rl_quad - f_cr_quad)); ~%"), 
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$  


/* Phase-space Hamiltonian boundary surface streaming */
calcHamilGenBoundarySurfStreamNonCanonicalHelper(dir, fh, funcNm, cdim, vdim, basisFun, nodeNum, polyOrder, useHigherOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,vid,hamil,cv,vv,surfVars,surfCVars, 
   bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes, 
   NSurf,num_nodes_conf,num_nodes_vel,numNodes,
   fedge_e,fskin_e,incr],

  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC),  


  /* Left-side function */
  printf(fh, "#include <gkyl_nc_hamil_surf_comps_kernels.h> ~%"),
  funcNameFhat_l : sconcat("vlasov_nc_hamil_gen_boundary_surf_node",(nodeNum-1),"_",clabels[dir],"_", cdim, "x", vdim, "v_", basisFun, "_p", polyOrder),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const int edge,
   const double *poisson_tensor_conf, const double *hamil, const double *fl, 
   const double *fr, double* GKYL_RESTRICT Fhat_nodal) ~%{ ~%", funcNameFhat_l),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  for i : 1 thru vdim do printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i]),
  printf(fh, "  double f_l_quad = 0.0; ~%"), 
  printf(fh, "  double f_r_quad = 0.0; ~%"),  

  hamil : doExpand1(hamil, bV), /* Hamiltonian a function of the full phase space. */

  /* Surface contribution is defined as integral(phi^- Fhat) over the surface. */
  /* cv = variable in direction of surface update. */
  cv : varsP[dir],
  vv : varsV[dir], 
  surfVars : delete(cv,varsP), /* Surface variables at constant cv surface. */
  surfCVars : delete(cv,varsC), /* Remaining configuration space variables at cv surface. */
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovConfSurfBasis(cdim, vdim, basisFun, polyOrder, surfVars, surfCVars, varsV, useHigherOrder),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  /* Create expansions of f_edge and f_skin on volume basis. */
  fL_e : doExpand1(fl, bP),
  fR_e : doExpand1(fr, bP),

  /* Save enough names for 3D */
  poissonTensorConf : [poisson_tensor_conf_0, poisson_tensor_conf_1, poisson_tensor_conf_2],

  /* Compute the charateristic for the NC Poisson Tensor */
  Pi_dH_dv : 0,
  for j : 1 thru vdim do (

    /* Offset the row by NC*(dir - 1)*vdim components */
    printf(fh, "  const double *poisson_tensor_conf_~a = &poisson_tensor_conf[~a]; ~%", j - 1, NC*(dir-1)*vdim + NC*(j-1)),

    poissonTensorConf_local : doExpand1(poissonTensorConf[j],bC),
    v_diff : varsV[j],
    Pi_dH_dv : Pi_dH_dv + poissonTensorConf_local*diff(hamil,v_diff)*dv11[j]
  ),

  /* NOTE: WE ARE USING L TO DENOTE THE LEFT EDGE UPDATE AND R TO DENOTE RIGHT EDGE UPDATE OF GLOBAL DOMAIN */
  printf(fh, "~%"),
  printf(fh, "  double alpha_quad = 0.0; ~%"), 
  /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evauluated at +1 */
  printf(fh, "  if (edge == -1) { ~%"),
  evAt : 1.0,
  dH_dv_n : float(evAtNodes(subst(cv=evAt,Pi_dH_dv),[surfNodes[nodeNum]],surfVars)), 
  printf(fh, "    alpha_quad = ~a; ~%", dH_dv_n[1]),

  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "  } else { ~%~%"),
  evAt : -1.0,
  dH_dv_n : float(evAtNodes(subst(cv=evAt,Pi_dH_dv),[surfNodes[nodeNum]],surfVars)), 
  printf(fh, "    alpha_quad = ~a; ~%", dH_dv_n[1]),
  printf(fh, "  } ~%"),


  f_l_n : float(evAtNodes(subst(cv=1,fL_e),[surfNodes[nodeNum]],surfVars)), 
  f_r_n : float(evAtNodes(subst(cv=-1,fR_e),[surfNodes[nodeNum]],surfVars)), 
  printf(fh, " ~%"),
  printf(fh, "  f_l_quad = ~a; ~%", f_l_n[1]), 
  printf(fh, "  f_r_quad = ~a; ~%", f_r_n[1]), 
  printf(fh, "  double Fhat_nodal = 0.5*(alpha_quad*(f_r_quad + f_l_quad) - fabs(alpha_quad)*(f_r_quad - f_l_quad)); ~%"), 

  /* Construct the nodal expansion from a tensor product of the configuration-space nodal basis 
      and velocity-space nodal basis. We do this separation because Maxima struggles to make
      high dimensional nodal bases and we know the basis we need is a tensor product of two
      lower dimensional basis sets. */
  basisNodalConf_index : floor((nodeNum-1)/num_nodes_vel) + 1,
  basisNodalVel_index  : mod(nodeNum-1, num_nodes_vel) + 1,
  Fhat_nodal_e : Fhat_nodal*basisNodalVel[basisNodalVel_index]*basisNodalConf[basisNodalConf_index],

  printf(fh, "} ~%")
)$ 