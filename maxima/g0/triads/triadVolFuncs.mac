/* Functions which compute the components of the volume update of the Vlasov 
   equation using a discontinuous Galerkin (DG) method. Different 
   component include: 
   1. Streaming in configuration space via velocity-space derivatives of 
      the Hamiltonian, with either a velocity-space only Hamiltonian such as
      H = p^2/2m or H = mc^2*sqrt(1 + p^2), or a full phase-space Hamiltonian
      including geometric terms, H = g^ij p_i p_j/2m. 
   2. Forces in velocity space due to geometric terms in the Hamiltonian, -grad_x(H)
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
pt_conf_total : [1,6,18]$ 
dx1 : [dx10, dx11, dx12]$
dv1 : [dv10, dv11, dv12]$
vTrans  : [vx*dv1[1]/2+wx1, vy*dv1[2]/2+wx2, vz*dv1[3]/2+wx3]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
PB_vol(f,g,x,y) := diff(f,x)*diff(g,y) - diff(g,x)*diff(f,y)$


grab_dir_from_pt_index(vdim, pt_index) := block(
  [pairs, ijk],

  /* ijk correspond to: (row, column, j-index) of the poisson tensor*/

  if vdim = 1 then (
    /* 1D: Shape of conf_poisson_tensor non-zero elements.
    +----+----+
    | -- | 00 |
    +----+----+
    | -- | -- |
    +----+----+
    */
    pairs : [[1, 2, 0]]
  )
  else if vdim = 2 then (
    /* 2D: Shape of conf_poisson_tensor non-zero elements.
    +----+----+----+----+
    | -- | -- | 00 | 01 |
    +----+----+----+----+
    | -- | -- | 02 | 03 |
    +----+----+----+----+
    | -- | -- | -- |04+j|
    +----+----+----+----+
    | -- | -- | -- | -- |
    +----+----+----+----+
    */
    pairs : [[1,3,0],[1,4,0],
             [2,3,0],[2,4,0],
             [3,4,1],[3,4,2]]
  )
  else if vdim = 3 then (
    /* 3D: Shape of conf_poisson_tensor non-zero elements.
    +----+----+----+----+----+----+
    | -- | -- | -- | 00 | 01 | 02 |
    +----+----+----+----+----+----+
    | -- | -- | -- | 03 | 04 | 05 |
    +----+----+----+----+----+----+
    | -- | -- | -- | 06 | 07 | 08 |
    +----+----+----+----+----+----+
    | -- | -- | -- | -- |09+j|10+j|
    +----+----+----+----+----+----+
    | -- | -- | -- | -- | -- |11+j|
    +----+----+----+----+----+----+
    | -- | -- | -- | -- | -- | -- |
    +----+----+----+----+----+----+
    */
    pairs : [[1,4,0],[1,5,0],[1,6,0],
             [2,4,0],[2,5,0],[2,6,0],
             [3,4,0],[3,5,0],[3,6,0],
             [4,5,1],[4,6,1],[5,6,1],
             [4,5,2],[4,6,2],[5,6,2],
             [4,5,3],[4,6,3],[5,6,3]]
  ),

  ijk : pairs[pt_index],
  return(ijk)
)$


/* Hamiltonian volume contribution for Non-Canonical Brackets, either just streaming, 
   grad_x(w) . grad_v(H) f, if Hamiltonian only depends on velocity space, or, 
   grad_x(w) . grad_v(H) f - grad_v(w) . grad_x(H) f  */
calcHamilVolNonCanonical(fh, funcNm, cdim, vdim, basisFun, polyOrder, hamil_vel, vmap) := block(
  [varsC,bC,varsV,bV,varsP,bP,NP,
   bV_vi,NV_1D,jacobNodes,numJacobNodes,jacobNodes_vi,basisNodal_vi,
   cid,vid,pb_dim,hamil,f_e,
   fl_v,jacob_vi,basisNodal,fl_v_ne,f_no_J_c,clst_J,f_vol_e,
   pb,pbBasis,clst_vol, poissonTensorConf, pdim, NC, pt_conf_comp_total,
   dir, pt_index, dir1, dir2, index_vsum, varsP1, varsP2, dz_val1, dz_val2, dvol, p_factor,
   poissonTensorConf_local],

  pdim : cdim + vdim,
  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 
  NP : length(bP), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  const double *jacob_vel, const double *poisson_tensor_conf, const double *hamil, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  if (hamil_vel) then (
    hamil : doExpand1(hamil, bV)
  )
  else (
    hamil : doExpand1(hamil, bP)    
  ),
  f_e : doExpand1(f, bP),

  /* Save enough distribution names for 3D */
  poissonTensorConf : [poisson_tensor_conf_0, poisson_tensor_conf_1, poisson_tensor_conf_2, 
    poisson_tensor_conf_3, poisson_tensor_conf_4, poisson_tensor_conf_5, poisson_tensor_conf_6,
    poisson_tensor_conf_7, poisson_tensor_conf_8, poisson_tensor_conf_9, poisson_tensor_conf_10,
    poisson_tensor_conf_11, poisson_tensor_conf_12, poisson_tensor_conf_13, poisson_tensor_conf_14,
    poisson_tensor_conf_15, poisson_tensor_conf_16, poisson_tensor_conf_17],

  pt_conf_comp_total : pt_conf_total[vdim],
  
  cid : cidx(cdim),
  vid : vidx(cdim,vdim), 
  for dir : 1 thru cdim do printf(fh, "  const double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  for dir : 1 thru vdim do printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),

  /* Create a projection of the momentum */
  for i : 1 thru vdim do (
    printf(fh, "  const double wx~a = w[~a]; ~%", i, cdim+i-1),
    printf(fh, "  const double dv1~a_sq = dv1~a*dv1~a; ~%",  i-1, i-1, i-1)
  ),


  /* for a 2*vdim space varsPFull */
  if (vdim = 3) then (
    varsPFull : [x, y, z, vx, vy, vz]
  )
  else if (vdim = 2) then (
    varsPFull : [x, y, vx, vy]
  )
  else if (vdim = 1) then (
    varsPFull : [x, vx]
  ),

  /* The Poisson Tensor is sparse and antisymmetric, which is exploited here by only
    indexing over unique and non-zero elements */
  /* If the system is independant of a spatial coordinate, this code skips those contributions
    which are zero */
  /* Assumed a 2*vdim Poisson tensor size. */
  /* cdim is only used to determind coordinate independance. */
  printf(fh, "  ~%"),
  f_vol_e : f_e, 
  for pt_index : 1 thru pt_conf_comp_total do (
    [dir1, dir2, index_vsum] : grab_dir_from_pt_index(vdim, pt_index),
    varsP1 : varsPFull[dir1], varsP2 : varsPFull[dir2],

    poissonTensorConf_local : doExpand1(poissonTensorConf[pt_index],bC),

    /* Exclude making variables for when cdim < vdim */
    if not((( dir1 <= vdim ) and ( dir1 > cdim )) or (( dir2 <= vdim ) and ( dir2 > cdim ))) then (
      printf(fh, "  const double *poisson_tensor_conf_~a = &poisson_tensor_conf[~a]; ~%", pt_index - 1, NC*(pt_index-1)),

      /* Compute the volume element */
      if (dir1 <= vdim ) then dz_val1 : dx1[dir1] else dz_val1 : dv1[dir1-vdim],
      if (dir2 <= vdim ) then dz_val2 : dx1[dir2] else dz_val2 : dv1[dir2-vdim],
      dvol : dz_val1*dz_val2, 

      /* For cdim /= vdim, we assume the ignorable coordinates are the last pairs.
        For instance if we have varsC = [x,y,z] with:
        - 1 ignorable coordinate: [x, y, \dot{x}, \dot{y}] are all that show up in {f,H} 
        - 2 ignorable coordinates: [x, \dot{x},] are all that show up in {f,H} 
        It is assumed that H does not depend on these ignorable coordinates. */

      /* Convert to a phase space PT by mulitplying by p for the bottom right block comps */
      if ( (dir1 > vdim) and (dir2 > vdim) ) then p_factor : vTrans[index_vsum] else p_factor : 1,
      pbBasis : dvol*(PB_vol(bP,hamil,varsP1,varsP2))*poissonTensorConf_local*p_factor,
      pb : fullratsimp(calcInnerProdList(varsP, 1, pbBasis, f_vol_e)), 
      /* Volume factor for intergation */
      clst_vol : [dx10, dx11, dx12, dv10, dv11, dv12],
      /* Replace dv*dv with dv_sq */
      pb : subst([dv10*dv10 = dv10_sq, dv11*dv11 = dv11_sq, dv12*dv12 = dv12_sq], pb),
      pb : subst([dv10^2 = dv10_sq, dv11^2 = dv11_sq, dv12^2 = dv12_sq], pb),
      writeCIncrExprsCollect1(out, pb, clst_vol), 
      printf(fh, "~%") 
    )
  ),

  printf(fh, "} ~%")
)$  