load("modal-basis");
load("utilities")$
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
dx11 : [dx10, dx11, dx12]$
dv11 : [dv10, dv11, dv12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* exact rationalization in f over integration vars, then return the expression in 
a form that splitFuncIntoTerms() can identify terms */
exact_rat(expr, vars) := block([r], r : rat(expr, vars), ratdisrep(r))$

/* split f into additive terms (w.r.t. vars); leave other symbols as exact params */
splitFuncIntoTerms(f, vars) := block([g],
  g : exact_rat(f, vars),
  if atom(g) then [g] elseif op(g) = "+" then args(g) else [g]
)$

/* The inner product was slowing down because f was growing to a massive number of terms
   This function breaks f up into a list of indificdual terms and then computes the inner product
   for each term individually. This has been verified to give the same result as calcInnerProd list
   and returns out in the same order. */
calcInnerProdListTriad(vars, w, funcList, f) := block(
  [terms, nI, nT, out : [], i, j, acc],
  terms : splitFuncIntoTerms(f, vars),
  nI    : length(funcList),
  nT    : length(terms),

  for i : 1 thru nI do (
    acc : 0,
    for j : 1 thru nT do (
      /* accumulate <phi_i, w * term_j> */
      acc : acc + innerProd(vars, w, funcList[i], terms[j])
    ),

    /* Simplify individual terms and add them to the list */
    out : endcons( exact_rat(acc, vars), out )
  ),
  out 
)$