/* Functions which compute the components of the volume update of the Vlasov 
   equation using a discontinuous Galerkin (DG) method. Different 
   component include: 
   1. Streaming in configuration space via velocity-space derivatives of 
      the Hamiltonian, with either a velocity-space only Hamiltonian such as
      H = p^2/2m or H = mc^2*sqrt(1 + p^2), or a full phase-space Hamiltonian
      including geometric terms, H = g^ij p_i p_j/2m. 
   2. Forces in velocity space due to geometric terms in the Hamiltonian, -grad_x(H)
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
pt_conf_total : [1,6,18]$ 
dx1 : [dx10, dx11, dx12]$
dv1_inv : [dv10, dv11, dv12]$
vTrans  : [vx*dv0/2+wx1, vy*dv1/2+wx2, vz*dv2/2+wx3]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
PB_vol(f,g,x,y) := diff(f,x)*diff(g,y) - diff(g,x)*diff(f,y)$


grab_dir_from_pt_index(vdim, pt_index) := block(
  [pairs, ijk],

  /* ijk correspond to: (row, column, j-index) of the poisson tensor*/

  if vdim = 1 then (
    /* 1D: Shape of conf_poisson_tensor non-zero elements.
    +----+----+
    | -- | 00 |
    +----+----+
    | -- | -- |
    +----+----+
    */
    pairs : [[1, 2, 0]]
  )
  else if vdim = 2 then (
    /* 2D: Shape of conf_poisson_tensor non-zero elements.
    +----+----+----+----+
    | -- | -- | 00 | 01 |
    +----+----+----+----+
    | -- | -- | 02 | 03 |
    +----+----+----+----+
    | -- | -- | -- |04+j|
    +----+----+----+----+
    | -- | -- | -- | -- |
    +----+----+----+----+
    */
    pairs : [[1,3,0],[1,4,0],
             [2,3,0],[2,4,0],
             [3,4,1],[3,4,2]]
  )
  else if vdim = 3 then (
    /* 3D: Shape of conf_poisson_tensor non-zero elements.
    +----+----+----+----+----+----+
    | -- | -- | -- | 00 | 01 | 02 |
    +----+----+----+----+----+----+
    | -- | -- | -- | 03 | 04 | 05 |
    +----+----+----+----+----+----+
    | -- | -- | -- | 06 | 07 | 08 |
    +----+----+----+----+----+----+
    | -- | -- | -- | -- |09+j|10+j|
    +----+----+----+----+----+----+
    | -- | -- | -- | -- | -- |11+j|
    +----+----+----+----+----+----+
    | -- | -- | -- | -- | -- | -- |
    +----+----+----+----+----+----+
    */
    pairs : [[1,4,0],[1,5,0],[1,6,0],
             [2,4,0],[2,5,0],[2,6,0],
             [3,4,0],[3,5,0],[3,6,0],
             [4,5,1],[4,6,1],[5,6,1],
             [4,5,2],[4,6,2],[5,6,2],
             [4,5,3],[4,6,3],[5,6,3]]
  ),

  ijk : pairs[pt_index],
  return(ijk)
)$



/* Compute int ( (dw/dz^i \alpha^i)_h (Jf)_h dz ) per component   */
calcHamilVolNonCanonicalHelper(fh, funcNm, cdim, vdim, basisFun, polyOrder, comp, vmap) := block(
  [varsC, bC, varsV, bV, varsP, bP, NP,
  cid, vid, pdim, NC,
  dir, dvol,
  alpha_local_e, pbBasis, pb, clst_vol],

  pdim : cdim + vdim,
  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 
  NP : length(bP), 

  printf(fh, "#include <gkyl_nc_hamil_vol_comps_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const int dir,
   const double *alpha, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),


  cid : cidx(cdim),
  vid : vidx(cdim,vdim), 
  for i : 1 thru cdim do printf(fh, "  const double dx1~a = 2.0/dxv[~a]; ~%", i-1, cid[i]),
  for i : 1 thru vdim do printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i]),

  printf(fh, "  ~%"),
  alpha_local_e : doExpand1(alpha,bP),

  /* Convert to a phase space PT by mulitplying by p for the bottom right block comps */
  for dir : 1 thru pdim do (
    printf(fh, "  if (dir == ~a) { ~%", dir - 1),
    if (dir <= cdim ) then dvol : dx1[dir] else dvol : dv1_inv[dir-cdim],
    pbBasis : dvol*diff(bP[comp],varsP[dir])*alpha_local_e,
    pb : fullratsimp(calcInnerProdList(varsP, 1, bP, pbBasis)),

    /* Volume factor for intergation */
    clst_vol : [dx10, dx11, dx12, dv10, dv11, dv12],
    writeCIncrExprsCollect1(out, pb, clst_vol), 
    printf(fh, "  } ~%"),
    printf(fh, "~%"), 
    flush_output(fh)

  ), 

  printf(fh, "} ~%")
)$  


/* Hamiltonian volume contribution for Non-Canonical Brackets, either just streaming, 
   grad_x(w) . grad_v(H) f, if Hamiltonian only depends on velocity space, or, 
   grad_x(w) . grad_v(H) f - grad_v(w) . grad_x(H) f  */
calcHamilVolNonCanonicalAlpha(fh, funcNm, cdim, vdim, basisFun, polyOrder, vmap) := block(
  [varsC, bC, varsV, bV, varsP, bP, NP,
  cid, vid, pdim, NC, hamil,
  poissonTensorConf, pt_conf_comp_total,
  varsPFull, pt_index, dir1, dir2, index_vsum, varsP1, varsP2,
  dz_val2, dvol, p_factor,
  alpha_index_sym, alpha_index_asym,
  pbBasis, pb, clst_vol,
  poissonTensorConf_local],

  pdim : cdim + vdim,
  [varsC,bC,varsV,bV,varsP,bP] :  loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 
  NP : length(bP), 

  printf(fh, "#include <gkyl_nc_hamil_vol_comps_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const int dir,
   const double *poisson_tensor_conf, const double *hamil, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  hamil : doExpand1(hamil, bV),

  /* Save enough distribution names for 3D */
  poissonTensorConf : [pt_conf_0, pt_conf_1, pt_conf_2, 
    pt_conf_3, pt_conf_4, pt_conf_5, pt_conf_6,
    pt_conf_7, pt_conf_8, pt_conf_9, pt_conf_10,
    pt_conf_11, pt_conf_12, pt_conf_13, pt_conf_14,
    pt_conf_15, pt_conf_16, pt_conf_17],

  pt_conf_comp_total : pt_conf_total[vdim],
  
  cid : cidx(cdim),
  vid : vidx(cdim,vdim), 
  for i : 1 thru cdim do printf(fh, "  const double dx1~a = 2.0/dxv[~a]; ~%", i-1, cid[i]),
  for i : 1 thru vdim do printf(fh, "  const double dv~a = dxv[~a]; ~%", i-1, vid[i]),
  for i : 1 thru vdim do printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i]),
  for i : 1 thru vdim do printf(fh, "  const double wx~a = w[~a]; ~%", i, cdim+i-1),

  /* for a 2*vdim space varsPFull */
  if (vdim = 3) then (
    varsPFull : [x, y, z, vx, vy, vz]
  )
  else if (vdim = 2) then (
    varsPFull : [x, y, vx, vy]
  )
  else if (vdim = 1) then (
    varsPFull : [x, vx]
  ),

  /* The Poisson Tensor is sparse and antisymmetric, which is exploited here by only
    indexing over unique and non-zero elements */
  /* If the system is independant of a spatial coordinate, this code skips those contributions
    which are zero */
  /* Assumed a 2*vdim Poisson tensor size. */
  /* cdim is only used to determind coordinate independance. */
  printf(fh, "  ~%"), 
  for pt_index : 1 thru pt_conf_comp_total do (
    [dir1, dir2, index_vsum] : grab_dir_from_pt_index(vdim, pt_index),
    varsP1 : varsPFull[dir1], varsP2 : varsPFull[dir2],

    poissonTensorConf_local : doExpand1(poissonTensorConf[pt_index],bC),

    /* Exclude making variables for when cdim < vdim */
    if not((( dir1 <= vdim ) and ( dir1 > cdim )) or (( dir2 <= vdim ) and ( dir2 > cdim ))) then (

      /* Determine the characteristic index to save the output to */
      /* in 1x3v for instance dir1 can be 1 to 6, but alpah_index if for the output
       whihc only have four chateristic directions, so this returns only 1, 2, 3, 4 for each
       ascending direction (excluding the zero entries which will be zero by both dh/dz and dw/dz) */
      if (dir1 <= cdim ) then alpha_index_sym : dir1 else alpha_index_sym : dir1 - (vdim - cdim),
      if (dir2 <= cdim ) then alpha_index_asym : dir2 else alpha_index_asym : dir2 - (vdim - cdim),

      printf(fh, "  const double *pt_conf_~a = &poisson_tensor_conf[~a]; ~%", pt_index - 1, NC*(pt_index-1)),

      /* Compute the volume element */
      if (dir2 <= vdim ) then dz_val2 : dx1[dir2] else dz_val2 : dv1_inv[dir2-vdim],
      dvol : dz_val2, 

      /* For cdim /= vdim, we assume the ignorable coordinates are the last pairs.
        For instance if we have varsC = [x,y,z] with:
        - 1 ignorable coordinate: [x, y, \dot{x}, \dot{y}] are all that show up in {f,H} 
        - 2 ignorable coordinates: [x, \dot{x},] are all that show up in {f,H} 
        It is assumed that H does not depend on these ignorable coordinates. */

      /* Convert to a phase space PT by mulitplying by p for the bottom right block comps */
      if ( (dir1 > vdim) and (dir2 > vdim) ) then p_factor : vTrans[index_vsum] else p_factor : 1,

      /* Symmetric contributions Calcuation & accumulation*/
      pbBasis : dvol*diff(hamil,varsP2)*poissonTensorConf_local*p_factor,
      pb : fullratsimp(calcInnerProdList(varsP, 1, bP, pbBasis)), 

      /* Volume factor for intergation */
      clst_vol : [dx10, dx11, dx12, dv10, dv11, dv12],
      printf(fh, "  if (dir == ~a) { ~%", alpha_index_sym - 1),
      writeCIncrExprsCollect1(out, pb, clst_vol),
      printf(fh, "  } ~%"),


      /* Antisymmetric contributions Calcuation & accumulation */
      /* Asymmetry is why we swap P2 -> P1 and pick up a minus sign (PT and p_factor do not change) */
      pbBasis : - dvol*diff(hamil,varsP1)*poissonTensorConf_local*p_factor,
      pb : fullratsimp(calcInnerProdList(varsP, 1, bP, pbBasis)), 

      /* Volume factor for intergation */
      clst_vol : [dx10, dx11, dx12, dv10, dv11, dv12],
      printf(fh, "  if (dir == ~a) { ~%", alpha_index_asym - 1),
      writeCIncrExprsCollect1(out, pb, clst_vol),
      printf(fh, "  } ~%"),


      printf(fh, "~%") 
    )
  ),

  printf(fh, "} ~%")
)$  