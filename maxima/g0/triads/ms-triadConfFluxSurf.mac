load("triads/traidConfFluxSurfFuncs")$
load(stringproc)$
/* This script calls the functions which calculate the
   components of the modal DG expansion of the velocity space 
   flux, first accumulating different forces into an array
   storing the phase space characteristics alpha_v at quadrature
   points, and then constructing a nodal Lax-Friedrichs flux,
   G = alpha/2*(f^+ + f^-) - |alpha|/2*(f^+ - f^-)
   and converting that back to a modal expansion. */

/* ...... USER INPUTS........ */

/* Serendipity basis. */
minPolyOrder_Ser : 1$
maxPolyOrder_Ser : 2$
minCdim_Ser : 1$
minVdim_Ser : 1$    /* see begining of v loop below though. */
maxCdim_Ser : 3$
maxVdim_Ser : 3$

/* Tensor product basis. */
minPolyOrder_Tensor : 2$
maxPolyOrder_Tensor : 2$
minCdim_Tensor : 2$
minVdim_Tensor : 3$    /* see begining of v loop below though. */
maxCdim_Tensor : 0$
maxVdim_Tensor : 3$

/* ...... END OF USER INPUTS........ */

bName        : ["ser","tensor"]$
minPolyOrder : [minPolyOrder_Ser, minPolyOrder_Tensor]$
maxPolyOrder : [maxPolyOrder_Ser, maxPolyOrder_Tensor]$
minCdim      : [minCdim_Ser, minCdim_Tensor]$
minVdim      : [minVdim_Ser, minVdim_Tensor]$
maxCdim      : [maxCdim_Ser, maxCdim_Tensor]$
maxVdim      : [maxVdim_Ser, maxVdim_Tensor]$
useHigherOrderList : [false, true]$

clabels : ["x","y","z"]$
vlabels : ["vx","vy","vz"]$

for bInd : 1 thru length(bName) do (
  for c : minCdim[bInd] thru maxCdim[bInd] do (
    minVdimB : max(c,minVdim[bInd]), 
    maxVdimB : maxVdim[bInd], 
    for v : minVdimB thru maxVdimB do (

      minPolyOrderB : minPolyOrder[bInd],
      maxPolyOrderB : maxPolyOrder[bInd],
      if (c+v>5 and maxPolyOrderB > 1) then maxPolyOrderB : 1,

      for polyOrder : minPolyOrderB thru maxPolyOrderB do (
        disp(printf(false,sconcat("Creating configuration flux ",bName[bInd]," ~ax~av_p~a"),c,v,polyOrder)),
        /* Can only have scalar potential force in directions where we can take configuration space gradients. */
        for dir : 1 thru c do (
          for hoInd : 1 thru length(useHigherOrderList) do (
            useHigherOrder : useHigherOrderList[hoInd],
            if useHigherOrder then si : "ho_" else si : "",
            if not((bName[bInd] = "ser")and (polyOrder = 1) and (useHigherOrder = true)) then (
              if ((bName[bInd] = "ser")and (polyOrder = 1) and (useHigherOrder = false)) then si : "",
              fname : sconcat("~/max-out/",si,"lax_flux_nodal_to_modal_", clabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
              fh : openw(fname),
              funcName : sconcat(si,"lax_flux_nodal_to_modal_",clabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
              calcNodalLaxToModalVelFlux(dir, fh, funcName, c, v, bName[bInd], polyOrder, useHigherOrder), 
              close(fh)  
            )  
          )       
        ),
        disp(printf(false,sconcat("Creating hamiltonian configuration flux ",bName[bInd]," ~ax~av_p~a"),c,v,polyOrder)),
        for dir : 1 thru c do (
          for hoInd : 1 thru length(useHigherOrderList) do (
            useHigherOrder : useHigherOrderList[hoInd],
            if useHigherOrder then si : "ho_" else si : "",
            if not((bName[bInd] = "ser")and (polyOrder = 1) and (useHigherOrder = true)) then (
              if ((bName[bInd] = "ser")and (polyOrder = 1) and (useHigherOrder = false)) then si : "",
              /* Phase-space Hamiltonian surface component. Only generate with Serendipity basis for now. */
              if (bName[bInd] = "ser") then (
                fname : sconcat("~/max-out/hamil_",si,"alpha_quad_", clabels[dir], "_", c, "x", v, "v_", bName[bInd], "_p", polyOrder, ".c"),
                fh : openw(fname),
                funcName : sconcat("hamil_",si,"alpha_quad_",clabels[dir],"_", c, "x", v, "v_", bName[bInd], "_p", polyOrder),
                calcHamilGenVelSurfForceFlux(dir, fh, funcName, c, v, bName[bInd], polyOrder, useHigherOrder), 
                close(fh)
              )
            )
          )
        )
      )
    )
  )
);
