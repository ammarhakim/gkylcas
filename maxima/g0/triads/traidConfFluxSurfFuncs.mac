/* Functions which compute the components of the surface flux in configuration space. 
   The procedure we utilize a set of functions that compute the characteristics
   alpha at surface quadrature points of the needed order, accumulating each component, 
   e.g., Hamiltonian forces.

   We then evaluate the Lax-Friedrichs flux G = alpha/2*(f^+ + f^-) - |alpha|/2*(f^+ - f^-)
   at each quadrature point, and then convert that back to a modal expansion of the 
   velocity-space flux for use in the final update in hyper_dg. 

   Note that we do not make any assumptions on the order of the phase space expansion
   and thus to evaluate G, we must utilize enough Gauss-Legendre quadrature points
   to integrate a 3*p polynomial (cubic for p=1, sixth order for p=2, ninth order for p=3). 
   We thus must use 2, 4, and 5 Gauss-Legendre points respectively. 

   In velocity space, certain Hamiltonians such as H = v^2/2 require fewer velocity space
   quadrature points since these Hamiltonians are "sparse." We separate the velocity space
   vs. configuration space quadrature loops and generate separate nodal configuration space
   and nodal velocity space surface bases. Since these quadrature rules are all tensor products
   of configuration space and velocity space, the final phase space basis is simply a tensor
   product of the configuration space and velocity space bases.  
*/

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load("new_vlasov/vlasov-basis");
load(stringproc)$
fpprec : 24$

clabels : ["x","y","z"]$
dx1 : [dx10, dx11, dx12]$
dv1 : [dv10, dv11, dv12]$
cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Phase-space Hamiltonian forces at velocity-space surface quadrature points. */
calcHamilGenVelSurfForceFlux(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, useHigherOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,hamil,cv,surfVars,surfCVars,bSurf,NSurf,
   nodes_conf,basisNodalConf,num_nodes_conf,nodes_vel,basisNodalVel,num_nodes_vel,
   surfNodes,numNodes,PI_dH_dv_l, NC, vid],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 
  NC : length(bC), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const int hamil_pt_edge, 
    const double *poisson_tensor_conf, const double *hamil, double* GKYL_RESTRICT alpha_quad) ~%{ ~%", funcNm),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  for i : 1 thru vdim do printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i]),
  printf(fh, "~%"),
  hamil : doExpand1(hamil, bV), /* Hamiltonian a function of the *velocity* phase space. */

  /* Save enough names for 3D */
  poissonTensorConf : [poisson_tensor_conf_0, poisson_tensor_conf_1, poisson_tensor_conf_2],

  /* Surface contribution is defined as integral(phi^- Fhat) over the surface. */
  /* cv = variable in direction of surface update. */
  cv : varsP[dir],
  surfVars : delete(cv,varsP), /* Surface variables at constant cv surface. */
  surfCVars : delete(cv,varsC), /* Remaining configuration space variables at cv surface. */
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovConfSurfBasis(cdim, vdim, basisFun, polyOrder, surfVars, surfCVars, varsV, useHigherOrder),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 

  /* Compute the characteristic for the NC Poisson Tensor */
  Pi_dH_dv : 0,
  for j : 1 thru vdim do (

    /* Offset the row by NC*(dir - 1)*vdim components */
    printf(fh, "  const double *poisson_tensor_conf_~a = &poisson_tensor_conf[~a]; ~%", j - 1, NC*(dir-1)*vdim + NC*(j-1)),

    poissonTensorConf_local : doExpand1(poissonTensorConf[j],bC),
    v_diff : varsV[j],
    Pi_dH_dv : Pi_dH_dv + poissonTensorConf_local*diff(hamil,v_diff)*dv1[j]
  ),


  /* Each cells owns its *lower* edge fluxes, so we evaluate the derivative of the 
     Hamiltonian at cv = -1. Note that the flux is z_\dot = Pi^{ij} \dH/dz^j. */
  printf(fh, "  if (hamil_pt_edge == -1) {~%"),
  PI_dH_dv_l : float(evAtNodes(subst(cv=-1,Pi_dH_dv),surfNodes,surfVars)), 
  for i : 1 thru numNodes do (
    printf(fh, "    alpha_quad[~a] += ~a;~%", i-1, PI_dH_dv_l[i]) 
  ),
  printf(fh, "  }~%"),
  printf(fh, "  else if (hamil_pt_edge == 1) {~%"),
  PI_dH_dv_l : float(evAtNodes(subst(cv=1,Pi_dH_dv),surfNodes,surfVars)), 
  for i : 1 thru numNodes do (
    printf(fh, "    alpha_quad[~a] += ~a;~%", i-1, PI_dH_dv_l[i]) 
  ),
  printf(fh, "  }~%"),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 

/* Nodal Lax-Friedrichs to modal configuration-space flux. */
calcNodalLaxToModalVelFlux(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, useHigherOrder) := block(
  [varsC,bC,varsV,bV,varsP,bP,cid,
   surfVars,surfCVars,bSurf,NSurf,
   nodes_conf,basisNodalConf,num_nodes_conf,nodes_vel,basisNodalVel,num_nodes_vel,
   surfNodes,numNodes,jacob_edge,jacob_vi_surf,jacob_surf_tot,
   f_l_e,f_r_e,f_l_n,f_r_n,lax_list,lax_e,Ghat_c],

  [varsC,bC,varsV,bV,varsP,bP] : loadVlasovBasis(basisFun, cdim, vdim, polyOrder), 

  printf(fh, "#include <gkyl_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double *dxv, const double *jacob_vel_surf, 
  const double *alpha_quad, const double *f_l, const double *f_r, 
  double *lax, double* GKYL_RESTRICT Fhat_nodal) ~%{ ~%", funcNm),
  cid : cidx(cdim),
  printf(fh, "  double dx1~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir]),
  printf(fh, "~%"),

  cv : varsC[dir], 
  surfVars : delete(cv,varsP), /* Surface variables at constant cv surface. */
  surfCVars : delete(cv,varsC), 
  [bSurf,nodes_conf,basisNodalConf,nodes_vel,basisNodalVel,surfNodes] : loadVlasovConfSurfBasis(cdim, vdim, basisFun, polyOrder, surfVars, surfCVars, varsV, useHigherOrder),
  NSurf : length(bSurf), 
  num_nodes_conf : length(nodes_conf), 
  num_nodes_vel : length(nodes_vel), 
  numNodes : length(surfNodes), 
  printf(fh, "  double *out = &Fhat_nodal[~a]; ~%", (dir-1)*numNodes),

  /* Create expansions of f_left and f_right on volume basis. */
  f_l_e : doExpand1(f_l, bP),
  f_r_e : doExpand1(f_r, bP),
  f_l_n : float(evAtNodes(subst(cv=1,f_l_e),surfNodes,surfVars)), 
  f_r_n : float(evAtNodes(subst(cv=-1,f_r_e),surfNodes,surfVars)), 
  printf(fh, "  double alpha_max = 0.0; ~%"), 
  printf(fh, "  double f_l_quad = 0.0; ~%"), 
  printf(fh, "  double f_r_quad = 0.0; ~%"), 
  for i : 1 thru numNodes do (
    printf(fh, "  alpha_max = fmax(alpha_max, fabs(alpha_quad[~a])); ~%", i-1), 
    printf(fh, "  f_l_quad = ~a; ~%", f_l_n[i]), 
    printf(fh, "  f_r_quad = ~a; ~%", f_r_n[i]), 
    printf(fh, "  out[~a] = 0.5*(alpha_quad[~a]*(f_r_quad + f_l_quad) - fabs(alpha_quad[~a])*(f_r_quad - f_l_quad)); ~%", i-1, i-1, i-1),
    printf(fh, "~%")    
  ), 

  /* Estimate stable time step from the maximum quadrature point evaluation. */
  printf(fh, "  return ~a*~a*alpha_max;~%", float(0.5*(2*polyOrder+1)), dx1[dir]),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$ 