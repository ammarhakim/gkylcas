/*
   Create kernels for the surface and volume expansions of the radiation drag. 
   For the surface expansions, evaluates the form of the drag at the corresponding surface 
   and then projects the resulting evaluation onto a surface basis in each direction
   of the update. Each cell owns the *lower* surface expansion in that direction.
   For the volume expansions, the form of the drag is evaluated within the volume.

   In both cases, these expansions are generated by evaluating the radiation drag on a nodal
   basis and then projecting the nodal basis onto our modal basis. 
*/

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
load("nodal_operations/quadrature_functions")$
load("utilities_gyrokinetic")$
fpprec : 24$

buildGKRadNuKernel(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,varsP,bC,bP,pDim,varsV,cid,vid,varsSub,
   surfVar,surfIntVars,surf_vvars,volNodes,surfNodes,bSurf,basisVolNodal,basisSurfNodal,
   numC,numVolNodes,numSurfNodes,
   vars_bmag,bC_bmag,bmag_full_e,bmag_c,bmag_e,bmag_surf_n,bmag_vol_n,
   basis_vpar,vpar_c,vpar_e,vpar_vol_n,vpar_surf,vpar_surf_n,
   basis_mu,mu_c,mu_e,mu_vol_n,mu_surf,mu_surf_n,
   vnu_surf_nodal_e,vnu_surf_ModProj_e,vnu_nodal_e,vnu_ModProj_e,
   vsqnu_surf_nodal_e,vsqnu_surf_ModProj_e,vsqnu_nodal_e,vsqnu_ModProj_e],

  kill(varsC,varsP,bC,bP),

  if (cdim = 3) then (
    [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, 2, vdim, polyOrder),
    pDim : 2+vdim,
    varsV : makelist(varsP[i],i,cdim,2+vdim),
    surfVar : varsP[dir-1],         /* Surface variable. */
    surf_vvars : delete(surfVar, makelist(varsP[2+i],i,1,vdim))
  )
  else (
    [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
    pDim : cdim+vdim,
    varsV : makelist(varsP[i],i,cdim+1,cdim+vdim),
    surfVar : varsP[dir],         /* Surface variable. */
    surf_vvars : delete(surfVar, makelist(varsP[cdim+i],i,1,vdim))
  ),

  surfIntVars : delete(surfVar,varsP), 

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    volNodes : gaussOrdGkHyb(1+1, varsC, varsV),
    surfNodes : gaussOrdGkHyb(1+1, varsC, surf_vvars),
    bSurf : basisFromVars("gkhyb",surfIntVars,polyOrder),
    if (cdim = 3) then (
      basisVolNodal : getVarsNodalBasisWithNodesHyb("gkhyb", 2, 2, varsP, volNodes),
      basisSurfNodal : getVarsNodalBasisWithNodesHyb("gkhyb", 2, 1, surfIntVars, surfNodes)
    )
    else (
      basisVolNodal : getVarsNodalBasisWithNodesHyb("gkhyb", cdim, 2, varsP, volNodes),
      basisSurfNodal : getVarsNodalBasisWithNodesHyb("gkhyb", cdim, 1, surfIntVars, surfNodes)
    )
  ) else (
    volNodes : gaussOrd(polyOrder+1, pDim),
    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    bSurf : basisFromVars(basisFun,surfIntVars,polyOrder),
    basisVolNodal : getVarsNodalBasisWithNodes("tensor", pDim, polyOrder, varsP, volNodes),
    basisSurfNodal : getVarsNodalBasisWithNodes("tensor", pDim-1, polyOrder, surfIntVars, surfNodes)
  ),
  numC : length(bC),  
  numVolNodes : length(volNodes),
  numSurfNodes : length(surfNodes),  

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH void ~a(const double *vmap, const double *vmapSq, 
    double charge, double mass, double a, double alpha, double beta, double gamma, double v0, 
    const double *bmag, double* GKYL_RESTRICT drag_rad_nu_surf, double* GKYL_RESTRICT drag_rad_nu) ~%{ ~%", funcNm),
  printf(fh, "  // charge: elementary charge.~%"),
  printf(fh, "  // mass: mass of electron.~%"),
  printf(fh, "  // a, alpha, beta, gamma, v0: Radiation fitting parameters.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // drag_rad_nu_surf: Radiation drag in direction dir at corresponding surfaces.~%"),
  printf(fh, "  //                   Note: Each cell owns their *lower* edge surface evaluation.~%"),
  printf(fh, "  // drag_rad_nu: Radiation drag direction dir volume expansion.~%"),
  printf(fh, "~%"),

  printf(fh, "  double scaled_v0 = v0/sqrt(mass/(2.0*fabs(charge)));~%"),
  printf(fh, "  double c_const = 8.0*fabs(charge)/sqrt(M_PI)*pow(2*fabs(charge)/mass,gamma/2.0); ~%"),
  printf(fh, "  double const_mult = a*(alpha+beta)/c_const;~%"),
  printf(fh, "  double vmag = 0.0;~%"),
  printf(fh, "  double vmag_surf = 0.0;~%"),
  printf(fh, "~%"),

  /* if cdim = 3, down-project input bmag which is expanded in (x,y,z)
     onto (x,z) basis because it has no coefficients which depend upon y */
  bmagBasis : getAxisymmetricConfBasis(bC),
  bmag_e : doExpand1(bmag, bmagBasis),

  /* Evaluate bmag at ordinates. Only depends on configuration space */
  bmag_surf_n : gcfac(float(evAtNodes(bmag_e,surfNodes,surfIntVars))), 
  bmag_vol_n : gcfac(float(evAtNodes(bmag_e,volNodes,varsP))),

  /* Expand the velocity map fields. */
  [vmap_e,vmapSq_e,vmap_prime_e] : expandVmapFields(varsP),
  vpar_e    : vmap_e[1],
  mu_e      : vmap_e[2],
  vpar_sq_e : vmapSq_e[1],

  /* Evaluate expansions of vpar, mu and vpar^2 at volume nodes */
  vpar_vol_n    : gcfac(float(evAtNodes(vpar_e,volNodes,varsP))), 
  mu_vol_n      : gcfac(float(evAtNodes(mu_e,volNodes,varsP))), 
  vpar_sq_vol_n : gcfac(float(evAtNodes(vpar_sq_e,volNodes,varsP))), 

  /* Evaluate vmag = sqrt(vpar^2 + 2*mu*B/m) at the ordinates and then the radiation drag. 
     For the surface expansion, we first evaluate velocity variable at surface (either vpar or mu)
     and then construct vmag at that surface. */
  if (dir = cdim + 1) then (
    printf(fh, "  double vnu_surf_nodal[~a] = {0.0};~%", numSurfNodes),
    printf(fh, "  double vnu_nodal[~a] = {0.0};~%", numVolNodes),

    vpar_surf    : gcfac(float(expand(subst(vpar=-1, vpar_e)))), 
    vpar_sq_surf : gcfac(float(expand(subst(vpar=-1, vpar_sq_e)))), 
    mu_surf_n    : gcfac(float(evAtNodes(mu_e,surfNodes,surfIntVars))), 
    for i : 1 thru numSurfNodes do (
      printf(fh, "  vmag_surf = sqrt((~a)+2.0*(~a)/mass);~%", vpar_sq_surf, mu_surf_n[i]*bmag_surf_n[i]),
      printf(fh, "  vnu_surf_nodal[~a] = (~a)*((a/c_const*(alpha+beta)*pow(vmag_surf,gamma))/(beta*pow(vmag_surf/scaled_v0,-alpha)+alpha*pow(vmag_surf/scaled_v0,beta)));~%", i-1, vpar_surf)
    ),
    printf(fh, "~%"),
    vnu_surf_nodal_e : doExpand1(vnu_surf_nodal,basisSurfNodal),

    vnu_surf_ModProj_e : fullratsimp(calcInnerProdList(surfIntVars, 1, bSurf, vnu_surf_nodal_e)),
    writeCExprs1(drag_rad_nu_surf, vnu_surf_ModProj_e),
    printf(fh, "~%"),

    for i : 1 thru numVolNodes do (
      printf(fh, "  vmag = sqrt((~a)+2.0*(~a)/mass);~%", vpar_sq_vol_n[i], mu_vol_n[i]*bmag_vol_n[i]),
      printf(fh, "  vnu_nodal[~a] = (~a)*((a/c_const*(alpha+beta)*pow(vmag,gamma))/(beta*pow(vmag/scaled_v0,-alpha)+alpha*pow(vmag/scaled_v0,beta)));~%", i-1, vpar_vol_n[i])
    ),
    printf(fh, "~%"),
    vnu_nodal_e : doExpand1(vnu_nodal,basisVolNodal),

    vnu_ModProj_e : fullratsimp(calcInnerProdList(varsP, 1, bP, vnu_nodal_e)),
    writeCExprs1(drag_rad_nu, vnu_ModProj_e),
    printf(fh, "~%"),
    flush_output(fh)
  )
  else (
    printf(fh, "  double vsqnu_surf_nodal[~a] = {0.0};~%", numSurfNodes),
    printf(fh, "  double vsqnu_nodal[~a] = {0.0};~%", numVolNodes),

    mu_surf : gcfac(float(expand(subst(mu=-1, mu_e)))), 
    vpar_sq_surf_n : gcfac(float(evAtNodes(vpar_sq_e,surfNodes,surfIntVars))), 
    for i : 1 thru numSurfNodes do (
      printf(fh, "  vmag_surf = sqrt((~a)+2.0*(~a)/mass);~%", vpar_sq_surf_n[i], mu_surf*bmag_surf_n[i]),
      printf(fh, "  vsqnu_surf_nodal[~a] = 2.0*(~a)*((a/c_const*(alpha+beta)*pow(vmag_surf,gamma))/(beta*pow(vmag_surf/scaled_v0,-alpha)+alpha*pow(vmag_surf/scaled_v0,beta)));~%", i-1, mu_surf)
    ),
    printf(fh, "~%"),
    vsqnu_surf_nodal_e : doExpand1(vsqnu_surf_nodal,basisSurfNodal),

    vsqnu_surf_ModProj_e : fullratsimp(calcInnerProdList(surfIntVars, 1, bSurf, vsqnu_surf_nodal_e)),
    writeCExprs1(drag_rad_nu_surf, vsqnu_surf_ModProj_e),
    printf(fh, "~%"),
    flush_output(fh),

    for i : 1 thru numVolNodes do (
      printf(fh, "  vmag = sqrt((~a)+2.0*(~a)/mass);~%", vpar_sq_vol_n[i], mu_vol_n[i]*bmag_vol_n[i]),
      printf(fh, "  vsqnu_nodal[~a] = 2.0*(~a)*((a/c_const*(alpha+beta)*pow(vmag,gamma))/(beta*pow(vmag/scaled_v0,-alpha)+alpha*pow(vmag/scaled_v0,beta)));~%", i-1, mu_vol_n[i])
    ),
    printf(fh, "~%"),
    vsqnu_nodal_e : doExpand1(vsqnu_nodal,basisVolNodal),

    vsqnu_ModProj_e : fullratsimp(calcInnerProdList(varsP, 1, bP, vsqnu_nodal_e)),
    writeCExprs1(drag_rad_nu, vsqnu_ModProj_e),
    printf(fh, "~%"),
    flush_output(fh)
  ),
  printf(fh, "} ~%")
)$
