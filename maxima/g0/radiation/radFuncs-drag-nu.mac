/*
   Create kernels for the surface and volume expansions of the radiation drag. 
   For the surface expansions, evaluates the form of the drag at the corresponding surface 
   and then projects the resulting evaluation onto a surface basis in each direction
   of the update. Each cell owns the *lower* surface expansion in that direction.
   For the volume expansions, the form of the drag is evaluated within the volume.

   In both cases, these expansions are generated by evaluating the radiation drag on a nodal
   basis and then projecting the nodal basis onto our modal basis. 
*/

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
load("nodal_operations/quadrature_functions")$
load("utilities")$
fpprec : 24$

let(wvpar^2, wvpar_sq)$
let(dvpar^2, dvpar_sq)$

buildGKRadNuKernel(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,varsP,bC,bP,pDim,varsV,cid,vid,varsSub,
   surfVar,surfIntVars,surf_vvars,volNodes,surfNodes,bSurf,basisVolNodal,basisSurfNodal,
   numC,numVolNodes,numSurfNodes,
   vars_bmag,bC_bmag,bmag_full_e,bmag_c,bmag_e,bmag_surf_n,bmag_vol_n,
   basis_vpar,vpar_c,vpar_e,vpar_vol_n,vpar_surf,vpar_surf_n,
   basis_mu,mu_c,mu_e,mu_vol_n,mu_surf,mu_surf_n,
   vnu_surf_nodal_e,vnu_surf_ModProj_e,vnu_nodal_e,vnu_ModProj_e,
   vsqnu_surf_nodal_e,vsqnu_surf_ModProj_e,vsqnu_nodal_e,vsqnu_ModProj_e],

  kill(varsC,varsP,bC,bP),

  if (cdim = 3) then (
    [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, 2, vdim, polyOrder),
    pDim : 2+vdim,
    varsV : makelist(varsP[i],i,3,2+vdim),
    surfVar : varsP[dir-1],         /* Surface variable. */
    surfIntVars : delete(surfVar,varsP), 
    surf_vvars : delete(surfVar, makelist(varsP[2+i],i,1,vdim))
  )
  else (
    [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
    pDim : cdim+vdim,
    varsV : makelist(varsP[i],i,cdim+1,cdim+vdim),
    surfVar : varsP[dir],         /* Surface variable. */
    surfIntVars : delete(surfVar,varsP), 
    surf_vvars : delete(surfVar, makelist(varsP[cdim+i],i,1,vdim))
  ),
  /* Radiation drag coefficient can only depend on (x,z,vpar,mu)
     because we assume B = B(x,z) */
  if (cdim > 1) then (
    varsSub : [y=z],
    bC : subst(varsSub, copylist(bC)),  
    varsC : subst(varsSub, copylist(varsC)),
    bP : subst(varsSub, copylist(bP)),  
    varsP : subst(varsSub, copylist(varsP)),
    surfIntVars : subst(varsSub, copylist(surfIntVars))
  ),

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    volNodes : gaussOrdGkHyb(1+1, varsC, varsV),
    surfNodes : gaussOrdGkHyb(1+1, varsC, surf_vvars),
    bSurf : basisFromVars("gkhyb",surfIntVars,polyOrder),
    if (cdim = 3) then (
      basisVolNodal : getVarsNodalBasisWithNodesHyb("gkhyb", 2, 2, varsP, volNodes),
      basisSurfNodal : getVarsNodalBasisWithNodesHyb("gkhyb", 2, 1, surfIntVars, surfNodes)
    )
    else (
      basisVolNodal : getVarsNodalBasisWithNodesHyb("gkhyb", cdim, 2, varsP, volNodes),
      basisSurfNodal : getVarsNodalBasisWithNodesHyb("gkhyb", cdim, 1, surfIntVars, surfNodes)
    )
  ) else (
    volNodes : gaussOrd(polyOrder+1, pDim),
    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    bSurf : basisFromVars(basisFun,surfIntVars,polyOrder),
    basisVolNodal : getVarsNodalBasisWithNodes("tensor", pDim, polyOrder, varsP, volNodes),
    basisSurfNodal : getVarsNodalBasisWithNodes("tensor", pDim-1, polyOrder, surfIntVars, surfNodes)
  ),
  numC : length(bC),  
  numVolNodes : length(volNodes),
  numSurfNodes : length(surfNodes),  

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, 
  double charge, double mass, double a, double alpha, double beta, double gamma, double v0, 
  const double *bmag, double* GKYL_RESTRICT drag_rad_nu_surf, double* GKYL_RESTRICT drag_rad_nu) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // charge: elementary charge.~%"),
  printf(fh, "  // mass: mass of electron.~%"),
  printf(fh, "  // a, alpha, beta, gamma, v0: Radiation fitting parameters.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // drag_rad_nu_surf: Radiation drag in direction dir at corresponding surfaces.~%"),
  printf(fh, "  //                   Note: Each cell owns their *lower* edge surface evaluation.~%"),
  printf(fh, "  // drag_rad_nu: Radiation drag direction dir volume expansion.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double wvpar = w[~a], dvpar = dxv[~a]; ~%", cdim, cdim),
  printf(fh, "  const double wvmu = w[~a], dvmu = dxv[~a]; ~%", cdim+1, cdim+1),
  printf(fh, "  const double wvpar_sq = wvpar*wvpar, dvpar_sq = dvpar*dvpar; ~%"),
  printf(fh, "~%"),

  printf(fh, "  double scaled_v0 = v0/sqrt(mass/(2.0*fabs(charge)));~%"),
  printf(fh, "  double c_const = 8.0*fabs(charge)/sqrt(M_PI)*pow(2*fabs(charge)/mass,gamma/2.0); ~%"),
  printf(fh, "  double const_mult = a*(alpha+beta)/c_const;~%"),
  printf(fh, "  double vmag = 0.0;~%"),
  printf(fh, "  double vmag_surf = 0.0;~%"),
  printf(fh, "~%"),

  /* if cdim = 3, down-project input bmag which is expanded in (x,y,z)
     onto (x,z) basis because it has no coefficients which depend upon y */
  if (cdim = 3) then (
    [vars_bmag, bC_bmag] : loadBasis(basisFun, cdim, polyOrder),
    bmag_full_e : doExpand1(bmag, bC_bmag),
    bmag_c : calcInnerProdList(vars_bmag, 1, bC, bmag_full_e),
    printf(fh, "  double bmag_2d[~a] = {0.0};~%", numC),
    writeCExprs1(bmag_2d, bmag_c), 
    bmag_e : doExpand1(bmag_2d, bC)
  )
  else (
    bmag_e : doExpand1(bmag, bC)
  ),
  /* Evaluate bmag at ordinates. Only depends on configuration space */
  bmag_surf_n : gcfac(float(evAtNodes(bmag_e,surfNodes,surfIntVars))), 
  bmag_vol_n : gcfac(float(evAtNodes(bmag_e,volNodes,varsP))),

  /* Project vpar, vpar^2 and mu onto their one dimensional bases and evaluate expansions at volume nodes */
  printf(fh, "  double vpar_p[~a] = {0.0};~%", 2),
  printf(fh, "  double vpar_sq_p[~a] = {0.0};~%", 3),
  printf(fh, "  double mu_p[~a] = {0.0};~%", 2), 
  basis_vpar : basisFromVars("ser",[vpar],1),
  basis_vpar_sq : basisFromVars("ser",[vpar],2),
  basis_mu : basisFromVars("ser",[mu],1),
  vpar_c : calcInnerProdList([vpar], 1, basis_vpar, dvpar/2.0*varsV[1] + wvpar),
  vpar_sq_c : calcInnerProdList([vpar], 1, basis_vpar_sq, (dvpar/2.0*varsV[1] + wvpar)^2),
  vpar_sq_c : map(letsimp, vpar_sq_c),
  mu_c : calcInnerProdList([mu], 1, basis_mu, dvmu/2.0*varsV[2] + wvmu),
  writeCExprs1(vpar_p, vpar_c), 
  writeCExprs1(vpar_sq_p, vpar_sq_c), 
  writeCExprs1(mu_p, mu_c),
  vpar_e : doExpand1(vpar_p, basis_vpar),
  vpar_sq_e : doExpand1(vpar_sq_p, basis_vpar_sq),
  mu_e : doExpand1(mu_p, basis_mu),
  vpar_vol_n : gcfac(float(evAtNodes(vpar_e,volNodes,varsP))), 
  vpar_sq_vol_n : gcfac(float(evAtNodes(vpar_sq_e,volNodes,varsP))), 
  mu_vol_n : gcfac(float(evAtNodes(mu_e,volNodes,varsP))), 
  printf(fh, "~%"),

  /* Evaluate vmag = sqrt(vpar^2 + 2*mu*B/m) at the ordinates and then the radiation drag. 
     For the surface expansion, we first evaluate velocity variable at surface (either vpar or mu)
     and then construct vmag at that surface. */
  if (dir = cdim + 1) then (
    printf(fh, "  double vnu_surf_nodal[~a] = {0.0};~%", numSurfNodes),
    printf(fh, "  double vnu_nodal[~a] = {0.0};~%", numVolNodes),

    vpar_surf : gcfac(float(expand(subst(vpar=-1, vpar_e)))), 
    vpar_sq_surf : gcfac(float(expand(subst(vpar=-1, vpar_sq_e)))), 
    mu_surf_n : gcfac(float(evAtNodes(mu_e,surfNodes,surfIntVars))), 
    for i : 1 thru numSurfNodes do (
      printf(fh, "  vmag_surf = sqrt((~a)+2.0*(~a)/mass);~%", vpar_sq_surf, mu_surf_n[i]*bmag_surf_n[i]),
      printf(fh, "  vnu_surf_nodal[~a] = (~a)*((a/c_const*(alpha+beta)*pow(vmag_surf,gamma))/(beta*pow(vmag_surf/scaled_v0,-alpha)+alpha*pow(vmag_surf/scaled_v0,beta)));~%", i-1, vpar_surf)
    ),
    printf(fh, "~%"),
    vnu_surf_nodal_e : doExpand1(vnu_surf_nodal,basisSurfNodal),

    vnu_surf_ModProj_e : fullratsimp(calcInnerProdList(surfIntVars, 1, bSurf, vnu_surf_nodal_e)),
    writeCExprs1(drag_rad_nu_surf, vnu_surf_ModProj_e),
    printf(fh, "~%"),
    printf(fh, "  if ( gkyl_compare(wvpar - dvpar/2.0, 0.0, 1e-4)) {~%"),
    for i : 1 thru numSurfNodes do (
      printf(fh, "    drag_rad_nu_surf[~a] = 0.0; ~%", i-1)
    ),
    printf(fh, "  }~%"),
    flush_output(fh),

    for i : 1 thru numVolNodes do (
      printf(fh, "  vmag = sqrt((~a)+2.0*(~a)/mass);~%", vpar_sq_vol_n[i], mu_vol_n[i]*bmag_vol_n[i]),
      printf(fh, "  vnu_nodal[~a] = (~a)*((a/c_const*(alpha+beta)*pow(vmag,gamma))/(beta*pow(vmag/scaled_v0,-alpha)+alpha*pow(vmag/scaled_v0,beta)));~%", i-1, vpar_vol_n[i])
    ),
    printf(fh, "~%"),
    vnu_nodal_e : doExpand1(vnu_nodal,basisVolNodal),

    vnu_ModProj_e : fullratsimp(calcInnerProdList(varsP, 1, bP, vnu_nodal_e)),
    writeCExprs1(drag_rad_nu, vnu_ModProj_e),
    printf(fh, "~%"),
    flush_output(fh)
  )
  else (
    printf(fh, "  double vsqnu_surf_nodal[~a] = {0.0};~%", numSurfNodes),
    printf(fh, "  double vsqnu_nodal[~a] = {0.0};~%", numVolNodes),

    mu_surf : gcfac(float(expand(subst(mu=-1, mu_e)))), 
    vpar_sq_surf_n : gcfac(float(evAtNodes(vpar_sq_e,surfNodes,surfIntVars))), 
    for i : 1 thru numSurfNodes do (
      printf(fh, "  vmag_surf = sqrt((~a)+2.0*(~a)/mass);~%", vpar_sq_surf_n[i], mu_surf*bmag_surf_n[i]),
      printf(fh, "  vsqnu_surf_nodal[~a] = 2.0*(~a)*((a/c_const*(alpha+beta)*pow(vmag_surf,gamma))/(beta*pow(vmag_surf/scaled_v0,-alpha)+alpha*pow(vmag_surf/scaled_v0,beta)));~%", i-1, mu_surf)
    ),
    printf(fh, "~%"),
    vsqnu_surf_nodal_e : doExpand1(vsqnu_surf_nodal,basisSurfNodal),

    vsqnu_surf_ModProj_e : fullratsimp(calcInnerProdList(surfIntVars, 1, bSurf, vsqnu_surf_nodal_e)),
    writeCExprs1(drag_rad_nu_surf, vsqnu_surf_ModProj_e),
    printf(fh, "~%"),
    flush_output(fh),

    for i : 1 thru numVolNodes do (
      printf(fh, "  vmag = sqrt((~a)+2.0*(~a)/mass);~%", vpar_sq_vol_n[i], mu_vol_n[i]*bmag_vol_n[i]),
      printf(fh, "  vsqnu_nodal[~a] = 2.0*(~a)*((a/c_const*(alpha+beta)*pow(vmag,gamma))/(beta*pow(vmag/scaled_v0,-alpha)+alpha*pow(vmag/scaled_v0,beta)));~%", i-1, mu_vol_n[i])
    ),
    printf(fh, "~%"),
    vsqnu_nodal_e : doExpand1(vsqnu_nodal,basisVolNodal),

    vsqnu_ModProj_e : fullratsimp(calcInnerProdList(varsP, 1, bP, vsqnu_nodal_e)),
    writeCExprs1(drag_rad_nu, vsqnu_ModProj_e),
    printf(fh, "~%"),
    flush_output(fh)
  ),
  printf(fh, "} ~%")
)$