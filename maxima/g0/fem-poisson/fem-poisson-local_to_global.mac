/* Generate the kernel that computes the global indexes of the memory
   to which each node (or nodal basis) in a given cell contributes. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions");
load("bvp_utilities/bvp-util");
load("fem/fem-util");
fpprec : 24$

generate_fem_poisson_local_to_global(fh, funcNm, dim, basisFun, pMax) := block(
  [],

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  /* Associative list between stencil location (-1,0,1) and variable strings in kernel name. */
  coordVarS : getCoordVarS(varsC),

  /* List of stencil locations. Each entry is a dim-dimensional list
     with -1 meaning it is at a lower boundary, 1 upper boundary, or
     0 away from boundaries in that direction. */
  stencilLoc : getStencilCoords(dim),

  /* Types of boundary conditions for which to generate kernels.
       =0 periodic
       =1 non-periodic
  */
  bcTypes : [0, 1],
  bcStrs  : ["periodic", "nonperiodic"],
  bcKey   : makelist([bcTypes[i],bcStrs[i]],i,1,length(bcTypes)),

  bcCombos : makelist([bcTypes[i]],i,1,length(bcTypes)),
  for d : 2 thru dim do (
    bcCombos : listify(cartesian_product(setify(bcCombos),setify(bcTypes))),
    for i : 1 thru length(bcCombos) do ( bcCombos[i] : flatten(bcCombos[i]) )
  ),

  /* We will create local->global kernels for each interior and upper
     boundary region of the domain. Each region must have different kernels
     for each possible combination of the boundary conditions. */
  for sI : 1 thru length(stencilLoc) do (
    /* Exclude lower boundary kernels (ones that do not own upper cell-boundary nodes). */
    if (stencilLoc[sI]=makelist(0,d,1,dim)) or
       (length(sublist(stencilLoc[sI],lambda([x],x < 0)))=0) then (

      /* Loop over BC combinations. Will create a separate kernel for each. */
      for bcI : 1 thru length(bcCombos) do (
  
        currBC : copylist(bcCombos[bcI]),
  
        /* String used in kernel name, identifying stencil location and BC. */
        stencilStr : "",
        for d : 1 thru dim do (
          stencilStr : sconcat(stencilStr,assoc(stencilLoc[sI][d],[[-1,"_lo"],[0,"_in"],[1,"_up"]]),
                       assoc(stencilLoc[sI][d],coordVarS)[d],"_",assoc(currBC[d],bcKey),string(varsC[d]))
        ),

        for polyOrder : 1 thru pMax do (
  
          printf(fh, "void ~a_p~a~a(const int *numCells, const int *idx, long *globalIdxs) ~%{ ~%", funcNm, polyOrder, stencilStr),
          printf(fh, "  // numCells:   number of cells in each direction.~%"),
          printf(fh, "  // idx:        multi-dimensional index of current cell.~%"),
          printf(fh, "  // globalIdxs: global linear index of each basis function/node in current cell.~%"),
          printf(fh, "~%"),
  
          bN   : getNodalBasis(basisFun, dim, polyOrder),
          numB : length(bN),
  
          nodes    : args(getNodes(basisFun, dim, polyOrder)),
          numNodes : length(nodes),

          storedNodes    : getStoredNodes(nodes,stencilLoc[sI]), /* lower nodes only, see notes. */
          storedNodesBC  : getStoredNodesWithBC(nodes,stencilLoc[sI],currBC), /* BC-aware (includes some upper nodes for nonperiodic BC). */
          numStoredNodes : length(storedNodes),

          /* Create a list of possible locations and number of stored nodes
             in the domain (only interior and upper boundary locations needed). */
          locToNumStoredNodes       : [[makelist(0,d,1,dim),0]],
          locToNumStoredNodes[1][2] : length(getStoredNodes(nodes,locToNumStoredNodes[1][1])),
          for dI : 1 thru dim do (
            numPS : length(locToNumStoredNodes),
            for pS : 1 thru numPS do (
              newS        : [copylist(locToNumStoredNodes[pS][1]),0],
              newS[1][dI] : 1,
              newNodes    : getStoredNodes(nodes,newS[1]),
              for d : 1 thru dI do ( if currBC[d]=0 then (
                newNodes : deleteNodes(newNodes,[[d,1]],false)
              ) ),
              newS[2]     : length(newNodes),
              locToNumStoredNodes : endcons(newS,locToNumStoredNodes)
            )
          ),

          /* 
             In 1D need something like:
               globalIdx = idx[0]*(nodes/cell in cells prior to this one along this x-line)+local node index.
             In 2D (row-major order):
               globalIdx = idx[0]*(nodes/line in y-lines (i.e. i=const) prior to this one)
                          +idx[1]*(nodes/cell in cells prior to this one along this y-line)+local node index.
                         = idx[0]*((numCells[1]-1)*(nodes/interior-cell of y-lines prior to this one)
                                   +nodes/upper-boundary-cell of y-lines prior to this one)
                          +idx[1]*(nodes/cell in cells prior to this one along this y-line)+local node index.
             In 3D (row-major order) need something like:
               globalIdx = idx[0]*(nodes/plane in yz-planes (i.e. i=const) prior to this one)
                          +idx[1]*(nodes/line in z-lines (i.e. j=const) prior to this one)
                          +idx[2]*(nodes/cell in cells prior to this one along this z-line)+local node index.
                         = idx[0]*((numCells[1]-1)*((numCells[2]-1)*(nodes/interior-cell of z-lines prior in yz-planes prior to this one)
                                                    +nodes/upper-boundary-cell of upper-z-line in yz-planes prior to this one)
                                   +(numCells[2]-1)*(nodes/upper-boundary-cell of upper-y-line in yz-planes prior to this one)
                                   +nodes/upper-right-cell of yz-planes prior to this one)
                          +idx[1]*((numCells[2]-1)*(nodes/interior-cells of z-lines of this yz-plane)+nodes/upper-boundary-cell of z-lines of this yz-plane)
                          +idx[2]*(nodes/cell in cells prior to this one along this z-line)+local node index.
          */

          /* This cell's memory offset. Or the number of nodes before this cell (following the
             fastest-changing dimension, row-major order), as a factor which multiplies each
             of idx[0], idx[1] and idx[2]. */
          getCellMemOff(cellLoc) := block([tmpLoc,numNodesFac,dI,d,tmpNum],
            /* Add nodes along this row-major order line (x-line for 1D, y-line for 2D, z-line for 3D). */
            tmpLoc      : copylist(cellLoc),
            tmpLoc[dim] : 0,
            numNodesFac : makelist(0,d,1,dim),
            numNodesFac[dim] : assoc(tmpLoc,locToNumStoredNodes),
            /* Add nodes in lines/planes (2D/3D) prior to this one. */
            for dI : dim-1 thru 1 step -1 do (
              tmpLoc          : copylist(cellLoc),
              for d : dim thru dI step -1 do ( tmpLoc[d] : 0 ),
              numNodesFac[dI] : (numCells[dim-1]-1)*assoc(tmpLoc,locToNumStoredNodes),
              tmpLoc[dim]     : 1,
              numNodesFac[dI] : numNodesFac[dI]+assoc(tmpLoc,locToNumStoredNodes),
              if (dim=3) and (dI=1) then (
                numNodesFac[dI] : (numCells[dim-2]-1)*numNodesFac[dI],
                tmpLoc[dim-1]   : 1,
                tmpNum          : assoc(tmpLoc,locToNumStoredNodes),
                numNodesFac[dI] : (numCells[dim-1]-1)*tmpNum+numNodesFac[dI],
                tmpLoc[dim-2]   : 1,
                numNodesFac[dI] : numNodesFac[dI]+assoc(tmpLoc,locToNumStoredNodes)
              )
            ),
            return(numNodesFac)
          ),
          cellMemOffFac : getCellMemOff(stencilLoc[sI]),

          /* Compute the memory offset of the nodes in this cell (not just the nodes it owns). */
          upbDirs    : sublist_indices(stencilLoc[sI],lambda([x],x=1)),
          nodeMemOff : makelist(0,i,1,numNodes),
          for nI : 1 thru numNodes do (
            currNode : copylist(nodes[nI]),
            cellIdx  : makelist(idx[d-1],d,1,dim),
            /* Modify cell index & node number for nodes on periodic boundary. */
            upNodeCoords : sublist_indices(currNode,lambda([x],x=1)), /* Node coordinates that =1. */
            newNode : copylist(currNode),
            for d : 1 thru length(upNodeCoords) do (
              if isInList(upNodeCoords[d],upbDirs) then (
                if (currBC[upNodeCoords[d]]=0) then ( /* Only for periodic boundaries. */
                  newNode[upNodeCoords[d]] : -1,
                  cellIdx[upNodeCoords[d]] :  0
                )
              ) else (
                newNode[upNodeCoords[d]] : -1,
                cellIdx[upNodeCoords[d]] : idx[upNodeCoords[d]-1]+1
              )
            ),
            nodeIdx : sublist_indices(storedNodesBC, lambda([x], x=newNode))[1],
            /* Modify cell index & node number for nodes not stored in this cell and not on a boundary. */
            isOnBoundary : false,
            for d : 1 thru length(upNodeCoords) do (
              if isInList(upNodeCoords[d],upbDirs) then ( isOnBoundary : true )
            ),
            if (not isInList(currNode,storedNodes)) and (not isOnBoundary) then (
              compLength(a, b) := length(a) > length(b),
              checkCoords : delete([],sort(full_listify(powerset(setify(upNodeCoords))), 'compLength)), /* Excludes the null set. */
              ifStr : " ",
              for hi : 1 thru length(checkCoords) do (
                newLoc     : copylist(stencilLoc[sI]),
                newCellIdx : copylist(cellIdx),
                newNode    : copylist(currNode),
                condStr    : "",
                for d : 1 thru length(upNodeCoords) do (
                  newCellIdx[upNodeCoords[d]] : idx[upNodeCoords[d]-1]+1,
                  newNode[upNodeCoords[d]]    : -1
                ),
                for j : 1 thru length(checkCoords[hi]) do (
                  if (j>1) then ( condStr : sconcat(condStr," && ") ),
                  condStr : sconcat(condStr,"(idx[",checkCoords[hi][j]-1,"]+1==numCells[",checkCoords[hi][j]-1,"]-1)"), /* If in 2nd to last cell. */
                  newLoc[checkCoords[hi][j]] : 1 /* Should be -1, but 0 works with getCellMemOff. */
                ),
                boundCellOffFac : getCellMemOff(newLoc),
                newNodeIdx      : sublist_indices(storedNodesBC, lambda([x], x=newNode))[1],
                nodeMemOff      : sum(newCellIdx[d]*boundCellOffFac[d],d,1,dim)+newNodeIdx-1,
                printf(fh, " ~aif (~a) {~%",ifStr,condStr),
                printf(fh, "    ~a = ~a; ~%", globalIdxs[nI-1], fullratsimp(nodeMemOff)),
                printf(fh, "  }"),
                ifStr : "else "
              ),
              /* Nodes not on a last cell (in a given direction) can use the
                 same idx factors as for interior cells. */
              newNode : copylist(currNode),
              for d : 1 thru length(upNodeCoords) do (
                newNode[upNodeCoords[d]] : -1,
                cellIdx[upNodeCoords[d]] : idx[upNodeCoords[d]-1]+1
              ),
              newNodeIdx : sublist_indices(storedNodesBC, lambda([x], x=newNode))[1],
              nodeMemOff : sum(cellIdx[d]*cellMemOffFac[d],d,1,dim)+newNodeIdx-1,
              printf(fh, " else {~%"),
              printf(fh, "    ~a = ~a; ~%", globalIdxs[nI-1], fullratsimp(nodeMemOff)),
              printf(fh, "  }~%"),
              printf(fh, "~%")
            ) else (
              nodeMemOff : sum(cellIdx[d]*cellMemOffFac[d],d,1,dim)+nodeIdx-1,
              printf(fh, "  ~a = ~a; ~%", globalIdxs[nI-1], fullratsimp(nodeMemOff))
            )
          ),

          printf(fh,"~%"),

          printf(fh,"}~%"),
          printf(fh,"~%")
        )
      )
    )
  )
)$
