/*  Generate kernels for constructing the cubic velocity mapping and
    corresponding quadratic representation of the inverse Jacobian. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
fpprec : 24$

calc_vmap(fh, funcNm, vdim) := block(
  [bV_p3, varsV_p3, NV_p3, bV_p2, varsV_p2, NV_p2],

  kill(varsV_p2, bV_p2, varsV_p3, bV_p3),

  /* Load cubic mapping for momentum-space coordinate 
     Only 1D because we have 3 1D mappings. But we need
     3 of them to obtain the correct variation in up to 3V. */
  [varsV_p3,bV_p3] : loadBasis("Tensor", 1, 3),
  NV_p3 : length(bV_p3),

  /* Quadratic mapping for the Jacobian (derivative of the cubic mapping) */
  [varsV_p2,bV_p2] : loadBasis("Tensor", 1, 2),
  NV_p2 : length(bV_p2),

  /* Specific bases for computing Jacobian */
  bV_vx_p3 : subst(x=x, copylist(bV_p3)), 
  bV_vy_p3 : subst(x=y, copylist(bV_p3)), 
  bV_vz_p3 : subst(x=z, copylist(bV_p3)), 
  bV_vx_p2 : subst(x=x, copylist(bV_p2)), 
  bV_vy_p2 : subst(x=y, copylist(bV_p2)), 
  bV_vz_p2 : subst(x=z, copylist(bV_p2)), 
  [varsV_vdim_p3,bV_vdim_p3] : loadBasis("Ser", vdim, 3),
  [varsV_vdim_p2,bV_vdim_p2] : loadBasis("Tensor", vdim, 2),
  NV_vdim_p2 : length(bV_vdim_p2), 
  NV_vdim_p3 : length(bV_vdim_p3), 

  /* Function declaration with input/output variables. */
  printf(fh, "void ~a(const double *dv, const double *v_cubic_dir[GKYL_MAX_VDIM], double* GKYL_RESTRICT vmap, double* GKYL_RESTRICT jacob_vel_inv, 
    double* GKYL_RESTRICT vmap_pgkyl, double* GKYL_RESTRICT jacob_vel_pgkyl, double* GKYL_RESTRICT jacob_vel_gauss) ~%{ ~%", funcNm),
  printf(fh, "  // v_cubic_dir: Cubic C^1 representation of the velocity mapping.~%"),
  printf(fh, "  // vmap: Velocity-space nonuniform mapping in each dimension.~%"),
  printf(fh, "  // jacob_vel_inv: Inverse of velocity space Jacobian in each dimension.~%"),
  printf(fh, "  // vmap_pgkyl: Velocity-space nonuniform mapping for I/O (defined in full 1V, 2V, or 3V).~%"),
  printf(fh, "  // jacob_vel_pgkyl: Velocity space Jacobian for I/O (defined in full 1V, 2V, or 3V).~%"),
  printf(fh, "  // jacob_vel_gauss: Velocity space Jacobian at Gauss-Legendre quadrature points.~%"),
  printf(fh, " ~%"),  

  printf(fh, "  double dv_tot = 1.0; ~%"),
  for dir : 1 thru vdim do (
    printf(fh, "  const double dv~a = 2.0/dv[~a]; ~%", dir-1, dir-1),
    printf(fh, "  dv_tot *= 2.0/dv[~a]; ~%", dir-1, dir-1),
    printf(fh, "  const double *v_cubic_dir~a = &v_cubic_dir[~a][0]; ~%", dir-1, dir-1),
    printf(fh, "  double *p~a = &vmap[~a]; ~%", dir-1, NV_p3*(dir-1)),
    printf(fh, "  double *vmap_pgkyl~a = &vmap_pgkyl[~a]; ~%", dir-1, NV_vdim_p3*(dir-1)),
    printf(fh, "  double *jacob_vel_inv~a = &jacob_vel_inv[~a]; ~%", dir-1, NV_p2*(dir-1))
  ),

  px_e : doExpand1(p0, bV_p3), 
  py_e : doExpand1(p1, bV_p3), 
  pz_e : doExpand1(p2, bV_p3), 

  /* For p = 2, we use the nodes (-1, 0, 1) (Gauss-Lobatto nodes) */
  nodes_lobatto : getNodes("Tensor", 1, 2),
  num_nodes_lobatto : length(nodes_lobatto), 
  basis_nodal_lobatto : getVarsNodalBasisWithNodes("Tensor", 1, 2, varsV_p3, nodes_lobatto), 
  /* Evaluate the derivative at nodes */
  jacob_velx_nodes : expand(float(evAtNodes(diff(px_e,x),nodes_lobatto,varsV_p3))),  
  jacob_vely_nodes : expand(float(evAtNodes(diff(py_e,x),nodes_lobatto,varsV_p3))),  
  jacob_velz_nodes : expand(float(evAtNodes(diff(pz_e,x),nodes_lobatto,varsV_p3))),  
  jacob_vel_nodes : [jacob_velx_nodes, jacob_vely_nodes, jacob_velz_nodes], 

  jacob_velx_nodal_e : doExpand1(jacob_vel_inv_nodal0,basis_nodal_lobatto), 
  jacob_vely_nodal_e : doExpand1(jacob_vel_inv_nodal1,basis_nodal_lobatto),
  jacob_velz_nodal_e : doExpand1(jacob_vel_inv_nodal2,basis_nodal_lobatto),
  jacob_vel_nodal_e : [jacob_velx_nodal_e, jacob_vely_nodal_e, jacob_velz_nodal_e],  

  for i : 1 thru vdim do (
    printf(fh, "  p~a[0] = v_cubic_dir~a[0];~%", i-1, i-1), 
    printf(fh, "  p~a[1] = v_cubic_dir~a[1];~%", i-1, i-1),
    printf(fh, "  p~a[2] = v_cubic_dir~a[2];~%", i-1, i-1),
    printf(fh, "  p~a[3] = v_cubic_dir~a[3];~%", i-1, i-1), 
    printf(fh, "~%"),

    printf(fh, "  double jacob_vel_inv_nodal~a[~a] = {0.0};~%", i-1, num_nodes_lobatto), 
    jacob_vel_nodes_dir : jacob_vel_nodes[i], 
    for j : 1 thru num_nodes_lobatto do (
      printf(fh, "  jacob_vel_inv_nodal~a[~a] = 1.0/(dv~a*(~a));~%", i-1, j-1, i-1, jacob_vel_nodes_dir[j])
    ),
    printf(fh, "~%"),

    jacob_vel_inv_c : calcInnerProdList(varsV_p2, 1, bV_p2, jacob_vel_nodal_e[i]), 
    for k : 1 thru NV_p2 do (
      printf(fh, "  jacob_vel_inv~a[~a] = ~a;~%", i-1, k-1, float(expand(jacob_vel_inv_c[k])))
    ),
    printf(fh, "~%") 
  ), 

  /* Expand vmap and inverse Jacobian in high dimensional basis for I/O
     along with full Jacobian at Gauss-Legendre quadrature nodes */
  nodes_gauss : gaussOrd(3, vdim),
  num_nodes_gauss : length(nodes_gauss), 
  px_gauss_e : doExpand1(p0, bV_vx_p3), 
  py_gauss_e : doExpand1(p1, bV_vy_p3), 
  pz_gauss_e : doExpand1(p2, bV_vz_p3), 
  /* Evaluate the derivative at nodes */
  if (vdim = 1) then (
    vmap_vx_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, px_gauss_e), 
    jacob_vel_vdim_c : calcInnerProdList(varsV_vdim_p2, 1, bV_vdim_p2, diff(px_gauss_e,x)), 
    writeCExprs1(vmap_pgkyl0, vmap_vx_c), 
    printf(fh, "~%"), 
    jacob_vel_gauss_nodes : evAtNodes(diff(px_gauss_e,x), nodes_gauss, varsV_vdim_p3)
  )
  else if (vdim = 2) then(
    vmap_vx_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, px_gauss_e), 
    vmap_vy_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, py_gauss_e), 
    jacob_vel_vdim_c : calcInnerProdList(varsV_vdim_p2, 1, bV_vdim_p2, diff(px_gauss_e,x)*diff(py_gauss_e,y)), 
    writeCExprs1(vmap_pgkyl0, vmap_vx_c), 
    writeCExprs1(vmap_pgkyl1, vmap_vy_c), 
    printf(fh, "~%"),     
    jacob_vel_gauss_nodes : evAtNodes(diff(px_gauss_e,x)*diff(py_gauss_e,y), nodes_gauss, varsV_vdim_p3)
  )
  else (
    vmap_vx_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, px_gauss_e), 
    vmap_vy_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, py_gauss_e), 
    vmap_vz_c : calcInnerProdList(varsV_vdim_p3, 1, bV_vdim_p3, pz_gauss_e), 
    jacob_vel_vdim_c : calcInnerProdList(varsV_vdim_p2, 1, bV_vdim_p2, diff(px_gauss_e,x)*diff(py_gauss_e,y)*diff(pz_gauss_e,z)), 
    writeCExprs1(vmap_pgkyl0, vmap_vx_c), 
    writeCExprs1(vmap_pgkyl1, vmap_vy_c), 
    writeCExprs1(vmap_pgkyl2, vmap_vz_c), 
    printf(fh, "~%"),  
    jacob_vel_gauss_nodes : evAtNodes(diff(px_gauss_e,x)*diff(py_gauss_e,y)*diff(pz_gauss_e,z), nodes_gauss, varsV_vdim_p3)
  ),
  for i : 1 thru NV_vdim_p2 do (
    printf(fh, "  jacob_vel_pgkyl[~a] = dv_tot*(~a);~%", i-1, float(expand(jacob_vel_vdim_c[i])))
  ),
  printf(fh, "~%"), 
  for i : 1 thru num_nodes_gauss do (
    printf(fh, "  jacob_vel_gauss[~a] = dv_tot*(~a);~%", i-1, float(expand(jacob_vel_gauss_nodes[i])))
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$  

