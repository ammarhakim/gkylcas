/* Functions (called by moment-calc.mac) that compute the
   moments of the distribution function in Vlasov model. */

load("modal-basis");
load("out-scripts");
load("utilities")$
load("nodal_operations/nodal_functions")$
load(stringproc)$
fpprec : 24$

volExpr(cdim, vdim) := prod(dxv[cdim+i-1], i, 1, vdim)$
volExprTot(totDim) := prod(dxv[i-1], i, 1, totDim)$
pVsub : [x=vx,y=vy,z=vz]$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
dv11 : [dv10, dv11, dv12]$

vTrans  : [vx*dv1/2.0+wx1, vy*dv2/2.0+wx2, vz*dv3/2.0+wx3]$
wTrans  : [wx1, wx2, wx3]$
dvTrans : [vx*dv1/2.0, vy*dv2/2.0, vz*dv3/2.0]$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

/* M0 integrated over a subset of velocity-space in the upper half-plane */
calcSRM0_reduced(fh, funcNm, cdim, vdim, basisFun, polyOrder, upper) := block(
  [varsC, bC, varsP, bP],
  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  /* Load cubic mapping for momentum-space coordinate 
     Only 1D because we have 3 1D mappings. But we need
     3 of them to obtain the correct variation in up to 3V. */
  [varsV_p3,bV_p3] : loadBasis(basisFun, 1, 3),
  bV_vx : subst(x=vx, copylist(bV_p3)), 
  bV_vy : subst(x=vy, copylist(bV_p3)), 
  bV_vz : subst(x=vz, copylist(bV_p3)), 
  NV_p3 : length(bV_p3),

  if (upper) then (
    printf(fh, "GKYL_CU_DH void ~a_M0_upper_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, const double *vmap, double v_thresh, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder)
  )
  else (
    printf(fh, "GKYL_CU_DH void ~a_M0_lower_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, const double *vmap, double v_thresh, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder)
  ), 
  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),
  vid : vidx(cdim,vdim),
  for i : 1 thru vdim do (
    printf(fh, "  const double *p~a = &vmap[~a]; ~%", i-1, NV_p3*(i-1))
  ),

  px_e : doExpand1(p0, bV_vx), 
  py_e : doExpand1(p1, bV_vy), 
  pz_e : doExpand1(p2, bV_vz), 
  p_e : [px_e, py_e, pz_e],

  /* Make a set of Gauss-Legendre nodes for evaluating configuration-space basis. */
  nodes_conf : gaussOrd(polyOrder+1, cdim),
  num_nodes_conf : length(nodes_conf), 

  /* Make a set of Gauss-Legendre nodes for evaluating velocity-space mapping. 
     Velocity-space is assumed to be quadratic (p+1 = 3 quadrature points). */
  nodes_vel : gaussOrd(3, vdim),
  num_nodes_vel : length(nodes_vel), 
  px_ords : gcfac(float(evAtNodes(px_e,nodes_vel,varsV))),
  py_ords : gcfac(float(evAtNodes(py_e,nodes_vel,varsV))),
  pz_ords : gcfac(float(evAtNodes(pz_e,nodes_vel,varsV))),

  f_e : doExpand1(f, bP),
  if (polyOrder=1 and basisFun="ser") then (  /* Force p=1 Serendipity to use hybrid basis. */
    nodes_phase : gaussOrdHyb(1+1, cdim, vdim), 
    basisNodal_phase : getVarsNodalBasisWithNodesHyb("hyb", cdim, vdim, varsP, nodes_phase)
  )
  else (
    nodes_phase : gaussOrd(polyOrder+1, cdim+vdim), 
    basisNodal_phase : getVarsNodalBasisWithNodes("Tensor", cdim+vdim, polyOrder, varsP, nodes_phase)
  ),
  num_nodes_phase : length(nodes_phase), 

  f_ords : gcfac(float(evAtNodes(f_e,nodes_phase,varsP))),
  printf(fh, "  double f_nodes[~a] = {0.0};~%", num_nodes_phase),
  for j : 1 thru num_nodes_vel do (
    if (upper) then (
      printf(fh, "  if (~a > v_thresh) { ~%", px_ords[j])
    )
    else (
      printf(fh, "  if (~a < -v_thresh) { ~%", px_ords[j])
    ), 
    for i : 1 thru num_nodes_conf do (
      printf(fh, "    f_nodes[~a] = ~a; ~%", (j-1)+(i-1)*num_nodes_vel, f_ords[j+(i-1)*num_nodes_vel])
    ), 
    printf(fh, "  } ~%")
  ), 
  fNodal_e : doExpand1(f_nodes, basisNodal_phase),
  /* Compute moment in nodal basis since we can do so without aliasing */
  M : calcInnerProdList(varsP, 1, bC, fNodal_e), 
  clst : [volFact],
  writeCIncrExprsCollect1(out, volFact*M, clst),
  
  printf(fh, "} ~%")
)$  

/* Momentum */
calcSRM1i(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV, fl, M, clst],
  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  /* Load basis sets for inverse Jacobian in each direction, 
     which are p=2 in one velocity dimension (derivative of cubic C^1 mapping) */
  [varsV_1D, bV_1D] :  loadBasis(basisFun, 1, 2), 
  bV_vx : subst(x=vx, copylist(bV_1D)), 
  bV_vy : subst(x=vy, copylist(bV_1D)), 
  bV_vz : subst(x=vz, copylist(bV_1D)), 
  NV_1D : length(bV_1D),
  
  printf(fh, "GKYL_CU_DH void ~a_M1i_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, const double *jacob_vel_inv, const double *gamma, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),

  vid : vidx(cdim,vdim),
  for i : 1 thru vdim do (
    printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i]), 
    printf(fh, "  const double *jacob_vel_inv~a = &jacob_vel_inv[~a]; ~%", i-1, NV_1D*(i-1))
  ),

  /* Expand inverse velocity space Jacobian in corresponding coordinate */
  jacob_vel_inv_vx : doExpand1(jacob_vel_inv0, bV_vx), 
  jacob_vel_inv_vy : doExpand1(jacob_vel_inv1, bV_vy), 
  jacob_vel_inv_vz : doExpand1(jacob_vel_inv2, bV_vz),
  jacob_vel_inv_fld : [jacob_vel_inv_vx, jacob_vel_inv_vy, jacob_vel_inv_vz],  

  /* Compute p/gamma from input gamma, p/gamma = d/dp gamma */
  gamma_e : doExpand1(gamma, bV), 
  printf(fh, "  double p0_over_gamma[~a] = {0.0}; ~%", NV), 
  px_over_gamma_c : calcInnerProdList(varsV, 1, bV, jacob_vel_inv_fld[1]*dv11[1]*diff(gamma_e, vx)), 
  writeCExprs1(p0_over_gamma, px_over_gamma_c), 
  /* zero out components of px/gamma which are empty due to derivative */
  px_over_gamma_NoZero : doMakeExprLst(px_over_gamma_c, p0_over_gamma),
  px_over_gamma_NoZero_e : doExpandLst(px_over_gamma_NoZero, bV), 
  p_over_gamma_fld : [px_over_gamma_NoZero_e],
  printf(fh, "~%"),
  if (vdim > 1) then (
    printf(fh, "  double p1_over_gamma[~a] = {0.0}; ~%", NV), 
    py_over_gamma_c : calcInnerProdList(varsV, 1, bV, jacob_vel_inv_fld[2]*dv11[2]*diff(gamma_e, vy)), 
    writeCExprs1(p1_over_gamma, py_over_gamma_c), 
    /* zero out components of py/gamma which are empty due to derivative */
    py_over_gamma_NoZero : doMakeExprLst(py_over_gamma_c, p1_over_gamma),
    py_over_gamma_NoZero_e : doExpandLst(py_over_gamma_NoZero, bV), 
    p_over_gamma_fld : [px_over_gamma_NoZero_e, py_over_gamma_NoZero_e],
    printf(fh, "~%")
  ),
  if (vdim = 3) then (
    printf(fh, "  double p2_over_gamma[~a] = {0.0}; ~%", NV), 
    pz_over_gamma_c : calcInnerProdList(varsV, 1, bV, jacob_vel_inv_fld[3]*dv11[3]*diff(gamma_e, vz)), 
    writeCExprs1(p2_over_gamma, pz_over_gamma_c), 
    /* zero out components of px/gamma which are empty due to derivative */
    pz_over_gamma_NoZero : doMakeExprLst(pz_over_gamma_c, p2_over_gamma),
    pz_over_gamma_NoZero_e : doExpandLst(pz_over_gamma_NoZero, bV), 
    p_over_gamma_fld : [px_over_gamma_NoZero_e, py_over_gamma_NoZero_e, pz_over_gamma_NoZero_e],
    printf(fh, "~%")
  ),
  
  fl : doExpand1(f, bP),
  
  M : (M : [],
    for dir : 1 thru vdim do (
      M : append(M, calcInnerProdList(varsP, p_over_gamma_fld[dir], bC, fl))
    ),
  M),
  
  clst : [volFact],
  writeCIncrExprsCollect1(out, volFact*M, clst),
  
  printf(fh, "} ~%")
)$

/* M3i energy-flux moment (just p in relativity) */
calcSRM3i(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, fl, M3, M3i],
  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  
  /* Load cubic mapping for momentum-space coordinate 
     Only 1D because we have 3 1D mappings. But we need
     3 of them to obtain the correct variation in up to 3V. */
  [varsV_p3,bV_p3] : loadBasis(basisFun, 1, 3),
  bV_vx : subst(x=vx, copylist(bV_p3)), 
  bV_vy : subst(x=vy, copylist(bV_p3)), 
  bV_vz : subst(x=vz, copylist(bV_p3)), 
  NV_p3 : length(bV_p3),

  printf(fh, "GKYL_CU_DH void ~a_M3i_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, const double *vmap, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),
  vid : vidx(cdim,vdim),
  for i : 1 thru vdim do (
    printf(fh, "  const double *p~a = &vmap[~a]; ~%", i-1, NV_p3*(i-1))
  ),

  px_e : doExpand1(p0, bV_vx), 
  py_e : doExpand1(p1, bV_vy), 
  pz_e : doExpand1(p2, bV_vz), 
  p_e : [px_e, py_e, pz_e],

  fl : doExpand1(f, bP),

  M3 : (M3 : [],
    for dir : 1 thru vdim do (
      M3 : append(M3, calcInnerProdList(varsP, p_e[dir], bC, fl))
    ),
  M3),

  clst : [volFact],
  M3i : [],
  M3i : append(M3i, volFact*M3),
  writeCIncrExprsCollect1(out, M3i, clst),
  
  printf(fh, "} ~%")
)$

calcSRIntMDist(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV, fl, M0, Energy, M3, clst, int],
  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  /* Load cubic mapping for momentum-space coordinate 
     Only 1D because we have 3 1D mappings. But we need
     3 of them to obtain the correct variation in up to 3V. */
  [varsV_p3,bV_p3] : loadBasis(basisFun, 1, 3),
  bV_vx : subst(x=vx, copylist(bV_p3)), 
  bV_vy : subst(x=vy, copylist(bV_p3)), 
  bV_vz : subst(x=vz, copylist(bV_p3)), 
  NV_p3 : length(bV_p3),
    
  printf(fh, "GKYL_CU_DH void ~a_int_mom_~ax~av_~a_p~a(const double *w, const double *dxv, const int *idx, const double *vmap, const double *gamma, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  const double volFact = ~a*~a; ~%", volExprTot(cdim+vdim), float(1/(2^(cdim+vdim))) ),
  for i : 1 thru vdim do (
    printf(fh, "  const double *p~a = &vmap[~a]; ~%", i-1, NV_p3*(i-1))
  ),

  px_e : doExpand1(p0, bV_vx), 
  py_e : doExpand1(p1, bV_vy), 
  pz_e : doExpand1(p2, bV_vz), 
  p_e : [px_e, py_e, pz_e],

  fl : doExpand1(f, bP),

  M : [],

  M0 : fullratsimp(innerProd(varsP, 1, 1, fl)),
  M  : endcons(M0,M),

  Energy : fullratsimp(innerProd(varsP, 1, doExpand1(gamma, bV), fl)),
  M  : endcons(Energy, M),

  /* Energy flux */
  for dir : 1 thru vdim do (
    M3 : fullratsimp(innerProd(varsP, 1, p_e[dir], fl)),
    M  : endcons(M3,M)
  ),

  M : map(letsimp, M),
  clst : [volFact],
  writeCIncrExprsCollect1(out, volFact*M, clst),

  printf(fh, "} ~%")
)$

calcSRMoments(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block([],
  printf(fh, "#include <gkyl_mom_vlasov_sr_kernels.h> ~%"),
  calcSRM0_reduced(fh, funcNm, cdim, vdim, basisFun, polyOrder, true),
  calcSRM0_reduced(fh, funcNm, cdim, vdim, basisFun, polyOrder, false),
  calcSRM1i(fh, funcNm, cdim, vdim, basisFun, polyOrder),
  calcSRM3i(fh, funcNm, cdim, vdim, basisFun, polyOrder),
  calcSRIntMDist(fh, funcNm, cdim, vdim, basisFun, polyOrder)
)$
