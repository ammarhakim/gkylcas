/*  Generate kernels for 
    1. gamma = sqrt(1 + p^2),
    2. gamma_inv = 1.0/sqrt(1 + p^2),
    These quantities are derived from the grid and must be continuous, 
    so they are projected onto basis functions using Gauss-Lobatto nodes. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
fpprec : 24$

let(w0^2, w0_sq)$
let(dv0^2, dv0_sq)$
let(w1^2, w1_sq)$
let(dv1^2, dv1_sq)$
let(w2^2, w2_sq)$
let(dv2^2, dv2_sq)$

calcLorentz(fh, funcNm, vdim, basisFun, polyOrder) := block(
  [bV, NV],

  kill(varsV, bV),

  /* Load basis of dimensionality requested. */
  [varsV,bV] : loadBasis(basisFun, vdim, polyOrder),
  NV : length(bV),

  /* Load cubic mapping for momentum-space coordinate 
     Only 1D because we have 3 1D mappings. But we need
     3 of them to obtain the correct variation in up to 3V. */
  [varsV_p3,bV_p3] : loadBasis(basisFun, 1, 3),
  bV_vx : subst(x=x, copylist(bV_p3)), 
  bV_vy : subst(x=y, copylist(bV_p3)), 
  bV_vz : subst(x=z, copylist(bV_p3)), 
  NV_p3 : length(bV_p3),

  printf(fh, "#include <gkyl_sr_Gamma_kernels.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *vmap, double* GKYL_RESTRICT gamma, double* GKYL_RESTRICT gamma_inv) ~%{ ~%", funcNm),
  printf(fh, "  // w:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv: Cell spacing.~%"),
  printf(fh, "  // vmap:  Momentum-space nonuniform mapping.~%"),
  printf(fh, "  // gamma:  Particle Lorentz boost factor sqrt(1 + p^2).~%"),
  printf(fh, "  // gamma_inv: Inverse particle Lorentz boost factor 1/sqrt(1 + p^2).~%"),
  printf(fh, " ~%"),  

  for dir : 1 thru vdim do (
    printf(fh, "  const double *p~a = &vmap[~a]; ~%", dir-1, NV_p3*(dir-1))
  ),

  px_e : doExpand1(p0, bV_vx), 
  py_e : doExpand1(p1, bV_vy), 
  pz_e : doExpand1(p2, bV_vz), 

  /* For p = 2, we use the nodes (-1, 0, 1) (Gauss-Lobatto nodes) */
  nodes_lobatto : getNodes(basisFun, vdim, polyOrder),
  num_nodes_lobatto : length(nodes_lobatto), 
  px_nodes : expand(float(evAtNodes(px_e,nodes_lobatto,varsV))),  
  py_nodes : expand(float(evAtNodes(py_e,nodes_lobatto,varsV))),  
  pz_nodes : expand(float(evAtNodes(pz_e,nodes_lobatto,varsV))),  

  printf(fh, "  double gamma_nodal[~a] = {0.0};~%", num_nodes_lobatto),
  printf(fh, "  double gamma_inv_nodal[~a] = {0.0};~%", num_nodes_lobatto),
  printf(fh, "~%"), 
  for i : 1 thru num_nodes_lobatto do (
    if (vdim = 1) then (
      printf(fh, "  gamma_nodal[~a] = sqrt(1.0 + pow(~a, 2.0));~%", i-1, px_nodes[i])
    )
    else if (vdim = 2) then (
      printf(fh, "  gamma_nodal[~a] = sqrt(1.0 + pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, px_nodes[i], py_nodes[i])
    )
    else (
      printf(fh, "  gamma_nodal[~a] = sqrt(1.0 + pow(~a, 2.0) + pow(~a, 2.0) + pow(~a, 2.0));~%", i-1, px_nodes[i], py_nodes[i], pz_nodes[i])
    ), 
    printf(fh, "  gamma_inv_nodal[~a] = 1.0/gamma_nodal[~a];~%", i-1, i-1)
  ), 
  printf(fh, "~%"), 
  
  basis_nodal_lobatto : getVarsNodalBasisWithNodes(basisFun, vdim, polyOrder, varsV, nodes_lobatto), 
  gamma_nodal_e : doExpand1(gamma_nodal,basis_nodal_lobatto),
  gamma_inv_nodal_e : doExpand1(gamma_inv_nodal,basis_nodal_lobatto),

  gamma_c : calcInnerProdList(varsV, 1, bV, gamma_nodal_e), 
  gamma_inv_c : calcInnerProdList(varsV, 1, bV, gamma_inv_nodal_e), 
  writeCExprs1(gamma, gamma_c), 
  printf(fh, "~%"), 
  writeCExprs1(gamma_inv, gamma_inv_c), 
  flush_output(fh),

  printf(fh, "} ~%")
)$  

