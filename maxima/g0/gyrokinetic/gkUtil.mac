/*
  Utility functions for GK Maxima scripts.
*/
load("vect")$
load("nodal_operations/nodal_functions")$
load("nodal_operations/quadrature_functions")$

doMakeExprLst(vals, S) := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

expandInputFields(bC,bmagBasis) := block(
  [bmag_e,bmagInv_e,phi_e,Apar_e,dApardt_e,dApardtPrev_e,cdim,
   AparL_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,BdriftX_e,BdriftY_e],
  /* Expand background magnetic field and potentials. */
  bmag_e    : doExpand1(bmag,bmagBasis),
  phi_e     : doExpand1(phi,bC),
  Apar_e        : doExpand1(apar,bC),
  dApardt_e     : doExpand1(apardot,bC),
  dApardtPrev_e : doExpand1(apardot_prev,bC),
  /* NOTE: even though Apar and dApar/dt are allowed to be discontinuous
     in the parallel (z) direction, the surface term in the z direction
     does not involve Apar. Since Apar is continuous in the other directions,
     it does not matter if we use the right or left value. */

  cmag_e : doExpand1(cmag,bmagBasis),

  expOut : [bmag_e,cmag_e,phi_e,Apar_e,dApardt_e,dApardtPrev_e],

  b_x_e : doExpand1(b_x, bmagBasis),
  b_y_e : doExpand1(b_y, bmagBasis),
  b_z_e : doExpand1(b_z, bmagBasis),
  jacobTotInv_e : doExpand1(jacobtot_inv, bmagBasis),

  expOut : append(expOut,[b_x_e,b_y_e,b_z_e,jacobTotInv_e]),

  return(expOut)
)$

calcAndWrite_HamilES(fH,charge,mass,wv,rdv2,bP,inFlds,sideStr) := block(
  [varsP,numP,hamil_c,subList,hamilNoZero_c],
  /* Expand the Hamiltonian, and write them out. */

  /* Extract magnetic field and electrostatic potential. */
  bmag_e : inFlds[1],
  phi_e  : inFlds[3],

  hamil_e : charge*phi_e,
  if vdim > 0 then ( hamil_e : hamil_e + (1/2)*mass*(wv[1] + vpar/rdv2[1])^2 ),
  if vdim > 1 then ( hamil_e : hamil_e + (wv[2]+mu/rdv2[2])*bmag_e ),

  varsP : listofvars(bP),
  numP  : length(bP),

  /* Project Hamiltonian onto basis functions */
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),

  /* Write Hamiltonian. */
  printf(fh, "  double hamil~a[~a] = {0.}; ~%", sideStr, numP),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  hamilCvar : eval_string(sconcat("hamil",sideStr)),
  writeCExprsNoExpand1(hamilCvar, gcfac(subst(replaceList, hamil_c))),
  printf(fH, "~%"),
  flush_output(fH),

  hamilNoZero_c : doMakeExprLst(hamil_c, hamilCvar),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,

  return(hamil_e)
)$

calcAndWrite_BstardBmag(fH,cdim,bP,bmagBasis,surfDir,mass,charge,wvpar,rdx2,rdv2,inFlds,sideStr) := block (
  [cmag_e,Apar_e,BmagInv_e,BdriftX_e,BdriftY_e,BstarXdBmag_e,BstarYdBmag_e,BstarZdBmag_e,b_x_e,b_y_e,b_z_e,
   jacobTotInv_e,rdy2,rdz2,AparL_e,BstarZdBmagL_e,varsP,numP,replaceList,BstarXdBmag_c,BstarYdBmag_c,BstarZdBmag_c,
   BstarXdBmag_noZero_c,BstarYdBmag_noZero_c,BstarZdBmag_noZero_c,BstarZdBmagL_c,BstarZdBmagL_noZero_c,BstardBmagL_e],
  /* Compute the Bstar divided by B and write it out. */

  cmag_e        : inFlds[2],
  Apar_e        : inFlds[4],
  b_x_e         : inFlds[7],  b_y_e : inFlds[8],  b_z_e : inFlds[9],
  jacobTotInv_e : inFlds[10],

  if cdim > 1 then (rdy2 : rdx2[2]) else (rdy2 : 0),
  if cdim > 2 then (rdz2 : rdx2[3]) else (rdz2 : 0),

  /* Zero out some terms below to avoid the discontinuity of alpha in the
     parallel direction (due to the discontinuity of Apar). Otherwise some
     other treatment of some Apar terms or alpha may be needed. Initially we
     had a step averaging alpha across the surface (just for the parallel
     direction), but NRM suspects this might've caused instability in some
     cases. Hence the zeros below. */
  discontFac : 0,

  /* Expand BstarX/Bmag on basis. */
  BstarXdBmag_e : (-((mass/charge)*(wvpar+vpar/rdv2[1]))*rdz2*diff(b_y_e,z)
                   + rdy2*diff(Apar_e*b_z_e,y) - discontFac*rdz2*diff(Apar_e*b_y_e,z))*jacobTotInv_e,
  /* Expand BstarY/Bmag on basis. */
  BstarYdBmag_e : (-((mass/charge)*(wvpar+vpar/rdv2[1]))*(rdx2[1]*diff(b_z_e,x) - rdz2*diff(b_x_e,z))
                   + discontFac*rdz2*diff(Apar_e*b_x_e,z) - rdx2[1]*diff(Apar_e*b_z_e,x))*jacobTotInv_e,
  /* Expand BstarZ/Bmag on basis. */
  BstarZdBmag_e : (cmag_e + ((mass/charge)*(wvpar+vpar/rdv2[1]))*rdx2[1]*diff(b_y_e,x)
                   + discontFac*(rdx2[1]*diff(Apar_e*b_y_e,x) - rdy2*diff(Apar_e*b_x_e,y)))*jacobTotInv_e,

  varsP : listofvars(bP),
  numP  : length(bP),

  /* Project Bstar's onto basis, and print to arrays. */
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  if cdim > 1 then (
    BstarXdBmag_c : calcInnerProdList(varsP, 1, bP, BstarXdBmag_e),
    if (surfDir = 0 or surfDir = 1 or surfDir = cdim+1) then (
      printf(fh, "  double BstarXdBmag~a[~a] = {0.}; ~%", sideStr,numP),
      writeCExprsNoExpand1(eval_string(sconcat("BstarXdBmag",sideStr)), gcfac(subst(replaceList, BstarXdBmag_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    BstarXdBmag_noZero_c : doMakeExprLst(BstarXdBmag_c, eval_string(sconcat("BstarXdBmag",sideStr))),
    BstarXdBmag_e : BstarXdBmag_noZero_c . bP,

    BstarYdBmag_c : calcInnerProdList(varsP, 1, bP, BstarYdBmag_e),
    if (surfDir = 0 or surfDir = 2 or surfDir = cdim+1) then (
      printf(fh, "  double BstarYdBmag~a[~a] = {0.}; ~%", sideStr, numP),
      writeCExprsNoExpand1(eval_string(sconcat("BstarYdBmag",sideStr)), gcfac(subst(replaceList, BstarYdBmag_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    BstarYdBmag_noZero_c : doMakeExprLst(BstarYdBmag_c, eval_string(sconcat("BstarYdBmag",sideStr))),
    BstarYdBmag_e : BstarYdBmag_noZero_c . bP
  ),
  if cdim # 2 then (
    BstarZdBmag_c : calcInnerProdList(varsP, 1, bP, BstarZdBmag_e),
    if (surfDir=0 or surfDir>=cdim) then (
      printf(fh, "  double BstarZdBmag~a[~a] = {0.}; ~%", sideStr, numP),
      writeCExprsNoExpand1(eval_string(sconcat("BstarZdBmag",sideStr)), gcfac(subst(replaceList, BstarZdBmag_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    BstarZdBmag_noZero_c : doMakeExprLst(BstarZdBmag_c, eval_string(sconcat("BstarZdBmag",sideStr))),
    BstarZdBmag_e : BstarZdBmag_noZero_c . bP
  ),

  /* Make Bstar/Bmag vector. */
  if cdim = 1 then (
    BstardBmag_e : [BstarZdBmag_e]
  ) elseif cdim = 2 then (
    BstardBmag_e : [BstarXdBmag_e, BstarYdBmag_e]
  ) elseif cdim = 3 then (
    BstardBmag_e : [BstarXdBmag_e, BstarYdBmag_e, BstarZdBmag_e]
  ),

  return(BstardBmag_e)
)$

calcAndWrite_BstarZdBmag(fH,cdim,bP,bmagBasis,surfDir,mass,charge,wvpar,rdx2,rdv2,inFlds,sideStr) := block (
  [cmag_e,Apar_e,BmagInv_e,BdriftX_e,BdriftY_e,BstarXdBmag_e,BstarYdBmag_e,BstarZdBmag_e,b_x_e,b_y_e,b_z_e,
   jacobTotInv_e,rdy2,rdz2,AparL_e,BstarZdBmagL_e,varsP,numP,replaceList,BstarXdBmag_c,BstarYdBmag_c,BstarZdBmag_c,
   BstarXdBmag_noZero_c,BstarYdBmag_noZero_c,BstarZdBmag_noZero_c,BstarZdBmagL_c,BstarZdBmagL_noZero_c,BstardBmagL_e],
  /* Compute the Bstar divided by B and write it out. */

  cmag_e        : inFlds[2],
  b_x_e         : inFlds[7],  b_y_e : inFlds[8],  b_z_e : inFlds[9],
  jacobTotInv_e : inFlds[10],

  if cdim > 1 then (rdy2 : rdx2[2]) else (rdy2 : 0),
  if cdim > 2 then (rdz2 : rdx2[3]) else (rdz2 : 0),

  if (sideStr="L") then (Apar_e : inFlds[11])
  elseif (sideStr="R") then (Apar_e : inFlds[12])
  else (Apar_e : inFlds[4]),

  /* Expand BstarZ/Bmag on basis. */
  BstarZdBmag_e : (cmag_e + ((mass/charge)*(wvpar+vpar/rdv2[1]))*rdx2[1]*diff(b_y_e,x)
                   + (rdx2[1]*diff(Apar_e*b_y_e,x) - rdy2*diff(Apar_e*b_x_e,y)))*jacobTotInv_e,

  varsP : listofvars(bP),
  numP  : length(bP),

  /* Project Bstar's onto basis, and print to arrays. */
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  BstarZdBmag_c : calcInnerProdList(varsP, 1, bP, BstarZdBmag_e),
  printf(fh, "  double BstarZdBmag~a[~a]; ~%", sideStr, numP),
  writeCExprsNoExpand1(eval_string(sconcat("BstarZdBmag",sideStr)), gcfac(subst(replaceList, BstarZdBmag_c))),
  printf(fh, "~%"),
  flush_output(fh),
  BstarZdBmag_noZero_c : doMakeExprLst(BstarZdBmag_c, eval_string(sconcat("BstarZdBmag",sideStr))),
  BstarZdBmag_e : BstarZdBmag_noZero_c . bP,

  return(BstarZdBmag_e)
)$

poissonBracket(f,g,mass,charge,rdx2V,rdv2V,pbFacs) := block(
  [varsCall,cdim,varsC,rdy2,rdz2,BstardBmag_e,bmagInv_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e],
  /* Compute the Poisson bracket for the simple helical magnetic field. */

  varsCall : [x,y,z],
  cdim     : length(rdx2V),
  varsC    : makelist(varsCall[d],d,1,cdim),

  /* Function that computes the gradient. */
  /* 
     For some reason the following use of "vect" functions was giving extra
     brackets when generating volume kernels. Opt for our own function instead.
  scalefactors(varsC),
  fgrad(fIn) := ev(express(grad(fIn)),diff)*rdx2V,
  */
  fgrad(fIn,vars,diffFacs) := makelist(diff(fIn,vars[d]),d,1,length(vars))*diffFacs,

  if cdim > 1 then (rdy2 : rdx2V[2]) else (rdy2 : 0),
  if cdim > 2 then (rdz2 : rdx2V[3]) else (rdz2 : 0),

  BstardBmag_e : pbFacs[1],
  b_x_e : pbFacs[2],  b_y_e : pbFacs[3],  b_z_e : pbFacs[4],
  jacobTotInv_e : pbFacs[5],

  pb_e : (1/mass)*BstardBmag_e . (rdv2V[1]*(fgrad(f,varsC,rdx2V)*diff(g,vpar)-fgrad(g,varsC,rdx2V)*diff(f,vpar)))
        +(-(1/charge)*b_z_e*rdx2V[1]*rdy2*(diff(f,x)*diff(g,y)-diff(f,y)*diff(g,x))
          +(1/charge)*b_y_e*rdx2V[1]*rdz2*(diff(f,x)*diff(g,z)-diff(f,z)*diff(g,x))
          -(1/charge)*b_x_e*rdy2*rdz2*(diff(f,y)*diff(g,z)-diff(f,z)*diff(g,y)))*jacobTotInv_e,

  return(pb_e)
)$

calcAndWrite_alpha(fH,surfDir,bP,polyOrder,basisType,mass,charge,rdx2V,rdv2V,
                   inFlds,hamil_e,BstardBmag_e,sideStr,isStep2) := block(
  [varsP,varLabel,dirLabel,wSurf,rdSurfVar2,surfVar,surfIntVars,pbAuxFlds,bmagInv_e,b_x_e,
   b_y_e,b_z_e,jacobTotInv_e,alpha_e,Apar_e,dApardt_e,dApardtPrev_e,alphaL_e,
   bSurf,numSurf,evPoint,alpha_c,alphaCvar,alphaNoZero_c,alphaUpCvar,alphaUpNoZero_c],
  /* Calculate phase space velocity alpha in direction of surfVar. */
  /* We assume alpha.n is continuous across boundary, although H may not be. */
  /* Distinguish between alpha and alphaUp, where alphaUp is the one used to
     determine upwind direction. */

  varsP    : listofvars(bP),
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  wSurf      : eval_string(sconcat("w",dirLabel)),
  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  pbAuxFlds     : [BstardBmag_e],
  b_x_e         : inFlds[7],  b_y_e : inFlds[8],  b_z_e : inFlds[9],
  jacobTotInv_e : inFlds[10],

  pbAuxFlds : append(pbAuxFlds,[b_x_e,b_y_e,b_z_e,jacobTotInv_e]),
  alpha_e : poissonBracket(wSurf+surfVar/rdSurfVar2,hamil_e,mass,charge,rdx2V,rdv2V,pbAuxFlds),

  Apar_e : inFlds[4],  dApardt_e : inFlds[5],

  alphaUp_e : alpha_e,
  if surfVar = vpar then (
    alpha_e   : alpha_e - (charge/mass)*dApardt_e,
    alphaUp_e : alpha_e
  ),

  bSurf : basisFromVars(basisType,surfIntVars,polyOrder),  /* Surface basis. */
  numSurf : length(bSurf),

  if sideStr="L" then (evPoint : -1)
  elseif sideStr="R" then (evPoint : 1),

  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  /* Project full alpha expression evaluated at interior surface
     onto surface basis and print to C variable alpha. */
  alpha_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=evPoint,alpha_e)),
  printf(fh, "  double alpha~a[~a] = {0.}; ~%", sideStr, numSurf),
  alphaCvar : eval_string(sconcat("alpha",sideStr)),
  writeCExprsNoExpand1(alphaCvar, subst(replaceList,alpha_c)),
  printf(fh, "~%"),
  flush_output(fh),
  alphaNoZero_c : doMakeExprLst(alpha_c, alphaCvar),
  alphaSurf_e   : doExpandLst(alphaNoZero_c, bSurf),

  alphaUpSurf_e : alphaSurf_e,

  return([alphaUp_e,alphaSurf_e,alphaUpSurf_e])
)$

calc_surfAvgAlpha(bP,surfVar,alpha_e,evAtLower) := block(
  [i,v,varsP,numP,surfIntVars,surfBasis,ignoreVars,alphaSurfAvg_c,alphaSurfAvg_e,evPoint],
  /* Calculate the surface-averaged alpha. */

  varsP : listofvars(bP),
  numP  : length(bP),
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  if evAtLower then (evPoint:-1) else (evPoint:1),

  /* alpha coefficients are for an expansion in the full-dim phase basis. We
     need to project onto the a basis on the surface with the right normalization
     and dimensionality. */
  surfBasis  : copylist(bP),
  ignoreVars : listify(setdifference(setify(varsP),setify(surfIntVars))),
  for i : 1 thru numP do (
    for v : 1 thru length(ignoreVars) do (
      if not freeof(ignoreVars[v],bP[i]) then ( surfBasis[i] : 0 )
  )),
  alphaSurfAvg_c : calcInnerProdList(surfIntVars,1,surfBasis,subst(surfVar=evPoint,alpha_e)),
  alphaSurfAvg_e : doExpand(alphaSurfAvg_c,surfBasis),
  alphaSurfAvg_s : fullratsimp(innerProd(surfIntVars,1,alphaSurfAvg_e,1)/innerProd(surfIntVars,1,1,1)),

  return(alphaSurfAvg_s)
)$

calcAndWrite_surfAvgAlpha(fH,bP,surfDir,alpha_e,sideStr) := block([replaceList,evAtLower],
  /* Given the phase-space velocity alpha, compute the average over the surface
     perpendicular to the surfVar dimension, and at the lower/upper boundary if
     sideStr=R/L. Write it out too.*/

  surfVar : varsP[surfDir],             /* Surface variable. */

  if sideStr="R" then (evAtLower:true) else (evAtLower:false),
  
  alphaSurfAvg_s : calc_surfAvgAlpha(bP,surfVar,alpha_e,evAtLower),

  printf(fH, "  // Surface-averaged phase velocity in this direction.~%"),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq,
                 wvparL^2=wvparSqL, rdvpar2L^2=rdvpar2SqL, rdx2L^2=rdx2SqL,
                 wvparR^2=wvparSqR, rdvpar2R^2=rdvpar2SqR, rdx2R^2=rdx2SqR, m_^2=mSq, q_^2=qSq],
  printf(fH, "  double alphaSurfAvg~a = ~a; ~%~%", sideStr, float(subst(replaceList, alphaSurfAvg_s))),
  flush_output(fH),

  return(alphaSurfAvg_s)
)$

calcAndWrite_upwindIncr_wSurfAvgAlpha(fH,bP,polyOrder,surfDir,sideStr,alphaSurf_e,isStep2) := block(
  [varsP,numP,surfIntVars,fL_e,fR_e,fhatSurf_e,replaceList,fhatAlpha_c,incr_r,tMod,incrMod_r],
  /* Given a surface expansion of the phase-space velocity, alpha, determine the upwinding
     based on the surface average of alpha. Write the common increment to left/right cells
     (the actual output from the C kernel should be this increment times some scaling factor). */

  varsP       : listofvars(bP),
  numP        : length(bP),
  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  /* Expand distribution function. */
  fL_e : doExpand1(fL,bP),  fR_e : doExpand1(fR,bP),

  printf(fH, "  if (alphaSurfAvg~a>0) { ~%", sideStr),

  fhatSurf_e : subst(surfVar=1, fL_e),

  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq,
                 wvparL^2=wvparSqL, rdvpar2L^2=rdvpar2SqL, rdx2L^2=rdx2SqL,
                 wvparR^2=wvparSqR, rdvpar2R^2=rdvpar2SqR, rdx2R^2=rdx2SqR, m_^2=mSq, q_^2=qSq],
  /* Write out the increment to the right cell. Omit a dxv factor we incorporate later. */
  fhatAlpha_c : calcInnerProdList(surfIntVars, alphaSurf_e, subst(surfVar=-1, bP), fhatSurf_e),
  incrR_c     : fullratsimp(fhatAlpha_c),
  writeCExprsNoExpand1(incr, subst(replaceList, incrR_c)),
  flush_output(fH),

  if surfVar=vpar and polyOrder=1 and (not isStep2) then (
    tMod       : calcInnerProdList(surfIntVars, 1, subst(surfVar=-1, bP), fhatSurf_e),
    incrModR_c : fullratsimp(tMod),
    writeCExprsNoExpand1(incrEmMod, subst(replaceList, incrModR_c))
  ),

  printf(fH, "  } else { ~%"),

  fhatSurf_e : subst(surfVar=-1, fR_e),

  if surfVar=vpar and polyOrder=1 and (not isStep2) then (
    tMod       : calcInnerProdList(surfIntVars, 1, subst(surfVar=-1, bP), fhatSurf_e),
    incrModR_c : fullratsimp(tMod),
    writeCExprsNoExpand1(incrEmMod, subst(replaceList, incrModR_c))
  ),

  fhatAlpha_c : calcInnerProdList(surfIntVars, alphaSurf_e, subst(surfVar=-1, bP), fhatSurf_e),
  incrR_c     : fullratsimp(fhatAlpha_c),

  fhatAlpha_c : calcInnerProdList(surfIntVars, alphaSurf_e, subst(surfVar=1, bP), fhatSurf_e),
  incrL_c     : -fullratsimp(fhatAlpha_c),

  writeCExprsNoExpand1(incr, subst(replaceList, incrR_c)),
  printf(fH, "  }~%"),
  flush_output(fH),

  return([incrL_c,incrR_c])
)$

calcAndWrite_upwindIncr_wQuadNodeAlpha(fH,basisType,polyOrder,bP,surfDir,sideStr,
                                       alphaSurf_e,alphaUpSurf_e,fLR,isStep2) := block(
  [varsP,numP,pDim,surfIntVars,surfNodes,numNodes,fL_e,fR_e,fOrdL_n,fOrdR_n,alphaOrd_n,
   fUpOrd_n,fUp_c,fHatSurf_e,replaceList,Ghat_c,evPoint],
  /* Compute the common increment to left/right cells with upwinding based on
     the quadrature-node values of the phase-space velocity alpha. Write them
     out. The actual output should be these increments scaled by some
     cell-length factor. */

  varsP       : listofvars(bP),
  numP        : length(bP),
  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */
  pDim        : length(varsP),

  surfNodes : gaussOrd(polyOrder+1, pDim-1),
  numNodes  : length(surfNodes),

  /* Expand distribution function. */
  fL_e : doExpand1(fLR[1],bP),
  fR_e : doExpand1(fLR[2],bP),

  /* Evaluate fL, fR, and alpha at surface quadrature nodes. */
  fOrdL_n : gcfac(float(evAtNodes(subst(surfVar=+1,fL_e),surfNodes,surfIntVars))),
  fOrdR_n : gcfac(float(evAtNodes(subst(surfVar=-1,fR_e),surfNodes,surfIntVars))),
  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. */
  alphaOrd_n : gcfac(float(evAtNodes(alphaUpSurf_e,surfNodes,surfIntVars))),
  /* Determine upwinding at each surface quadrature node. */
  printf(fH, "  double fUpOrd~a[~a] = {0.};~%", sideStr, numNodes),
  for i : 1 thru numNodes do (
    printf(fH, "  if (~a > 0.) {~%",float(expand(fullratsimp(alphaOrd_n[i]/abs(content(args(alphaOrd_n[i])[1])[1]))))),
    printf(fH, "    fUpOrd~a[~a] = ~a; ~%", sideStr, i-1, fOrdL_n[i]),
    printf(fH, "  } else {~%"),
    printf(fH, "    fUpOrd~a[~a] = ~a; ~%", sideStr, i-1, fOrdR_n[i]),
    printf(fH, "  }~%")
  ),
  printf(fH, "~%"),
  flush_output(fH),

  bSurf : basisFromVars(basisType,surfIntVars,polyOrder),  /* Surface basis. */

  /* Get (quadrature) nodal surface expansion of fUp. */
  basisNodal : getVarsNodalBasisWithNodes("tensor", pDim-1, polyOrder, surfIntVars, surfNodes),
  fUpNodal_e : sum(eval_string(sconcat("fUpOrd",sideStr))[i-1]*basisNodal[i], i, 1, length(basisNodal)),
  fUp_c : fullratsimp(calcInnerProdList(surfIntVars, 1, bSurf, fUpNodal_e)),
  /* Write coefficients of modal surface expansion fupwind. */
  printf(fH, "  double fUp~a[~a] = {0.};~%", sideStr, length(bSurf)),
  writeCExprs1(eval_string(sconcat("fUp",sideStr)), fUp_c),
  printf(fH, "~%"),
  flush_output(fH),
  
  /* Zero out components of fUp which are empty and make new lists with right variable name. */
  fUp_NoZero : doMakeExprLst(fUp_c, eval_string(sconcat("fUp",sideStr))),
  fHatSurf_e : doExpandLst(fUp_NoZero, bSurf),

  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],

  if (sideStr="L") then (evPoint : -1)
  elseif (sideStr="R") then (evPoint : 1),

  Ghat_c : calcInnerProdList(surfIntVars, alphaSurf_e, bSurf, fHatSurf_e),
  Ghat_e : doExpand(Ghat_c, bSurf),
  printf(fH, "  double Ghat~a[~a] = {0.}; ~%", sideStr, numP),
  writeCExprs1(eval_string(sconcat("Ghat",sideStr)), Ghat_c),
  printf(fH, "~%"),
  flush_output(fH),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero : doMakeExprLst(Ghat_c, eval_string(sconcat("Ghat",sideStr))),
  Ghat_e     : doExpandLst(GhatNoZero, bSurf),

  incr_c : fullratsimp(calcInnerProdList(surfIntVars, -evPoint, subst(surfVar=evPoint, bP), Ghat_e)),

  return(incr_c)
)$


calcAndWrite_upwindIncr_wLFfluxes(fH,basisType,polyOrder,bP,surfDir,alphaSurf_e) := block(
  [varsP,surfIntVars,bSurf,numSurf,fL_e,fR_e,fAvg_c,
   fAvgNoZero_c,fAvg_e,fJump_c,fAvgAlpha_c,Ghat_c,Ghat_e],
  /* Compute Lax-Friedrich fluxes using the max phase-speed given to the kernel. */

  varsP       : listofvars(bP),
  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  bSurf : basisFromVars(basisType,surfIntVars,polyOrder),  /* Surface basis. */
  numSurf : length(bSurf),

  /* Expand distribution function. */
  fL_e : doExpand1(fL,bP),  fR_e : doExpand1(fR,bP),

  printf(fh, "  double amax = amax_in; ~%"),
  printf(fH, "~%"),

  printf(fh, "  double fAvg[~a]; ~%", numSurf),

  /* Print C exprs for favg = fr(sv=-1) + fl(sv=1) projected onto surface basis. */
  fAvg_c : gcfac(calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=-1, fR_e)+subst(surfVar=1, fL_e))),
  writeCExprsNoExpand1(fAvg, fAvg_c),
  fAvgNoZero_c : doMakeExprLst(fAvg_c, fAvg),
  fAvg_e       : doExpandLst(fAvgNoZero_c, bSurf),
  flush_output(fH),

  /* Project fjump = fr(sv=-1) - fl(sv=1) onto surface basis. Don't need
     to print it out because it is just part of Ghat. */
  fJump_c : gcfac(calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=-1, fR_e)-subst(surfVar=1, fL_e))),
  printf(fH, "~%"),
  flush_output(fH),

  /* Evaluate surface projection of Ghat = (alpha*fAvg - amax*fJump)/2. */
  printf(fh, "  double Ghat[~a]; ~%", numSurf),
  fAvgAlpha_c : gcfac(calcInnerProdList(surfIntVars, fAvg_e, bSurf, alphaSurf_e)),
  Ghat_c      : fullratsimp(fAvgAlpha_c/2 - (amax/2)*fJump_c),
  writeCExprsNoExpand1(Ghat, Ghat_c),
  printf(fH, "~%"),
  flush_output(fH),
  Ghat_e : doExpand1(Ghat, bSurf),

  /* Evaluate contribution to right cell (surfVar=-1). */
  incrR_c : gcfac(fullratsimp(calcInnerProdList(surfIntVars, 1, subst(surfVar=-1, bP), Ghat_e))),
  writeCExprsNoExpand1(incr, incrR_c),
  printf(fh, "~%"),
  flush_output(fH),

  incrL_c : gcfac(fullratsimp(innerProd(surfIntVars, -1, subst(surfVar=1, bP), Ghat_e))),

  return([incrL_c,incrR_c])
)$

calcAndWrite_quadCFLfreq_wPhaseAlpha(basisType,polyOrder,bP,surfDir,alpha_e) := block(
  [i,varsP,numP,pDim,surfVar,surfIntVars,surfNodes,numNodes,bSurf,numSurf,surfBasis,
   ignoreVars,alphaSurfL_c,alphaSurfL_e,alphaSurfL_n,alphaSurfR_c,alphaSurfR_e,alphaSurfR_n],
  /* Compute the CFL frequency from quadrature node contributions on the
     surfaces in the dir dimension, given a phase-space volume expansion
     of the speed (i.e. coming from doExpand(alpha,bP)). */

  varsP       : listofvars(bP),
  numP        : length(bP),
  pDim        : length(varsP),
  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  /* Evaluate cfl by evaluating at all surface quadrature points. */
  /* Get quadrature nodes on surface. */
  surfNodes : gaussOrd(polyOrder+1, pDim-1),
  numNodes : length(surfNodes),

  bSurf       : basisFromVars(basisType,surfIntVars,polyOrder),  /* Surface basis. */
  numSurf     : length(bSurf),

  surfBasis  : copylist(bP),
  ignoreVars : listify(setdifference(setify(varsP),setify(surfIntVars))),
  for i : 1 thru numP do (
    for v : 1 thru length(ignoreVars) do (
      if not freeof(ignoreVars[v],bP[i]) then ( surfBasis[i] : 0 )
  )),

  /* Coefficients of alpha written out to the file above are phase-space volume
     expansion coefficients. Need to evaluate at the surface and project onto
     surface basis, before (expanding and) evaluating at surface nodes. */
  /*
  alphaSurfL_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=-1,alpha_e)),
  alphaSurfL_e : doExpand(alphaSurfL_c, bSurf),
  */
  /*
  alphaSurfL_c : calcInnerProdList(surfIntVars,1,surfBasis,subst(surfVar=-1,alpha_e)),
  alphaSurfL_e : doExpand(alphaSurfL_c,surfBasis),
  alphaSurfL_n : gcfac(float(evAtNodes(alphaSurfL_e,surfNodes,surfIntVars))),
  */
  /* The extra factor of bP[1] below remains unexplained. NRM might've
     stumbled up one it by trial and error. */
  alphaSurfL_n : gcfac(float(evAtNodes(subst(surfVar=-1,alpha_e)*bP[1],surfNodes,surfIntVars)*bP[1])),
  printf(fh, "  // Evaluate alpha at left surface quadrature points.~%"),
  for i : 1 thru numNodes do (
    printf(fh, "  alphaL = ~a; ~%", gcfac(float(alphaSurfL_n[i]))),
    printf(fh, "  cflFreq += -0.5*(alphaL-fabs(alphaL)); ~%")
  ),

  /*
  alphaSurfR_c : calcInnerProdList(surfIntVars,1,surfBasis,subst(surfVar=+1,alpha_e)),
  alphaSurfR_e : doExpand(alphaSurfR_c,surfBasis),
  alphaSurfR_n : gcfac(float(evAtNodes(alphaSurfR_e,surfNodes,surfIntVars))),
  */
  alphaSurfR_n : gcfac(float(evAtNodes(subst(surfVar=+1,alpha_e)*bP[1],surfNodes,surfIntVars)*bP[1])),
  printf(fh, "  // Evaluate alpha at right surface quadrature points.~%"),
  for i : 1 thru numNodes do (
    printf(fh, "  alphaR = ~a; ~%", gcfac(float(alphaSurfR_n[i]))),
    printf(fh, "  cflFreq += 0.5*(alphaR+fabs(alphaR)); ~%")
  )
)$
