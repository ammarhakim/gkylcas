/*
  Utility functions for GK Maxima scripts.
*/
load("vect")$
load("nodal_operations/nodal_functions")$
load("nodal_operations/quadrature_functions")$
load("utilities")$

expandVmapFields(varsP) := block(
  [pDim,vdim,cdim,jnk,vmapBasis,vmapSqBasis,vmapBnum,vmapSqBnum,vmap_e,vmapSq_e,vmap_prim_e,d,vmap_c,vmapSq_c],

  pDim : length(varsP),
  vdim : 1,
  if isInList(mu,varsP) then vdim : 2,
  cdim : pDim-vdim,

  /* Basis for the velocity space mapping. */
  [jnk,vmapBasis] : loadBasis("Ser", 1, 1),  [jnk,vmapSqBasis] : loadBasis("Ser", 1, 2),
  vmapBnum        : length(vmapBasis),       vmapSqBnum        : length(vmapSqBasis),

  vmap_e : [],  vmapSq_e : [],  vmap_prime_e : [],
  for d : 1 thru vdim do (
    vmap_c : makelist(vmap[(d-1)*vmapBnum+i-1],i,1,vmapBnum),
    vmap_e : endcons(doExpand(vmap_c,subst(x=varsP[cdim+d],vmapBasis)), vmap_e),

    vmapSq_c : makelist(vmapSq[(d-1)*vmapSqBnum+i-1],i,1,vmapSqBnum),
    vmapSq_e : endcons(doExpand(vmapSq_c,subst(x=varsP[cdim+d],vmapSqBasis)), vmapSq_e),

    vmap_prime_e : endcons(vmap_prime[d-1], vmap_prime_e)
  ),

  /* Make mu'=1 if vdim=1 to avoid other if-statements in other Maxima scripts. */
  if (vdim=1) then (
    vmap_prime_e : endcons(1, vmap_prime_e)
  ),

  return([vmap_e,vmapSq_e,vmap_prime_e])
)$

expandInputFields(bC,bP,dxv,bmagBasis) := block(
  [varsP,pdim,cdim,vdim,bmag_e,bmagInv_e,phi_e,Apar_e,dApardt_e,dApardtPrev_e,
   AparL_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,BdriftX_e,BdriftY_e,jnk,
   vmapBasis,vmapSqBasis,vmap_c,vmapSq_c,vmapBnum,vmapSqBnum,d],

  varsP : listofvars(bP),
  pdim : length(varsP),
  cdim : length(listofvars(bC)),
  vdim : pdim-cdim,

  /* Expand background magnetic field and potentials. */
  bmag_e    : doExpand1(bmag,bmagBasis),
  phi_e     : doExpand1(phi,bC),
  Apar_e        : doExpand1(apar,bC),
  dApardt_e     : doExpand1(apardot,bC),
  dApardtPrev_e : doExpand1(apardot_prev,bC),
  /* NOTE: even though Apar and dApar/dt are allowed to be discontinuous
     in the parallel (z) direction, the surface term in the z direction
     does not involve Apar. Since Apar is continuous in the other directions,
     it does not matter if we use the right or left value. */

  cmag_e : doExpand1(cmag,bmagBasis),

  b_x_e : doExpand1(b_x, bmagBasis),
  b_y_e : doExpand1(b_y, bmagBasis),
  b_z_e : doExpand1(b_z, bmagBasis),
  jacobTotInv_e : doExpand1(jacobtot_inv, bmagBasis),

  /* Basis for the velocity space mapping. */
  [jnk,vmapBasis] : loadBasis("Ser", 1, 1),  [jnk,vmapSqBasis] : loadBasis("Ser", 1, 2),
  vmapBnum        : length(vmapBasis),       vmapSqBnum        : length(vmapSqBasis),

  vmap_e : [],  vmapSq_e : [],  vmap_prime_e : [],
  for d : 1 thru vdim do (
    vmap_c : makelist(vmap[(d-1)*vmapBnum+i-1],i,1,vmapBnum),
    vmap_e : endcons(doExpand(vmap_c,subst(x=varsP[cdim+d],vmapBasis)), vmap_e),

    vmapSq_c : makelist(vmapSq[(d-1)*vmapSqBnum+i-1],i,1,vmapSqBnum),
    vmapSq_e : endcons(doExpand(vmapSq_c,subst(x=varsP[cdim+d],vmapSqBasis)), vmapSq_e),

    vmap_prime_e : endcons(vmap_prime[d-1], vmap_prime_e)
  ),

  expOut : [bmag_e,cmag_e,phi_e,Apar_e,dApardt_e,dApardtPrev_e,
            b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_e,vmapSq_e,
            vmap_prime_e],

  return(expOut)
)$

calcAndWrite_HamilES(fH,charge,mass,wv,rdv2,bP,inFlds,sideStr) := block(
  [varsP,numP,pDim,vdim,bmag_e,phi_e,hamil_e,hamil_c,replaceList,hamilCvar,hamilNoZero_c],
  /* Expand the Hamiltonian, and write them out. */

  varsP : listofvars(bP),
  numP  : length(bP),
  pDim  : length(varsP),
  vdim  : 1,
  if isInList(mu,varsP) then vdim : 2,

  /* Extract magnetic field and electrostatic potential. */
  bmag_e   : inFlds[1],
  phi_e    : inFlds[3],
  vmap_e   : inFlds[11],
  vmapSq_e : inFlds[12],

  hamil_e : charge*phi_e + (1/2)*mass*vmapSq_e[1],
  if vdim > 1 then ( hamil_e : hamil_e + vmap_e[2]*bmag_e ),

  /* Project Hamiltonian onto basis functions */
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),

  /* Write Hamiltonian. */
  printf(fh, "  double hamil~a[~a] = {0.}; ~%", sideStr, numP),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  hamilCvar : eval_string(sconcat("hamil",sideStr)),
  writeCExprsNoExpand1(hamilCvar, gcfac(float(expand(subst(replaceList, hamil_c))))),
  printf(fH, "~%"),
  flush_output(fH),

  hamilNoZero_c : makelistNoZeros1(hamil_c, hamilCvar),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,

  return(hamil_e)
)$

calc_HamilES_no_write(charge,mass,wv,rdv2,bP,inFlds) := block(
  [varsP,numP,pDim,vdim,bmag_e,phi_e,hamil_e,hamil_c,hamilNoZero_c],
  /* Expand the Hamiltonian, and write them out. */

  varsP : listofvars(bP),
  numP  : length(bP),
  pDim  : length(varsP),
  vdim  : 0,
  if isInList(vpar,varsP) then vdim : vdim+1,
  if isInList(mu,varsP) then vdim : vdim+1,

  /* Extract magnetic field and electrostatic potential. */
  bmag_e   : inFlds[1],
  phi_e    : inFlds[3],
  vmap_e   : inFlds[11],
  vmapSq_e : inFlds[12],

  hamil_e : charge*phi_e + (1/2)*mass*vmapSq_e[1],
  if vdim > 1 then ( hamil_e : hamil_e + vmap_e[2]*bmag_e ),

  /* Project Hamiltonian onto basis functions */
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),

  hamilNoZero_c : makelistNoZeros1(hamil_c, hamil),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,

  return(hamil_e)
)$

calcAndWrite_BstardBmag(fH,cdim,bP,bmagBasis,surfDir,mass,charge,wvpar,rdx2,rdv2,inFlds,sideStr) := block (
  [cmag_e,Apar_e,BmagInv_e,BdriftX_e,BdriftY_e,BstarXdBmag_e,BstarYdBmag_e,BstarZdBmag_e,b_x_e,b_y_e,b_z_e,
   jacobTotInv_e,rdy2,rdz2,AparL_e,BstarZdBmagL_e,varsP,numP,replaceList,BstarXdBmag_c,BstarYdBmag_c,BstarZdBmag_c,
   BstarXdBmag_noZero_c,BstarYdBmag_noZero_c,BstarZdBmag_noZero_c,BstarZdBmagL_c,BstarZdBmagL_noZero_c,BstardBmagL_e],
  /* Compute the Bstar divided by B and write it out. */

  cmag_e        : inFlds[2],
  Apar_e        : inFlds[4],
  b_x_e         : inFlds[7],  b_y_e : inFlds[8],  b_z_e : inFlds[9],
  jacobTotInv_e : inFlds[10],

  if cdim > 1 then (rdy2 : rdx2[2]) else (rdy2 : 0),
  if cdim > 2 then (rdz2 : rdx2[3]) else (rdz2 : 0),

  /* Zero out some terms below to avoid the discontinuity of alpha in the
     parallel direction (due to the discontinuity of Apar). Otherwise some
     other treatment of some Apar terms or alpha may be needed. Initially we
     had a step averaging alpha across the surface (just for the parallel
     direction), but NRM suspects this might've caused instability in some
     cases. Hence the zeros below. */
  discontFac : 0,

  /* Expand BstarX/Bmag on basis. */
  BstarXdBmag_e : (-((mass/charge)*(wvpar+vpar/rdv2[1]))*rdz2*diff(b_y_e,z)
                   + rdy2*diff(Apar_e*b_z_e,y) - discontFac*rdz2*diff(Apar_e*b_y_e,z))*jacobTotInv_e,
  /* Expand BstarY/Bmag on basis. */
  BstarYdBmag_e : (-((mass/charge)*(wvpar+vpar/rdv2[1]))*(rdx2[1]*diff(b_z_e,x) - rdz2*diff(b_x_e,z))
                   + discontFac*rdz2*diff(Apar_e*b_x_e,z) - rdx2[1]*diff(Apar_e*b_z_e,x))*jacobTotInv_e,
  /* Expand BstarZ/Bmag on basis. */
  BstarZdBmag_e : (cmag_e + ((mass/charge)*(wvpar+vpar/rdv2[1]))*rdx2[1]*diff(b_y_e,x)
                   + discontFac*(rdx2[1]*diff(Apar_e*b_y_e,x) - rdy2*diff(Apar_e*b_x_e,y)))*jacobTotInv_e,

  varsP : listofvars(bP),
  numP  : length(bP),

  /* Project Bstar's onto basis, and print to arrays. */
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  if cdim > 1 then (
    BstarXdBmag_c : calcInnerProdList(varsP, 1, bP, BstarXdBmag_e),
    if (surfDir = 0 or surfDir = 1 or surfDir = cdim+1) then (
      printf(fh, "  double BstarXdBmag~a[~a] = {0.}; ~%", sideStr,numP),
      writeCExprsNoExpand1(eval_string(sconcat("BstarXdBmag",sideStr)), gcfac(subst(replaceList, BstarXdBmag_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    BstarXdBmag_noZero_c : makelistNoZeros1(BstarXdBmag_c, eval_string(sconcat("BstarXdBmag",sideStr))),
    BstarXdBmag_e : BstarXdBmag_noZero_c . bP,

    BstarYdBmag_c : calcInnerProdList(varsP, 1, bP, BstarYdBmag_e),
    if (surfDir = 0 or surfDir = 2 or surfDir = cdim+1) then (
      printf(fh, "  double BstarYdBmag~a[~a] = {0.}; ~%", sideStr, numP),
      writeCExprsNoExpand1(eval_string(sconcat("BstarYdBmag",sideStr)), gcfac(subst(replaceList, BstarYdBmag_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    BstarYdBmag_noZero_c : makelistNoZeros1(BstarYdBmag_c, eval_string(sconcat("BstarYdBmag",sideStr))),
    BstarYdBmag_e : BstarYdBmag_noZero_c . bP
  ),
  if cdim # 2 then (
    BstarZdBmag_c : calcInnerProdList(varsP, 1, bP, BstarZdBmag_e),
    if (surfDir=0 or surfDir>=cdim) then (
      printf(fh, "  double BstarZdBmag~a[~a] = {0.}; ~%", sideStr, numP),
      writeCExprsNoExpand1(eval_string(sconcat("BstarZdBmag",sideStr)), gcfac(subst(replaceList, BstarZdBmag_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    BstarZdBmag_noZero_c : makelistNoZeros1(BstarZdBmag_c, eval_string(sconcat("BstarZdBmag",sideStr))),
    BstarZdBmag_e : BstarZdBmag_noZero_c . bP
  ),

  /* Make Bstar/Bmag vector. */
  if cdim = 1 then (
    BstardBmag_e : [BstarZdBmag_e]
  ) elseif cdim = 2 then (
    BstardBmag_e : [BstarXdBmag_e, BstarYdBmag_e]
  ) elseif cdim = 3 then (
    BstardBmag_e : [BstarXdBmag_e, BstarYdBmag_e, BstarZdBmag_e]
  ),

  return(BstardBmag_e)
)$

calcAndWrite_BstarZdBmag(fH,cdim,bP,bmagBasis,surfDir,mass,charge,wvpar,rdx2,rdv2,inFlds,sideStr) := block (
  [cmag_e,Apar_e,BmagInv_e,BdriftX_e,BdriftY_e,BstarXdBmag_e,BstarYdBmag_e,BstarZdBmag_e,b_x_e,b_y_e,b_z_e,
   jacobTotInv_e,rdy2,rdz2,AparL_e,BstarZdBmagL_e,varsP,numP,replaceList,BstarXdBmag_c,BstarYdBmag_c,BstarZdBmag_c,
   BstarXdBmag_noZero_c,BstarYdBmag_noZero_c,BstarZdBmag_noZero_c,BstarZdBmagL_c,BstarZdBmagL_noZero_c,BstardBmagL_e],
  /* Compute the Bstar divided by B and write it out. */

  cmag_e        : inFlds[2],
  b_x_e         : inFlds[7],  b_y_e : inFlds[8],  b_z_e : inFlds[9],
  jacobTotInv_e : inFlds[10],

  if cdim > 1 then (rdy2 : rdx2[2]) else (rdy2 : 0),
  if cdim > 2 then (rdz2 : rdx2[3]) else (rdz2 : 0),

  if (sideStr="L") then (Apar_e : inFlds[11])
  elseif (sideStr="R") then (Apar_e : inFlds[12])
  else (Apar_e : inFlds[4]),

  /* Expand BstarZ/Bmag on basis. */
  BstarZdBmag_e : (cmag_e + ((mass/charge)*(wvpar+vpar/rdv2[1]))*rdx2[1]*diff(b_y_e,x)
                   + (rdx2[1]*diff(Apar_e*b_y_e,x) - rdy2*diff(Apar_e*b_x_e,y)))*jacobTotInv_e,

  varsP : listofvars(bP),
  numP  : length(bP),

  /* Project Bstar's onto basis, and print to arrays. */
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  BstarZdBmag_c : calcInnerProdList(varsP, 1, bP, BstarZdBmag_e),
  printf(fh, "  double BstarZdBmag~a[~a]; ~%", sideStr, numP),
  writeCExprsNoExpand1(eval_string(sconcat("BstarZdBmag",sideStr)), gcfac(subst(replaceList, BstarZdBmag_c))),
  printf(fh, "~%"),
  flush_output(fh),
  BstarZdBmag_noZero_c : makelistNoZeros1(BstarZdBmag_c, eval_string(sconcat("BstarZdBmag",sideStr))),
  BstarZdBmag_e : BstarZdBmag_noZero_c . bP,

  return(BstarZdBmag_e)
)$

poissonBracket(f,g,mass,charge,rdx2V,rdv2V,pbFacs,no_by) := block(
  [varsCall,cdim,varsC,rdy2,rdz2,BstardBmag_e,bmagInv_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e],
  /* Compute the Poisson bracket in general geometry. */

  /* Function that computes the gradient. */
  /* 
     For some reason the following use of "vect" functions was giving extra
     brackets when generating volume kernels. Opt for our own function instead.
  scalefactors(varsC),
  fgrad(fIn) := ev(express(grad(fIn)),diff)*rdx2V,
  */
  fgrad(fIn,vars,diffFacs) := makelist(diff(fIn,vars[d]),d,1,length(vars))*diffFacs,

  cdim : length(rdx2V),
  if (cdim = 1) then (
    varsCall : [x],
    rdy2 : 0,
    rdz2 : 0
  ) else if (cdim = 2) then (
    varsCall : [x,z],
    rdy2 : 0,
    rdz2 : rdx2V[2]
  ) else if (cdim = 3) then (
    varsCall : [x,y,z],
    rdy2 : rdx2V[2],
    rdz2 : rdx2V[3]
  ),

  varsC : makelist(varsCall[d],d,1,cdim),
  BstardBmag_e : pbFacs[1],
  b_x_e : pbFacs[2],  b_y_e : pbFacs[3],  b_z_e : pbFacs[4],
  jacobTotInv_e : pbFacs[5],  vmap_prime_e : pbFacs[6],

  if (no_by) then ( b_y_e : 0 ),

  pb_e : (1/mass)*BstardBmag_e .
        ((rdv2V[1]/vmap_prime_e[1])*(fgrad(f,varsC,rdx2V)*diff(g,vpar)-fgrad(g,varsC,rdx2V)*diff(f,vpar)))
        +(-(1/charge)*b_z_e*rdx2V[1]*rdy2*(diff(f,x)*diff(g,y)-diff(f,y)*diff(g,x))
          +(1/charge)*b_y_e*rdx2V[1]*rdz2*(diff(f,x)*diff(g,z)-diff(f,z)*diff(g,x))
          -(1/charge)*b_x_e*rdy2*rdz2*(diff(f,y)*diff(g,z)-diff(f,z)*diff(g,y)))*jacobTotInv_e,

  return(pb_e)
)$

calcAndWrite_alphaEM(fH,surfDir,bP,polyOrder,basisType,mass,charge,rdx2V,rdv2V,
                   inFlds,hamil_e,BstardBmag_e,sideStr,isStep2) := block(
  [varsP,varLabel,dirLabel,wSurf,rdSurfVar2,surfVar,surfIntVars,pbAuxFlds,bmagInv_e,b_x_e,
   b_y_e,b_z_e,jacobTotInv_e,alpha_e,Apar_e,dApardt_e,dApardtPrev_e,alphaL_e,
   bSurf,numSurf,evPoint,alpha_c,alphaCvar,alphaNoZero_c,alphaUpCvar,alphaUpNoZero_c],
  /* Calculate phase space velocity alpha in direction of surfVar. */
  /* We assume alpha.n is continuous across boundary, although H may not be. */
  /* Distinguish between alpha and alphaUp, where alphaUp is the one used to
     determine upwind direction. */

  varsP    : listofvars(bP),
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  wSurf      : eval_string(sconcat("w",dirLabel)),
  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  b_x_e         : inFlds[7],   b_y_e  : inFlds[8],   b_z_e    : inFlds[9],
  jacobTotInv_e : inFlds[10],

  pbAuxFlds  : [BstardBmag_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_e,vmapSq_e],
  alpha_e : poissonBracket(wSurf+surfVar/rdSurfVar2,hamil_e,mass,charge,rdx2V,rdv2V,pbAuxFlds),

  Apar_e : inFlds[4],  dApardt_e : inFlds[5],

  alphaUp_e : alpha_e,
  if surfVar = vpar then (
    alpha_e   : alpha_e - (charge/mass)*dApardt_e,
    alphaUp_e : alpha_e
  ),

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("gkhyb",surfIntVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisType,surfIntVars,polyOrder)
  ),
  numSurf : length(bSurf),

  if sideStr="L" then (evPoint : -1)
  elseif sideStr="R" then (evPoint : 1),

  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  /* Project full alpha expression evaluated at interior surface
     onto surface basis and print to C variable alpha. */
  alpha_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=evPoint,alpha_e)),
  printf(fh, "  double alpha~a[~a] = {0.}; ~%", sideStr, numSurf),
  alphaCvar : eval_string(sconcat("alpha",sideStr)),
  writeCExprsNoExpand1(alphaCvar, subst(replaceList,alpha_c)),
  printf(fh, "~%"),
  flush_output(fh),
  alphaNoZero_c : makelistNoZeros1(alpha_c, alphaCvar),
  alphaSurf_e   : doExpand(alphaNoZero_c, bSurf),

  alphaUpSurf_e : alphaSurf_e,

  return([alphaUp_e,alphaSurf_e,alphaUpSurf_e])
)$

calcAndWrite_alpha(fH,surfDir,bP,polyOrder,basisType,mass,charge,rdx2V,rdv2V,
                   inFlds,hamil_e,BstardBmag_e,sideStr,no_by,isStep2) := block(
  [varsP,varLabel,dirLabel,wSurf,rdSurfVar2,surfVar,surfIntVars,b_x_e,b_y_e,b_z_e,
   jacobTotInv_e,vmap_e,vmap_prime_e,pbAuxFlds,cdim,surfVar_phys,alpha_e,bSurf,
   numSurf,evPoint,alpha_c,alphaCvar,clst,alphaNoZero_c],
  /* Calculate phase space velocity alpha in direction of surfVar. */
  /* We assume alpha.n is continuous across boundary, although H may not be. */
  /* Distinguish between alpha and alphaUp, where alphaUp is the one used to
     determine upwind direction. */

  varsP    : listofvars(bP),
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  wSurf      : eval_string(sconcat("w",dirLabel)),
  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  b_x_e         : inFlds[7],   b_y_e : inFlds[8],  b_z_e : inFlds[9],
  jacobTotInv_e : inFlds[10],  vmap_e : inFlds[11],  vmap_prime_e : inFlds[13],

  pbAuxFlds : [BstardBmag_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_prime_e],

  cdim : length(rdx2V),
  surfVar_phys : wSurf+surfVar/rdSurfVar2,
  if (surfDir > cdim) then ( surfVar_phys : vmap_e[surfDir-cdim] ),

  alpha_e : poissonBracket(surfVar_phys,hamil_e,mass,charge,rdx2V,rdv2V,pbAuxFlds,no_by),

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("gkhyb",surfIntVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisType,surfIntVars,polyOrder)
  ),
  numSurf : length(bSurf),

  if sideStr="L" then (evPoint : -1)
  elseif sideStr="R" then (evPoint : 1),

  dvparSimp : makelist(dxv[i-1]=2/eval_string(sconcat("rd",varLabel[i],"2")),i,1,pDim),

  /* Project full alpha expression evaluated at interior surface
     onto surface basis and print to C variable alpha. */
  alpha_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=evPoint,alpha_e)),
  alpha_c : subst(dvparSimp, alpha_c),
  clst : [rdx2vec, rdv2vec, m_, q_, wvpar, rdvpar2Sq,
          makelist(dxv[i-1],i,1,pDim), makelist(vmap[i-1],i,1,2*length(vmap_e[1]))],
  alphaCvar : eval_string(sconcat("alpha",sideStr)),
  writeCExprsCollect1(alphaCvar, alpha_c, clst),
  printf(fh, "~%"),
  flush_output(fh),
  alphaNoZero_c : makelistNoZeros1(alpha_c, alphaCvar),
  alphaSurf_e   : doExpand(alphaNoZero_c, bSurf),

  return(alphaSurf_e)
)$

calc_alpha_no_write(fH,surfDir,bP,polyOrder,basisType,mass,charge,rdx2V,rdv2V,
                   inFlds,hamil_e,BstardBmag_e,sideStr,no_by,isStep2) := block(
  [varsP,varLabel,dirLabel,wSurf,rdSurfVar2,surfVar,surfIntVars,b_x_e,b_y_e,b_z_e,
   jacobTotInv_e,vmap_e,vmap_prime_e,pbAuxFlds,cdim,surfVar_phys,alpha_e,bSurf,
   numSurf,evPoint,alpha_c,alphaCvar,clst,alphaNoZero_c],
  /* Calculate phase space velocity alpha in direction of surfVar. */
  /* We assume alpha.n is continuous across boundary, although H may not be. */
  /* Distinguish between alpha and alphaUp, where alphaUp is the one used to
     determine upwind direction. */

  varsP    : listofvars(bP),
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  wSurf      : eval_string(sconcat("w",dirLabel)),
  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  b_x_e         : inFlds[7],  b_y_e : inFlds[8],  b_z_e : inFlds[9],
  jacobTotInv_e : inFlds[10],  vmap_e : inFlds[11],  vmap_prime_e : inFlds[13],

  pbAuxFlds : [BstardBmag_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_prime_e],

  cdim : length(rdx2V),
  surfVar_phys : wSurf+surfVar/rdSurfVar2,
  if (surfDir > cdim) then ( surfVar_phys : vmap_e[surfDir-cdim] ),

  alpha_e : poissonBracket(surfVar_phys,hamil_e,mass,charge,rdx2V,rdv2V,pbAuxFlds,no_by),

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("gkhyb",surfIntVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisType,surfIntVars,polyOrder)
  ),
  numSurf : length(bSurf),

  if sideStr="L" then (evPoint : -1)
  elseif sideStr="R" then (evPoint : 1),

  /* Project full alpha expression evaluated at interior surface
     onto surface basis and print to C variable alpha. */
  alpha_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=evPoint,alpha_e)),
  alphaCvar : eval_string(sconcat("alpha",sideStr)),
  alphaNoZero_c : makelistNoZeros1(alpha_c, alphaCvar),
  alphaSurf_e   : doExpand(alphaNoZero_c, bSurf),

  return(alphaSurf_e)
)$

calc_surfAvgAlpha(bP,surfVar,alpha_e,evAtLower) := block(
  [i,v,varsP,numP,surfIntVars,surfBasis,ignoreVars,alphaSurfAvg_c,alphaSurfAvg_e,evPoint],
  /* Calculate the surface-averaged alpha. */

  varsP : listofvars(bP),
  numP  : length(bP),
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  if evAtLower then (evPoint:-1) else (evPoint:1),

  /* alpha coefficients are for an expansion in the full-dim phase basis. We
     need to project onto the a basis on the surface with the right normalization
     and dimensionality. */
  surfBasis  : copylist(bP),
  ignoreVars : listify(setdifference(setify(varsP),setify(surfIntVars))),
  for i : 1 thru numP do (
    for v : 1 thru length(ignoreVars) do (
      if not freeof(ignoreVars[v],bP[i]) then ( surfBasis[i] : 0 )
  )),
  alphaSurfAvg_c : calcInnerProdList(surfIntVars,1,surfBasis,subst(surfVar=evPoint,alpha_e)),
  alphaSurfAvg_e : doExpand(alphaSurfAvg_c,surfBasis),
  alphaSurfAvg_s : fullratsimp(innerProd(surfIntVars,1,alphaSurfAvg_e,1)/innerProd(surfIntVars,1,1,1)),

  return(alphaSurfAvg_s)
)$

calcAndWrite_surfAvgAlpha(fH,bP,surfDir,alpha_e,sideStr) := block([replaceList,evAtLower],
  /* Given the phase-space velocity alpha, compute the average over the surface
     perpendicular to the surfVar dimension, and at the lower/upper boundary if
     sideStr=R/L. Write it out too.*/

  surfVar : varsP[surfDir],             /* Surface variable. */

  if sideStr="R" then (evAtLower:true) else (evAtLower:false),
  
  alphaSurfAvg_s : calc_surfAvgAlpha(bP,surfVar,alpha_e,evAtLower),

  printf(fH, "  // Surface-averaged phase velocity in this direction.~%"),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq,
                 wvparL^2=wvparSqL, rdvpar2L^2=rdvpar2SqL, rdx2L^2=rdx2SqL,
                 wvparR^2=wvparSqR, rdvpar2R^2=rdvpar2SqR, rdx2R^2=rdx2SqR, m_^2=mSq, q_^2=qSq],
  printf(fH, "  double alphaSurfAvg~a = ~a; ~%~%", sideStr, float(subst(replaceList, alphaSurfAvg_s))),
  flush_output(fH),

  return(alphaSurfAvg_s)
)$

calcAndWrite_upwindIncr_wSurfAvgAlpha(fH,bP,polyOrder,surfDir,sideStr,alphaSurf_e,isStep2) := block(
  [varsP,numP,surfIntVars,fL_e,fR_e,fhatSurf_e,replaceList,fhatAlpha_c,incr_r,tMod,incrMod_r],
  /* Given a surface expansion of the phase-space velocity, alpha, determine the upwinding
     based on the surface average of alpha. Write the common increment to left/right cells
     (the actual output from the C kernel should be this increment times some scaling factor). */

  varsP       : listofvars(bP),
  numP        : length(bP),
  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  /* Expand distribution function. */
  fL_e : doExpand1(fL,bP),  fR_e : doExpand1(fR,bP),

  printf(fH, "  if (alphaSurfAvg~a>0) { ~%", sideStr),

  fhatSurf_e : subst(surfVar=1, fL_e),

  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq,
                 wvparL^2=wvparSqL, rdvpar2L^2=rdvpar2SqL, rdx2L^2=rdx2SqL,
                 wvparR^2=wvparSqR, rdvpar2R^2=rdvpar2SqR, rdx2R^2=rdx2SqR, m_^2=mSq, q_^2=qSq],
  /* Write out the increment to the right cell. Omit a dxv factor we incorporate later. */
  fhatAlpha_c : calcInnerProdList(surfIntVars, alphaSurf_e, subst(surfVar=-1, bP), fhatSurf_e),
  incrR_c     : fullratsimp(fhatAlpha_c),
  writeCExprsNoExpand1(incr, subst(replaceList, incrR_c)),
  flush_output(fH),

  if surfVar=vpar and polyOrder=1 and (not isStep2) then (
    tMod       : calcInnerProdList(surfIntVars, 1, subst(surfVar=-1, bP), fhatSurf_e),
    incrModR_c : fullratsimp(tMod),
    writeCExprsNoExpand1(incrEmMod, subst(replaceList, incrModR_c))
  ),

  printf(fH, "  } else { ~%"),

  fhatSurf_e : subst(surfVar=-1, fR_e),

  if surfVar=vpar and polyOrder=1 and (not isStep2) then (
    tMod       : calcInnerProdList(surfIntVars, 1, subst(surfVar=-1, bP), fhatSurf_e),
    incrModR_c : fullratsimp(tMod),
    writeCExprsNoExpand1(incrEmMod, subst(replaceList, incrModR_c))
  ),

  fhatAlpha_c : calcInnerProdList(surfIntVars, alphaSurf_e, subst(surfVar=-1, bP), fhatSurf_e),
  incrR_c     : fullratsimp(fhatAlpha_c),

  fhatAlpha_c : calcInnerProdList(surfIntVars, alphaSurf_e, subst(surfVar=1, bP), fhatSurf_e),
  incrL_c     : -fullratsimp(fhatAlpha_c),

  writeCExprsNoExpand1(incr, subst(replaceList, incrR_c)),
  printf(fH, "  }~%"),
  flush_output(fH),

  return([incrL_c,incrR_c])
)$

calcAndWrite_upwindIncr_wQuadNodeAlpha(fH,basisType,polyOrder,bP,surfDir,sideStr,
                                       alphaSurf_e,alphaUpSurf_e,fLR,isStep2) := block(
  [varsP,numP,pDim,surfIntVars,vdim,cdim,surf_cvars,surf_vvars,surfNodes,
   numNodes,fL_e,fR_e,fOrdL_n,fOrdR_n,alphaOrd_n,
   fHatSurf_e,replaceList,Ghat_c,evPoint],
  /* Compute the common increment to left/right cells with upwinding based on
     the quadrature-node values of the phase-space velocity alpha. Write them
     out. The actual output should be these increments scaled by some
     cell-length factor. */

  varsP       : listofvars(bP),
  numP        : length(bP),
  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */
  pDim        : length(varsP),

  vdim : 0,
  if isInList(vpar,varsP) then vdim : vdim+1,
  if isInList(mu,varsP) then vdim : vdim+1,
  cdim : pDim-vdim,

  surf_cvars : delete(surfVar, makelist(varsP[i],i,1,cdim)),
  surf_vvars : delete(surfVar, makelist(varsP[cdim+i],i,1,vdim)),

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    surfNodes : gaussOrdGkHyb(1+1, surf_cvars, surf_vvars),
    bSurf     : basisFromVars("gkhyb",surfIntVars,polyOrder),
    basisStr  : sconcat("gkhyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    bSurf     : basisFromVars(basisFun,surfIntVars,polyOrder),
    basisStr  : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder) 
  ),
  numNodes  : length(surfNodes),

  /* Expand distribution function. */
  fL_e : doExpand1(fLR[1],bP),
  fR_e : doExpand1(fLR[2],bP),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. */
  alphaOrd_n : gcfac(float(evAtNodes(alphaUpSurf_e,surfNodes,surfIntVars))),
  /* Determine upwinding at each surface quadrature node. */
  printf(fH, "  double fUpOrd~a[~a] = {0.};~%", sideStr, numNodes),
  for i : 1 thru numNodes do (
    printf(fH, "  if (~a > 0.) {~%", float(expand(fullratsimp(alphaOrd_n[i]/abs(content(args(alphaOrd_n[i])[1])[1]))))),
    printf(fh, "    fUpOrd~a[~a] = ~a_surfx~a_eval_quad_node_~a_r(~a); ~%", sideStr, i-1, basisStr, surfDir, i-1, fLR[1]),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpOrd~a[~a] = ~a_surfx~a_eval_quad_node_~a_l(~a); ~%", sideStr, i-1, basisStr, surfDir, i-1, fLR[2]),
    printf(fh, "  } ~%")
  ),
  printf(fH, "~%"),
  flush_output(fH),

  /* Write coefficients of modal surface expansion fupwind. */
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  printf(fH, "  double fUp~a[~a] = {0.};~%", sideStr, length(bSurf)),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    dirStr : "x",
    if surfDir = cdim+1 then (dirStr : "vpar") elseif surfDir = cdim+2 then (dirStr : "mu"),
    printf(fh, "  ~a_~adir_upwind_quad_to_modal(fUpOrd~a, fUp~a); ~%", basisStr, dirStr, sideStr, sideStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(fUpOrd~a, fUp~a); ~%", basisStr, sideStr, sideStr)
  ),
  printf(fh, "~%"),
  flush_output(fH),
  fHatSurf_e : doExpand1(eval_string(sconcat("fUp",sideStr)), bSurf),

  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],

  if (sideStr="L") then (evPoint : -1)
  elseif (sideStr="R") then (evPoint : 1),

  Ghat_c : calcInnerProdList(surfIntVars, alphaSurf_e, bSurf, fHatSurf_e),
  Ghat_e : doExpand(Ghat_c, bSurf),
  printf(fH, "  double Ghat~a[~a] = {0.}; ~%", sideStr, length(bSurf)),
  writeCExprs1(eval_string(sconcat("Ghat",sideStr)), Ghat_c),
  printf(fH, "~%"),
  flush_output(fH),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero : makelistNoZeros1(Ghat_c, eval_string(sconcat("Ghat",sideStr))),
  Ghat_e     : doExpand(GhatNoZero, bSurf),

  incr_c : fullratsimp(calcInnerProdList(surfIntVars, -evPoint, subst(surfVar=evPoint, bP), Ghat_e)),

  return(incr_c)
)$

calcAndWrite_upwindIncr_cflFreq_wQuadNodeAlpha(fH,basisType,polyOrder,bP,surfDir,sideStr,
                                               alphaSurf_e,alphaUpSurf_e,fLR,isStep2) := block(
  [varsP,numP,surfVar,surfIntVars,pDim,vdim,cdim,surf_cvars,surf_vvars,surfNodes,
   bSurf,basisStr,numNodes,fL_e,fR_e,alphaOrd_n,i,
   dirStr,fHatSurf_e,evPoint,Ghat_c,Ghat_e,GhatNoZero,incr_c],

  varsP       : listofvars(bP),
  numP        : length(bP),
  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */
  pDim        : length(varsP),

  vdim : 0,
  if isInList(vpar,varsP) then vdim : vdim+1,
  if isInList(mu,varsP) then vdim : vdim+1,
  cdim : pDim-vdim,

  surf_cvars : delete(surfVar, makelist(varsP[i],i,1,cdim)),
  surf_vvars : delete(surfVar, makelist(varsP[cdim+i],i,1,vdim)),

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    surfNodes : gaussOrdGkHyb(1+1, surf_cvars, surf_vvars),
    bSurf     : basisFromVars("gkhyb",surfIntVars,polyOrder),
    basisStr  : sconcat("gkhyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    bSurf     : basisFromVars(basisFun,surfIntVars,polyOrder),
    basisStr  : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  numNodes  : length(surfNodes),

  /* Expand distribution function. */
  fL_e : doExpand1(fLR[1],bP),
  fR_e : doExpand1(fLR[2],bP),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. */
  alphaOrd_n : gcfac(float(evAtNodes(alphaUpSurf_e,surfNodes,surfIntVars))),

  /* Determine upwinding and cflFreq at each surface quadrature node. */
  printf(fH, "  double fUpOrd~a[~a] = {0.};~%", sideStr, numNodes),
  printf(fH, "  double alpha~a_n = 0.;~%", sideStr),
  printf(fH, "~%"),
  for i : 1 thru numNodes do (
    printf(fH, "  alpha~a_n = ~a;~%", sideStr, float(expand(fullratsimp(alphaOrd_n[i])))),
    printf(fH, "  if (alpha~a_n > 0.) {~%", sideStr),
    printf(fh, "    fUpOrd~a[~a] = ~a_surfx~a_eval_quad_node_~a_r(~a); ~%", sideStr, i-1, basisStr, surfDir, i-1, fLR[1]),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpOrd~a[~a] = ~a_surfx~a_eval_quad_node_~a_l(~a); ~%", sideStr, i-1, basisStr, surfDir, i-1, fLR[2]),
    printf(fh, "  } ~%"),
    /* The extra factor of bP[1] below remains unexplained. NRM might've
       stumbled up one it by trial and error. It may also have been meant
       to average all the quad node values, but that meaning is only correct
       for pure p=1. */
    printf(fh, "  cflFreq = fmax(cflFreq, fabs(alpha~a_n)); ~%", sideStr, sideStr)
  ),
  printf(fH, "~%"),
  flush_output(fH),

  /* Write coefficients of modal surface expansion fupwind. */
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  printf(fH, "  double fUp~a[~a] = {0.};~%", sideStr, length(bSurf)),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    dirStr : "x",
    if surfDir = cdim+1 then (dirStr : "vpar") elseif surfDir = cdim+2 then (dirStr : "mu"),
    printf(fh, "  ~a_~adir_upwind_quad_to_modal(fUpOrd~a, fUp~a); ~%", basisStr, dirStr, sideStr, sideStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(fUpOrd~a, fUp~a); ~%", basisStr, sideStr, sideStr)
  ),
  printf(fh, "~%"),
  flush_output(fH),
  fHatSurf_e : doExpand1(eval_string(sconcat("fUp",sideStr)), bSurf),

  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],

  if (sideStr="L") then (evPoint : -1)
  elseif (sideStr="R") then (evPoint : 1),

  Ghat_c : calcInnerProdList(surfIntVars, alphaSurf_e, bSurf, fHatSurf_e),
  Ghat_e : doExpand(Ghat_c, bSurf),
  printf(fH, "  double Ghat~a[~a] = {0.}; ~%", sideStr, length(bSurf)),
  writeCExprs1(eval_string(sconcat("Ghat",sideStr)), Ghat_c),
  printf(fH, "~%"),
  flush_output(fH),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero : makelistNoZeros1(Ghat_c, eval_string(sconcat("Ghat",sideStr))),
  Ghat_e     : doExpand(GhatNoZero, bSurf),

  incr_c : fullratsimp(calcInnerProdList(surfIntVars, -evPoint, subst(surfVar=evPoint, bP), Ghat_e)),

  return(incr_c)
)$

calcAndWrite_quadCFLfreq_wPhaseAlpha(basisType,polyOrder,bP,surfDir,alpha_e) := block(
  [i,varsP,numP,cdim,vdim,pDim,surfVar,surfIntVars,pOrderCFL,surf_cvars,surf_vvars,surfNodes,
   numNodes,alphaSurfL_c,alphaSurfL_e,alphaSurfL_n,alphaSurfR_c,alphaSurfR_e,alphaSurfR_n],
  /* Compute the CFL frequency from quadrature node contributions on the
     surfaces in the dir dimension, given a phase-space volume expansion
     of the speed (i.e. coming from doExpand(alpha,bP)). */

  varsP       : listofvars(bP),
  numP        : length(bP),
  pDim        : length(varsP),
  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */
  vdim : 0,
  if isInList(vpar,varsP) then vdim : vdim+1,
  if isInList(mu,varsP) then vdim : vdim+1,
  cdim : pDim-vdim,

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean gkhybrid basis. */
  pOrderCFL : polyOrder,
  if polyOrder=1 and surfDir=cdim+1 then ( pOrderCFL : 2 ),

  surf_cvars : delete(surfVar, makelist(varsP[i],i,1,cdim)),
  surf_vvars : delete(surfVar, makelist(varsP[cdim+i],i,1,vdim)),

  /* Evaluate cfl by evaluating at all surface quadrature points. */
  /* Get quadrature nodes on surface. */
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    surfNodes : gaussOrdGkHyb(1+1, surf_cvars, surf_vvars)
  ) else (
    surfNodes : gaussOrd(polyOrder+1, pDim-1)
  ),
  numNodes : length(surfNodes),

  /* Coefficients of alpha written out to the file above are phase-space volume
     expansion coefficients. Need to evaluate at the surface and project onto
     surface basis, before (expanding and) evaluating at surface nodes. */
  /* The extra factor of bP[1] below remains unexplained. NRM might've
     stumbled up one it by trial and error. */
  alphaSurfL_n : gcfac(float(evAtNodes(subst(surfVar=-1,alpha_e)*bP[1],surfNodes,surfIntVars)*bP[1])),
  printf(fh, "  // Evaluate alpha at left surface quadrature points.~%"),
  for i : 1 thru numNodes do (
    printf(fh, "  alphaL = ~a; ~%", gcfac(float(alphaSurfL_n[i]))),
    printf(fh, "  cflFreq += -~a*(alphaL-fabs(alphaL)); ~%",float(0.5*(2*pOrderCFL+1)))
  ),

  alphaSurfR_n : gcfac(float(evAtNodes(subst(surfVar=+1,alpha_e)*bP[1],surfNodes,surfIntVars)*bP[1])),
  printf(fh, "  // Evaluate alpha at right surface quadrature points.~%"),
  for i : 1 thru numNodes do (
    printf(fh, "  alphaR = ~a; ~%", gcfac(float(alphaSurfR_n[i]))),
    printf(fh, "  cflFreq += ~a*(alphaR+fabs(alphaR)); ~%",float(0.5*(2*pOrderCFL+1)))
  )
)$

/*
  Utility functions for computing surface DG updates
  for the generic case applicable to all our kinetic equations:
  For a *continuous* phase space flux alpha, if sign(alpha) is a constant
  we can use simple upwind fluxes.
    F = alpha_surf*f^- (if sign(alpha_surf) = 1), 
    F = alpha_surf*f^+ (if sign(alpha_surf) = -1) 
  Otherwise, we project sign(alpha_surf) first evaluating sign(alpha_surf) 
  at quadrature points and then using a nodal-to-modal transformation do
    F = alpha_surf ( 1/2*(f^+ + f^-) - 1/2*sgn_alpha_surf*(f^+ - f^-) 

  In this notation alpha_surf is the expansion of the *continuous* phase space flux
  on the given surface, f^+ is the distribution function evaluated just outside the surface
  and f^- is the distribution function evaluated just inside the surface
        +------+------+
        |      |      |
        |   f^-|f^+   |
        |      |      |
        +------+------+
           alpha_surf
*/

/* Determine the upwinded distribution function in gyrokinetics */
calcAndWrite_GKfUpwind(file_handle,cdim,surfDir,surfVar,surfIntVars,bSurf,fl_e,fr_e,basisStr,sideStr,no_by) := block(
  [fstrL, fstrR, fLNm, fRNm, fUpNm, sgn_alpha_surfNm, sgn_alphaUpNm, NSurf,fSurfl_c, fSurfr_c, fSurfl_e, fSurfr_e,
   surfNodes,nodeVars,basisNodal,sgn_alphaNodal_e,bSurf_no_by,sgn_alphaHatModProj_e,sgn_alphaUp_e,fUp_c],
   
  /* Naming convention for subsequent distribution function evaluations 
     for a cell-based update. If performing the left surface update 
     we need fl(surfVar=+1) and fc(surfVar=-1) (f_lr and f_cl) and if we are performing
     the right surface update we need fc(surfVar=+1) and fr(surfVar=-1) (f_cr and f_rl) */
  if (sideStr = "L") then (
    fstrL : "lr",
    fstrR : "cl"
  ) else (
    fstrL : "cr",
    fstrR : "rl"
  ),
  fLNm : eval_string(sconcat("f_",fstrL)),
  fRNm : eval_string(sconcat("f_",fstrR)),
  fUpNm : eval_string(sconcat("fUp",sideStr)),
  sgn_alpha_surfNm : eval_string(sconcat("sgn_alpha_surf",sideStr)),
  sgn_alphaUpNm : eval_string(sconcat("sgn_alphaUp",sideStr)),

  NSurf : length(bSurf),
  printf(file_handle, "  double fUp~a[~a] = {0.};~%", sideStr, NSurf),
  fSurfl_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=1, fl_e)),
  fSurfr_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=-1, fr_e)),
  fSurfl_e : doExpand1(fLNm, bSurf), 
  fSurfr_e : doExpand1(fRNm, bSurf), 

  clst : [vmap_prime_l[0],vmap_prime_l[1],vmap_prime_c[0],vmap_prime_c[1],
          vmap_prime_r[0],vmap_prime_r[1],vmap_prime_edge[0],vmap_prime_edge[1],
          vmap_prime_skin[0],vmap_prime_skin[1]],
  /* If sign(alpha_surf) is single signed
     1. f^- (if sign(alpha_surf) = 1), 
     2. f^+ (if sign(alpha_surf) = -1) */
  printf(file_handle, "  if (const_sgn_alpha~a[0] == 1) {  ~%", sideStr),
  printf(file_handle, "    if (sgn_alpha_surf~a[0] == 1.0) {  ~%", sideStr),
  writeCExprsCollect1(fUpNm, fSurfl_c, clst),
  printf(file_handle, "    } else { ~%"),
  writeCExprsCollect1(fUpNm, fSurfr_c, clst),
  printf(file_handle, "    } ~%"),

  /* Else sign(alpha_surf) is changing quadrature point to quadrature point
     1/2*(f^+ + f^-) - 1/2*sgn_alpha_surf*(f^+ - f^-) */
  printf(file_handle, "  } else { ~%"),
  printf(file_handle, "  double f_~a[~a] = {0.};~%", fstrL, NSurf),
  printf(file_handle, "  double f_~a[~a] = {0.};~%", fstrR, NSurf),
  if (polyOrder = 1) then (  /* Force p=1 to use hybrid basis. */
    /* if no toroidal field and p=1, use a further reduced quadrature evaluation
       to exploit the larger sparsity in the x and z updates. 
       The x update is surfDir = 1 and the z update is surfDir = cdim */
    if (no_by and surfDir = 1) then (
      surfNodes : gaussOrd(1+1, 1),
      nodeVars : [z],
      basisNodal  : getVarsNodalBasisWithNodesHyb("gkhyb", 1, 1, nodeVars, surfNodes),
      sgn_alphaNodal_e : doExpand1(sgn_alpha_surfNm,basisNodal),
      bSurf_no_by : basisFromVars("gkhyb",nodeVars,polyOrder),
      sgn_alphaHatModProj_e : fullratsimp(calcInnerProdList(nodeVars, 1, bSurf_no_by, sgn_alphaNodal_e)),
      printf(file_handle, "  double sgn_alphaUp~a[~a] = {0.};~%", sideStr, length(bSurf_no_by)),
      writeCExprs1(sgn_alphaUpNm, sgn_alphaHatModProj_e),
      sgn_alphaUp_e : doExpand1(sgn_alphaUpNm, bSurf_no_by)
    )
    else if (no_by and surfDir = cdim) then (
      surfNodes : gaussOrdGkHyb(1+1, [x], [vpar]),
      nodeVars : [x,vpar],
      basisNodal  : getVarsNodalBasisWithNodesHyb("gkhyb", 1, 1, nodeVars, surfNodes),
      sgn_alphaNodal_e : doExpand1(sgn_alpha_surfNm,basisNodal),
      bSurf_no_by : basisFromVars("gkhyb",nodeVars,polyOrder),
      sgn_alphaHatModProj_e : fullratsimp(calcInnerProdList(nodeVars, 1, bSurf_no_by, sgn_alphaNodal_e)),
      printf(file_handle, "  double sgn_alphaUp~a[~a] = {0.};~%", sideStr, length(bSurf_no_by)),
      writeCExprs1(sgn_alphaUpNm, sgn_alphaHatModProj_e),
      sgn_alphaUp_e : doExpand1(sgn_alphaUpNm, bSurf_no_by)
    )
    else (
      dirStr : "x",
      if (surfDir = cdim+1) then (dirStr : "vpar") elseif (surfDir = cdim+2) then (dirStr : "mu"),
      printf(file_handle, "  double sgn_alphaUp~a[~a] = {0.};~%", sideStr, NSurf),
      printf(file_handle, "  ~a_~adir_upwind_quad_to_modal(~a, ~a); ~%", basisStr, dirStr, sgn_alpha_surfNm, sgn_alphaUpNm),
      sgn_alphaUp_e : doExpand1(sgn_alphaUpNm, bSurf)
    )
  ) else (
    printf(file_handle, "  double sgn_alphaUp~a[~a] = {0.};~%", sideStr, NSurf),
    printf(file_handle, "  ~a_upwind_quad_to_modal(~a, ~a); ~%", basisStr, sgn_alpha_surfNm, sgn_alphaUpNm),
    sgn_alphaUp_e : doExpand1(sgn_alphaUpNm, bSurf)
  ),
  printf(file_handle, "~%"),

  writeCExprsCollect1(fLNm, fSurfl_c, clst),
  printf(file_handle, "~%"),
  flush_output(file_handle),

  writeCExprsCollect1(fRNm, fSurfr_c, clst),
  printf(file_handle, "~%"),
  flush_output(file_handle),

  fUp_c : calcInnerProdList(surfIntVars, 1, bSurf, 0.5*(fSurfl_e + fSurfr_e) - 0.5*sgn_alphaUp_e*(fSurfr_e - fSurfl_e)),
  writeCExprsNoExpand1(fUpNm, gcfac(float(expand(fUp_c)))),
  printf(file_handle, "~%"),
  flush_output(file_handle),

  printf(file_handle, "  } ~%")
)$

/* Determine the upwinded distribution function in gyrokinetics */
calcAndWrite_sgn_alpha(file_handle,surfIntVars,surfNodes,numNodes,alphaSurf_e,sideStr) := block(
  [alphaOrd_n],
  /* Determine sign(alpha_surf) for upwinding at each surface quadrature node. */

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. */
  alphaOrd_n : gcfac(float(evAtNodes(alphaSurf_e,surfNodes,surfIntVars))),
  
  printf(file_handle, "  int const_sgn_alpha_surf = 1;  ~%"),
  printf(file_handle, "  ~%"),
  /* Write out first quadrature point 
     We are going to compare the signs of the quadrature points to see if the sign is constant */
  printf(file_handle, "  if (~a > 0.) ~%", gcfac(float(expand(fullratsimp(alphaOrd_n[1]))))),
  printf(file_handle, "    sgn_alpha_surf~a[0] = 1.0; ~%", sideStr),
  printf(file_handle, "  else  ~%"),
  printf(file_handle, "    sgn_alpha_surf~a[0] = -1.0; ~%", sideStr),
  printf(file_handle, "  ~%"),
  /* Write out the other quadrature point evaluations and compare the signs point by point */
  for i : 2 thru numNodes do (
    printf(file_handle, "  if (~a > 0.) ~%", gcfac(float(expand(fullratsimp(alphaOrd_n[i]))))),
    printf(file_handle, "    sgn_alpha_surf~a[~a] = 1.0; ~%", sideStr, i-1),
    printf(file_handle, "  else  ~%"),
    printf(file_handle, "    sgn_alpha_surf~a[~a] = -1.0; ~%", sideStr, i-1),
    printf(file_handle, "  ~%"),
    printf(file_handle, "  if (sgn_alpha_surf~a[~a] == sgn_alpha_surf~a[~a]) ~%", sideStr, i-1, sideStr, i-2),
    printf(file_handle, "    const_sgn_alpha_surf = const_sgn_alpha_surf ? 1 : 0; ~%"),
    printf(file_handle, "  else  ~%"),
    printf(file_handle, "    const_sgn_alpha_surf = 0; ~%"),
    printf(file_handle, "  ~%")
  )
)$
