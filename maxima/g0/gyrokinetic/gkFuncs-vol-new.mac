/*
   Create kernels for the volume term of the gyrokinetic equation.
*/

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("gyrokinetic/gkUtil")$
load("utilities")$
fpprec : 24$

buildGKVolKernel(fh, funcNm, cdim, vdim, basisFun, polyOrder, varsInB, no_by) := block(
  [pDim,varsC,bC,varsP,bP,varsV,vmapBasis,vmapSqBasis,vmapSubBasis,vSub,numC,numP,varLabel,d,rdx2vec,rdv2vec,allVarLabelsC,
   bmagBasis,ignoreVars,inFlds_e,cmag_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_e,BstardBmag_e,
   hamil_e,pbAuxFlds,alphaSum_e,vd,dir,dirLabel,wDir,rdDirVar2,vmap_prime_fac,dirVar,
   dirVar_phys,alpha_e,alpha_c,alphaLabel,alphaNoZero_c,alphaDotGradBasis_e,f_e,volTerm_c, dH_dz_e, alphaJf_e, Jf_e, replaceListHamil, replaceListVpar, hamil2_c, isqlist, ivlist],

  kill(varsC,varsP,bC,bP),
  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  numC : length(bC),  numP : length(bP), 

  varLabel : makelist(string(varsP[d]),d,1,pDim),

  varsV : makelist(varsP[i],i,cdim+1,pDim),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *vmap, const double *vmapSq,
    const double q_, const double m_, const double *bmag, const double *phi,
    const double *dualcurlbhatoverB, const double *rtg33inv, const double *bioverJB,
    const double *fin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // vmap: velocity space mapping.~%"),
  printf(fh, "  // vmapSq: velocity space mapping squared.~%"),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // phi: electrostatic potential .~%"),
  printf(fh, "  // fin: Distribution function.~%"),
  printf(fh, "  // out: output increment.~%"),
  printf(fh, "~%"),

  /* Declare cell-center variables and variables multiplying gradients. */
  for d : 1 thru pDim do (
    printf(fh, "  double rd~a2 = 2.0/dxv[~a];~%", varLabel[d], d-1)
  ),
  printf(fh, "~%"),
  rdx2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,1,cdim),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),

  /* Declare variables with squared of cell centers and rdx2 variables (only need vpar^2). */
  printf(fh, "  double rdvpar2Sq = rdvpar2*rdvpar2;~%"),
  printf(fh, "  double dvparSq = dxv[~a]*dxv[~a];~%", cdim, cdim),
  printf(fh, "~%"),
  replaceList : [rdvpar2^2=rdvpar2Sq,dxv[cdim]^2=dvparSq,rdvpar2Sq=4/dvparSq],
  dvparSimp : append(makelist(dxv[i-1]=2/eval_string(sconcat("rd",varLabel[i],"2")),i,1,pDim),
                     [dvparSq=4/rdvpar2Sq]),

  /* Create pointers to the components of b_i. */
  allVarLabelsC : ["x","y","z"],
  for d : 1 thru 3 do (
    printf(fh, "  const double *bioverJB_~a = &bioverJB[~a];~%", allVarLabelsC[d], numC*(d-1))
  ),
  printf(fh, "~%"),

  /* Create pointers to the components of dualcurlbhatoverB. */
  allVarLabelsC : ["x","y","z"],
  for d : 1 thru 3 do (
    printf(fh, "  const double *dualcurlbhatoverB_~a = &dualcurlbhatoverB[~a];~%", allVarLabelsC[d], numC*(d-1))
  ),
  printf(fh, "~%"),

  /* Axisymmetric basis (independent of y). */
  bmagBasis : getAxisymmetricConfBasis(bC),
  /* Expand input fields for Hamiltonian calculation */
  phi_e     : doExpand1(phi,bC),
  bmag_e : doExpand1(bmag, bmagBasis),
  dualcurlbhatoverB_x_e : doExpand1(dualcurlbhatoverB_x, bmagBasis),
  dualcurlbhatoverB_y_e : doExpand1(dualcurlbhatoverB_y, bmagBasis),
  dualcurlbhatoverB_z_e : doExpand1(dualcurlbhatoverB_z, bmagBasis),
  rtg33inv_e : doExpand1(rtg33inv, bmagBasis),
  bioverJB_x_e : doExpand1(bioverJB_x, bmagBasis),
  bioverJB_y_e : doExpand1(bioverJB_y, bmagBasis),
  bioverJB_z_e : doExpand1(bioverJB_z, bmagBasis),

  dualcurlbhatoverB_list : [dualcurlbhatoverB_x_e, dualcurlbhatoverB_y_e, dualcurlbhatoverB_z_e],
  bioverJB_list : [bioverJB_x_e, bioverJB_y_e, bioverJB_z_e],

  /* Basis for the velocity space mapping. */
  [jnk,vmapBasis] : loadBasis("Ser", 1, 1),  [jnk,vmapSqBasis] : loadBasis("Ser", 1, 2),
  vmapBnum        : length(vmapBasis),       vmapSqBnum        : length(vmapSqBasis),

  vmap_e : [],  vmapSq_e : [],  vmap_prime_e : [],
  for d : 1 thru vdim do (
    vmap_c : makelist(vmap[(d-1)*vmapBnum+i-1],i,1,vmapBnum),
    vmap_e : endcons(doExpand(vmap_c,subst(x=varsP[cdim+d],vmapBasis)), vmap_e),

    vmapSq_c : makelist(vmapSq[(d-1)*vmapSqBnum+i-1],i,1,vmapSqBnum),
    vmapSq_e : endcons(doExpand(vmapSq_c,subst(x=varsP[cdim+d],vmapSqBasis)), vmapSq_e),

    vmap_prime_e : endcons(vmap_prime[d-1], vmap_prime_e)
  ),

  /* Redefine vmap_prime to exploit the relationship between it and vmap. */
  vmap_prime_e : makelist(diff(vmap_e[d],varsP[cdim+d]),d,1,vdim),

  /* Finally write out the hamiltonian*/
  hamil_e : q_*phi_e + (1/2)*m_*vmapSq_e[1],
  if vdim > 1 then ( hamil_e : hamil_e + vmap_e[2]*bmag_e ),
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),
  printf(fh, "  double hamil[~a] = {0.}; ~%", numP),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  hamilCvar : eval_string(sconcat("hamil")),
  writeCExprsNoExpand1(hamilCvar, gcfac(float(expand(subst(replaceList, hamil_c))))),
  printf(fh, "~%"),
  flush_output(fh),
  hamilNoZero_c : makelistNoZeros1(hamil_c, hamilCvar),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,



  printf(fh, "  double vmap2 = vmap[1]*vmap[1]; ~%"),

  printf(fh, "~%"),

  /*Expand Jf*/
  Jf_e : doExpand1(fin,bP),

  /* Calculate expressions for dericatives of the hamiltonian*/
  vpardim : pDim-1,
  if vdim = 1 then ( vpardim : pDim ),
  dH_dz_e : makelist(0, i, 1, pDim),  
  for i : 1 thru vpardim do (
    if i = vpardim then (
      dH_dz_e[i] : diff(hamil_e,varsP[i])
    )
    else (
      dH_dz_e[i] : diff(hamil_e*rdx2vec[i],varsP[i])
    )
  ),

  /* Expand mvpar = dH/dv * 1/v' and mvpar^2 on vmap sub basis */
  vmapSubBasis : [],
  ivlist : [],
  for i : 1 thru numP do (
    if every(lambda([v], freeof(v, bP[i])), delete(vpar, varsP)) = true then (
      vmapSubBasis : append(vmapSubBasis,[ bP[i]] ),
      ivlist : append(ivlist,[i])
    )
  ),

  mvpar_e : dH_dz_e[vpardim]/vmap_prime_e[1],
  mvparsq_e : mvpar_e*mvpar_e/m_,
  mvpar_c : calcInnerProdList(varsP, 1, bP, mvpar_e),
  mvparsq_c : calcInnerProdList(varsP, 1, bP, mvparsq_e),

  isqlist : [],
  for i : 1 thru numP do (
    if freeof(hamil[i]^2, expand(mvparsq_e)) = false then (
      isqlist : append(isqlist,[i])
    )
  ),

  /*Make sure to avoid having hamil[i]^2 or vmap[i]^2 in expressions*/
  replaceListHamil : [],
  printf(fh, "  double hamil2[~a] = {0.}; ~%", length(isqlist)),
  for i : 1 thru length(isqlist) do (
    printf(fh, "  hamil2[~a] = hamil[~a]*hamil[~a]; ~%", i-1, isqlist[i], isqlist[i]),
    replaceListHamil : append(replaceListHamil, [hamil[isqlist[i]]^2=hamil2[i-1]])
  ),
  printf(fh, "~%"),
  replaceListVpar : [vmap[1]^2=vmap2],
  printf(fh, "~%"),

  /* write out mvpar and mvpar^2 expressions with ^2 replaced with hamil2 or vmap2*/
  printf(fh, "  double mvpar[~a] = {0.}; ~%", length(vmapSubBasis)),
  printf(fh, "  double mvparsq[~a] = {0.}; ~%", length(vmapSubBasis)),
  mvpar_c : subst(replaceListHamil, mvpar_c),
  mvpar_c : subst(replaceListVpar,  mvpar_c),
  mvpar_c : makelist(mvpar_c[ivlist[i]], i, 1, length(ivlist)),
  mvparCvar : eval_string(sconcat("mvpar")),
  writeCExprsNoExpand1(mvparCvar, (float(expand(subst(replaceList, mvpar_c))))),
  mvparNoZero_c : makelistNoZeros1(mvpar_c, mvparCvar),
  mvpar_e : mvparNoZero_c . vmapSubBasis,

  mvparsq_c : subst(replaceListHamil, mvparsq_c),
  mvparsq_c : subst(replaceListVpar,  mvparsq_c),
  mvparsq_c : makelist(mvparsq_c[ivlist[i]], i, 1, length(ivlist)),
  mvparsqCvar : eval_string(sconcat("mvparsq")),
  writeCExprsNoExpand1(mvparsqCvar, gcfac(float(expand(subst(replaceList, mvparsq_c))))),
  mvparsqNoZero_c : makelistNoZeros1(mvparsq_c, mvparsqCvar),
  mvparsq_e : mvparsqNoZero_c . vmapSubBasis,

  printf(fh, "~%"),


  /* Note: no contribution from mu. */
  for dir : 1 thru cdim+1 do (

    dirLabel : varLabel[dir],

    wDir      : eval_string(sconcat("w",dirLabel)),
    rdDirVar2 : eval_string(sconcat("rd",dirLabel,"2")),
  
    dirVar    : varsP[dir],         /* Variable in current direction. */

    if dir = cdim then (
      alpha_e : rtg33inv_e*mvpar_e/m_
    )
    else if dir = vpardim then (
      alpha_e : -rtg33inv_e * dH_dz_e[cdim]/m_
    )
    else (
      alpha_e : 0
    ),


    if no_by = false then (
      if dir < vpardim then (
        alpha_e : alpha_e + dualcurlbhatoverB_list[dir]*mvparsq_e/q_
      ),
      if cdim = 3 then (
        if dir = 1 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[2]*dH_dz_e[3] - bioverJB_list[3]*dH_dz_e[2])
        ),
        if dir = 2 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[3]*dH_dz_e[1] - bioverJB_list[1]*dH_dz_e[3])
        ),
        if dir = 3 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[1]*dH_dz_e[2] - bioverJB_list[2]*dH_dz_e[1])
        )
      ),
      if cdim = 2 then (
        if dir = 1 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[2]*dH_dz_e[2])
        ),
        if dir = 2 then (
          alpha_e : alpha_e - 1/q_ * (bioverJB_list[2]*dH_dz_e[1])
        )
      ),
      if dir = vpardim then (
        for k : 1 thru cdim do (
          alpha_e : alpha_e + dualcurlbhatoverB_list[k]*dH_dz_e[k]*mvpar_e/q_/m_
        )
      )

    ),

    if dir < vpardim then (
      alpha_e : alpha_e*rdx2vec[dir]
    )
    else if dir = vpardim then (
      alpha_e : alpha_e/vmap_prime_e[1]
    ),

    /* Project alpha on basis and write to array. */
    printf(fh, "  double alpha~a[~a] = {0.}; ~%", dirLabel, numP),
    alpha_c : fullratsimp(calcInnerProdList(varsP, 1, bP, alpha_e)),
    alpha_c : subst(replaceList, alpha_c),
    alpha_c : subst(dvparSimp, alpha_c),
    alphaLabel : eval_string(sconcat(alpha, dirLabel)),
    clst : [rdx2vec, rdv2vec, m_, q_, wvpar, rdvpar2Sq,
            makelist(dxv[i-1],i,1,pDim), makelist(vmap[i-1],i,1,2*length(vmap_e[1]))],
    writeCExprsCollect1(alphaLabel, alpha_c, clst),
    printf(fh, "~%"),
    flush_output(fh),
    alphaNoZero_c : makelistNoZeros1(alpha_c, alphaLabel),
    alpha_e       : doExpand(alphaNoZero_c, bP),

    alphaJf_e : alpha_e*Jf_e,

    printf(fh, "~%"),
    volTerm_c : fullratsimp(calcInnerProdList(varsP, 1, diff(bP,varsP[dir]), alphaJf_e)),
    volTerm_c : subst(replaceList, volTerm_c),
    writeCIncrExprsNoExpand(float(expand(volTerm_c))),
    flush_output(fh),
    printf(fh, "~%")

  ),

  printf(fh, "  return 0.; ~%"),
  printf(fh, "} ~%")

)$

buildGKStep2VolKernel(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [pDim,varsC,bC,varsP,bP,vSub,numC,numP,f_e,dApardt_e,
   volTerm_c,replaceList,alpha_e,dir,dirVar],
  /* Generate the volume kernel for the 2nd step in gyrokinetics with Apar. */

  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  numC : length(bC),  numP : length(bP),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double q_, const double m_, const double *apardot, const double *fin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // apardot: time derivative of Apar.~%"),
  printf(fh, "  // fIn: Distribution function.~%"),
  printf(fh, "  // out: output increment.~%"),
  printf(fh, "~%"),

  printf(fh, "  double rdvpar2 = 2.0/dxv[~a]; ~%", cdim),

  /* Expand distribution function on basis. */
  f_e : doExpand1(fin,bP),

  /* Expand dApar/dt. */
  dApardt_e : doExpand1(apardot,bC),

  /* Calculate volume term, which is inner product
     < - f (q/m) dApar/dt d/dvpar(bP) > */
  volTerm_c : fullratsimp(calcInnerProdList(varsP, 1, diff(bP,vpar), -(q_/m_)*dApardt_e*rdvpar2*f_e)),

  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  /* Write C increment expressions for volume term. */
  writeCIncrExprsNoExpand(float(subst(replaceList, facsum(volTerm_c,rdvpar2)))),

  alpha_e : - (q_/m_)*dApardt_e*rdvpar2,

  /* CFL calculation. */
  /* Calculate cflFreq = sum_d alpha_d / dxv[d]. */
  printf(fh, "  double cflFreq = 0.0; ~%"),
  printf(fh, "  double alphaL = 0.0; ~%"),
  printf(fh, "  double alphaR = 0.0; ~%"),

  dir    : cdim+1,
  dirVar : varsP[dir],         /* Variable in current direction. */

  /* Evaluate cfl by evaluating at all surface quadrature points. */
  calcAndWrite_quadCFLfreq_wPhaseAlpha(basisFun,polyOrder,bP,dir,alpha_e),
  printf(fh, "~%"),

  printf(fh, "  return cflFreq; ~%"),
  printf(fh, "} ~%")
)$
