/* 
  Generate kernels for the surface term 
  diffusion contribution for the Rosenbluth/Fokker-Planck Operator
*/

load("modal-basis")$
load("out-scripts")$
load("recovery")$

generateFpoVlasovDiffSurf(fname, funcNm, cdim, basisFun, polyOrder, pv1, pv2) := block(
  [vdim, dirNums, pvdir1, pvdir2, varsC, bC, varsP, bP, NC, surfVars, bSurf, numSurf, fh, stencilCells,
  DCL_lst, DCC_lst, DCR_lst, fTL_lst, fTC_lst, fTR_lst, fCL_lst, fCC_lst, fCR_lst, fBL_lst, fBC_lst, fBR_lst,
  D_rec2_lo_p, D_rec2_up_p, f_rec2_lo_p, f_rec2_up_p, f_rec6_lo_p, f_rec6_up_p, D_rec_lo_c, D_rec_up_c, 
  D_rec_lo_e, D_rec_up_e, f_rec_lo_c, f_rec_up_c, f_rec_lo_e, f_rec_up_e, df_rec_lo_c, df_rec_up_c,
  df_rec_lo_e, df_rec_up_e, surft1_lo_c, surft1_up_c, surft2_lo_c, surft2_up_c, surft1_lo_e, surft1_up_e, 
  surft2_lo_e, surft2_up_e, kernel],
  /* FPO is always 3V */
  vdim : 3,

  dirNums : [[vx, cdim+1], [vy, cdim+2], [vz,cdim+3]],
  pvdir1 : assoc(pv1,dirNums),
  pvdir2 : assoc(pv2,dirNums),

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bP),

  /* Working at a pv1 surface */
  surfVars : delete(pv1, varsP),
  bSurf : basisFromVars(basisFun, surfVars, polyOrder),
  numSurf : length(bSurf),

  disp(printf(false, "Creating ~a", fname)),

  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double* dxv, const double* diff_coeff_stencil[9], const double* f_stencil[9], double* GKYL_RESTRICT out) { ~%", funcNm),

  printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
  printf(fh, "  // diff_coeff_stencil[3]: 3-cell stencil of diffusion tensor. ~%"),
  printf(fh, "  // f_stencil[9]: 9-cell stencil of distribution function. ~%"), 
  printf(fh, "  // out: Incremented output. ~%~%"),
 
  printf(fh, "  double dv1_sq = 4.0/dxv[~a]/dxv[~a]; ~%~%", pvdir1-1, pvdir2-1),
    printf(fh, "  double D_rec_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double D_rec_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double f_rec_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double f_rec_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double df_rec_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double df_rec_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft1_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft1_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft2_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft2_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "~%"),

  printf(fh, "  // Index into D and f stencils. ~%"),
  diff_coeff_index : 3*(pvdir1-cdim-1) + (pvdir2-cdim-1),

  if (pv1 = pv2) then (
    stencilCells : [CL, CC, CR],
    printf(fh, "  const double* DCL = &diff_coeff_stencil[0][~a]; ~%", diff_coeff_index*NC),
    printf(fh, "  const double* DCC = &diff_coeff_stencil[1][~a]; ~%", diff_coeff_index*NC),
    printf(fh, "  const double* DCR = &diff_coeff_stencil[2][~a]; ~%", diff_coeff_index*NC)
  ) elseif (pvdir1 < pvdir2) then (
    stencilCells : [BL, CL, TL, BC, CC, TC, BR, CR, TR],
    printf(fh, "  const double* DCL = &diff_coeff_stencil[1][~a]; ~%", diff_coeff_index*NC),
    printf(fh, "  const double* DCC = &diff_coeff_stencil[4][~a]; ~%", diff_coeff_index*NC),
    printf(fh, "  const double* DCR = &diff_coeff_stencil[7][~a]; ~%", diff_coeff_index*NC)
  ) else (
    stencilCells : [BL, BC, BR, CL, CC, CR, TL, TC, TR],
    printf(fh, "  const double* DCL = &diff_coeff_stencil[3][~a]; ~%", diff_coeff_index*NC),
    printf(fh, "  const double* DCC = &diff_coeff_stencil[4][~a]; ~%", diff_coeff_index*NC),
    printf(fh, "  const double* DCR = &diff_coeff_stencil[5][~a]; ~%", diff_coeff_index*NC)
  ),

  printf(fh, "~%"),

  for i : 1 thru length(stencilCells) do (
    printf(fh, "  const double* f~a = f_stencil[~a]; ~%", stencilCells[i], i-1)
  ),
  printf(fh, "~%"),
  flush_output(fh),

  /*
    Stencil required to update cell CC
    D and f must be made continuous across cell boundaries
    We never require a derivative of D, so use 2-cell recovery
    For f, we'll be taking a derivative normal to the boundary for the diagonal 
      components (2-cell), and along the boundary for the cross components (6-cell)

    +----+----+----+
    | TL | TC | TR |
    +----+----+----+
    | CL | CC | CR |
    +----+----+----+
    | BL | BC | BR |
    +----+----+----+ 
  
    ^
    |
    pv2  pv1 -->
    
    Edges of interest here are between CL/CC and CC/CR
  */

  /* Components of D and f necessary for upcoming recoveries */
  DCL_lst : makelist(DCL[i], i, 0, NC-1),
  DCC_lst : makelist(DCC[i], i, 0, NC-1),
  DCR_lst : makelist(DCR[i], i, 0, NC-1),

  fTL_lst : makelist(fTL[i], i, 0, NC-1),
  fTC_lst : makelist(fTC[i], i, 0, NC-1),
  fTR_lst : makelist(fTR[i], i, 0, NC-1),
  fCL_lst : makelist(fCL[i], i, 0, NC-1),
  fCC_lst : makelist(fCC[i], i, 0, NC-1),
  fCR_lst : makelist(fCR[i], i, 0, NC-1),
  fBL_lst : makelist(fBL[i], i, 0, NC-1),
  fBC_lst : makelist(fBC[i], i, 0, NC-1),
  fBR_lst : makelist(fBR[i], i, 0, NC-1),

  /* Recover continuous D across cell boundaries */
  D_rec2_lo_p : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, dg(DCL_lst), dg(DCC_lst)),
  D_rec2_up_p : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, dg(DCC_lst), dg(DCR_lst)),

  /* Diagonal term -> taking derivative d/dpv1 (f) */
  f_rec2_lo_p : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
  f_rec2_up_p : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),
  
  if (pv1 # pv2) then (
    /* Cross term -> taking derivative of f along pv1 cell boundary */
    f_rec6_lo_p : calcRecovFaceGen(basisFun, [pv1, pv2], varsP, 0, 0, polyOrder, 0,
      dg(dg(fBL_lst), dg(fBC_lst)), dg(dg(fCL_lst), dg(fCC_lst)), dg(dg(fTL_lst), dg(fTC_lst))),
    f_rec6_up_p : calcRecovFaceGen(basisFun, [pv1, pv2], varsP, 0, 0, polyOrder, 0,
      dg(dg(fBC_lst), dg(fBR_lst)), dg(dg(fCC_lst), dg(fCR_lst)), dg(dg(fTC_lst), dg(fTR_lst)))
  ),

  /* Write out recovered quatities */
  D_rec_lo_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv1=0, D_rec2_lo_p)),
  D_rec_up_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv1=0, D_rec2_up_p)),
  writeCExprs1(D_rec_lo, D_rec_lo_c),
  writeCExprs1(D_rec_up, D_rec_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  D_rec_lo_e : doExpand1(D_rec_lo, bSurf),
  D_rec_up_e : doExpand1(D_rec_up, bSurf),
  
  f_rec_lo_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv1=0, f_rec2_lo_p)),
  f_rec_up_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv1=0, f_rec2_up_p)),
  writeCExprs1(f_rec_lo, f_rec_lo_c),
  writeCExprs1(f_rec_up, f_rec_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  f_rec_lo_e : doExpand1(f_rec_lo, bSurf),
  f_rec_up_e : doExpand1(f_rec_up, bSurf),

  if (pv1 = pv2) then (
    df_rec_lo_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv1=0, diff(f_rec2_lo_p, pv2))),
    df_rec_up_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv1=0, diff(f_rec2_up_p, pv2)))
  ) else (
    df_rec_lo_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv1=0, diff(f_rec6_lo_p, pv2))),
    df_rec_up_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv1=0, diff(f_rec6_up_p, pv2)))
  ),

  writeCExprs1(df_rec_lo, df_rec_lo_c),
  writeCExprs1(df_rec_up, df_rec_up_c),
  printf(fh, "~%"),
  flush_output(fh),
  
  df_rec_lo_e : doExpand1(df_rec_lo, bSurf),
  df_rec_up_e : doExpand1(df_rec_up, bSurf),

  /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
  surft1_lo_c : calcInnerProdList(surfVars, D_rec_lo_e, bSurf, df_rec_lo_e),
  surft1_up_c : calcInnerProdList(surfVars, D_rec_up_e, bSurf, df_rec_up_e),

  /* surft2 = -1/2 * < d/dpv2 (psi-) * Dij * f_rec > */
  surft2_lo_c : calcInnerProdList(surfVars, D_rec_lo_e, bSurf, f_rec_lo_e),
  surft2_up_c : calcInnerProdList(surfVars, D_rec_up_e, bSurf, f_rec_up_e),

  /* Write out individual surface term expansions */
  writeCExprs1(surft1_lo, surft1_lo_c),
  writeCExprs1(surft1_up, surft1_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  surft1_lo_e : doExpand1(surft1_lo, bSurf),
  surft1_up_e : doExpand1(surft1_up, bSurf),

  writeCExprs1(surft2_lo, surft2_lo_c),
  writeCExprs1(surft2_up, surft2_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  surft2_lo_e : doExpand1(surft2_lo, bSurf),
  surft2_up_e : doExpand1(surft2_up, bSurf),
  
  kernel : calcInnerProdList(surfVars, 1, subst(pv1=1, bP), surft1_up_e) + 
    calcInnerProdList(surfVars, -1, subst(pv1=-1, bP), surft1_lo_e) + 
    calcInnerProdList(surfVars, -1, subst(pv1=1, diff(bP,pv2)), surft2_up_e) + 
    calcInnerProdList(surfVars, 1 ,subst(pv1=-1, diff(bP,pv2)), surft2_lo_e),
  writeCIncrExprsCollect1lhsc(out, 0.5*dv1_sq*kernel),

  /* Return CFL in volume kernel */
  printf(fh, "} ~%"),
  close(fh)
)$

