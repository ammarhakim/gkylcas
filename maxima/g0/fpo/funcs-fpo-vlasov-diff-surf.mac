/* 
Generate kernels for the surface and volume terms 
for the diffusion term of the Rosenbluth/Fokker-Planck Operator.
*/

load("modal-basis")$
load("out-scripts")$
load("recovery")$

fpprec : 24$

/* Off-Diagonal terms */
generateFpoVlasovDiffSurfCross(fname, funcNm, cdim, basisFun, polyOrder, pv1, pv2) := block(
  [vdim, pdim, dirNums, pvdir1, pvdir2, varsC, bC, varsP, bP, NC, surfVars1, bSurf1, numSurf,
  surfVars2, bSurf2, fh, stencilCells, diff_coeff_index_12, Dsurf_surft1_lo_e, Dsurf_surft1_up_e,
  Dsurf_surft2_lo_e, Dsurf_surft2_up_e, fTL_lst, fTC_lst, fTR_lst, fCL_lst, fCC_lst, fCR_lst,
  fBL_lst, fBC_lst, fBR_lst, DCC_e, fCC_e, f_rec2_lo_p, f_rec2_up_p, f_rec6_lo_p, f_rec6_up_p,
  f_rec_lo_c, f_rec_up_c, df_rec_lo_c, df_rec_up_c, f_rec_lo_e, f_rec_up_e, df_rec_lo_e,
  df_rec_up_e, surft1_lo_c, surft1_up_c, surft2_lo_c, surft2_up_c, vol_c, surft1_lo_e,
  surft1_up_e, surft2_lo_e, surft2_up_e, vol_lst, kernel],

  if (polyOrder = 1) then ( basisFun : "hyb" ),

  /*
    9-cell stencil required to update cell CC.

    +----+----+----+
    | TL | TC | TR |
    +----+----+----+
    | CL | CC | CR |
    +----+----+----+
    | BL | BC | BR |
    +----+----+----+ 
  
    ^
    |
    pv_upper  pv_lower -->
  */

  /* FPO is always 3V */
  vdim : 3,
  pdim : vdim+cdim,
  dirNums : [[vx, 1], [vy, 2], [vz, 3]],
  pvdir1 : assoc(pv1,dirNums),
  pvdir2 : assoc(pv2,dirNums),

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bP),

  surfVars1 : delete(pv1, varsP),
  bSurf1 : basisFromVars(basisFun, surfVars1, polyOrder),
  numSurf : length(bSurf1),

  surfVars2 : delete(pv2, varsP),
  bSurf2 : basisFromVars(basisFun, surfVars2, polyOrder),

  /* Open file and print function signature */
  disp(printf(false, "Creating ~a", fname)),

  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double* dxv, const double* diff_coeff_C, 
  const double* diff_coeff_surf_stencil[9], const double* f_stencil[9], double* GKYL_RESTRICT out) { ~%", funcNm),

  printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
  printf(fh, "  // diff_coeff_C: Diffusion tensor in center cell. ~%"),
  printf(fh, "  // diff_coeff_surf_stencil[9]: 9-cell stencil of surface expansion of recovered diffusion tensor. ~%"),
  printf(fh, "  // f_stencil[9]: 9-cell stencil of distribution function. ~%"), 
  printf(fh, "  // out: Incremented output. ~%~%"),
 
  printf(fh, "  double dv_inv_sq = 4.0/dxv[~a]/dxv[~a]; ~%~%", pvdir1+cdim-1, pvdir2+cdim-1),
  printf(fh, "  double f_rec_lo[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double f_rec_up[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double df_rec_lo[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double df_rec_up[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double surft1_lo[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double surft1_up[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double surft2_lo[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double surft2_up[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double vol[~a] = {0.0}; ~%", NC),
  printf(fh, "~%"),

  stencilCells : [BL, CL, TL, BC, CC, TC, BR, CR, TR], 

  printf(fh, "  // Index into D and f stencils. ~%"),
  for i : 1 thru length(stencilCells) do (
    printf(fh, "  const double *f~a = f_stencil[~a]; ~%", stencilCells[i], i-1)
  ),
  printf(fh, "~%"),

  /* Index into Dij and surface expansions of recovered Dij */
  diff_coeff_index_12 : 3*(pvdir1-1) + (pvdir2-1),
  printf(fh, "  const double *DCC = &diff_coeff_C[~a]; ~%", diff_coeff_index_12*NC),
  printf(fh, "~%"),

  /* Surface expansions are stored as (Dij)_i, (Dij)_j, ... */
  if (pvdir1 < pvdir2) then (
    printf(fh, "  const double *Dsurf_CC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
      pv1, 4,  2*diff_coeff_index_12*numSurf),
    printf(fh, "  const double *Dsurf_CC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
      pv2, 4,  (2*diff_coeff_index_12+1)*numSurf),
    printf(fh, "  const double* Dsurf_TC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
      pv2, 5, (2*diff_coeff_index_12+1)*numSurf),
    printf(fh, "  const double* Dsurf_CR_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
      pv1, 7, 2*diff_coeff_index_12*numSurf),

    Dsurf_surft1_lo_e : doExpand1(eval_string(sconcat("Dsurf_CC_", pv1)), bSurf1),
    Dsurf_surft1_up_e : doExpand1(eval_string(sconcat("Dsurf_CR_", pv1)), bSurf1),
    Dsurf_surft2_lo_e : doExpand1(eval_string(sconcat("Dsurf_CC_", pv2)), bSurf2),
    Dsurf_surft2_up_e : doExpand1(eval_string(sconcat("Dsurf_TC_", pv2)), bSurf2)
  )
  else (
    printf(fh, "  const double *Dsurf_CC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
      pv1, 4,  2*diff_coeff_index_12*numSurf),
    printf(fh, "  const double *Dsurf_CC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
      pv2, 4,  (2*diff_coeff_index_12+1)*numSurf),
    printf(fh, "  const double* Dsurf_TC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
      pv1, 5, 2*diff_coeff_index_12*numSurf),
    printf(fh, "  const double* Dsurf_CR_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
      pv2, 7, (2*diff_coeff_index_12+1)*numSurf),

    Dsurf_surft1_lo_e : doExpand1(eval_string(sconcat("Dsurf_CC_", pv1)), bSurf1),
    Dsurf_surft1_up_e : doExpand1(eval_string(sconcat("Dsurf_TC_", pv1)), bSurf1),
    Dsurf_surft2_lo_e : doExpand1(eval_string(sconcat("Dsurf_CC_", pv2)), bSurf2),
    Dsurf_surft2_up_e : doExpand1(eval_string(sconcat("Dsurf_CR_", pv2)), bSurf2)
  ),

  /* Components of f */
  fTL_lst : makelist(fTL[i], i, 0, NC-1),
  fTC_lst : makelist(fTC[i], i, 0, NC-1),
  fTR_lst : makelist(fTR[i], i, 0, NC-1),
  fCL_lst : makelist(fCL[i], i, 0, NC-1),
  fCC_lst : makelist(fCC[i], i, 0, NC-1),
  fCR_lst : makelist(fCR[i], i, 0, NC-1),
  fBL_lst : makelist(fBL[i], i, 0, NC-1),
  fBC_lst : makelist(fBC[i], i, 0, NC-1),
  fBR_lst : makelist(fBR[i], i, 0, NC-1),

  DCC_e : doExpand1(DCC, bP),
  fCC_e : doExpand1(fCC, bP),

  flush_output(fh),

  /*
     2- and 6-cell recovery for surface terms.
     Directions change if we're in a lower or upper off-diagonal term.
  */
  if (pvdir1 < pvdir2) then (
    f_rec2_lo_p : calcRecov2CellGen(basisFun, pv2, varsP, polyOrder, dg(fBC_lst), dg(fCC_lst)),
    f_rec2_up_p : calcRecov2CellGen(basisFun, pv2, varsP, polyOrder, dg(fCC_lst), dg(fTC_lst)),

    f_rec6_lo_p : calcRecovFaceGen(basisFun, [pv1, pv2], varsP, 0, 0, polyOrder, 0, 
      dg(dg(fBL_lst), dg(fBC_lst)), dg(dg(fCL_lst), dg(fCC_lst)), dg(dg(fTL_lst), dg(fTC_lst))), 
    f_rec6_up_p : calcRecovFaceGen(basisFun, [pv1, pv2], varsP, 0, 0, polyOrder, 0, 
      dg(dg(fBC_lst), dg(fBR_lst)), dg(dg(fCC_lst), dg(fCR_lst)), dg(dg(fTC_lst), dg(fTR_lst)))
  )
  else (
    f_rec2_lo_p : calcRecov2CellGen(basisFun, pv2, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
    f_rec2_up_p : calcRecov2CellGen(basisFun, pv2, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),
  
    f_rec6_lo_p : calcRecovFaceGen(basisFun, [pv1, pv2], varsP, 0, 0, polyOrder, 0, 
      dg(dg(fBL_lst), dg(fCL_lst)), dg(dg(fBC_lst), dg(fCC_lst)), dg(dg(fBR_lst), dg(fCR_lst))), 
    f_rec6_up_p : calcRecovFaceGen(basisFun, [pv1, pv2], varsP, 0, 0, polyOrder, 0, 
      dg(dg(fCL_lst), dg(fTL_lst)), dg(dg(fCC_lst), dg(fTC_lst)), dg(dg(fCR_lst), dg(fTR_lst)))
  ),

  /* Surface projections of (f_rec)_v2 and (df/dv2)_v1 */
  f_rec_lo_c : calcInnerProdList(surfVars2, 1, bSurf2, subst(pv2=0.0, f_rec2_lo_p)),
  f_rec_up_c : calcInnerProdList(surfVars2, 1, bSurf2, subst(pv2=0.0, f_rec2_up_p)),

  df_rec_lo_c : calcInnerProdList(surfVars1, 1, bSurf1, 
    subst(pv1= 0.0, diff(f_rec6_lo_p, pv2))),
  df_rec_up_c : calcInnerProdList(surfVars1, 1, bSurf1, 
    subst(pv1= 0.0, diff(f_rec6_up_p, pv2))),
  
  /* Expansions of recovered quantities */
  f_rec_lo_e : doExpand1(f_rec_lo, bSurf2),
  f_rec_up_e : doExpand1(f_rec_up, bSurf2),
  df_rec_lo_e : doExpand1(df_rec_lo, bSurf1),
  df_rec_up_e : doExpand1(df_rec_up, bSurf1),

  /* surft1 = 1/2 <psi- * Dij * d/dvj(f_rec)> dS_vi  */
  surft1_lo_c : calcInnerProdList(surfVars1, Dsurf_surft1_lo_e, bSurf1, df_rec_lo_e),
  surft1_up_c : calcInnerProdList(surfVars1, Dsurf_surft1_up_e, bSurf1, df_rec_up_e),

  /* surft2 = -1/2 <Dij * f_rec * d/dvi(psi-)> dS_vj */
  surft2_lo_c : calcInnerProdList(surfVars2, Dsurf_surft2_lo_e, bSurf2, f_rec_lo_e),
  surft2_up_c : calcInnerProdList(surfVars2, Dsurf_surft2_up_e, bSurf2, f_rec_up_e),

  /* vol = 1/2 * <f * d/dvi(Dij*d/dvj(psi))> */
  vol_c : calcInnerProdList(varsP, 1, diff(DCC_e * diff(bP, pv2), pv1), fCC_e),

  surft1_lo_e : doExpand1(surft1_lo, bSurf1),
  surft1_up_e : doExpand1(surft1_up, bSurf1),

  surft2_lo_e : doExpand1(surft2_lo, bSurf2),
  surft2_up_e : doExpand1(surft2_up, bSurf2),

  vol_lst : makelist(vol[i], i, 0, NC-1),

  kernel : calcInnerProdList(surfVars1, 1, subst(pv1=1, bP), surft1_up_e) +
    calcInnerProdList(surfVars1, -1, subst(pv1=-1, bP), surft1_lo_e) +
    calcInnerProdList(surfVars2, -1, subst(pv2=1, diff(bP, pv1)), surft2_up_e) +
    calcInnerProdList(surfVars2, 1, subst(pv2=-1, diff(bP, pv1)), surft2_lo_e) +
    vol_lst,
   
  writeCExprs1(f_rec_lo, f_rec_lo_c),
  writeCExprs1(f_rec_up, f_rec_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(df_rec_lo, df_rec_lo_c),
  writeCExprs1(df_rec_up, df_rec_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Write out individual surface term expansions */
  writeCExprs1(surft1_lo, surft1_lo_c),
  writeCExprs1(surft1_up, surft1_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(surft2_lo, surft2_lo_c),
  writeCExprs1(surft2_up, surft2_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(vol, vol_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCIncrExprsCollect1(out, 0.5*dv_inv_sq*kernel, [dv_inv_sq]),

  /* 
      Calculate CFL.
      Diffusion term estimate: 4*(p+1)^2 / (dv1*dv2) * D_surf[0]/2^((pdim-1)/2)
  */
  printf(fh, "~%"),

  /* Max in pv1 direction */
  if (pvdir1 < pvdir2) then (
    printf(fh, "  double cflFreq = fmax(fabs(Dsurf_CC_~a[0]), fabs(Dsurf_CR_~a[0])); ~%",
      pv1, pv1)
  )
  else (
    printf(fh, "  double cflFreq = fmax(fabs(Dsurf_CC_~a[0]), fabs(Dsurf_TC_~a[0])); ~%",
      pv1, pv1)
  ),

  if ( basisFun = "hyb" ) then ( pOrder : polyOrder + 1 )
  else ( pOrder : polyOrder ),
  printf(fh, "~%"),
  printf(fh, "  return ~a*cflFreq; ~%", float(dv_inv_sq*(pOrder+1)^2*2.0^(-0.5*(pdim-1)))),
  printf(fh, "} ~%"),
  close(fh)

)$

/* Diagonal term */
generateFpoVlasovDiffSurfDiag(fname, funcNm, cdim, basisFun, polyOrder, pv) := block(
  [vdim, pdim, dirNums, pvdir, varsC, bC, varsP, bP, NC, surfVars, bSurf, numSurf, fh,
  stencilCells, diff_coeff_index, fL_lst, fC_lst, fR_lst, DC_e, fC_e, D_surf_C_e, 
  D_surf_R_e, f_rec2_lo_p, f_rec2_up_p, df_rec_lo_c, df_rec_up_c, f_rec_lo_c, f_rec_up_c,
  f_rec_lo_e, f_rec_up_e, df_rec_lo_e, df_rec_up_e, surft1_lo_c, surft1_up_c, 
  surft2_lo_c, surft2_up_c, vol_c, surft1_lo_e, surft1_up_e, surft2_lo_e, surft2_up_e,
  vol_lst, kernel],

  if (polyOrder = 1) then ( basisFun : "hyb" ),
    
  /* FPO is always 3V */
  vdim : 3,
  pdim : vdim+cdim,
  dirNums : [[vx, 1], [vy, 2], [vz,3]],
  pvdir : assoc(pv,dirNums),

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bP),

  surfVars : delete(pv, varsP),
  bSurf : basisFromVars(basisFun, surfVars, polyOrder),
  numSurf : length(bSurf),

  disp(printf(false, "Creating ~a", fname)),

  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double* dxv, const double* diff_coeff_C, 
  const double* diff_coeff_surf_stencil[9], const double* f_stencil[9], double* GKYL_RESTRICT out) { ~%", funcNm),

  printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
  printf(fh, "  // diff_coeff_C: Diffusion tensor in center cell. ~%"),
  printf(fh, "  // diff_coeff_surf_stencil[9]: 9-cell stencil of surface expansion of recovered diffusion tensor. ~%"),
  printf(fh, "  // f_stencil[9]: 9-cell stencil of distribution function. ~%"), 
  printf(fh, "  // out: Incremented output. ~%~%"),
 
  printf(fh, "  double dv_inv_sq = 4.0/dxv[~a]/dxv[~a]; ~%~%", pvdir+cdim-1, pvdir+cdim-1),
  printf(fh, "  double f_rec_lo[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double f_rec_up[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double df_rec_lo[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double df_rec_up[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double surft1_lo[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double surft1_up[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double surft2_lo[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double surft2_up[~a] = {0.0}; ~%", numSurf),
  printf(fh, "  double vol[~a] = {0.0}; ~%", NC),
  printf(fh, "~%"),

  stencilCells : [L, C, R],

  printf(fh, "  // Index into D and f stencils. ~%"),
  for i : 1 thru length(stencilCells) do (
    printf(fh, "  const double* f~a = f_stencil[~a]; ~%", stencilCells[i], i-1)
  ),
  printf(fh, "~%"),

  diff_coeff_index : 4*(pvdir-1),
  printf(fh, "  const double* DC = &diff_coeff_C[~a]; ~%", diff_coeff_index*NC),
  printf(fh, "  const double* D_surf_C = &diff_coeff_surf_stencil[~a][~a]; ~%", 
    1, 2*diff_coeff_index*numSurf),
  printf(fh, "  const double* D_surf_R = &diff_coeff_surf_stencil[~a][~a]; ~%", 
    2, 2*diff_coeff_index*numSurf),
  printf(fh, "~%"),

  /* Components of f */
  fL_lst : makelist(fL[i], i, 0, NC-1),
  fC_lst : makelist(fC[i], i, 0, NC-1),
  fR_lst : makelist(fR[i], i, 0, NC-1),

  /* Expansions of diffusion tensor and f in center cell */
  DC_e : doExpand1(DC, bP),
  fC_e : doExpand1(fC, bP),

  D_surf_C_e : doExpand1(D_surf_C, bSurf),
  D_surf_R_e : doExpand1(D_surf_R, bSurf),

  f_rec2_lo_p : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, dg(fL_lst), dg(fC_lst)),
  f_rec2_up_p : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, dg(fC_lst), dg(fR_lst)),

  df_rec_lo_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, diff(f_rec2_lo_p, pv))),
  df_rec_up_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, diff(f_rec2_up_p, pv))),

  /* Write out recovered quatities */
  f_rec_lo_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, f_rec2_lo_p)),
  f_rec_up_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, f_rec2_up_p)),
  writeCExprs1(f_rec_lo, f_rec_lo_c),
  writeCExprs1(f_rec_up, f_rec_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  f_rec_lo_e : doExpand1(f_rec_lo, bSurf),
  f_rec_up_e : doExpand1(f_rec_up, bSurf),

  writeCExprs1(df_rec_lo, df_rec_lo_c),
  writeCExprs1(df_rec_up, df_rec_up_c),
  printf(fh, "~%"),
  flush_output(fh),
  
  df_rec_lo_e : doExpand1(df_rec_lo, bSurf),
  df_rec_up_e : doExpand1(df_rec_up, bSurf),

  /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
  surft1_lo_c : calcInnerProdList(surfVars, D_surf_C_e, bSurf, df_rec_lo_e),
  surft1_up_c : calcInnerProdList(surfVars, D_surf_R_e, bSurf, df_rec_up_e),

  /* surft2 = -1/2 * < d/dpv2 (psi-) * Dij * f_rec > */
  surft2_lo_c : calcInnerProdList(surfVars, D_surf_C_e, bSurf, f_rec_lo_e),
  surft2_up_c : calcInnerProdList(surfVars, D_surf_R_e, bSurf, f_rec_up_e),

  /* vol = 1/2 * < d/dvj (Dij * d/dvi(psi)) * f > */
  vol_c : calcInnerProdList(varsP, 1, diff(DC_e * diff(bP, pv), pv), fC_e),

  /* Write out individual surface term expansions */
  writeCExprs1(surft1_lo, surft1_lo_c),
  writeCExprs1(surft1_up, surft1_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(surft2_lo, surft2_lo_c),
  writeCExprs1(surft2_up, surft2_up_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(vol, vol_c),
  printf(fh, "~%"),
  flush_output(fh),

  surft1_lo_e : doExpand1(surft1_lo, bSurf),
  surft1_up_e : doExpand1(surft1_up, bSurf),

  surft2_lo_e : doExpand1(surft2_lo, bSurf),
  surft2_up_e : doExpand1(surft2_up, bSurf),

  vol_lst : makelist(vol[i], i, 0, NC-1),
  
  kernel : calcInnerProdList(surfVars, 1, subst(pv=1, bP), surft1_up_e) + 
    calcInnerProdList(surfVars, -1, subst(pv=-1, bP), surft1_lo_e) + 
    calcInnerProdList(surfVars, -1, subst(pv=1, diff(bP,pv)), surft2_up_e) + 
    calcInnerProdList(surfVars, 1 ,subst(pv=-1, diff(bP,pv)), surft2_lo_e) +
    vol_lst,
  writeCIncrExprsCollect1(out, 0.5*dv_inv_sq*kernel, [dv_inv_sq]),

  /* 
      Calculate CFL.
      Diffusion term estimate: 4*(p+1)^2 / (dv1*dv2) * D_surf[0]/2^((pdim-1)/2)
  */
  if ( basisFun = "hyb" ) then ( pOrder : polyOrder + 1 )
  else ( pOrder : polyOrder ),
  printf(fh, "~%"),
  printf(fh, "  double cflFreq = fmax(fabs(D_surf_C[0]), fabs(D_surf_R[0])); ~%"),    
  printf(fh, "~%"),
  printf(fh, "  return ~a*cflFreq; ~%", float(dv_inv_sq*(pOrder+1)^2*2.0^(-0.5*(pdim-1)))),
  printf(fh, "} ~%"),
  close(fh)   
)$
