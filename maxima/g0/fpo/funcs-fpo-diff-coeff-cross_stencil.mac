/*
  Generate kernels for the cross terms of the
  diffusion tensor for the Rosenbluth/Fokker-Planck Operator
  Dij = d^2 G / dv_i dv_j where i != j

  In 9 regions of the velocity space domain (in order of indexing, pv1 is x-axis):
  Domain volume
  Left edge
  Right edge
  Bottom edge
  Top edge
  Bottom left corner
  Top left corner
  Bottom right corner
  Top right corner
*/

load("modal-basis");
load("out-scripts");
load("recovery");
load("bvp_utilities/bvp-util");

generate_fpo_diff_coeff_cross_stencil(fname, funcNm, cdim, basisFun, polyOrder, dirCombo) := block(
  [vdim, dim, pv1, pv2, dirNums, coordVarS, stencilLoc, stencilStr, pvdir1, pvdir2, fnameStencil, fh,
  varsC, bC, varsP, bP, surfVarspv1, surfVarspv2, bSurfpv1, bSurfpv2, NC, numSurf, GTL_lst, GTC_lst,
  GTR_lst, GCL_lst, GCC_lst, GCR_lst, GBL_lst, GBC_lst, GBR_lst, GCC_e, g_surf_CC_pv1_lst, g_surf_CC_pv2_lst,
  g_surf_CL_pv2_lst, g_surf_CR_pv2_lst, dgdpv1_surf_CC_pv2_lst, dgdpv2_surf_CC_pv1_lst g_surf_CC_pv1_e, 
  g_surf_CC_pv2_e, surft1_pv1_upper_e, surft1_pv1_lower_e, surft1_pv2_upper_e, surft1_pv2_lower_e, 
  surft2_pv1_upper_e, surft2_pv1_lower_e, surft2_pv2_upper_e, surft2_pv2_lower_e, stencilCells1,
  stencilCells2, Grecpv2_upper, Grecpv2_lower, surft1_upper_c, surft1_lower_c, Grecpv1_upper, 
  Grecpv1_lower, surft2_upper_c, surft2_lower_c, surft1_upper_e, surft1_lower_e, surft1_pv, surft1_surfVars,
  surft2_upper_e, surft2_lower_e, surft2_pv, surft2_surfVars, stencilCells, surf_idx, surft1, surft2,
  vol, diff_coeff_out],
  /* FPO is only defined in 3V */
  vdim : 3,
  /* Stencils are always 2D */
  dim : 2,

  pv1 : dirCombo[1],
  pv2 : dirCombo[2],

  dirNums : [[vx, cdim+1], [vy, cdim+2], [vz,cdim+3]],

  kill(varsC, basisC, varsP, basisP),

  /* Associative list between stencil location (-1,0,1) and variable strings in kernel name. */
  coordVarS : getCoordVarS([pv1, pv2]),

  /* List of stencil locations. Each entry is a dim-dimensional list
  with -1 meaning it is at a lower boundary, 1 upper boundary, or
  0 away from boundaries in that direction. */
  stencilLoc : getStencilCoords(dim),

  for sI : 1 thru length(stencilLoc) do (
    /* String used in kernel name to differentiate stencil locations */
    stencilStr : "",
    for d : 1 thru dim do (
      stencilStr : sconcat(stencilStr, "_", 
      assoc(stencilLoc[sI][d], [[-1, "lo"], [0, "in"], [1, "up"]]), string(dirCombo[d]))
    ),

    kill(diff_coeff, surft1, surft2, vol),
    kill(surft1_lower_c, surft1_upper_c, surft2_lower_c, surft2_upper_c),
    pvdir1 : assoc(pv1,dirNums),
    pvdir2 : assoc(pv2,dirNums),

    fnameStencil : sconcat(fname,"_stencil", stencilStr, ".c"),
    disp(printf(false, "Creating ~a", fnameStencil)),
    fh : openw(fnameStencil),
    printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%"),
    printf(fh, " ~%"),

    printf(fh, "GKYL_CU_DH void ~a_p~a~a(const double *dxv, const double *gamma, const double* fpo_g_stencil[9], const double* fpo_g_surf_stencil[9], const double* fpo_dgdv_surf, double *diff_coeff) { ~%", funcNm, polyOrder, stencilStr),
    printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
    printf(fh, "  // gamma: Scalar factor gamma. ~%"),
    printf(fh, "  // fpo_g_stencil[9]: 9 cell stencil of Rosenbluth potential G. ~%"),
    printf(fh, "  // fpo_g_surf_stencil[9]: 9 cell stencil of surface projection of G. ~%"),
    printf(fh, "  // fpo_dgdv_surf: Surface expansion of dG/dv in center cell. ~%"),
    printf(fh, "  // diff_coeff: Output array for diffusion tensor. ~%"),
    printf(fh, "~%"),
    printf(fh, "  // Use cell-average value for gamma. ~%"),
    printf(fh, "  double gamma_avg = gamma[0]/sqrt(pow(2, ~a)); ~%", cdim),

    printf(fh, "  double dv1_pv1 = 2.0/dxv[~a]; ~%", pvdir1-1),
    printf(fh, "  double dv1_pv2 = 2.0/dxv[~a]; ~%", pvdir2-1),
    printf(fh, "  double dv1_sq = 4.0/dxv[~a]/dxv[~a]; ~%", pvdir1-1, pvdir2-1),
    printf(fh, " ~%"),

    [varsC, bC, varsP, bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

    surfVarspv1 : delete(pv1, varsP),
    surfVarspv2 : delete(pv2, varsP),
    bSurfpv1 : basisFromVars(basisFun, surfVarspv1, polyOrder),
    bSurfpv2 : basisFromVars(basisFun, surfVarspv2, polyOrder),

    NC : length(bP),
    numSurf : length(bSurfpv1),

    /* All components necessary for upcoming recovery */
    GTL_lst : makelist(GTL[i], i, 0, NC-1),
    GTC_lst : makelist(GTC[i], i, 0, NC-1),
    GTR_lst : makelist(GTR[i], i, 0, NC-1),
    GCL_lst : makelist(GCL[i], i, 0, NC-1),
    GCC_lst : makelist(GCC[i], i, 0, NC-1),
    GCR_lst : makelist(GCR[i], i, 0, NC-1),
    GBL_lst : makelist(GBL[i], i, 0, NC-1),
    GBC_lst : makelist(GBC[i], i, 0, NC-1),
    GBR_lst : makelist(GBR[i], i, 0, NC-1),

    GCC_e : doExpand1(GCC, bP),

    /* 
      Surface expansions of G
      NAME_var means it is a surface expansion at a $var boundary
      e.g. g_surf_CC_pv1 is at a pv1 boundary
    */
    g_surf_CC_pv1_lst : makelist(g_surf_CC_pv1[i], i, 0, numSurf-1),
    g_surf_CC_pv2_lst : makelist(g_surf_CC_pv2[i], i, 0, numSurf-1),
    g_surf_CL_pv2_lst : makelist(g_surf_CL_pv2[i], i, 0, numSurf-1),
    g_surf_CR_pv2_lst : makelist(g_surf_CR_pv2[i], i, 0, numSurf-1),

    dgdpv1_surf_CC_pv2_lst : makelist(dgdpv1_surf_CC_pv2[i], i, 0, numSurf-1)/dv1_pv1,
    dgdpv2_surf_CC_pv1_lst : makelist(dgdpv2_surf_CC_pv1[i], i, 0, numSurf-1)/dv1_pv2,

    dgdpv1_surf_CC_pv1_e : doExpand1(dgdpv1_surf_CC_pv1, bSurfpv1)/dv1_pv1,

    g_surf_CC_pv1_e : doExpand1(g_surf_CC_pv1, bSurfpv1),
    g_surf_CC_pv2_e : doExpand1(g_surf_CC_pv2, bSurfpv2),

    surft1_pv1_upper_e : doExpand1(surft1_upper, bSurfpv1),
    surft1_pv1_lower_e : doExpand1(surft1_lower, bSurfpv1),
    surft1_pv2_upper_e : doExpand1(surft1_upper, bSurfpv2),
    surft1_pv2_lower_e : doExpand1(surft1_lower, bSurfpv2),

    surft2_pv1_upper_e : doExpand1(surft2_upper, bSurfpv1),
    surft2_pv1_lower_e : doExpand1(surft2_lower, bSurfpv1),
    surft2_pv2_upper_e : doExpand1(surft2_upper, bSurfpv2),
    surft2_pv2_lower_e : doExpand1(surft2_lower, bSurfpv2),

    stencilCells1 : [],
    stencilCells2 : [],

    if (stencilLoc[sI]= [0, 0]) then (

      /*
        +-----+-----+-----+
        | GTL | GTC | GTR |
        +-----+-----+-----+
        | GCL | GCC | GCR |
        +-----+-----+-----+
        | GBL | GBC | GBR |
        +-----+-----+-----+ 
      */

      stencilCells1 : [BL, CL, TL, BC, CC, TC, BR, CR, TR],
      stencilCells2 : [BL, BC, BR, CL, CC, CR, TL, TC, TR],

      /* 6-cell recovery across +/-1 interfaces in pv2 */
      Grecpv2_upper : calcRecovFaceGen(basisFun, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
      dg(dg(GCL_lst), dg(GTL_lst)), dg(dg(GCC_lst), dg(GTC_lst)), dg(dg(GCR_lst), dg(GTR_lst))),
      Grecpv2_lower : calcRecovFaceGen(basisFun, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
      dg(dg(GBL_lst), dg(GCL_lst)), dg(dg(GBC_lst), dg(GCC_lst)), dg(dg(GBR_lst), dg(GCR_lst))),

      /* Evaluate surface projection of dG/dpv1 at pv2 boundaries */
      surft1_upper_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_upper, pv1)),
      surft1_lower_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_lower, pv1)), 

      /* 1-cell recovery across +/-1 interfaces in pv1 */
      Grecpv1_upper : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, dg(GCC_lst), dg(GCR_lst)),
      Grecpv1_lower : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, dg(GCL_lst), dg(GCC_lst)),

      surft2_upper_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_upper)),
      surft2_lower_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_lower))
    )
    elseif (stencilLoc[sI] = [-1, 0]) then (    
      /*
        Left
        +-----+-----+-----+
        | +++ | GTC | GTR |
        +-----+-----+-----+
        | +++ | GCC | GCR |
        +-----+-----+-----+
        | +++ | GBC | GBR |
        +-----+-----+-----+
      */

      stencilCells1 : [BC, CC, TC, BR, CR, TR],
      stencilCells2 : [BC, BR, CC, CR, TC, TR],

      Grecpv1_upper : calcRecovFaceGen(basisFun, [pv1, pv2], varsP, 0, 0, polyOrder, 1,
        dg(dg(GBC_lst), dg(GBR_lst)), dg(dg(GCC_lst), dg(GCR_lst)), dg(dg(GTC_lst), dg(GTR_lst))),

      surft1_upper_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, diff(Grecpv1_upper, pv2)),
      surft1_lower_c : dgdpv2_surf_CC_pv1_lst,

      Grecpv2_upper : calcRecov2CellGen(basisFun, pv2, varsP, polyOrder, 
        dg(GCC_lst), dg(GTC_lst)),
      Grecpv2_lower : calcRecov2CellGen(basisFun, pv2, varsP, polyOrder,
        dg(GBC_lst), dg(GCC_lst)),

      surft2_upper_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, subst(pv2=0, Grecpv2_upper)),
      surft2_lower_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, subst(pv2=0, Grecpv2_lower))
    )
    elseif (stencilLoc[sI] = [1, 0]) then (    
      /* 
        Right
        +-----+-----+-----+
        | GTL | GTC | +++ |
        +-----+-----+-----+
        | GCL | GCC | +++ |
        +-----+-----+-----+
        | GBL | GBC | +++ |
        +-----+-----+-----+
      */

      stencilCells1 : [BL, CL, TL, BC, CC, TC],
      stencilCells2 : [BL, BC, CL, CC, TL, TC],

      Grecpv1_lower : calcRecovFaceGen(basisFun, [pv1, pv2], varsP, 0, 0, polyOrder, 1,
        dg(dg(GBL_lst), dg(GBC_lst)), dg(dg(GCL_lst), dg(GCC_lst)), dg(dg(GTL_lst), dg(GTC_lst))),

      surft1_upper_c : dgdpv2_surf_CC_pv1_lst,
      surft1_lower_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, diff(Grecpv1_lower, pv2)),

      Grecpv2_upper : calcRecov2CellGen(basisFun, pv2, varsP, polyOrder, 
        dg(GCC_lst), dg(GTC_lst)),
      Grecpv2_lower : calcRecov2CellGen(basisFun, pv2, varsP, polyOrder,
        dg(GBC_lst), dg(GCC_lst)),

      surft2_upper_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, subst(pv2=0, Grecpv2_upper)),
      surft2_lower_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, subst(pv2=0, Grecpv2_lower))
    )
    elseif (stencilLoc[sI] = [0, 1]) then (
      /* 
        Top
        +-----+-----+-----+
        | +++ | +++ | +++ |
        +-----+-----+-----+
        | GCL | GCC | GCR |
        +-----+-----+-----+
        | GBL | GBC | GBR |
        +-----+-----+-----+
      */

      /* 6-cell recovery across +/-1 interfaces in pv2 */
      stencilCells1 : [BL, CL, BC, CC, BR, CR],
      stencilCells2 : [BL, BC, BR, CL, CC, CR],

      /* 
        Upper surface term is simply the (nodal C0 continuous) surface expansion of dG/dv
        in the pv1 direction 
      */
      Grecpv2_lower : calcRecovFaceGen(basisFun, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
        dg(dg(GBL_lst), dg(GCL_lst)), dg(dg(GBC_lst), dg(GCC_lst)), 
        dg(dg(GBR_lst), dg(GCR_lst))),

      /* Evaluate surface projection of dG/dpv1 at pv2 boundaries */
      surft1_upper_c : dgdpv1_surf_CC_pv2_lst,
      surft1_lower_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_lower, pv1)),

      /* 1-cell recovery across +/-1 interfaces in pv1 */
      Grecpv1_upper : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, 
        dg(GCC_lst), dg(GCR_lst)),
      Grecpv1_lower : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder,
        dg(GCL_lst), dg(GCC_lst)),

      surft2_upper_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_upper)),
      surft2_lower_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_lower))
    )
    elseif (stencilLoc[sI] = [0, -1]) then (
      /*
        Bottom
        +-----+-----+-----+
        | GTL | GTC | GTR |
        +-----+-----+-----+
        | GCL | GCC | GCR |
        +-----+-----+-----+
        | +++ | +++ | +++ |
        +-----+-----+-----+
      */
      stencilCells1 : [CL, TL, CC, TC, CR, TR],
      stencilCells2 : [CL, CC, CR, TL, TC, TR],

      /* 6-cell recovery across +/-1 interfaces in pv2 */
      Grecpv2_upper : calcRecovFaceGen(basisFun, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
        dg(dg(GCL_lst), dg(GTL_lst)), dg(dg(GCC_lst), dg(GTC_lst)), dg(dg(GCR_lst), dg(GTR_lst))),

      surft1_upper_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_upper, pv1)),
      surft1_lower_c : dgdpv1_surf_CC_pv2_lst,

      /* 1-cell recovery across +/-1 interfaces in pv1 */
      Grecpv1_upper : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, 
        dg(GCC_lst), dg(GCR_lst)),
      Grecpv1_lower : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder,
        dg(GCL_lst), dg(GCC_lst)),

      surft2_upper_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_upper)),
      surft2_lower_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_lower))
    )
    elseif (stencilLoc[sI][1] = -1 and stencilLoc[sI][2] # 0) then (
      /* Top/Bottom Left Corner */ 
      if (stencilLoc[sI][2] = -1) then (
        /*
          Bottom Left Corner
          +-----+-----+-----+
          | +++ | GTC | GTR |
          +-----+-----+-----+
          | +++ | GCC | GCR |
          +-----+-----+-----+
          | +++ | +++ | +++ |
          +-----+-----+-----+
        */
        stencilCells1 : [CC, TC, CR, TR],
        stencilCells2 : [CC, CR, TC, TR],

        /*
          Surft1 upper: same as left edge
          Surft1 lower: analytic projection of dG/dpv1
        */
        Grecpv2_upper : calcRecovFaceGen(basisFun, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
          bc(D=0,N=1,val=subst(pv2=1, dgdpv1_surf_CC_pv1_e)),
          dg(dg(GCC_lst), dg(GTC_lst)), dg(dg(GCR_lst), dg(GTR_lst))),

        surft1_upper_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_upper, pv1)),
        surft1_lower_c : dgdpv1_surf_CC_pv2_lst
      )
      elseif (stencilLoc[sI][2] = 1) then (
        /*
          Top Left Corner
          +-----+-----+-----+
          | +++ | +++ | +++ |
          +-----+-----+-----+
          | +++ | GCC | GCR |
          +-----+-----+-----+
          | +++ | GBC | GBR |
          +-----+-----+-----+
        */
        stencilCells1 : [BC, CC, BR, CR],
        stencilCells2 : [BC, BR, CC, CR],

        /*
          Surft1 upper: analytic projection of dG/dpv1
          Surft1 lower: same as left edge 
        */
        Grecpv2_lower : calcRecovFaceGen(basisFun, [pv2, pv1], varsP, 0, 0, polyOrder, 2,
          bc(D=0,N=1,val=subst(pv2=-1, dgdpv1_surf_CC_pv1_e)),
          dg(dg(GBC_lst), dg(GCC_lst)), dg(dg(GBR_lst), dg(GCR_lst))),

        surft1_upper_c : dgdpv1_surf_CC_pv2_lst,
        surft1_lower_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_lower, pv1))
        ),

      /* surft2 is identical to left edge case and the same for both corners */
      /* 1-cell recovery across +/-1 interfaces in pv1 */
      Grecpv1_upper : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, dg(GCC_lst), dg(GCR_lst)),

      surft2_upper_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_upper)),
      surft2_lower_c : g_surf_CC_pv1_lst 
    )
    elseif (stencilLoc[sI][1] = 1 and stencilLoc[sI][2] # 0) then (
      /* Top/Bottom Right Corner */ 
      if (stencilLoc[sI][2] = -1) then (
        /*
          Bottom Right Corner
          +-----+-----+-----+
          | GTL | GTC | +++ |
          +-----+-----+-----+
          | GCL | GCC | +++ |
          +-----+-----+-----+
          | +++ | +++ | +++ |
          +-----+-----+-----+
        */
        stencilCells1 : [CL, TL, CC, TC],
        stencilCells2 : [CL, CC, TL, TC],

        /*
          Surft1 upper: same as right edge
          Surft1 lower: analytic projection of dG/dpv1
        */

        /* 6-cell recovery across +/-1 interfaces in pv2 */
      Grecpv2_upper : calcRecovFaceGen(basisFun, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
        dg(dg(GCL_lst), dg(GTL_lst)), dg(dg(GCC_lst), dg(GTC_lst)),
        bc(D=0,N=1,val=subst(pv2=1, dgdpv1_surf_CC_pv1_e))),

        surft1_upper_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_upper, pv1)),
        surft1_lower_c : dgdpv1_surf_CC_pv2_lst 
      )
      elseif (stencilLoc[sI][2] = 1) then (
        /*
          Top Right Corner
          +-----+-----+-----+
          | +++ | +++ | +++ |
          +-----+-----+-----+
          | GCL | GCC | +++ |
          +-----+-----+-----+
          | GBL | GBC | +++ |
          +-----+-----+-----+
        */
        stencilCells1 : [BL, CL, BC, CC],
        stencilCells2 : [BL, BC, CL, CC],

        /*
          Surft1 upper: analytic projection of dG/dpv1
          Surft1 lower: same as right edge 
        */
        Grecpv2_lower : calcRecovFaceGen(basisFun, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
          dg(dg(GBL_lst), dg(GCL_lst)), dg(dg(GBC_lst), dg(GCC_lst)),
          bc(D=0,N=1,val=subst(pv2=-1, dgdpv1_surf_CC_pv1_e))),
     
        surft1_upper_c : dgdpv1_surf_CC_pv2_lst, 
        surft1_lower_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_lower, pv1))
      ),

      /* surft2 is identical to right edge case and the same for both corners */
      /* 1-cell recovery across +/-1 interfaces in pv1 */
      Grecpv1_lower : calcRecov2CellGen(basisFun, pv1, varsP, polyOrder, dg(GCL_lst), dg(GCC_lst)),

      surft2_upper_c : g_surf_CC_pv1_lst, 
      surft2_lower_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_lower))
    ), 
    if (stencilLoc[sI][1] # 0 and stencilLoc[sI][2] = 0) then (
      /* i.e. left or right edge */
      surft1_upper_e : surft1_pv1_upper_e,
      surft1_lower_e : surft1_pv1_lower_e,
      surft1_pv : pv1,
      surft1_surfVars : surfVarspv1,
  
      surft2_upper_e : surft2_pv2_upper_e,
      surft2_lower_e : surft2_pv2_lower_e,
      surft2_pv : pv2,
      surft2_surfVars : surfVarspv2
    )
    else (
      surft1_upper_e : surft1_pv2_upper_e,
      surft1_lower_e : surft1_pv2_lower_e,
      surft1_pv : pv2,
      surft1_surfVars : surfVarspv2,
  
      surft2_upper_e : surft2_pv1_upper_e,
      surft2_lower_e : surft2_pv1_lower_e,
      surft2_pv : pv1,
      surft2_surfVars : surfVarspv1
    ),

    /* Choose stencil indexing order based on directions */
    if (pvdir1 < pvdir2) then (
      stencilCells : stencilCells1
    )
    else (
      stencilCells : stencilCells2
    ),

    /* Index into G stencil */
    surf_idx : [],
    for i : 1 thru length(stencilCells) do (
      printf(fh, "  const double* G~a = fpo_g_stencil[~a]; ~%", stencilCells[i], i-1),
      if (stencilCells[i] = CL or stencilCells[i] = CC or stencilCells[i] = CR) then (
        surf_idx : append(surf_idx, [i])
      )
    ),
    printf(fh, "~%"),

    /* Fetch correct cells for surface expansion from stencil */
    for i : 1 thru length(surf_idx) do (
      printf(fh, "  const double* g_surf_~a = fpo_g_surf_stencil[~a]; ~%",
        stencilCells[surf_idx[i]], surf_idx[i]-1),
      printf(fh, "  const double* g_surf_~a_pv2 = &g_surf_~a[~a]; ~%", 
        stencilCells[surf_idx[i]], stencilCells[surf_idx[i]], (pvdir2-cdim-1)*numSurf)
    ),
    printf(fh, "  ~%"),

    /* Index into surface expansion to get pv1/pv2 boundaries */
    printf(fh, "  const double* g_surf_CC_pv1 = &g_surf_CC[~a]; ~%", (pvdir1-cdim-1)*numSurf),
    dgdpv1_idx : 3*(pvdir2-cdim-1) + (pvdir1-cdim-1),
    printf(fh, "  const double* dgdpv1_surf_CC_pv2 = &fpo_dgdv_surf[~a]; ~%",
      (dgdpv1_idx)*numSurf),

    dgdpv2_idx : 3*(pvdir1-cdim-1) + (pvdir2-cdim-1),
    printf(fh, "  const double* dgdpv2_surf_CC_pv1 = &fpo_dgdv_surf[~a]; ~%",
      (dgdpv2_idx)*numSurf),
    printf(fh, "  const double* dgdpv1_surf_CC_pv1 = &fpo_dgdv_surf[~a]; ~%", 
      (4*(pvdir1-cdim-1))*numSurf),

    printf(fh, "  ~%"),
    printf(fh, "  double surft1_upper[~a], surft1_lower[~a]; ~%", numSurf, numSurf),
    printf(fh, "  double surft2_upper[~a], surft2_lower[~a]; ~%", numSurf, numSurf),
    printf(fh, "  ~%"),

    /* Off-diagonal components of diffusion tensor in row major order */
    printf(fh, "  double *diff_coeff_vxvy = &diff_coeff[~a]; ~%", 1*NC),
    printf(fh, "  double *diff_coeff_vxvz = &diff_coeff[~a]; ~%", 2*NC),
    printf(fh, "  double *diff_coeff_vyvx = &diff_coeff[~a]; ~%", 3*NC),
    printf(fh, "  double *diff_coeff_vyvz = &diff_coeff[~a]; ~%", 5*NC),
    printf(fh, "  double *diff_coeff_vzvx = &diff_coeff[~a]; ~%", 6*NC),
    printf(fh, "  double *diff_coeff_vzvy = &diff_coeff[~a]; ~%", 7*NC),
    printf(fh, "  ~%"),
    printf(fh, "  double *out = diff_coeff_~a~a; ~%", dirCombo[1], dirCombo[2]),
    printf(fh, "  ~%"),

    surft1 : calcInnerProdList(surft1_surfVars, 1, subst(surft1_pv=1.0,bP), surft1_upper_e) +
      calcInnerProdList(surft1_surfVars, -1, subst(surft1_pv=-1.0,bP), surft1_lower_e),

    surft2 : calcInnerProdList(surft2_surfVars, 1, subst(surft2_pv=1.0,diff(bP, surft1_pv)), surft2_upper_e) +
      calcInnerProdList(surft2_surfVars, -1,  subst(surft2_pv=-1.0,diff(bP, surft1_pv)), surft2_lower_e),

    vol : calcInnerProdList(varsP, 1, diff(diff(bP, pv1), pv2), GCC_e),

    diff_coeff_out : surft1 - surft2 + vol,
    writeCExprs1(surft1_upper, surft1_upper_c),
    writeCExprs1(surft1_lower, surft1_lower_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(surft2_upper, surft2_upper_c),
    writeCExprs1(surft2_lower, surft2_lower_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(out, gamma_avg*diff_coeff_out*dv1_sq),
    printf(fh, "} ~%"),
    printf(fh, "~%"),
    flush_output(fh),

    close(fh),

    kill(Grecpv1_upper, Grecpv1_lower, Grecpv2_upper, Grecpv2_lower, surft1_upper_c, surft1_lower_c, surft2_upper_c, surft2_lower_c)
    )
)$
