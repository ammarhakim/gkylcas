load("recovery") $
load ("modal-basis") $
load(stringproc)$

dirs : [vx, vy, vz] $

calcFpoDVol1x3v(polyOrder, bName) := block(
  [ba, numBasis, fname, fh,
  lst_D, lst_f, kernel,
  dir1, dir2,
  isFirst],
  
  load(sconcat("basis-precalc/basis", bName, "1x3v")),
  ba : basisP[polyOrder],
  numBasis : length(ba),
  
  /* This is a not always necessary step and one could in most cases
  use directly 'dg(qlll)' instead of dg(lst_qlll) but this does prevent
  potential super nasty aliasing!  */

  lst_g : makelist(g[i], i, 0, numBasis-1),

  kname : sconcat("fpo_vlasov_D_vol_1x3v_",
    sdowncase(bName), "_p", polyOrder),
  print("Generating:", kname),
  fname : sconcat("~/max-out/", kname, ".c"),
  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h>~%~%"),
  printf(fh, "GKYL_CU_DH void~%"),
  printf(fh, sconcat(kname,
      "(const double* w, const double* dx,~%")),
  printf(fh, "  const double* g, double* GKYL_RESTRICT out) ~%"),
  printf(fh, "{~%"),
  printf(fh, "  // w[NDIM]: Cell-center coordinates~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing~%"),
  printf(fh, "  // g: Rosenbluth potential~%"),
  printf(fh, "  // out: Incremented output~%~%"),

  for d1 : 1 thru 3 do (
    dir1 : dirs[d1],
    for d2 : d1 thru 3 do (
      dir2 : dirs[d2],
      
      idx : if d1=1 then 0 else d1,
      idx : (idx + d2-1)*numBasis,
      
      printf(fh, sconcat("  const double J", dir1, dir2,
          " = 4/dx[", d1, "]/dx[", d2, "];~%~%")),
      
      kernel : calcInnerProdList(varsP, 1,
        diff(diff(ba, dir1), dir2),
        doExpand(lst_g, ba)),
      for i : 1 thru numBasis do (
        printf(fh, "  out[~a + ~a] +=  J~a~a*(~a);~%",
          idx, i-1, dir1, dir2,
          float(expand(kernel[i])))
      ),
      printf(fh, "~%")
    )
  ),
  printf(fh, "}~%"),
  close(fh)
) $