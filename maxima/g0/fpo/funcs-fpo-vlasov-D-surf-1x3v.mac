load("recovery") $
load ("modal-basis") $
load(stringproc)$

dirs : [vx, vy, vz] $

getLists(numBasis) := block(
  /* This is a not always necessary step and one could in most cases
  use directly 'dg(qlll)' instead of dg(lst_qlll) but this does prevent
  potential super nasty aliasing!  */
  [],
  lst_gllc : makelist(gllc[i], i, 0, numBasis-1),
  lst_glcl : makelist(glcl[i], i, 0, numBasis-1),
  lst_glcc : makelist(glcc[i], i, 0, numBasis-1),
  lst_glcu : makelist(glcu[i], i, 0, numBasis-1),
  lst_gluc : makelist(gluc[i], i, 0, numBasis-1),
  
  lst_gcll : makelist(gcll[i], i, 0, numBasis-1),
  lst_gclc : makelist(gclc[i], i, 0, numBasis-1),
  lst_gclu : makelist(gclu[i], i, 0, numBasis-1),
  lst_gccl : makelist(gccl[i], i, 0, numBasis-1),
  lst_gccc : makelist(gccc[i], i, 0, numBasis-1),
  lst_gccu : makelist(gccu[i], i, 0, numBasis-1),
  lst_gcul : makelist(gcul[i], i, 0, numBasis-1),
  lst_gcuc : makelist(gcuc[i], i, 0, numBasis-1),
  lst_gcuu : makelist(gcuu[i], i, 0, numBasis-1),
  
  lst_gulc : makelist(gulc[i], i, 0, numBasis-1),
  lst_gucl : makelist(gucl[i], i, 0, numBasis-1),
  lst_gucc : makelist(gucc[i], i, 0, numBasis-1),
  lst_gucu : makelist(gucu[i], i, 0, numBasis-1),
  lst_guuc : makelist(guuc[i], i, 0, numBasis-1)
) $

getRecoveries(vars, polyOrder, bName) := block(
  [],
  gl_rec2 : [
  'calcRecov2CellGen(bName, vx, vars, polyOrder,
    dg(lst_glcc), dg(lst_gccc)),
  'calcRecov2CellGen(bName, vy, vars, polyOrder,
    dg(lst_gclc), dg(lst_gccc)),
  'calcRecov2CellGen(bName, vz, vars, polyOrder,
    dg(lst_gccl), dg(lst_gccc))
  ],

  gu_rec2 : [
  'calcRecov2CellGen(bName, vx, vars, polyOrder,
    dg(lst_gccc), dg(lst_gucc)),
  'calcRecov2CellGen(bName, vy, vars, polyOrder,
    dg(lst_gccc), dg(lst_gcuc)),
  'calcRecov2CellGen(bName, vz, vars, polyOrder,
    dg(lst_gccc), dg(lst_gccu))
  ],

  gl_rec6 : [
  [
  false,
  'calcRecovFaceGen(bName, [vx, vy], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_gllc), dg(lst_gclc)),
    dg(dg(lst_glcc), dg(lst_gccc)),
    dg(dg(lst_gluc), dg(lst_gcuc))),
  'calcRecovFaceGen(bName, [vx, vz], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_glcl), dg(lst_gccl)),
    dg(dg(lst_glcc), dg(lst_gccc)),
    dg(dg(lst_glcu), dg(lst_gccu)))
  ],
  [
  'calcRecovFaceGen(bName, [vy, vx], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_gllc), dg(lst_glcc)),
    dg(dg(lst_gclc), dg(lst_gccc)),
    dg(dg(lst_gulc), dg(lst_gucc))),
  false,
  'calcRecovFaceGen(bName, [vy, vz], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_gcll), dg(lst_gccl)),
    dg(dg(lst_gclc), dg(lst_gccc)),
    dg(dg(lst_gclu), dg(lst_gccu)))
  ],
  [
  'calcRecovFaceGen(bName, [vz, vx], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_glcl), dg(lst_glcc)),
    dg(dg(lst_gccl), dg(lst_gccc)),
    dg(dg(lst_gucl), dg(lst_gucc))),
  'calcRecovFaceGen(bName, [vz, vy], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_gcll), dg(lst_gclc)),
    dg(dg(lst_gccl), dg(lst_gccc)),
    dg(dg(lst_gcul), dg(lst_gcuc))),
  false
  ]
  ],

  gu_rec6 : [
  [
  false,
  'calcRecovFaceGen(bName, [vx, vy], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_gclc), dg(lst_gulc)),
    dg(dg(lst_gccc), dg(lst_gucc)),
    dg(dg(lst_gcuc), dg(lst_guuc))),
  'calcRecovFaceGen(bName, [vx, vz], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_gccl), dg(lst_gucl)),
    dg(dg(lst_gccc), dg(lst_gucc)),
    dg(dg(lst_gccu), dg(lst_gucu)))
  ],
  [
  'calcRecovFaceGen(bName, [vy, vx], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_glcc), dg(lst_gluc)),
    dg(dg(lst_gccc), dg(lst_gcuc)),
    dg(dg(lst_gucc), dg(lst_guuc))),
  false,
  'calcRecovFaceGen(bName, [vy, vz], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_gccl), dg(lst_gcul)),
    dg(dg(lst_gccc), dg(lst_gcuc)),
    dg(dg(lst_gccu), dg(lst_gcuu)))
  ],
  [
  'calcRecovFaceGen(bName, [vz, vx], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_glcc), dg(lst_glcu)),
    dg(dg(lst_gccc), dg(lst_gccu)),
    dg(dg(lst_gucc), dg(lst_gucu))),
  'calcRecovFaceGen(bName, [vz, vy], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_gclc), dg(lst_gclu)),
    dg(dg(lst_gccc), dg(lst_gccu)),
    dg(dg(lst_gcuc), dg(lst_gcuu))),
  false
  ]
  ]
  ) $

calcFpoDSurf1x3v(polyOrder, bName, d1, d2) := block(
  [dir1, dir2,
  fname, fh,
  ba, numBasis,
  lst_lcu, cnt],
  load(sconcat("basis-precalc/basis", bName, "1x3v")),
  ba : basisP[polyOrder],
  numBasis : length(ba),
  dir1 : dirs[d1],
  dir2 : dirs[d2],
  
  kname : sconcat("fpo_vlasov_D", dir1, dir2, "_surf_1x3v_",
    sdowncase(bName), "_p", polyOrder),
  print("Generating:", kname),
  fname : sconcat("~/max-out/", kname, ".c"),
  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h>~%~%"),
  printf(fh, "GKYL_CU_DH void~%"),
  printf(fh, sconcat(kname, "(const double* w, const double* dx,~%")),
  printf(fh, "  const double* g[], double* GKYL_RESTRICT out) ~%"),
  printf(fh, "{~%"),
  printf(fh, "  // w[NDIM]: Cell-center coordinates~%"),
  printf(fh, "  // dx[NDIM]: Cell spacing~%"),
  printf(fh, "  // g: ~%"),
  printf(fh, "  // out: Incremented output~%~%"),
  
  printf(fh, sconcat("  const double J", dir1, dir2,
      " = 4/dx[", d1, "]/dx[", d2, "];~%~%")),
  
  lst_lcu : ["l", "c", "u"],
  cnt : 0, /* C starts with 0 */
  for i : 1 thru 3 do (
    for j : 1 thru 3 do (
      for k : 1 thru 3 do (
        printf(fh, "  const double* g~a~a~a = g[~a];~%",
          lst_lcu[i], lst_lcu[j], lst_lcu[k], cnt),
        cnt : cnt + 1
      )
    )
  ),
  printf(fh, "~%"),

  
  surfVars : delete(dir1, varsP),
  /* Black magic start */
  /* Generate surface basis. this produces the ndim-1 orthogonal basis
  with no dir1 dependence. */
  ba_surf : sqrt(2)*delete(0, fullratsimp(
      innerProd(varsP, 1, ba, subst([dir1^2=var2, var2=1/3, dir1=0], ba)))*ba),
  /* Black magic ends */
  numSurfBasis : length(ba_surf),

  if d1 = d2 then (
    rec1_l : subst(dir1=0, diff(ev(gl_rec2[d1], nouns), dir2)),
    rec1_u : subst(dir1=0, diff(ev(gu_rec2[d1], nouns), dir2))
  ) else (
    rec1_l : diff(ev(gl_rec6[d1][d2], nouns), dir2),
    rec1_u : diff(ev(gu_rec6[d1][d2], nouns), dir2)
  ),
  
  surf1_l : calcInnerProdList(surfVars, 1, subst(dir1=-1, ba), rec1_l),
  surf1_u : calcInnerProdList(surfVars, 1, subst(dir1=1, ba), rec1_u),
  
  surfVars : delete(dir2, varsP),
  /* Black magic start */
  /* Generate surface basis. this produces the ndim-1 orthogonal basis
  with no dir2 dependence. */
  ba_surf : sqrt(2)*delete(0, fullratsimp(
      innerProd(varsP, 1, ba, subst([dir2^2=var2, var2=1/3, dir2=0], ba)))*ba),
  /* Black magic ends */
  numSurfBasis : length(ba_surf),

  rec2_l : subst(dir2=0, ev(gl_rec2[d2], nouns)),
  rec2_u : subst(dir2=0, ev(gu_rec2[d2], nouns)),
  
  surf2_l : calcInnerProdList(surfVars, 1, subst(dir2=-1, diff(ba, dir1)),
    rec2_l),
  surf2_u : calcInnerProdList(surfVars, 1, subst(dir2=1, diff(ba, dir1)),
    rec2_u),

  kernel : (surf1_u - surf2_u - surf1_l + surf2_l),
  
  idx : if d1=1 then 0 else d1,
  idx : (idx + d2-1)*numBasis,
  for i : 1 thru numBasis do (
    printf(fh, "  out[~a] += J~a~a*(~a);~%", idx + i-1, dir1, dir2,
      float(expand(kernel[i])))
  ),
  printf(fh, "}~%~%"),
  kill(kernel, surf1_l, surf1_u, surf2_l, surf2_u),
  close(fh)
) $