/* This script generates the kernels to calculate the diffusion tensor 
   from an input potential in an edge cell.
   D = Gamma * gradv gradv(g)

   For now, only the diagonal components: Dxx, Dyy, Dzz
*/
load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("recovery")$

calcFPODiffCoeffSurf(dir, fh, funcNm, cdim, vdim, basisFunc, polyOrder) := block(
  [letrat, letrules,
  varsC, bC, varsP, bP, NV, pv, lst_G_skin, lst_G_edge, g_surf_e, dgdv_surf_e,
  d2gdv2_surf_e, G_rec, diff_coeff],

  letrat : true,
  let(dv1_sq/dv1, dv1),

  /* Use hybrid basis if polyOrder=1 */
  if (polyOrder = 1) then (
    phaseBasisFunc : basisFunc
  )
  else (
    phaseBasisFunc : basisFunc
  ),

  /* Clear variables for safety, then load basis */
  kill(varsC, bC, varsP, bP),
  [varsC, bC, varsP, bP] : loadPhaseBasis(phaseBasisFunc, cdim, vdim, polyOrder),

  /* Variable to perform recovery in */
  recovDir : dir + cdim,
  pv : varsP[recovDir],
  disp(pv),

  /* Surface variables to integrate over */
  surfVars : delete(pv, varsP),

  /* Generate surface basis, ndim-1 basis set with no pv dependence */ 
  bSurf : basisFromVars(phaseBasisFunc, surfVars, polyOrder),

  /* Number of basis monomials */
  NC : length(bP),
  NCsurf : length(bSurf),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax~av_~a_p~a(const int edge, const double *dxv, double gamma, const double *G_skin, const double *G_edge, const double *fpo_d2Gdv2_surf, double *diff_coeff) { ~%", funcNm, pv, cdim, vdim, basisFunc, polyOrder),
  printf(fh, "  // dxv[NDIM]: Cell spacing. ~%"),
  printf(fh, "  // G_skin/edge:   Input potential skin/edge cells in recovery direction.~%"),
  printf(fh, "  // fpo_d2Gdv2_surf: Surface expansion of second derivative of potential.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double dv1 = 2.0/dxv[~a]; ~%", dir-1+cdim),
  printf(fh, "  const double dv1_sq = dv1*dv1; ~%"),

  printf(fh, "  const double *d2Gdv2_surf; ~%"),
  printf(fh, "  d2Gdv2_surf = &fpo_d2Gdv2_surf[~a]; ~%", NCsurf*(dir-1)),

  /* 
    Components go: xx, xy, xz, yy, yz, zz
  */
  printf(fh, "  double *diff_coeff_xx = &diff_coeff[~a]; ~%", 0*NC),
  printf(fh, "  double *diff_coeff_yy = &diff_coeff[~a]; ~%", 4*NC),
  printf(fh, "  double *diff_coeff_zz = &diff_coeff[~a]; ~%", 8*NC),

  printf(fh, "  if (edge == 1) {~%"),

  /* Expansions of G in skin and edge cells */
  lst_G_skin : makelist(G_skin[i], i, 0, NC-1),
  lst_G_edge : makelist(G_edge[i], i, 0, NC-1),

  g_surf_e : doExpand1(G_surf, bSurf),
  dgdv_surf_e : doExpand1(dGdv_surf, bSurf)/dv1,
  d2gdv2_surf_e : doExpand1(d2Gdv2_surf, bSurf)/dv1_sq, 

  /* 1-Cell recovery of G using the surface values of G as the constraint on one side */
  G_rec_upper : calcRecov1CellGen(phaseBasisFunc, pv, varsP, polyOrder, 2,
   dg(lst_G_skin), dg(lst_G_edge),
   bcs([der=2, val=d2gdv2_surf_e])),
   
  G_rec_lower : calcRecov1CellGen(phaseBasisFunc, pv, varsP, polyOrder, 2,
   bcs([der=2, val=d2gdv2_surf_e]),
   dg(lst_G_edge), dg(lst_G_skin)),

  /* Take derivative and project */
  D_c_upper : calcInnerProdList(varsP, 1, bP, diff(G_rec_upper, pv, 2)),
  D_c_lower : calcInnerProdList(varsP, 1, bP, diff(G_rec_lower, pv, 2)),

  D_c_upper : map(letsimp, gamma*dv1_sq*D_c_upper),
  D_c_lower : map(letsimp, gamma*dv1_sq*D_c_lower),

  if (dir = 1) then (
    writeCExprs1(diff_coeff_xx, D_c_upper),
    printf(fh, " } else {~%"),
    writeCExprs1(diff_coeff_xx, D_c_lower)
  )
  elseif (dir = 2) then (
      writeCExprs1(diff_coeff_yy, D_c_upper),
      printf(fh, " } else {~%"),
      writeCExprs1(diff_coeff_yy, D_c_lower)
  )
  elseif (dir = 3) then (
      writeCExprs1(diff_coeff_zz, D_c_upper),
      printf(fh, " } else {~%"),
      writeCExprs1(diff_coeff_zz, D_c_lower)
  ),

  printf(fh, "  } ~%"),
  printf(fh, "}~%")
)$
