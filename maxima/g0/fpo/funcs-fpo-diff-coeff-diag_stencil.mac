/*
  Generate kernels for the diagonal terms of the
  diffusion tensor for the Rosenbluth/Fokker-Planck Operator
  D_ii = d^2 G / dv_i^2 

  Using a 3-cell domain stencil:
  Left edge
  Domain volume
  Right edge
*/

load("modal-basis");
load("out-scripts");
load("recovery");
load("bvp_utilities/bvp-util");

generate_fpo_diff_coeff_diag_stencil(fname, funcNm, cdim, basisFun, polyOrder, pv) := block(
  [vdim, dim, pv1, pv2, dirNums, coordVarS, stencilLoc, stencilStr, pvdir, fnameStencil, fh,
  varsC, bC, varsP, bP, surfVarspv1, surfVarspv2, bSurfpv1, bSurfpv2, NC, numSurf, G_L_lst, G_C_lst,
  G_R_lst, G_C_e, d2G_surf_C_e, stencilCells, G_rec, diff_coeff_out],
  /* FPO is only defined in 3V */
  vdim : 3,

  /* Diagonal term stencils are always 1D */
  dim : 1,

  dirNums : [[vx, 1], [vy, 2], [vz,3]],

  kill(varsC, basisC, varsP, basisP),

  /* Associative list between stencil location (-1,0,1) and variable strings in kernel name. */
  coordVarS : getCoordVarS([pv]),

  /* List of stencil locations. Each entry is a dim-dimensional list
  with -1 meaning it is at a lower boundary, 1 upper boundary, or
  0 away from boundaries in that direction. */
  stencilLoc : getStencilCoords(dim),

  for sI : 1 thru length(stencilLoc) do (
    stencilStr : sconcat("_", assoc(stencilLoc[sI][1], 
      [[-1, "lo"], [0, "in"], [1, "up"]]), string(pv)),

    pvdir : assoc(pv, dirNums),

    fnameStencil : sconcat(fname, "_stencil", stencilStr, ".c"),
    disp(printf(false,"Creating ~a", fnameStencil)),
    fh : openw(fnameStencil),
    printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%~%"),

    printf(fh, "GKYL_CU_DH void ~a_p~a~a(const double *dxv, const double *gamma, const double* fpo_g_stencil[3], const double* fpo_d2gdv2_surf, double *diff_coeff) {~%", funcNm, polyOrder, stencilStr),
    printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
    printf(fh, "  // gamma: Scalar factor gamma. ~%"),
    printf(fh, "  // fpo_g_stencil[3]: 3 cell stencil of Rosenbluth potential G. ~%"),
    printf(fh, "  // fpo_d2gdv2_surf: Surface projection of d2G/dv2 in center cell. ~%"),
    printf(fh, "  // diff_coeff: Output array for diffusion tensor. ~%"),
    printf(fh, "~%"),
    printf(fh, "  // Use cell-average value for gamma. ~%"),
    printf(fh, "  double gamma_avg = gamma[0]/sqrt(pow(2, ~a)); ~%", cdim),

    printf(fh, "  double dv1_sq = 4.0/dxv[~a]/dxv[~a]; ~%", pvdir+cdim-1, pvdir+cdim-1),
    printf(fh, "~%"),

    [varsC, bC, varsP, bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

    surfVars : delete(pv, varsP),
    bSurf : basisFromVars(basisFun, surfVars, polyOrder),

    NC : length(bP),
    numSurf : length(bSurf),
    G_L_lst : makelist(G_L[i], i, 0, NC-1),
    G_C_lst : makelist(G_C[i], i, 0, NC-1),
    G_R_lst : makelist(G_R[i], i, 0, NC-1),

    G_C_e : doExpand1(G_C, bP),

    /* Surface projection of G */
    d2G_surf_C_e : doExpand1(d2G_surf_C, bSurf)/dv1_sq,

    if stencilLoc[sI] = [0] then (
      /*
        +-----+-----+-----+
        | G_L | G_C | G_R |
        +-----+-----+-----+
      */
      stencilCells : [L, C, R],

      G_rec : calcRecov1CellGen(basisFun, pv, varsP, polyOrder, 1, 
        dg(G_L_lst), dg(G_C_lst), dg(G_R_lst))
    )
    elseif stencilLoc[sI] = [-1] then (
      /*
        +-----+-----+-----+
        | +++ | G_C | G_R |
        +-----+-----+-----+
      */
      stencilCells : [C, R],

      G_rec : calcRecov1CellGen(basisFun, pv, varsP, polyOrder, 1,
        bcs([der=2, val=d2G_surf_C_e]), dg(G_C_lst), dg(G_R_lst))
    )
    elseif stencilLoc[sI] = [1] then (
      /*
        +-----+-----+-----+
        | G_L | G_C | +++ |
        +-----+-----+-----+
      */
      stencilCells : [L, C],

      G_rec : calcRecov1CellGen(basisFun, pv, varsP, polyOrder, 1,
        dg(G_L_lst), dg(G_C_lst), bcs([der=2, val=d2G_surf_C_e]))
    ),

    for i : 1 thru length(stencilCells) do (
      printf(fh, "  const double* G_~a = fpo_g_stencil[~a]; ~%", stencilCells[i], i-1)
    ),
    printf(fh, "  ~%"),
    printf(fh, "  const double *fpo_d2g_surf_C_vxvx = &fpo_d2gdv2_surf[~a]; ~%", 0*numSurf),
    printf(fh, "  const double *fpo_d2g_surf_C_vyvy = &fpo_d2gdv2_surf[~a]; ~%", 4*numSurf),
    printf(fh, "  const double *fpo_d2g_surf_C_vzvz = &fpo_d2gdv2_surf[~a]; ~%", 8*numSurf),
    printf(fh, "  ~%"),
    printf(fh, "  const double* d2G_surf_C = fpo_d2g_surf_C_~a~a; ~%", pv,pv),

    printf(fh, "  ~%"),
    diff_coeff_index : 4*(pvdir-1),
    printf(fh, "  diff_coeff_out = &diff_coeff[~a]; ~%", diff_coeff_index*NC),
    printf(fh, "  ~%"),

    diff_coeff_out : calcInnerProdList(varsP, 1, bP, diff(G_rec, pv, 2)),

    writeCExprs1(out, gamma_avg*diff_coeff_out*dv1_sq),
    printf(fh, "} ~%"),
    printf(fh, "~%"),
    flush_output(fh)
  )
)$
