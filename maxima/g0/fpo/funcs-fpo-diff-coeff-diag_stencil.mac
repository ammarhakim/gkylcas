/*
  Generate kernels for the diagonal terms of the
  diffusion tensor for the Rosenbluth/Fokker-Planck Operator
  D_ii = d^2 G / dv_i^2 

  Using a 3-cell domain stencil:
  Bottom edge
  Domain volume
  Top edge
*/

load("modal-basis");
load("out-scripts");
load("recovery");
load("bvp_utilities/bvp-util");

generate_fpo_diff_coeff_diag_stencil(fname, funcNm, cdim, basisFun, polyOrder, pv) := block(
  [],
  /* FPO is only defined in 3V */
  vdim : 3,

  /* Diagonal term stencils are always 1D */
  dim : 1,

  dirNums : [[vx, cdim+1], [vy, cdim+2], [vz,cdim+3]],

  kill(varsC, basisC, varsP, basisP),

  /* Associative list between stencil location (-1,0,1) and variable strings in kernel name. */
  coordVarS : getCoordVarS([pv]),

  /* List of stencil locations. Each entry is a dim-dimensional list
  with -1 meaning it is at a lower boundary, 1 upper boundary, or
  0 away from boundaries in that direction. */
  stencilLoc : getStencilCoords(dim),

  for sI : 1 thru length(stencilLoc) do (
    stencilStr : sconcat("_", assoc(stencilLoc[sI][1], 
      [[-1, "lo"], [0, "in"], [1, "up"]]), string(pv)),

    pvdir : assoc(pv, dirNums),

    fnameStencil : sconcat(fname, "_stencil", stencilStr, ".c"),
    disp(printf(false,"Creating ~a", fnameStencil)),
    fh : openw(fnameStencil),
    printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%~%"),

    printf(fh, "GKYL_CU_DH void ~a_p~a~a(const double *dxv, const double gamma, const double* fpo_g_stencil[3], const double* fpo_g_surf, double *diff_coeff) {~%", funcNm, polyOrder, stencilStr),
    printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
    printf(fh, "  // gamma: Scalar factor gamma. ~%"),
    printf(fh, "  // fpo_g_stencil[3]: 3 cell stencil of Rosenbluth potential G. ~%"),
    printf(fh, "  // fpo_g_surf: Surface projection of G in center cell. ~%"),
    printf(fh, "  // diff_coeff: Output array for diffusion tensor. ~%"),
    printf(fh, "~%"),

    printf(fh, "  double dv1_sq = 4.0/dxv[~a]/dxv[~a]; ~%", pvdir-1, pvdir-1),
    printf(fh, "~%"),

    [varsC, bC, varsP, bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

    surfVars : delete(pv, varsP),
    bSurf : basisFromVars(basisFun, surfVars, polyOrder),

    NC : length(bP),
    numSurf : length(bSurf),
    G_L_lst : makelist(G_L[i], i, 0, NC-1),
    G_C_lst : makelist(G_C[i], i, 0, NC-1),
    G_R_lst : makelist(G_R[i], i, 0, NC-1),

    G_C_e : doExpand1(G_C, bP),

    /* Surface projection of G */
    G_surf_C_e : doExpand1(G_surf_C, bSurf),

    surft1_L_e : doExpand1(surft1_L, bSurf),
    surft1_R_e : doExpand1(surft1_R, bSurf),
    surft2_L_e : doExpand1(surft2_L, bSurf),
    surft2_R_e : doExpand1(surft2_R, bSurf),

    if stencilLoc[sI] = [0] then (
      /*
        +-----+-----+-----+
        | G_L | G_C | G_R |
        +-----+-----+-----+
      */
      stencilCells : [L, C, R],
/*
      G_C_e : calcRecov1CellGen(basisFun, pv, varsP, polyOrder, 1, 
        dg(G_L_lst), dg(G_C_lst), dg(G_R_lst)),
*/
      G_rec_L : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, dg(G_L_lst), dg(G_C_lst)),
      G_rec_R : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, dg(G_C_lst), dg(G_R_lst))
    )
    elseif stencilLoc[sI] = [-1] then (
      /*
        +-----+-----+-----+
        | +++ | G_C | G_R |
        +-----+-----+-----+
      */
      stencilCells : [C, R],
      G_rec_L : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, 
        bcs([der=0, val=G_surf_C_e]), dg(G_C_lst)),
      G_rec_R : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, dg(G_C_lst), dg(G_R_lst))
    )
    elseif stencilLoc[sI] = [1] then (
      /*
        +-----+-----+-----+
        | G_L | G_C | +++ |
        +-----+-----+-----+
      */
      stencilCells : [L, C],
      G_rec_L : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, dg(G_L_lst), dg(G_C_lst)),
      G_rec_R : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, 
        dg(G_C_lst), bcs([der=0, val=G_surf_C_e]))
    ),

    for i : 1 thru length(stencilCells) do (
      printf(fh, "  const double* G_~a = fpo_g_stencil[~a]; ~%", stencilCells[i], i-1)
    ),
    printf(fh, "  const double* G_surf_C = &fpo_g_surf[~a]; ~%", (pvdir-cdim-1)*numSurf),

    printf(fh, "  ~%"),
    printf(fh, "  double surft1_R[~a], surft1_L[~a]; ~%", numSurf, numSurf),
    printf(fh, "  double surft2_R[~a], surft2_L[~a]; ~%", numSurf, numSurf),
    printf(fh, "  ~%"),
    printf(fh, "  double *diff_coeff_vxvx = &diff_coeff[~a]; ~%", 0*NC),
    printf(fh, "  double *diff_coeff_vyvy = &diff_coeff[~a]; ~%", 4*NC),
    printf(fh, "  double *diff_coeff_vzvz = &diff_coeff[~a]; ~%", 8*NC),
    printf(fh, "  ~%"),
    printf(fh, "  double *out = diff_coeff_~a~a; ~%", pv, pv),
    printf(fh, "  ~%"),

    surft1_L_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, diff(G_rec_L, pv))),
    surft1_R_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, diff(G_rec_R, pv))),

    surft2_L_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, G_rec_L)),
    surft2_R_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, G_rec_R)),
  
    surft1 : calcInnerProdList(surfVars, 1, subst(pv=1, bP), surft1_R_e) + 
      calcInnerProdList(surfVars, -1, subst(pv=-1, bP), surft1_L_e),
    surft2 : calcInnerProdList(surfVars, -1, subst(pv=1, diff(bP, pv)), surft2_R_e) +
      calcInnerProdList(surfVars, 1, subst(pv=-1, diff(bP, pv)), surft2_L_e),

    vol : calcInnerProdList(varsP, 1, diff(bP, pv, 2), G_C_e),  

    diff_coeff_out : surft1 + surft2 + vol,

    writeCExprs1(surft1_R, surft1_R_c),
    printf(fh, "~%"),
    writeCExprs1(surft1_L, surft1_L_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(surft2_R, surft2_R_c),
    printf(fh, "~%"),
    writeCExprs1(surft2_L, surft2_L_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(out, diff_coeff_out*dv1_sq),
    printf(fh, "} ~%"),
    printf(fh, "~%"),
    flush_output(fh)
  )
)$
