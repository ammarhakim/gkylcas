/* Functions (called by ms-moments-fpo-vlasov.mac) that compute the
   needed volume and boundary correction moments to construct a conservative
   Fokker-Planck operator for the Vlasov-Maxwell system.

   In the volume, these moments are: a + div(D) (3-components), a . v + div(D . v) 
   For boundary corrections, we compute an 8 component array, 4 components of which
   are identical to the LBO corrects and the other 4 components involve evaluation of
   the diffusion tensor at the edge of velocity space: 
   if the lower velocity space edge first correction is -f_(vmin) or -(vf)_(vmin),
   second correction is - D_ii f_(vmin) or -(v_i D_ii f)_(vmin)
   if the upper velocity space edge first correction is f_(vmax) or (vf)_(vmax).
   second correction is - D_ii f_(vmax) or -(v_i D_ii f)_(vmax)
   where D_ii is the diagonal component at the v surface (e.g., Dxx at vx surface). */

load("modal-basis");
load("out-scripts");
load(stringproc)$
fpprec : 24$

volExpr(cdim, vdim) := prod(dxv[cdim+i-1], i, 1, vdim)$

vTrans  : [vx*dv1/2+wx1, vy*dv2/2+wx2, vz*dv3/2+wx3]$
wTrans  : [wx1, wx2, wx3]$
dvTrans : [vx*dv1/2, vy*dv2/2, vz*dv3/2]$
vvarsAll : [vx, vy, vz]$

/* FPO moments (4-components) */
/* a + div(D) (3-components), a . v + div(D . v) */
calcFPOMoms(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,NP,NC,f_e,
   ax_e,Dxx_e,Dxy_e,Dxz_e,
   ay_e,Dyx_e,Dyy_e,Dyz_e,
   az_e,Dzx_e,Dzy_e,Dzz_e,clst,
   temp_1_e,temp_2_e,temp_3_e,temp_4_e,temp_5_e,temp_6_e,
   temp_7_e,temp_8_e,temp_9_e,temp_10_e,temp_11_e,temp_12_e,
   temp_1_c,temp_2_c,temp_3_c,temp_4_c,temp_5_c,temp_6_c,
   temp_7_c,temp_8_c,temp_9_c,temp_10_c,temp_11_c,temp_12_c,corr_c],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const int *idx, const double *a_i, const double *D_ij,  const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:   cell center in each direction. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]: cell length in each direction. ~%", cdim+vdim),
  printf(fh, "  // idx[~a]: cell index in each direction. ~%", cdim+vdim),
  printf(fh, "  // a_i:     Drag coefficient. ~%"),
  printf(fh, "  // D_ij:    Diffusion tensor. ~%"),
  printf(fh, "  // f[~a]:   Input distribution function. ~%", NP),
  printf(fh, "  // out:     Output moments a + div(D) (3-components), a . v + div(D . v). ~%"),
  printf(fh, " ~%"),
  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),
  for i : 1 thru vdim do (
    printf(fh, "  const double wx~a = w[~a], dv~a = dxv[~a]; ~%", i, cdim+i-1, i, cdim+i-1)
  ),

  /* Access components of drag coefficient a_i and diffusion tensor D_ij */
  printf(fh, "  const double *ax = &a_i[~a]; ~%", 0),
  printf(fh, "  const double *ay = &a_i[~a]; ~%", NP),
  printf(fh, "  const double *az = &a_i[~a]; ~%", 2*NP),
  printf(fh, "  const double *Dxx = &D_ij[~a]; ~%", 0),
  printf(fh, "  const double *Dxy = &D_ij[~a]; ~%", NP),
  printf(fh, "  const double *Dxz = &D_ij[~a]; ~%", 2*NP),
  printf(fh, "  const double *Dyx = &D_ij[~a]; ~%", 3*NP),
  printf(fh, "  const double *Dyy = &D_ij[~a]; ~%", 4*NP),
  printf(fh, "  const double *Dyz = &D_ij[~a]; ~%", 5*NP),
  printf(fh, "  const double *Dzx = &D_ij[~a]; ~%", 6*NP),
  printf(fh, "  const double *Dzy = &D_ij[~a]; ~%", 7*NP),
  printf(fh, "  const double *Dzz = &D_ij[~a]; ~%", 8*NP),  
  printf(fh, "~%"),

  printf(fh, "  double *ax_corr = &out[~a]; ~%", 0),
  printf(fh, "  double *ay_corr = &out[~a]; ~%", NC),
  printf(fh, "  double *az_corr = &out[~a]; ~%", 2*NC),
  printf(fh, "  double *energy_corr = &out[~a]; ~%", 3*NC),
  printf(fh, "~%"),

  f_e : doExpand1(f, bP),

  ax_e : doExpand1(ax, bP),
  Dxx_e : doExpand1(Dxx, bP),
  Dxy_e : doExpand1(Dxy, bP),
  Dxz_e : doExpand1(Dxz, bP),

  ay_e : doExpand1(ay, bP),
  Dyx_e : doExpand1(Dyx, bP),
  Dyy_e : doExpand1(Dyy, bP),
  Dyz_e : doExpand1(Dyz, bP),

  az_e : doExpand1(az, bP),
  Dzx_e : doExpand1(Dzx, bP),
  Dzy_e : doExpand1(Dzy, bP),
  Dzz_e : doExpand1(Dzz, bP),

  /* Temporary variables to avoid long expressions in momentum and energy corrections */
  printf(fh, "  double temp_1[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_2[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_3[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_4[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_5[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_6[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_7[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_8[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_9[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_10[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_11[~a] = {0.0}; ~%", NC),
  printf(fh, "  double temp_12[~a] = {0.0}; ~%", NC),

  temp_1_e : doExpand1(temp_1, bC),
  temp_2_e : doExpand1(temp_2, bC),
  temp_3_e : doExpand1(temp_3, bC),
  temp_4_e : doExpand1(temp_4, bC),
  temp_5_e : doExpand1(temp_5, bC),
  temp_6_e : doExpand1(temp_6, bC),
  temp_7_e : doExpand1(temp_7, bC),
  temp_8_e : doExpand1(temp_8, bC), 
  temp_9_e : doExpand1(temp_9, bC),
  temp_10_e : doExpand1(temp_10, bC),
  temp_11_e : doExpand1(temp_11, bC),
  temp_12_e : doExpand1(temp_12, bC),
  clst : [volFact, wx1, wx2, wx3, dv1, dv2, dv3],

  /* x momentum correction = (ax + d/dvx (Dxx) + d/dvy (Dyx) + d/dvz (Dzx)) f */
  temp_1_c : calcInnerProdList(varsP, 1, bC, ax_e*f_e),
  temp_2_c : calcInnerProdList(varsP, 1, bC, diff(Dxx_e, vx)*f_e),
  temp_3_c : calcInnerProdList(varsP, 1, bC, diff(Dyx_e, vy)*f_e),
  temp_4_c : calcInnerProdList(varsP, 1, bC, diff(Dzx_e, vz)*f_e),

  writeCExprs1(temp_1, temp_1_c), 
  writeCExprs1(temp_2, temp_2_c), 
  writeCExprs1(temp_3, temp_3_c),
  writeCExprs1(temp_4, temp_4_c),

  corr_c : calcInnerProdList(varsC, 1, bC, temp_1_e + temp_2_e + temp_3_e + temp_4_e),
  writeCIncrExprsCollect1(ax_corr, volFact*corr_c, clst),
  printf(fh, "~%"),

  /* y momentum correction = (ay + d/dvx (Dxy) + d/dvy (Dyy) + d/dvz (Dzy)) f */
  temp_1_c : calcInnerProdList(varsP, 1, bC, ay_e*f_e),
  temp_2_c : calcInnerProdList(varsP, 1, bC, diff(Dxy_e, vx)*f_e),
  temp_3_c : calcInnerProdList(varsP, 1, bC, diff(Dyy_e, vy)*f_e),
  temp_4_c : calcInnerProdList(varsP, 1, bC, diff(Dzy_e, vz)*f_e),

  writeCExprs1(temp_1, temp_1_c), 
  writeCExprs1(temp_2, temp_2_c), 
  writeCExprs1(temp_3, temp_3_c),
  writeCExprs1(temp_4, temp_4_c),

  corr_c : calcInnerProdList(varsC, 1, bC, temp_1_e + temp_2_e + temp_3_e + temp_4_e),
  writeCIncrExprsCollect1(ay_corr, volFact*corr_c, clst),
  printf(fh, "~%"),

  /* z momentum correction = (az + d/dvx (Dxz) + d/dvy (Dyz) + d/dvz (Dzz)) f */
  temp_1_c : calcInnerProdList(varsP, 1, bC, az_e*f_e),
  temp_2_c : calcInnerProdList(varsP, 1, bC, diff(Dxz_e, vx)*f_e),
  temp_3_c : calcInnerProdList(varsP, 1, bC, diff(Dyz_e, vy)*f_e),
  temp_4_c : calcInnerProdList(varsP, 1, bC, diff(Dzz_e, vz)*f_e),

  writeCExprs1(temp_1, temp_1_c), 
  writeCExprs1(temp_2, temp_2_c), 
  writeCExprs1(temp_3, temp_3_c),
  writeCExprs1(temp_4, temp_4_c),

  corr_c : calcInnerProdList(varsC, 1, bC, temp_1_e + temp_2_e + temp_3_e + temp_4_e),
  writeCIncrExprsCollect1(az_corr, volFact*corr_c, clst),
  printf(fh, "~%"),

  /* energy correction = (a . v + d/dvx (Dx . v) + d/dvy (Dy . v) + d/dvz (Dz . v)) f */
  temp_1_c : calcInnerProdList(varsP, 1, bC, vTrans[1]*ax_e*f_e),
  temp_2_c : calcInnerProdList(varsP, 1, bC, vTrans[2]*ay_e*f_e),
  temp_3_c : calcInnerProdList(varsP, 1, bC, vTrans[3]*az_e*f_e),

  temp_4_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[1]*Dxx_e, vx)*f_e),
  temp_5_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[2]*Dyx_e, vx)*f_e),
  temp_6_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[3]*Dzx_e, vx)*f_e),

  temp_7_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[1]*Dxy_e, vy)*f_e),
  temp_8_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[2]*Dyy_e, vy)*f_e),
  temp_9_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[3]*Dzy_e, vy)*f_e),

  temp_10_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[1]*Dxz_e, vz)*f_e),
  temp_11_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[2]*Dyz_e, vz)*f_e),
  temp_12_c : calcInnerProdList(varsP, 1, bC, diff(vTrans[3]*Dzz_e, vz)*f_e),

  writeCExprsCollect1(temp_1, temp_1_c, clst), 
  writeCExprsCollect1(temp_2, temp_2_c, clst), 
  writeCExprsCollect1(temp_3, temp_3_c, clst), 
  writeCExprsCollect1(temp_4, temp_4_c, clst), 
  writeCExprsCollect1(temp_5, temp_5_c, clst), 
  writeCExprsCollect1(temp_6, temp_6_c, clst), 
  writeCExprsCollect1(temp_7, temp_7_c, clst), 
  writeCExprsCollect1(temp_8, temp_8_c, clst), 
  writeCExprsCollect1(temp_9, temp_9_c, clst), 
  writeCExprsCollect1(temp_10, temp_10_c, clst), 
  writeCExprsCollect1(temp_11, temp_11_c, clst), 
  writeCExprsCollect1(temp_12, temp_12_c, clst), 

  corr_c : calcInnerProdList(varsC, 1, bC, 
    temp_1_e + temp_2_e + temp_3_e + temp_4_e + temp_5_e + temp_6_e 
  + temp_7_e + temp_8_e + temp_9_e + temp_10_e + temp_11_e + temp_12_e),
  writeCIncrExprsCollect1(energy_corr, volFact*corr_c, clst),
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$

calcFPOBoundaryIntegral(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,NP,NC,
   vv,surfVars,dv,
   fbIn_lower_e,fbIn_upper_e,D_ij_lower_e,D_ij_upper_e,
   mBlo_e,mBup_e,Dlo_e,Dup_e,fBlo_c,fBup_c,Dlo_c,Dup_c,
   dvSurf,surfExpr,clst],
    
  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
        
  printf(fh, "GKYL_CU_DH void ~a(const int *idx, enum gkyl_vel_edge edge, const double *vBoundary, const double *dxv, const double *D_ij, const double *fIn, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // idx[~a]:   cell index in each direction. ~%", cdim+vdim),
  printf(fh, "  // edge:      indicator of which velocity grid edge is being considered (VX/VPAR, VY/MU, VZ). ~%"),
  printf(fh, "  // vBoundary: velocity at the boundary of the velocity grid. ~%"),
  printf(fh, "  // dxv[~a]:   cell length in each direction. ~%", cdim+vdim),
  printf(fh, "  // D_ij:      Diffusion tensor. ~%"),
  printf(fh, "  // fIn[~a]:   Distribution function at lower/upper velocity boundaries. ~%", NP),
  printf(fh, "  // out:       Boundary corrections. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  const double *Dxx = &D_ij[~a]; ~%", 0),
  printf(fh, "  const double *Dyy = &D_ij[~a]; ~%", 4*NP),
  printf(fh, "  const double *Dzz = &D_ij[~a]; ~%", 8*NP),  
  printf(fh, "~%"),
  printf(fh, "  double dS = 0.0; ~%"),
  printf(fh, " ~%"),

  /* if atLower=true first correction is -f_(vmin) or -(vf)_(vmin),
     second correction is - D_ii f_(vmin) or -(v_i D_ii f)_(vmin)

     if atLower=false this is f_(vmax) or (vf)_(vmax).
     second correction is - D_ii f_(vmax) or -(v_i D_ii f)_(vmax)
     
     where D_ii is the diagonal component at the v surface (e.g., Dxx at vx surface).

     This evaluation is integrated over the velocity boundary surface, 
     and projected onto the configuration space basis function. 

     We store this as all 4 of the first corrections, then all 4 of 
     the second corrections involving the diffusion tensor. */
  printf(fh, "  double *ax_corr = &out[~a]; ~%", 0*NC),
  printf(fh, "  double *ay_corr = &out[~a]; ~%", 1*NC),
  printf(fh, "  double *az_corr = &out[~a]; ~%", 2*NC),
  printf(fh, "  double *energy_corr = &out[~a]; ~%", 3*NC),
  printf(fh, "  double *ax_D_ij_corr = &out[~a]; ~%", 4*NC),
  printf(fh, "  double *ay_D_ij_corr = &out[~a]; ~%", 5*NC),
  printf(fh, "  double *az_D_ij_corr = &out[~a]; ~%", 6*NC),
  printf(fh, "  double *energy_D_ij_corr = &out[~a]; ~%", 7*NC),
  printf(fh, "~%"),

  for dir : 1 thru vdim do (
    vv       : vvarsAll[dir],
    surfVars : delete(vv,varsP),
    dv       : makelist(dxv[cdim+i], i, 0, vdim-1),

    /* Expand the distribution function in the cells at the
       lower and upper boundaries of the velocity domain. */
    fbIn_lower_e : doExpand1(fIn,bP),
    fbIn_upper_e : doExpand1(fIn,bP),

    /* Expand the needed component of the diffusion tensor */
    if (dir = 1) then (
      D_ij_lower_e : doExpand1(Dxx,bP),
      D_ij_upper_e : doExpand1(Dxx,bP)
    )
    else if (dir = 2) then (
      D_ij_lower_e : doExpand1(Dyy,bP),
      D_ij_upper_e : doExpand1(Dyy,bP)
    )
    else (
      D_ij_lower_e : doExpand1(Dzz,bP),
      D_ij_upper_e : doExpand1(Dzz,bP)
    ),
    mBlo_e : -subst(vv=-1,fbIn_lower_e),
    mBup_e :  subst(vv=1,fbIn_upper_e),

    Dlo_e : subst(vv=-1,D_ij_lower_e),
    Dup_e : subst(vv=1,D_ij_upper_e),

    fBlo_c : calcInnerProdList(surfVars,1,bC,mBlo_e),
    fBup_c : calcInnerProdList(surfVars,1,bC,mBup_e),

    Dlo_c : calcInnerProdList(surfVars,1,bC,Dlo_e*mBlo_e),
    Dup_c : calcInnerProdList(surfVars,1,bC,Dup_e*mBup_e),

    /* Surface integral above was done in [-1,1] computational space. Surface
       factor needs to be multiplied to obtain result from physical grid. */
    dvSurf   : delete(dxv[cdim+dir-1],dv),
    surfExpr : float(prod(dvSurf[i],i,1,vdim-1)),
    printf(fh, "  dS = ~a; ~%", float(1/(2^(vdim-1)))*surfExpr),
    printf(fh, " ~%"),
    clst : [dS, vBoundary[0], vBoundary[1], vBoundary[2], vBoundary[3], vBoundary[4], vBoundary[5]],

    printf(fh, "  if (edge == GKYL_~a_LOWER) {~%", supcase(string(vvarsAll[dir]))),
    printf(fh, " ~%"),

    if (dir = 1) then (
      writeCIncrExprsCollect1(ax_corr, dS*fBlo_c, clst),
      printf(fh, " ~%"),
      writeCIncrExprsCollect1(ax_D_ij_corr, dS*Dlo_c, clst),
      printf(fh, " ~%")
    )
    else if (dir = 2) then (
      writeCIncrExprsCollect1(ay_corr, dS*fBlo_c, clst),
      printf(fh, " ~%"),
      writeCIncrExprsCollect1(ay_D_ij_corr, dS*Dlo_c, clst),
      printf(fh, " ~%")
    )
    else (
      writeCIncrExprsCollect1(az_corr, dS*fBlo_c, clst),
      printf(fh, " ~%"),
      writeCIncrExprsCollect1(az_D_ij_corr, dS*Dlo_c, clst),
      printf(fh, " ~%")
    ),

    writeCIncrExprsCollect1(energy_corr, dS*(vBoundary[dir-1]*fBlo_c), clst),
    printf(fh, " ~%"),
    writeCIncrExprsCollect1(energy_D_ij_corr, dS*(vBoundary[dir-1]*Dlo_c), clst),
    printf(fh, " ~%"),

    printf(fh, "  } else if (edge == GKYL_~a_UPPER) {~%", supcase(string(vvarsAll[dir]))),
    printf(fh, " ~%"),

    if (dir = 1) then (
      writeCIncrExprsCollect1(ax_corr, dS*fBup_c, clst),
      printf(fh, " ~%"),
      writeCIncrExprsCollect1(ax_D_ij_corr, dS*Dup_c, clst),
      printf(fh, " ~%")
    )
    else if (dir = 2) then (
      writeCIncrExprsCollect1(ay_corr, dS*fBup_c, clst),
      printf(fh, " ~%"),
      writeCIncrExprsCollect1(ay_D_ij_corr, dS*Dup_c, clst),
      printf(fh, " ~%")
    )
    else (
      writeCIncrExprsCollect1(az_corr, dS*fBup_c, clst),
      printf(fh, " ~%"),
      writeCIncrExprsCollect1(az_D_ij_corr, dS*Dup_c, clst),
      printf(fh, " ~%")
    ),

    writeCIncrExprsCollect1(energy_corr, dS*(vBoundary[dir+vdim-1]*fBup_c), clst),
    printf(fh, " ~%"),
    writeCIncrExprsCollect1(energy_D_ij_corr, dS*(vBoundary[dir+vdim-1]*Dup_c), clst),
    printf(fh, " ~%"),

    printf(fh, "  }~%"),
    printf(fh, " ~%")
  ),
  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$
