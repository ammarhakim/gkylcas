/* This script generates the kernels to calculate the drag coefficient 
   from an input potential in an edge cell.
   a = 2 * Gamma * grad(H)
*/
load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("recovery")$

calcFPODragCoeffSurf(dir, edge, fh, funcNm, cdim, basisFunc, polyOrder) := block(
  [varsC, bC, NC, cv, lst_H_skin, lst_H_edge, H_rec, drag_coeff],

  /* Clear variables for safety, then load basis */
  kill(varsC, bC),
  [varsC, bC] : loadBasis(basisFunc, cdim, polyOrder),
  
  /* Number of basis monomials */
  NC : length(bC),
  
  /* Variable to perform recovery in */
  cv : varsC[dir],

  printf(fh, "GKYL_CU_DH void ~av~a_~av_~a_p~a(double *dxv, double *H_l, double *H_c, double *H_r)~%", funcNm, cv, cdim, basisFunc, polyOrder),
  printf(fh, "  // dxv[NDIM]: Cell spacing. ~%"),
  printf(fh, "  // H_skin/edge:   Input potential in skin/edge cells.~%  "),
  printf(fh, "~%"),

  printf(fh, "  const double dv1 = 2.0/dxv[~a]; ~%", dir-1),

  /* Expansions of H in skin and edge cells */
  lst_H_skin : makelist(H_skin[i], i, 0, NC-1),
  lst_H_edge : makelist(H_edge[i], i, 0, NC-1),

  H_edge_e : doExpand(H_edge, bC),
  /* 1-Cell recovery of  H using the surface values of H 
    as the constraint on one side */
  if (edge = 1)
    then H_rec : calcRecov1CellGen(basisFunc, cv, varsC, polyOrder, 0, 
      dg(lst_H_skin), dg(lst_H_edge), bc(D=1, N=0, val=subst(edge, cv, H_edge_e)))
    else H_rec : calcRecov1CellGen(basisFunc, cv, varsC, polyOrder, 0, 
      bc(D=1, N=0, val=subst(edge, cv, H_edge_e)), dg(lst_H_edge), dg(lst_H_skin)),

  /* a = dH/dvi, project derivative */ 
  a_c : calcInnerProdList(varsC, 1, bC, diff(H_rec, cv)),
  writeCExprs1(drag_coeff, dv1*a_c),
  printf(fh, "} ~%"),
  printf(fh, "~%")
)$
