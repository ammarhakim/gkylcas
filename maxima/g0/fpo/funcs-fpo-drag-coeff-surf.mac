/* This script generates the kernels to calculate the drag coefficient 
   from an input potential in an edge cell.
   a = 2 * Gamma * grad(H)
*/
load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("recovery")$

calcFPODragCoeffSurf(dir, fh, funcNm, cdim, vdim, basisFunc, polyOrder) := block(
  [varsC, bC, varsP, bP, NC, pv, lst_H_skin, lst_H_edge, H_rec, drag_coeff],

  let(dv1^2, dv1_sq),
  /* Clear variables for safety, then load basis */
  kill(varsC, bC, varsP, bP),
  [varsC, bC, varsP, bP] : loadPhaseBasis(basisFunc, cdim, vdim, polyOrder),

  /* Variable to perform recovery in */
  recovDir : dir + cdim,
  pv : varsP[recovDir],
  display(pv),
  
  /* Surface variables to integrate over */
  surfVars : delete(pv, varsP),

  /* Generate surface basis, ndim-1 basis set with no pv dependence */
  bSurf : basisFromVars(basisFunc,surfVars,polyOrder),

  /* Number of basis monomials */
  NC : length(bP),
  NCsurf : length(bSurf),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax~av_~a_p~a(const int edge, const double *dxv, double gamma, const double *H_skin, const double *H_edge, const double *fpo_dHdv_surf, double *drag_coeff) {~%", funcNm, pv, cdim, vdim, basisFunc, polyOrder),
  printf(fh, "  // dxv[NDIM]: Cell spacing. ~%"),
  printf(fh, "  // H_skin/edge:   Input potential in skin/edge cells in recovery direction.~%  "),
  printf(fh, "  // fpo_dHdv_surf: Surface expansion of derivative of potential.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double dv1 = 2.0/dxv[~a]; ~%", dir-1+cdim),

  printf(fh, "  const double *dHdv_surf; ~%"),
  printf(fh, "  if (edge == -1) {~%"),
  printf(fh, "    dHdv_surf = &fpo_dHdv_surf[~a]; ~%", NCsurf*(dir-1)),
  printf(fh, "  } else { ~%"),
  printf(fh, "    dHdv_surf = &fpo_dHdv_surf[~a]; ~%", NCsurf*(3+dir-1)),
  printf(fh, "  }~%"),

  printf(fh, "  double *drag_coeff_x = &drag_coeff[~a]; ~%", 0*NC),
  printf(fh, "  double *drag_coeff_y = &drag_coeff[~a]; ~%", 1*NC),
  printf(fh, "  double *drag_coeff_z = &drag_coeff[~a]; ~%", 2*NC),

  printf(fh, "  if (edge == 1) {~%"),

  /* Expansions of H in skin and edge cells */
  lst_H_skin : makelist(H_skin[i], i, 0, NC-1),
  lst_H_edge : makelist(H_edge[i], i, 0, NC-1),

  /* Expand potential in surface basis */
  dHdv_surf_e : doExpand1(dHdv_surf, bSurf)/dv1,

  /* 1-Cell recovery of  H using the surface values of H 
    as the constraint on one side */
  H_rec_upper : calcRecov1CellGen(basisFunc, pv, varsP, polyOrder, 0, 
      dg(lst_H_skin), dg(lst_H_edge), bcs([der=1, val=dHdv_surf_e])),
  H_rec_lower : calcRecov1CellGen(basisFunc, pv, varsP, polyOrder, 0, 
      bcs([der=1, val=dHdv_surf_e]), dg(lst_H_edge), dg(lst_H_skin)),

  /* a = dH/dvi, project derivative */ 
  a_c_upper : calcInnerProdList(varsP, 1, bP, diff(H_rec_upper, pv)),
  a_c_lower : calcInnerProdList(varsP, 1, bP, diff(H_rec_lower, pv)),

  if (dir = 1) then (
    writeCExprs1(drag_coeff_x, 2.0*gamma*dv1*a_c_upper)
  )
  elseif (dir = 2) then (
    writeCExprs1(drag_coeff_y, 2.0*gamma*dv1*a_c_upper)
  )
  elseif (dir = 3) then (
    writeCExprs1(drag_coeff_z, 2.0*gamma*dv1*a_c_upper)
  ),
  printf(fh, "  } else {~%"),

  if (dir = 1) then (
    writeCExprs1(drag_coeff_x, 2.0*gamma*dv1*a_c_lower)
  )
  elseif (dir = 2) then (
    writeCExprs1(drag_coeff_y, 2.0*gamma*dv1*a_c_lower)
  )
  elseif (dir = 3) then (
    writeCExprs1(drag_coeff_z, 2.0*gamma*dv1*a_c_lower)
  ), 
  printf(fh, "  } ~%"),
  printf(fh, "}~%")
)$
