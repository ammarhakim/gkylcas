/*
  Generate kernels for the surface and volume terms for the drag 
  contribution for the Rosenbluth/Fokker-Planck Operator
  at a domain boundary.
*/

load("modal-basis");
load("nodal_operations/nodal_functions")$
load("out-scripts");
load("recovery");
load("bvp_utilities/bvp-util");

generateFpoVlasovDragBoundarySurf(fname, funcNm, cdim, basisFun, polyOrder, dirCombo) := block(
  [],
  /* FPO is only defined in 3V */
  vdim : 3,
  pdim : cdim+vdim,
  /* Diagonal stencils are always 1D */
  dim : 1,

  pv : dirCombo[1], 

  dirNums : [[vx, cdim+1], [vy, cdim+2], [vz,cdim+3]],

  pvdir : assoc(pv,dirNums),

  kill(varsC, basisC, varsP, basisP),

  /* Associative list between stencil location (-1,0,1) and variable strings in kernel name. */
  coordVarS : getCoordVarS([pv]),

  /* List of stencil locations. Each entry is a dim-dimensional list
  with -1 meaning it is at a lower boundary, 1 upper boundary, or
  0 away from boundaries in that direction. */
  stencilLoc : getStencilCoords(dim),

  /* Ignore internal domain stencil, as that's handled separately */
  stencilLoc : delete([0], stencilLoc),

  /* 
    Load basis, create surface basis, perform recoveries 
    that will be used in most cases 
  */
  [varsC, bC, varsP, bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  surfVars : delete(pv, varsP),
  bSurf : basisFromVars(basisFun, surfVars, polyOrder),

  NC : length(bP),
  numSurf : length(bSurf),

  /* Components of f and D necessary for upcoming recoveries */
  aL_lst : makelist(aL[i], i, 0, NC-1),
  aC_lst : makelist(aC[i], i, 0, NC-1),
  aR_lst : makelist(aR[i], i, 0, NC-1),

  fL_lst : makelist(fL[i], i, 0, NC-1),
  fC_lst : makelist(fC[i], i, 0, NC-1),
  fR_lst : makelist(fR[i], i, 0, NC-1),

  aC_e : doExpand1(aC, bP),
  fC_e : doExpand1(fC, bP),

  a_rec_lo_e : doExpand1(a_rec_lo, bSurf),
  a_rec_up_e : doExpand1(a_rec_up, bSurf),
  f_rec_lo_e : doExpand1(f_rec_lo, bSurf),
  f_rec_up_e : doExpand1(f_rec_up, bSurf),

  a_rec_lo : calcRecov2CellGen(basisFun, pv, varsP, polyOrder,
    dg(aL_lst), dg(aC_lst)),
  a_rec_up : calcRecov2CellGen(basisFun, pv, varsP, polyOrder,
    dg(aC_lst), dg(aR_lst)),


  /* Begin iteration over stencil locations */
  for sI : 1 thru length(stencilLoc) do (
    /* String used in kernel name to differentiate stencil locations */
    stencilStr : "",
    for d : 1 thru dim do (
      stencilStr : sconcat(stencilStr, "_", 
      assoc(stencilLoc[sI][d], [[-1, "lo"], [0, "in"], [1, "up"]]), string(dirCombo[d]))
    ),

    fnameStencil : sconcat(fname, stencilStr, ".c"),
    disp(printf(false, "Creating ~a", fnameStencil)),
    fh : openw(fnameStencil),
    printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%"),
    printf(fh, "#include <gkyl_basis_~a_~ax_p~a_surfx~a_eval_quad.h> ~%", bName[bInd], pdim, polyOrder, pvdir),
    printf(fh, "#include <gkyl_basis_~a_~ax_p~a_upwind_quad_to_modal.h> ~%~%", bName[bInd], pdim, polyOrder),
    printf(fh, " ~%"),

    printf(fh, "GKYL_CU_DH void ~a~a(const double *dxv, const double* drag_coeff_stencil[9], const double* f_stencil[9], double* out) { ~%", funcNm, stencilStr),
    printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
    printf(fh, "  // drag_coeff_stencil[9]: 9-cell stencil of drag coefficient. ~%"),
    printf(fh, "  // f_stencil[9]: 9-cell stencil of distribution function. ~%"), 
    printf(fh, "  // out: Incremented output. ~%~%"),
    printf(fh, "~%"),

    printf(fh, "  double dv1 = 2.0/dxv[~a]; ~%", pvdir-1),
    printf(fh, " ~%"),

    if stencilLoc[sI] = [-1] then (
      printf(fh, "  const double* aC = &drag_coeff_stencil[0][~a]; ~%", (pvdir-1-cdim)*NC),
      printf(fh, "  const double* aR = &drag_coeff_stencil[1][~a]; ~%", (pvdir-1-cdim)*NC), 
      printf(fh, "  const double* fC = f_stencil[0]; ~%"),
      printf(fh, "  const double* fR = f_stencil[1]; ~%")
    )
    elseif stencilLoc[sI] = [1] then (
      printf(fh, "  const double* aL = &drag_coeff_stencil[0][~a]; ~%", (pvdir-1-cdim)*NC),
      printf(fh, "  const double* aC = &drag_coeff_stencil[1][~a]; ~%", (pvdir-1-cdim)*NC), 
      printf(fh, "  const double* fL = f_stencil[0]; ~%"),
      printf(fh, "  const double* fC = f_stencil[1]; ~%")
    ),

    printf(fh, "~%"),

    /* Initialize Gauss=Legendre quadrature for upwinding */
    surfNodes : gaussOrd(polyOrder+1, pdim-1),
    numNodes : length(surfNodes),
    printf(fh, "  double fUpwindQuad[~a] = {0.0};~%", numNodes),
    printf(fh, "  double fUpwind[~a] = {0.0};~%", length(bSurf)),
    printf(fh, "  double alphaDragSurf[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double Ghat[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "~%"),
    if stencilLoc[sI] = [-1] then (
      /*
        +---+---+---+
        | + | C | R |
        +---+---+---+
      */
      stencilCells : [C, R],
      /* No surface contribution from lo side */
      alphaDragSurf_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, a_rec_up)),
      alst : doMakeExprLst(alphaDragSurf_c, alphaDragSurf),
      alphaDragSurf_e : doExpand(alst, bSurf),
      writeCExprs1(alphaDragSurf, alphaDragSurf_c),
      printf(fh, "~%"),
      alphaOrd_n : gcfac(float(evAtNodes(alphaDragSurf_e, surfNodes, surfVars))),
      for i : 1 thru numNodes do (
        /* Drag term on right side of interface */
        printf(fh, "  if (~a > 0) { ~%", alphaOrd_n[i]),  
        printf(fh, "    fUpwindQuad[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(fC); ~%", 
          i-1, sdowncase(basisFun), pdim, polyOrder, pvdir, i-1),
        printf(fh, "  } else { ~%"),
        printf(fh, "    fUpwindQuad[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(fR); ~%", 
          i-1, sdowncase(basisFun), pdim, polyOrder, pvdir, i-1),
        printf(fh, "  } ~%")
      )
    )
    elseif stencilLoc[sI] = [1] then (
      /*
        +---+---+---+
        | L | C | + |
        +---+---+---+
      */
      stencilCells : [L, C],
      
      /* No surface contribution from up side */
      alphaDragSurf_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, a_rec_lo)),
      alst : doMakeExprLst(alphaDragSurf_c, alphaDragSurf),
      alphaDragSurf_e : doExpand(alst, bSurf),
      writeCExprs1(alphaDragSurf, alphaDragSurf_c),
      printf(fh, "~%"),
      alphaOrd_n : gcfac(float(evAtNodes(alphaDragSurf_e, surfNodes, surfVars))),
      for i : 1 thru numNodes do (
        /* Drag term on right side of interface */
        printf(fh, "  if (~a > 0) { ~%", alphaOrd_n[i]),  
        printf(fh, "    fUpwindQuad[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(fL); ~%", 
          i-1, sdowncase(basisFun), pdim, polyOrder, pvdir, i-1),
        printf(fh, "  } else { ~%"),
        printf(fh, "    fUpwindQuad[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(fC); ~%", 
          i-1, sdowncase(basisFun), pdim, polyOrder, pvdir, i-1),
        printf(fh, "  } ~%")
      )
    ),


    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", 
      sdowncase(basisFun), pdim, polyOrder),
    printf(fh, "~%"),
  
    fHatSurf_e : doExpand1(fUpwind, bSurf),
    alphaDragSurf_e : doExpand1(alphaDragSurf, bSurf),

    Ghat_c : calcInnerProdList(surfVars, alphaDragSurf_e, bSurf, fHatSurf_e), 
    glst1 : doMakeExprLst(Ghat_c, Ghat),
    Ghat_e : doExpand(glst1, bSurf),
  
    drag_incr_up : calcInnerProdList(surfVars, 1, subst(pv=1, bP), Ghat_e),
    drag_incr_lo : calcInnerProdList(surfVars, -1, subst(pv=-1, bP), Ghat_e),

    writeCExprs1(Ghat, Ghat_c),
    printf(fh, "~%"),
    flush_output(fh),

    /* Use proper surface contribution */
    if stencilLoc[sI] = [-1] then (
      surf_incr : drag_incr_up 
    ) elseif stencilLoc[sI] = [1] then (
      surf_incr : drag_incr_lo 
    ),

    kernel : surf_incr,
    writeCIncrExprs1(out, 0.5*dv1*kernel),

    printf(fh, "} ~%"),
    flush_output(fh),
    close(fh)
    )
)$
