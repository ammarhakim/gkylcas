/*
  Generate kernels for the surface term for the drag 
  contribution for the Rosenbluth/Fokker-Planck Operator
  at a domain boundary, assuming zero-flux BCs.
*/

load("fpo/fpo-utils");
load("modal-basis");
load("nodal_operations/nodal_functions")$
load("out-scripts");
load("recovery");

fpprec : 24$


generateFpoVlasovDragBoundarySurf(fname, funcNm, cdim, basisFun, polyOrder, pv) := block(
  [vdim, pdim, varsC, bC, varsP, bP, NC, dirNums, pvdir, fh, surfVars, bSurf, numSurf, 
  surfNodes, numNodes, drag_coeff_surf_Edge_e, drag_coeff_surf_Skin_e, fEdge_e, fSkin_e,
  fUp_R_e, GhatR_c, GhatR_e, incrR_c, fUp_L_e, Ghat_L_e, incrL_c],

  if (polyOrder = 1) then ( basisFun : "hyb" ),

  /* FPO is always 3V */
  vdim : 3,
  pdim : cdim+vdim,

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bP),

  dirNums : [[vx, 1], [vy, 2], [vz, 3]],
  pvdir : assoc(pv,dirNums),

  disp(printf(false, "creating ~a", fname)),
  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%"),

  /* Including proper quad to modal kernel for hybrid case (always a v direction) */
  if (polyOrder = 1) then (
    printf(fh, "#include <gkyl_basis_hyb_~ax3v_p~a_upwind_quad_to_modal.h> ~%",
      cdim, polyOrder),
    printf(fh, "~%~%")
  )
  else (
    printf(fh, "#include <gkyl_basis_~a_~ax_p~a_upwind_quad_to_modal.h> ~%",
      basisFun, pdim, polyOrder),
    printf(fh, "~%~%")
  ),

  surfVars : delete(pv, varsP),
  bSurf : basisFromVars(basisFun, surfVars, polyOrder),
  numSurf : length(bSurf),

  if (basisFun = "hyb") then (
    surfNodes : gaussOrdHyb(polyOrder+1, cdim, vdim-1)
  )
  else (
    surfNodes : gaussOrd(polyOrder+1, pdim-1)
  ),
  numNodes : length(surfNodes),

  printf(fh, "GKYL_CU_DH double ~a(const double* dxv,
  const double *alpha_surf_Edge, const double *alpha_surf_Skin,
  const double *sgn_alpha_surf_Edge, const double *sgn_alpha_surf_Skin,
  const int *const_sgn_alpha_Edge, const int *const_sgn_alpha_Skin,
  const int edge, const double *fEdge, const double *fSkin,
  double* GKYL_RESTRICT out) { ~%", funcNm),

  printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
  printf(fh, "  // alpha_surf_Edge,Skin: Surface expansion of drag coefficient on lower boundary of Skin/Edge cell. ~%"),
  printf(fh, "  // sgn_alpha_Edge,Skin: sign(alpha_surf_l,r) at quadrature points. ~%"),
  printf(fh, "  // const_sgn_alpha_Edge,Skin: Boolean array true if sign(alpha_surf_l,r) is only one sign. ~%"),
  printf(fh, "  // fEdge, fSkin: Distribution function in left, center, and right cells. ~%"),
  printf(fh, "  // out: Incremented output. ~%~%"),
  printf(fh, "~%"),
  printf(fh, "  // Index into drag coefficient surface expansion arrays ~%"),
  printf(fh, "  const double *drag_coeff_surf_Edge = &alpha_surf_Edge[~a]; ~%", (pvdir-1)*numSurf),
  printf(fh, "  const double *drag_coeff_surf_Skin = &alpha_surf_Skin[~a]; ~%", (pvdir-1)*numSurf),
  printf(fh, "  const double *sgn_drag_coeff_surf_Edge = &sgn_alpha_surf_Edge[~a]; ~%", (pvdir-1)*numNodes),
  printf(fh, "  const double *sgn_drag_coeff_surf_Skin = &sgn_alpha_surf_Skin[~a]; ~%", (pvdir-1)*numNodes),
  printf(fh, "  const int *const_sgn_drag_coeff_Edge = &const_sgn_alpha_Edge[~a]; ~%", pvdir-1),
  printf(fh, "  const int *const_sgn_drag_coeff_Skin = &const_sgn_alpha_Skin[~a]; ~%", pvdir-1),
  printf(fh, "  double dv_inv = 2.0/dxv[~a]; ~%", pvdir-1+cdim),
  printf(fh, "~%"),
  printf(fh, "  double cflFreq = 0.0; ~%"),
  printf(fh, "~%"),

  drag_coeff_surf_Edge_e : doExpand1(drag_coeff_surf_Edge, bSurf),
  drag_coeff_surf_Skin_e : doExpand1(drag_coeff_surf_Skin, bSurf),

  fEdge_e : doExpand1(fEdge, bP), 
  fSkin_e : doExpand1(fSkin, bP), 

  /* 
    If edge == -1, we are doing the left edge boundary and the skin cell needs to be 
    evaluated at +1 
  */
  printf(fh, "  if (edge == -1) { ~%"),
  /*
    +------+------+------+
    | ++++ | Skin | Edge |
    +------+------+------+
  */
  printf(fh, "  const double *drag_coeff_surf_R = drag_coeff_surf_Edge; ~%"),
  printf(fh, "  const double *sgn_drag_coeff_surf_R = sgn_drag_coeff_surf_Edge; ~%"),
  printf(fh, "  const int *const_sgn_drag_coeff_R = const_sgn_drag_coeff_Edge; ~%"),
  calcAndWrite_fUpwind(fh, pv, pdim, polyOrder, surfVars, bSurf, fSkin_e, fEdge_e, basisFun, "R"),
  
  fUp_R_e : doExpand1(fUp_R, bSurf),

  printf(fh, "  double GhatR[~a] = {0.0}; ~%", numSurf),
  GhatR_c : calcInnerProdList(surfVars, 1, bSurf, drag_coeff_surf_Edge_e*fUp_R_e),
  writeCExprsNoExpand1(GhatR, gcfac(float(expand(GhatR_c)))),
  printf(fh, "~%"),
  flush_output(fh),

  GhatR_e : doExpand1(GhatR, bSurf),

  incrR_c : calcInnerProdList(surfVars, -1.0, subst(pv=1.0, bP), GhatR_e),

  writeCIncrExprsCollect1(out, 0.5*dv_inv*incrR_c, [dv_inv]),
  printf(fh, "  cflFreq = fabs(drag_coeff_surf_Edge[0]);"),
  printf(fh, "~%"),

  /* 
    Otherwise edge == +1, we are doing the right edge boundary and the skin cell needs 
    to be evauluated at -1 
  */
  printf(fh, "~%  } else { ~%"),

  /*
    +------+------+------+
    | Edge | Skin | ++++ |
    +------+------+------+
  */  
  printf(fh, "  const double *drag_coeff_surf_L = drag_coeff_surf_Skin; ~%"),
  printf(fh, "  const double *sgn_drag_coeff_surf_L = sgn_drag_coeff_surf_Skin; ~%"),
  printf(fh, "  const int *const_sgn_drag_coeff_L = const_sgn_drag_coeff_Skin; ~%"),
  calcAndWrite_fUpwind(fh, pv, pdim, polyOrder, surfVars, bSurf, fEdge_e, fSkin_e, basisFun, "L"),

  fUp_L_e : doExpand1(fUp_L, bSurf),

  printf(fh, "  double GhatL[~a] = {0.0}; ~%", numSurf),
  GhatL_c : calcInnerProdList(surfVars, 1, bSurf, drag_coeff_surf_Skin_e*fUp_L_e),
  writeCExprsNoExpand1(GhatL, gcfac(float(expand(GhatL_c)))),
  printf(fh, "~%"),
  flush_output(fh),
  GhatL_e : doExpand1(GhatL, bSurf),

  incrL_c : calcInnerProdList(surfVars, 1.0, subst(pv=-1.0, bP), GhatL_e),
  writeCIncrExprsCollect1(out, 0.5*dv_inv*incrL_c, [dv_inv]),
  printf(fh, "  cflFreq = fabs(drag_coeff_surf_Skin[0]);"),
  printf(fh, "~%"),
  printf(fh, "~%"),

  printf(fh, "  } ~%~%"),

  /* 
      Write out CFL frequency.
      Drag term estimate: (2p+1)/dv * a_surf[0]/2^((pdim-1)/2)
  */
  if ( basisFun = "hyb" ) then ( pOrder : polyOrder + 1 )
  else ( pOrder : polyOrder ),
  printf(fh, "  return ~a*cflFreq; ~%", float(0.5*dv_inv*(2*pOrder+1)*2.0^(-0.5*(pdim-1)))),

  printf(fh, "}~%"),
  flush_output(fh),
  close(fh)

)$
