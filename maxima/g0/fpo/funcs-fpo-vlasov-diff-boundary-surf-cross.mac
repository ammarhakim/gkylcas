/*
  Generate kernels for the surface term for the off-diagonal diffusion 
  contribution for the Rosenbluth/Fokker-Planck Operator
  at a domain boundary.

  In 9 regions of the velocity space domain (in order of indexing, pv1 is x-axis):
  Domain volume
  Left edge
  Right edge
  Bottom edge
  Top edge
  Bottom left corner
  Top left corner
  Bottom right corner
  Top right corner
*/

load("modal-basis");
load("out-scripts");
load("recovery");
load("bvp_utilities/bvp-util");

fpprec : 24$

/* Upper diagonal terms, vxvy, vxvz, vyvz */
generateFpoVlasovDiffBoundarySurfCrossUpper(fname, funcNm, cdim, basisFun, polyOrder, dirCombo) := block(
  [vdim, dirNums, pvx, pvy, pvdir1, pvdir2, coordVarS, stencilLoc, varsC, bC, varsP, bP, NC, surfVars, 
  bSurf, numSurf, fh, stencilCells, DCL_lst, DCC_lst, DCR_lst, fTL_lst, fTC_lst, fTR_lst, fCL_lst, 
  fCC_lst, fCR_lst, fBL_lst, fBC_lst, fBR_lst, DCC_e, fCC_e, f_rec_lo_p, f_rec_up_p, df_rec_lo_e, df_rec_up_e, stencilStr, fnameStencil, D_rec_lo_p, D_rec_up_p, D_rec_lo_c, D_rec_up_c, 
  df_rec_lo_c, df_rec_up_c, surf_lo_c, surf_up_c, stencilCells1, stencilCells2,
  surf_lo_e, surf_up_e,  diff_coeff_index, kernel],

  pvx : dirCombo[1],
  pvy : dirCombo[2],

  /* FPO is always 3V */
  vdim : 3,
  pdim : vdim+cdim,
  dirNums : [[vx, 1], [vy, 2], [vz, 3]],
  pvdirx : assoc(pvx,dirNums),
  pvdiry : assoc(pvy,dirNums),

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bP),

  surfvarspvx : delete(pvx, varsP),
  bSurfpvx : basisFromVars(basisFun, surfvarspvx, polyOrder),
  numSurf : length(bSurfpvx),

  surfvarspvy : delete(pvy, varsP),
  bSurfpvy : basisFromVars(basisFun, surfvarspvy, polyOrder),

  /* Associative list between stencil location (-1,0,1) and variable strings in kernel name. */
  coordVarS : getCoordVarS([pvx, pvy]),

  /* List of stencil locations. Each entry is a dim-dimensional list
  with -1 meaning it is at a lower boundary, 1 upper boundary, or
  0 away from boundaries in that direction. */
  dim : 2,
  stencilLoc : getStencilCoords(dim),

  /* Ignore internal domain stencil, as that's handled separately */
  stencilLoc : delete([0,0], stencilLoc),

  /* Begin iteration over stencil locations */
  for sI : 1 thru length(stencilLoc) do (
    /* String used in kernel name to differentiate stencil locations */
    stencilStr : "",
    for d : 1 thru dim do (
      stencilStr : sconcat(stencilStr, "_", 
      assoc(stencilLoc[sI][d], [[-1, "lo"], [0, "in"], [1, "up"]]), string(dirCombo[d]))
    ),

    fnameStencil : sconcat(fname, stencilStr, ".c"),
    disp(printf(false, "Creating ~a", fnameStencil)),
    fh : openw(fnameStencil),
    printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%"),
    printf(fh, " ~%"),

    printf(fh, "GKYL_CU_DH double ~a~a(const double *dxv, const double *diff_coeff_C,
      const double *diff_coeff_surf_stencil[9], const double *f_stencil[9], double* GKYL_RESTRICT out) { ~%", funcNm, stencilStr),
    printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
    printf(fh, "  // diff_coeff_stencil[3]: 3-cell stencil of diffusion tensor. ~%"),
    printf(fh, "  // f_stencil[9]: 9-cell stencil of distribution function. ~%"), 
    printf(fh, "  // out: Incremented output. ~%~%"),
    printf(fh, "~%"),

    printf(fh, "  double dv1_sq = 4.0/dxv[~a]/dxv[~a]; ~%", pvdirx-1+cdim, pvdiry-1+cdim),
    printf(fh, " ~%"),
    printf(fh, "  double f_rec_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double f_rec_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double df_rec_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double df_rec_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft1_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft1_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft2_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft2_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double vol[~a] = {0.0}; ~%", NC),
    printf(fh, "~%"),

    stencilCells : getStencilCellsList(stencilLoc[sI]),
    stencilCells_D : [CC, CR, TC],

    /* Index into diffusion coefficient stencil, uses original pvx/pvy for correct indexing */
    diff_coeff_index_xy : 3*(pvdirx-1) + (pvdiry-1), 
    diff_coeff_index_yx : 3*(pvdiry-1) + (pvdirx-1),

    printf(fh, "  // Index into D and f stencils. ~%"),
    printf(fh, "  const double* DCC = &diff_coeff_C[~a]; ~%", diff_coeff_index_xy*NC),

    for i : 1 thru length(stencilCells) do (
      printf(fh, "  const double* f~a = f_stencil[~a]; ~%", stencilCells[i], i-1),

      if (stencilCells[i] = CC) then (
        printf(fh, "  const double* D_surf_CC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
          pvx, i-1, diff_coeff_index_xy*numSurf),
        printf(fh, "  const double* D_surf_CC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
          pvy, i-1, diff_coeff_index_yx*numSurf)
      )
      elseif (stencilCells[i] = CR) then (
        printf(fh, "  const double* D_surf_CR_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
          pvx, i-1, diff_coeff_index_xy*numSurf)
      )
      elseif (stencilCells[i] = TC) then (
        printf(fh, "  const double* D_surf_TC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
          pvy, i-1, diff_coeff_index_yx*numSurf)     
      )
    ),
    printf(fh, "~%"),

    /* Components of f */
    fTL_lst : makelist(fTL[i], i, 0, NC-1),
    fTC_lst : makelist(fTC[i], i, 0, NC-1),
    fTR_lst : makelist(fTR[i], i, 0, NC-1),
    fCL_lst : makelist(fCL[i], i, 0, NC-1),
    fCC_lst : makelist(fCC[i], i, 0, NC-1),
    fCR_lst : makelist(fCR[i], i, 0, NC-1),
    fBL_lst : makelist(fBL[i], i, 0, NC-1),
    fBC_lst : makelist(fBC[i], i, 0, NC-1),
    fBR_lst : makelist(fBR[i], i, 0, NC-1),
  
    /* Expansions of diffusion tensor and f in center cell */
    DCC_e : doExpand1(DCC, bP),
    fCC_e : doExpand1(fCC, bP),
  
    D_surf_CC_pvx_e : doExpand1(eval_string(sconcat("D_surf_CC_", pvx)), bSurfpvx), 
    D_surf_CC_pvy_e : doExpand1(eval_string(sconcat("D_surf_CC_", pvy)), bSurfpvy), 
    D_surf_TC_pvy_e : doExpand1(eval_string(sconcat("D_surf_TC_", pvy)), bSurfpvy),
    D_surf_CR_pvx_e : doExpand1(eval_string(sconcat("D_surf_CR_", pvx)), bSurfpvx),

    /* Expansions of recovered quantities and surface terms */
    f_rec_lo_e : doExpand1(f_rec_lo, bSurfpvy),
    f_rec_up_e : doExpand1(f_rec_up, bSurfpvy),
  
    df_rec_lo_e : doExpand1(df_rec_lo, bSurfpvx),
    df_rec_up_e : doExpand1(df_rec_up, bSurfpvx),

    surft1_lo_e : doExpand1(surft1_lo, bSurfpvx),
    surft1_up_e : doExpand1(surft1_up, bSurfpvx),
  
    surft2_lo_e : doExpand1(surft2_lo, bSurfpvy),
    surft2_up_e : doExpand1(surft2_up, bSurfpvy),

    vol_lst : makelist(vol[i], i, 0, NC-1),

    if (stencilLoc[sI] = [-1, 0]) then ( 
      /*
        Left
        +----+----+----+
        | ++ | TC | TR |
        +----+----+----+
        | ++ | CC | CR |
        +----+----+----+
        | ++ | BC | BR |
        +----+----+----+
      */

      /* 2- and 6-cell recoveries of f */
      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, dg(fBC_lst), dg(fCC_lst)),
      f_rec2_up_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, dg(fCC_lst), dg(fTC_lst)),

      f_rec6_lo_p : 0,
      f_rec6_up_p : calcRecovFaceGen(basisFun, [pvx, pvy], varsP, 0, 0, polyOrder, 0,
        dg(dg(fBC_lst), dg(fBR_lst)), dg(dg(fCC_lst), dg(fCR_lst)), dg(dg(fTC_lst), dg(fTR_lst))),

      /* Write out recovered quantities */
      f_rec_lo_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_lo_p)),
      f_rec_up_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_up_p)),

      df_rec_lo_c : makelist(0, i, 0, numSurf-1),
      df_rec_up_c : calcInnerProdList(surfvarspvx, 1, bSurfpvx, 
        subst(pvx=0.0, diff(f_rec6_up_p, pvy))),

      /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : makelist(0, i, 0, numSurf-1),
      surft1_up_c : calcInnerProdList(surfvarspvx, D_surf_CR_pvx_e, bSurfpvx, df_rec_up_e),

    
      /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
      surft2_lo_c : calcInnerProdList(surfvarspvy, D_surf_CC_pvy_e, bSurfpvy, f_rec_lo_e),
      surft2_up_c : calcInnerProdList(surfvarspvy, D_surf_TC_pvy_e, bSurfpvy, f_rec_up_e)

    )
    elseif (stencilLoc[sI] = [1, 0]) then (    
      /* 
        Right
        +----+----+----+
        | TL | TC | ++ |
        +----+----+----+
        | CL | CC | ++ |
        +----+----+----+
        | BL | BC | ++ |
        +----+----+----+
      */

      /* 2- and 6-cell recoveries of f */
      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, dg(fBC_lst), dg(fCC_lst)),
      f_rec2_up_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, dg(fCC_lst), dg(fTC_lst)),
    
      f_rec6_lo_p : calcRecovFaceGen(basisFun, [pvx, pvy], varsP, 0, 0, polyOrder, 0,
        dg(dg(fBL_lst), dg(fBC_lst)), dg(dg(fCL_lst), dg(fCC_lst)), dg(dg(fTL_lst), dg(fTC_lst))),
      f_rec6_up_p : makelist(0, i, 0, numSurf-1), 
  
      /* Write out recovered quantities */
      f_rec_lo_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_lo_p)),
      f_rec_up_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_up_p)),
  
      df_rec_lo_c : calcInnerProdList(surfvarspvx, 1, bSurfpvx, 
        subst(pvx=0.0, diff(f_rec6_lo_p, pvy))),
      df_rec_up_c : makelist(0, i, 0, numSurf-1),
  
      /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : calcInnerProdList(surfvarspvx, D_surf_CC_pvx_e, bSurfpvx, df_rec_lo_e),
      surft1_up_c : makelist(0, i, 0, numSurf-1),
  
      /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
      surft2_lo_c : calcInnerProdList(surfvarspvy, D_surf_CC_pvy_e, bSurfpvy, f_rec_lo_e),
      surft2_up_c : calcInnerProdList(surfvarspvy, D_surf_TC_pvy_e, bSurfpvy, f_rec_up_e)

    )
    elseif (stencilLoc[sI] = [0, 1] or stencilLoc[sI] = [0, -1]) then (
      /*
        [0, 1]
        Top
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
        | CL | CC | CR |
        +----+----+----+
        | BL | BC | BR |
        +----+----+----+

        [0, -1]
        Bottom
        +----+----+----+
        | TL | TC | TR |
        +----+----+----+
        | CL | CC | CR |
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
      */
      /* 2-cell recovery for flux term */
      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, dg(fBC_lst), dg(fCC_lst)),
      f_rec2_up_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, dg(fCC_lst), dg(fTC_lst)),

      f_rec2_pvx_lo_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
      f_rec2_pvx_up_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),

      df_rec_lo_c : calcInnerProdList(surfvarspvx, 1, bSurfpvx, 
        subst(pvx=0.0, diff(f_rec2_pvx_lo_p, pvy))),
      df_rec_up_c : calcInnerProdList(surfvarspvx, 1, bSurfpvx, 
        subst(pvx=0.0, diff(f_rec2_pvx_up_p, pvy))),

      /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : calcInnerProdList(surfvarspvx, D_surf_CC_pvx_e, bSurfpvx, df_rec_lo_e),
      surft1_up_c : calcInnerProdList(surfvarspvx, D_surf_CR_pvx_e, bSurfpvx, df_rec_up_e),

      /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
      if (stencilLoc[sI] = [0, -1]) then (
        f_rec_lo_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=-1, fCC_e)),
        f_rec_up_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_up_p)),

        surft2_lo_c : calcInnerProdList(surfvarspvy, subst(pvy=-1, DCC_e), 
          bSurfpvy, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfvarspvy, D_surf_TC_pvy_e, bSurfpvy, f_rec_up_e)
      ) else (
        f_rec_lo_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_lo_p)),
        f_rec_up_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=1, fCC_e)),

        surft2_lo_c : calcInnerProdList(surfvarspvy, D_surf_CC_pvy_e, bSurfpvy, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfvarspvy, subst(pvy=1, DCC_e), 
          bSurfpvy, f_rec_up_e)
      )

    )
    elseif (stencilLoc[sI] = [-1, -1] or stencilLoc[sI] = [-1, 1]) then (
      /*
        [-1, -1]
        Bottom Left Corner
        +----+----+----+
        | ++ | TC | TR |
        +----+----+----+
        | ++ | CC | CR |
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+


        [-1, 1]
        Top Left Corner
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
        | ++ | CC | CR |
        +----+----+----+
        | ++ | BC | BR |
        +----+----+----+
      */

      /* 2-cell recovery for flux term */
      f_rec2_pvx_lo_p : 0, 
      f_rec2_pvx_up_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),

      df_rec_lo_c : makelist(0, i, 0, numSurf-1),
      df_rec_up_c : calcInnerProdList(surfvarspvx, 1, bSurfpvx, 
        subst(pvx=0.0, diff(f_rec2_pvx_up_p, pvy))),

      /* surf = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : makelist(0, i, 0, numSurf-1),
      surft1_up_c : calcInnerProdList(surfvarspvx, D_surf_CR_pvx_e, bSurfpvx, df_rec_up_e),

      /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
      if (stencilLoc[sI] = [-1, -1]) then (
        f_rec2_lo_p : subst(pvy=-1, fCC_e),
        f_rec2_up_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, 
          dg(fCC_lst), dg(fTC_lst)),

        surft2_lo_c : calcInnerProdList(surfvarspvy, subst(pvy=-1, DCC_e), 
          bSurfpvy, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfvarspvy, D_surf_TC_pvy_e, bSurfpvy, f_rec_up_e)

      ) else (
        f_rec2_lo_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, 
          dg(fBC_lst), dg(fCC_lst)),
        f_rec2_up_p : subst(pvy=1, fCC_e),

        surft2_lo_c : calcInnerProdList(surfvarspvy, D_surf_CC_pvy_e, bSurfpvy, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfvarspvy, subst(pvy=1, DCC_e), 
          bSurfpvy, f_rec_up_e)
      ),

      f_rec_lo_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_lo_p)),
      f_rec_up_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_up_p))

    )
    elseif (stencilLoc[sI] = [1, -1] or stencilLoc[sI] = [1, 1]) then (
      /*
        [1, -1]
        Bottom Right Corner
        +----+----+----+
        | TL | TC | ++ |
        +----+----+----+
        | CL | CC | ++ |
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+

        [1, 1]
        Top Right Corner
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
        | CL | CC | ++ |
        +----+----+----+
        | BL | BC | ++ |
        +----+----+----+
      */

      /* 2-cell recovery for flux term */
      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
      f_rec2_up_p : 0,

      df_rec_lo_c : calcInnerProdList(surfvarspvx, 1, bSurfpvx, 
        subst(pvx=0.0, diff(f_rec2_lo_p, pvy))),
      df_rec_up_c : makelist(0, i, 0, numSurf-1),

      /* surf = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : calcInnerProdList(surfvarspvx, D_surf_CC_pvx_e, bSurfpvx, df_rec_lo_e),
      surft1_up_c : makelist(0, i, 0, numSurf-1),

      /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
      if (stencilLoc[sI] = [1, -1]) then (
        f_rec2_lo_p : subst(pvy=-1, fCC_e),
        f_rec2_up_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, 
          dg(fCC_lst), dg(fTC_lst)),

        surft2_lo_c : calcInnerProdList(surfvarspvy, subst(pvy=-1, DCC_e), 
          bSurfpvy, subst(pvy=-1, fCC_e)),
        surft2_up_c : calcInnerProdList(surfvarspvy, D_surf_TC_pvy_e, bSurfpvy, f_rec_up_e)

      ) else (
        f_rec2_lo_p : subst(pvy=1, fCC_e),
        f_rec2_lo_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, 
          dg(fBC_lst), dg(fCC_lst)),

        surft2_lo_c : calcInnerProdList(surfvarspvy, D_surf_CC_pvy_e, bSurfpvy, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfvarspvy, subst(pvy=1, DCC_e), 
          bSurfpvy, subst(pvy=1, fCC_e))
      ),

      f_rec_lo_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_lo_p)),
      f_rec_up_c : calcInnerProdList(surfvarspvy, 1, bSurfpvy, subst(pvy=0, f_rec2_up_p))

    ),

    /* vol = 1/2 * < d/dvj (Dij * d/dvi(psi)) * f > */
    vol_c : calcInnerProdList(varsP, 1, diff(DCC_e * diff(bP, pvy), pvx), fCC_e),

    kernel : calcInnerProdList(surfvarspvx, 1, subst(pvx=1, bP), surft1_up_e) +
      calcInnerProdList(surfvarspvx, -1, subst(pvx=-1, bP), surft1_lo_e) +
      calcInnerProdList(surfvarspvy, -1, subst(pvy=1, diff(bP, pvx)), surft2_up_e) +
      calcInnerProdList(surfvarspvy, 1, subst(pvy=-1, diff(bP, pvx)), surft2_lo_e) +
      vol_lst,

    /* Write out recovered quantities */
    writeCExprs1(f_rec_lo, f_rec_lo_c),
    writeCExprs1(f_rec_up, f_rec_up_c),
    printf(fh, "~%"),
    flush_output(fh),
  
    writeCExprs1(df_rec_lo, df_rec_lo_c),
    writeCExprs1(df_rec_up, df_rec_up_c),
    printf(fh, "~%"),
    flush_output(fh),

    /* Write out individual surface term expansions */
    writeCExprs1(surft1_lo, surft1_lo_c),
    writeCExprs1(surft1_up, surft1_up_c),
    printf(fh, "~%"),
    flush_output(fh),
  
    writeCExprs1(surft2_lo, surft2_lo_c),
    writeCExprs1(surft2_up, surft2_up_c),
    printf(fh, "~%"),
    flush_output(fh),
  
    writeCExprs1(vol, vol_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCIncrExprsCollect1lhsc(out, 0.5*dv1_sq*kernel),

    /* No CFL contribution from cross terms? */
    printf(fh, "~%"),
    printf(fh, "  return 0.0; ~%"),
    printf(fh, "} ~%"),
    close(fh)
  )
)$

/* Lower diagonal terms, vyvx, vzvx, vzvy */
generateFpoVlasovDiffBoundarySurfCrossLower(fname, funcNm, cdim, basisFun, polyOrder, dirCombo) := block(
  [vdim, dirNums, pvy, pvx, pvdir1, pvdir2, coordVarS, stencilLoc, varsC, bC, varsP, bP, NC, surfVars, 
  bSurf, numSurf, fh, stencilCells, DCL_lst, DCC_lst, DCR_lst, fTL_lst, fTC_lst, fTR_lst, fCL_lst, 
  fCC_lst, fCR_lst, fBL_lst, fBC_lst, fBR_lst, DCC_e, fCC_e, f_rec_lo_p, f_rec_up_p, df_rec_lo_e, df_rec_up_e, stencilStr, fnameStencil, D_rec_lo_p, D_rec_up_p, D_rec_lo_c, D_rec_up_c, 
  df_rec_lo_c, df_rec_up_c, surf_lo_c, surf_up_c, stencilCells1, stencilCells2,
  surf_lo_e, surf_up_e,  diff_coeff_index, kernel],

  pvy : dirCombo[1],
  pvx : dirCombo[2],
  
  /* FPO is always 3V */
  vdim : 3,
  pdim : vdim+cdim,
  dirNums : [[vx, 1], [vy, 2], [vz, 3]],
  pvdiry : assoc(pvy,dirNums),
  pvdirx : assoc(pvx,dirNums),

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bP),

  surfVarspvx : delete(pvx, varsP),
  bSurfpvx : basisFromVars(basisFun, surfVarspvx, polyOrder),

  surfVarspvy : delete(pvy, varsP),
  bSurfpvy : basisFromVars(basisFun, surfVarspvy, polyOrder),
  numSurf : length(bSurfpvy),

  /* Associative list between stencil location (-1,0,1) and variable strings in kernel name. */
  coordVarS : getCoordVarS([pvy, pvx]),

  /* List of stencil locations. Each entry is a dim-dimensional list
  with -1 meaning it is at a lower boundary, 1 upper boundary, or
  0 away from boundaries in that direction. */
  dim : 2,
  stencilLoc : getStencilCoords(dim),

  /* Ignore internal domain stencil, as that's handled separately */
  stencilLoc : delete([0,0], stencilLoc),

  /* Begin iteration over stencil locations */
  for sI : 1 thru length(stencilLoc) do (
    /* String used in kernel name to differentiate stencil locations */
    stencilStr : "",
    for d : 1 thru dim do (
      stencilStr : sconcat(stencilStr, "_", 
      assoc(stencilLoc[sI][d], [[-1, "lo"], [0, "in"], [1, "up"]]), string(dirCombo[d]))
    ),

    fnameStencil : sconcat(fname, stencilStr, ".c"),
    disp(printf(false, "Creating ~a", fnameStencil)),
    fh : openw(fnameStencil),
    printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%"),
    printf(fh, " ~%"),

    printf(fh, "GKYL_CU_DH double ~a~a(const double *dxv, const double *diff_coeff_C,
      const double *diff_coeff_surf_stencil[9], const double *f_stencil[9], double* GKYL_RESTRICT out) { ~%", funcNm, stencilStr),
    printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
    printf(fh, "  // diff_coeff_stencil[3]: 3-cell stencil of diffusion tensor. ~%"),
    printf(fh, "  // f_stencil[9]: 9-cell stencil of distribution function. ~%"), 
    printf(fh, "  // out: Incremented output. ~%~%"),
    printf(fh, "~%"),

    printf(fh, "  double dv1_sq = 4.0/dxv[~a]/dxv[~a]; ~%", pvdiry-1+cdim, pvdirx-1+cdim),
    printf(fh, " ~%"),
    printf(fh, "  double f_rec_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double f_rec_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double df_rec_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double df_rec_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft1_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft1_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft2_lo[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double surft2_up[~a] = {0.0}; ~%", numSurf),
    printf(fh, "  double vol[~a] = {0.0}; ~%", NC),
    printf(fh, "~%"),

    stencilCells : getStencilCellsList(stencilLoc[sI]),
    stencilCells_D : [CC, CR, TC],

    diff_coeff_index_xy : 3*(pvdirx-1) + (pvdiry-1), 
    diff_coeff_index_yx : 3*(pvdiry-1) + (pvdirx-1),

    printf(fh, "  // Index into D and f stencils. ~%"),
    printf(fh, "  const double* DCC = &diff_coeff_C[~a]; ~%", diff_coeff_index_yx*NC),

    for i : 1 thru length(stencilCells) do (
      printf(fh, "  const double* f~a = f_stencil[~a]; ~%", stencilCells[i], i-1),

      if (stencilCells[i] = CC) then (
        printf(fh, "  const double* D_surf_CC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
          pvx, i-1, diff_coeff_index_xy*numSurf),
        printf(fh, "  const double* D_surf_CC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
          pvy, i-1, diff_coeff_index_yx*numSurf)
      )
      elseif (stencilCells[i] = CR) then (
        printf(fh, "  const double* D_surf_CR_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
          pvx, i-1, diff_coeff_index_xy*numSurf)
      )
      elseif (stencilCells[i] = TC) then (
        printf(fh, "  const double* D_surf_TC_~a = &diff_coeff_surf_stencil[~a][~a]; ~%", 
          pvy, i-1, diff_coeff_index_yx*numSurf)     
      )
    ),
    printf(fh, "~%"),

    /* Components of f */
    fTL_lst : makelist(fTL[i], i, 0, NC-1),
    fTC_lst : makelist(fTC[i], i, 0, NC-1),
    fTR_lst : makelist(fTR[i], i, 0, NC-1),
    fCL_lst : makelist(fCL[i], i, 0, NC-1),
    fCC_lst : makelist(fCC[i], i, 0, NC-1),
    fCR_lst : makelist(fCR[i], i, 0, NC-1),
    fBL_lst : makelist(fBL[i], i, 0, NC-1),
    fBC_lst : makelist(fBC[i], i, 0, NC-1),
    fBR_lst : makelist(fBR[i], i, 0, NC-1),
  
    /* Expansions of diffusion tensor and f in center cell */
    DCC_e : doExpand1(DCC, bP),
    fCC_e : doExpand1(fCC, bP), 

    D_surf_CC_pvx_e : doExpand1(eval_string(sconcat("D_surf_CC_", pvx)), bSurfpvx), 
    D_surf_CC_pvy_e : doExpand1(eval_string(sconcat("D_surf_CC_", pvy)), bSurfpvy), 
    D_surf_TC_pvy_e : doExpand1(eval_string(sconcat("D_surf_TC_", pvy)), bSurfpvy),
    D_surf_CR_pvx_e : doExpand1(eval_string(sconcat("D_surf_CR_", pvx)), bSurfpvx),

    /* Expansions of recovered quantities and surface terms */
    f_rec_lo_e : doExpand1(f_rec_lo, bSurfpvx),
    f_rec_up_e : doExpand1(f_rec_up, bSurfpvx),
   
    df_rec_lo_e : doExpand1(df_rec_lo, bSurfpvy),
    df_rec_up_e : doExpand1(df_rec_up, bSurfpvy),

    surft1_lo_e : doExpand1(surft1_lo, bSurfpvy),
    surft1_up_e : doExpand1(surft1_up, bSurfpvy),
  
    surft2_lo_e : doExpand1(surft2_lo, bSurfpvx),
    surft2_up_e : doExpand1(surft2_up, bSurfpvx),

    vol_lst : makelist(vol[i], i, 0, NC-1),

    if (stencilLoc[sI] = [0, -1]) then ( 
      /* 
        Bottom
        +----+----+----+
        | TL | TC | TR |
        +----+----+----+
        | CL | CC | CR |
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
      */

      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
      f_rec2_up_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),

      f_rec6_lo_p : 0,
      f_rec6_up_p : calcRecovFaceGen(basisFun, [pvy, pvx], varsP, 0, 0, polyOrder, 0,
        dg(dg(fCL_lst), dg(fTL_lst)), dg(dg(fCC_lst), dg(fTC_lst)), 
        dg(dg(fCR_lst), dg(fTR_lst))),

      /* Write out recovered quatities */
      f_rec_lo_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_lo_p)),
      f_rec_up_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_up_p)),

      df_rec_lo_c : makelist(0, i, 0, numSurf-1),
      df_rec_up_c : calcInnerProdList(surfVarspvy, 1, bSurfpvy, 
        subst(pvy=0.0, diff(f_rec6_up_p, pvx))),

      /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : makelist(0, i, 0, numSurf-1), 
      surft1_up_c : calcInnerProdList(surfVarspvy, D_surf_TC_pvy_e, bSurfpvy, df_rec_up_e),
  
      /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
      surft2_lo_c : calcInnerProdList(surfVarspvx, D_surf_CC_pvx_e, bSurfpvx, f_rec_lo_e),
      surft2_up_c : calcInnerProdList(surfVarspvx, D_surf_CR_pvx_e, bSurfpvx, f_rec_up_e)
    )
    elseif (stencilLoc[sI] = [0, 1]) then (    
      /*
        Top
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
        | CL | CC | CR |
        +----+----+----+
        | BL | BC | BR |
        +----+----+----+
      */

      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
      f_rec2_up_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),

      f_rec6_lo_p : calcRecovFaceGen(basisFun, [pvy, pvx], varsP, 0, 0, polyOrder, 0,
        dg(dg(fBL_lst), dg(fCL_lst)), dg(dg(fBC_lst), dg(fCC_lst)), 
        dg(dg(fBR_lst), dg(fCR_lst))),
      f_rec6_up_p : 0,

      /* Write out recovered quatities */
      f_rec_lo_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_lo_p)),
      f_rec_up_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_up_p)),

      df_rec_lo_c : calcInnerProdList(surfVarspvy, 1, bSurfpvy, 
        subst(pvy=0.0, diff(f_rec6_lo_p, pvx))),
      df_rec_up_c : makelist(0, i, 0, numSurf-1),

      /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : calcInnerProdList(surfVarspvy, D_surf_CC_pvy_e, bSurfpvy, df_rec_lo_e),
      surft1_up_c : makelist(0, i, 0, numSurf-1),

      /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
      surft2_lo_c : calcInnerProdList(surfVarspvx, D_surf_CC_pvx_e, bSurfpvx, f_rec_lo_e),
      surft2_up_c : calcInnerProdList(surfVarspvx, D_surf_CR_pvx_e, bSurfpvx, f_rec_up_e)
    )
    elseif (stencilLoc[sI] = [-1, 0] or stencilLoc[sI] = [1, 0]) then (
      /*
        Left
        +----+----+----+
        | ++ | TC | TR |
        +----+----+----+
        | ++ | CC | CR |
        +----+----+----+
        | ++ | BC | BR |
        +----+----+----+

        Right
        +----+----+----+
        | TL | TC | ++ |
        +----+----+----+
        | CL | CC | ++ |
        +----+----+----+
        | BL | BC | ++ |
        +----+----+----+
      */

      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
      f_rec2_up_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),

      f_rec2_pvy_lo_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, 
        dg(fBC_lst), dg(fCC_lst)),
      f_rec2_pvy_up_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, 
        dg(fCC_lst), dg(fTC_lst)),

      df_rec_lo_c : calcInnerProdList(surfVarspvy, 1, bSurfpvy, 
        subst(pvy=0.0, diff(f_rec2_pvy_lo_p, pvx))),
      df_rec_up_c : calcInnerProdList(surfVarspvy, 1, bSurfpvy, 
        subst(pvy=0.0, diff(f_rec2_pvy_up_p, pvx))),

      /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : calcInnerProdList(surfVarspvy, D_surf_CC_pvy_e, bSurfpvy, df_rec_lo_e),
      surft1_up_c : calcInnerProdList(surfVarspvy, D_surf_TC_pvy_e, bSurfpvy, df_rec_up_e),

      if (stencilLoc[sI] = [-1, 0]) then (
        f_rec_lo_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=-1, fCC_e)),
        f_rec_up_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_up_p)), 

        /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
        surft2_lo_c : calcInnerProdList(surfVarspvx, subst(pvx=-1, DCC_e), bSurfpvx, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfVarspvx, D_surf_CR_pvx_e, bSurfpvx, f_rec_up_e)
      )
      else (
        f_rec_lo_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_lo_p)),
        f_rec_up_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=1, fCC_e)),

        /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
        surft2_lo_c : calcInnerProdList(surfVarspvx, D_surf_CC_pvx_e, bSurfpvx, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfVarspvx, subst(pvx=1, DCC_e), bSurfpvx, f_rec_up_e)
      )
    )
    elseif (stencilLoc[sI] = [-1, -1] or stencilLoc[sI] = [1, -1]) then (
      /*
        [-1, -1]
        Bottom Left Corner
        +----+----+----+
        | ++ | TC | TR |
        +----+----+----+
        | ++ | CC | CR |
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+

        [1, -1]
        Bottom Right Corner
        +----+----+----+
        | TL | TC | ++ |
        +----+----+----+
        | CL | CC | ++ |
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
      */

      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
      f_rec2_up_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),

      f_rec2_pvy_lo_p : 0,
      f_rec2_pvy_up_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, 
        dg(fCC_lst), dg(fTC_lst)),

      df_rec_lo_c : makelist(0, i, 0, numSurf-1),
      df_rec_up_c : calcInnerProdList(surfVarspvy, 1, bSurfpvy, 
        subst(pvy=0.0, diff(f_rec2_pvy_up_p, pvx))),

      /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : makelist(0, i, 0, numSurf-1), 
      surft1_up_c : calcInnerProdList(surfVarspvy, D_surf_TC_pvy_e, bSurfpvy, df_rec_up_e),

      if (stencilLoc[sI] = [-1, -1]) then (
        f_rec_lo_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=-1, fCC_e)),
        f_rec_up_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_up_p)), 

        /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
        surft2_lo_c : calcInnerProdList(surfVarspvx, subst(pvx=-1, DCC_e), bSurfpvx, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfVarspvx, D_surf_CR_pvx_e, bSurfpvx, f_rec_up_e)
      )
      else (
        f_rec_lo_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_lo_p)),
        f_rec_up_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=1, fCC_e)),

        /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
        surft2_lo_c : calcInnerProdList(surfVarspvx, D_surf_CC_pvx_e, bSurfpvx, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfVarspvx, subst(pvx=1, DCC_e), bSurfpvx, f_rec_up_e)
      )
    )
    elseif (stencilLoc[sI] = [-1, 1] or stencilLoc[sI] = [1, 1]) then (
      /*
        [-1, 1]
        Top Left Corner
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
        | ++ | CC | CR |
        +----+----+----+
        | ++ | BC | BR |
        +----+----+----+

        [1, 1]
        Top Right Corner
        +----+----+----+
        | ++ | ++ | ++ |
        +----+----+----+
        | CL | CC | ++ |
        +----+----+----+
        | BL | BC | ++ |
        +----+----+----+
      */

      f_rec2_lo_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCL_lst), dg(fCC_lst)),
      f_rec2_up_p : calcRecov2CellGen(basisFun, pvx, varsP, polyOrder, dg(fCC_lst), dg(fCR_lst)),

      f_rec2_pvy_lo_p : calcRecov2CellGen(basisFun, pvy, varsP, polyOrder, 
        dg(fBC_lst), dg(fCC_lst)),
      f_rec2_pvy_up_p : 0,

      df_rec_lo_c : calcInnerProdList(surfVarspvy, 1, bSurfpvy, 
        subst(pvy=0.0, diff(f_rec2_pvy_lo_p, pvx))),
      df_rec_up_c : makelist(0, i, 0, numSurf-1),

      /* surft1 = 1/2 * < psi- * Dij * d/dvj(f_rec) > */
      surft1_lo_c : calcInnerProdList(surfVarspvy, D_surf_CC_pvy_e, bSurfpvy, df_rec_lo_e),
      surft1_up_c : makelist(0, i, 0, numSurf-1),

      if (stencilLoc[sI] = [-1, 1]) then (
        f_rec_lo_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=-1, fCC_e)),
        f_rec_up_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_up_p)), 

        /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
        surft2_lo_c : calcInnerProdList(surfVarspvx, subst(pvx=-1, DCC_e), bSurfpvx, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfVarspvx, D_surf_CR_pvx_e, bSurfpvx, f_rec_up_e)
      )
      else (
        f_rec_lo_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=0, f_rec2_lo_p)),
        f_rec_up_c : calcInnerProdList(surfVarspvx, 1, bSurfpvx, subst(pvx=1, fCC_e)),

        /* surft2 = -1/2 * < d/dpvy (psi-) * Dij * f_rec > */
        surft2_lo_c : calcInnerProdList(surfVarspvx, D_surf_CC_pvx_e, bSurfpvx, f_rec_lo_e),
        surft2_up_c : calcInnerProdList(surfVarspvx, subst(pvx=1, DCC_e), bSurfpvx, f_rec_up_e)
      )

    ),

    kernel : calcInnerProdList(surfVarspvy, 1, subst(pvy=1, bP), surft1_up_e) +
      calcInnerProdList(surfVarspvy, -1, subst(pvy=-1, bP), surft1_lo_e) +
      calcInnerProdList(surfVarspvx, -1, subst(pvx=1, diff(bP, pvy)), surft2_up_e) +
      calcInnerProdList(surfVarspvx, 1, subst(pvx=-1, diff(bP, pvy)), surft2_lo_e) +
      vol_lst,

    /* vol = 1/2 * < d/dvj (Dij * d/dvi(psi)) * f > */
    vol_c : calcInnerProdList(varsP, 1, diff(DCC_e * diff(bP, pvx), pvy), fCC_e),

    /* Write out recovered quantities */
    writeCExprs1(f_rec_lo, f_rec_lo_c),
    writeCExprs1(f_rec_up, f_rec_up_c),
    printf(fh, "~%"),
    flush_output(fh),
  
    writeCExprs1(df_rec_lo, df_rec_lo_c),
    writeCExprs1(df_rec_up, df_rec_up_c),
    printf(fh, "~%"),
    flush_output(fh),

    /* Write out individual surface term expansions */
    writeCExprs1(surft1_lo, surft1_lo_c),
    writeCExprs1(surft1_up, surft1_up_c),
    printf(fh, "~%"),
    flush_output(fh),
  
    writeCExprs1(surft2_lo, surft2_lo_c),
    writeCExprs1(surft2_up, surft2_up_c),
    printf(fh, "~%"),
    flush_output(fh),
  
    writeCExprs1(vol, vol_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCIncrExprsCollect1lhsc(out, 0.5*dv1_sq*kernel),

    /* No CFL contribution from cross terms? */
    printf(fh, "~%"),
    printf(fh, "  return 0.0; ~%"),
    printf(fh, "} ~%"),
    close(fh)
  )
)$
