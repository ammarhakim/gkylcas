/* 
  Generate kernels for the surface term 
  drag contribution for the Rosenbluth/Fokker-Planck Operator

*/

load("modal-basis")$
load("nodal_operations/nodal_functions")$
load("out-scripts")$
load("recovery")$
load("utilities")$

generateFpoVlasovDragSurf(fname, funcNm, cdim, basisFun, polyOrder, pv) := block(
  [],

  /* FPO is always 3V */
  vdim : 3,
  pdim : cdim+vdim,

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bP),

  dirNums : [[vx, cdim+1], [vy, cdim+2], [vz,cdim+3]],
  pvdir : assoc(pv,dirNums),

  /* Phase space variable for direction */
  surfVars : delete(pv, varsP),
  bSurf : basisFromVars(basisFun, surfVars, polyOrder),
  numSurf : length(bSurf),

  disp(printf(false, "creating ~a", fname)),
  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_surfx~a_eval_quad.h> ~%", bName[bInd], pdim, polyOrder, pvdir),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_upwind_quad_to_modal.h> ~%~%", bName[bInd], pdim, polyOrder),
  printf(fh, "GKYL_CU_DH void ~a(const double* dxv, const double* drag_coeff_stencil[9], const double* f_stencil[9], double* GKYL_RESTRICT out) { ~%", funcNm),

  printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
  printf(fh, "  // drag_coeff: Drag coefficient. ~%"),
  printf(fh, "  // f: Distribution function. ~%"),
  printf(fh, "  // out: Incremented output. ~%~%"),

  printf(fh, "~%"),
  printf(fh, "  const double* fL = f_stencil[0]; ~%"),
  printf(fh, "  const double* fC = f_stencil[1]; ~%"),
  printf(fh, "  const double* fR = f_stencil[2]; ~%"),

  printf(fh, "~%"),
  printf(fh, "  const double* aL = &drag_coeff_stencil[0][~a]; ~%", (pvdir-1-cdim)*NC),
  printf(fh, "  const double* aC = &drag_coeff_stencil[1][~a]; ~%", (pvdir-1-cdim)*NC),
  printf(fh, "  const double* aR = &drag_coeff_stencil[2][~a]; ~%", (pvdir-1-cdim)*NC),

  printf(fh, "  double dv1 = 2.0/dxv[~a]; ~%~%", pvdir-1),

  /* Drag coefficient in direction stencil */
  aL_lst : makelist(aL[i], i, 0, NC-1),
  aC_lst : makelist(aC[i], i, 0, NC-1),
  aR_lst : makelist(aR[i], i, 0, NC-1),

  /* Distribution function stencil */
  fL_lst : makelist(fL[i], i, 0, NC-1),
  fC_lst : makelist(fC[i], i, 0, NC-1),
  fR_lst : makelist(fR[i], i, 0, NC-1),

  /* Recover continuous drag coefficient at lower/upper cell boundary */
  a_rec_lo : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, dg(aL_lst), dg(aC_lst)),
  a_rec_up : calcRecov2CellGen(basisFun, pv, varsP, polyOrder, dg(aC_lst), dg(aR_lst)),

  /* Evaluate alphaDrag onto surface basis */
  alphaDragSurf_lo_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, a_rec_lo)), 
  alphaDragSurf_up_c : calcInnerProdList(surfVars, 1, bSurf, subst(pv=0, a_rec_up)),
  alst_lo : doMakeExprLst(alphaDragSurf_lo_c, alphaDragSurf_lo),
  alst_up : doMakeExprLst(alphaDragSurf_up_c, alphaDragSurf_up),
  alphaDragSurf_lo_e : doExpand(alst_lo, bSurf),
  alphaDragSurf_up_e : doExpand(alst_up, bSurf),
  printf(fh, "  double alphaDragSurf_lo[~a] = {0.0}; ~%", numSurf),
  writeCExprs1(alphaDragSurf_lo, alphaDragSurf_lo_c),
  printf(fh, "~%"),
  printf(fh, "  double alphaDragSurf_up[~a] = {0.0}; ~%", numSurf),
  writeCExprs1(alphaDragSurf_up, alphaDragSurf_up_c),
  printf(fh, "~%"),

  /* Initialize Gauss=Legendre quadrature for upwinding */
  surfNodes : gaussOrd(polyOrder+1, pdim-1),
  numNodes : length(surfNodes),

  /* Evaluate alpha at ordinates */
  alphaOrd_lo_n : gcfac(float(evAtNodes(alphaDragSurf_lo_e, surfNodes, surfVars))),
  alphaOrd_up_n : gcfac(float(evAtNodes(alphaDragSurf_up_e, surfNodes, surfVars))),

  printf(fh, "  double fUpwindQuad_lo[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwindQuad_up[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind_lo[~a] = {0.0};~%", length(bSurf)),
  printf(fh, "  double fUpwind_up[~a] = {0.0};~%", length(bSurf)),
  printf(fh, "  double Ghat_lo[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double Ghat_up[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "~%"),

  for i : 1 thru numNodes do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_lo_n[i]),
    printf(fh, "    fUpwindQuad_lo[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(fL); ~%", i-1, sdowncase(basisFun), pdim, polyOrder, pvdir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpwindQuad_lo[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(fC); ~%", i-1, sdowncase(basisFun), pdim, polyOrder, pvdir, i-1),
    printf(fh, "  } ~%"),
    /* Drag term on right side of interface */
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_up_n[i]),  
    printf(fh, "    fUpwindQuad_up[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(fC); ~%", i-1, sdowncase(basisFun), pdim, polyOrder, pvdir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpwindQuad_up[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(fR); ~%", i-1, sdowncase(basisFun), pdim, polyOrder, pvdir, i-1),
    printf(fh, "  } ~%")
  ),
  
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad_lo, fUpwind_lo); ~%", sdowncase(basisFun), pdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad_up, fUpwind_up); ~%", sdowncase(basisFun), pdim, polyOrder),
  printf(fh, "~%"),

  /* Expand upwinded f on left and right in surface basis */
  fHatSurf_lo_e : doExpand1(fUpwind_lo, bSurf),
  fHatSurf_up_e : doExpand1(fUpwind_up, bSurf),

  Ghat_lo_c : calcInnerProdList(surfVars, alphaDragSurf_lo_e, bSurf, fHatSurf_lo_e),
  Ghat_up_c : calcInnerProdList(surfVars, alphaDragSurf_up_e, bSurf, fHatSurf_up_e),

  glst1_lo : doMakeExprLst(Ghat_lo_c, Ghat_lo),
  Ghat_lo_e : doExpand(glst1_lo, bSurf),
  glst1_up : doMakeExprLst(Ghat_up_c, Ghat_up),
  Ghat_up_e : doExpand(glst1_up, bSurf),
  drag_incr_up : calcInnerProdList(surfVars, 1, subst(pv=1, bP), Ghat_up_e),
  drag_incr_lo : calcInnerProdList(surfVars, -1, subst(pv=-1, bP), Ghat_lo_e),

  writeCExprs1(Ghat_lo, Ghat_lo_c),
  printf(fh, "~%"),
  flush_output(fh),
  
  writeCExprs1(Ghat_up, Ghat_up_c),
  printf(fh, "~%"),
  flush_output(fh),
  writeCIncrExprs1(out, 0.5*dv1*drag_incr_up + 0.5*dv1*drag_incr_lo), 

  /* Return CFL in volume kernel */
  printf(fh, "~%}~%"),
  close(fh)
)$
