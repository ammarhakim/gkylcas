/*
  FPO diffusion volume term calculation is included in surface and 
  boundary surface kernels because some use one integration by parts
  while others use two integrations, yielding different volume terms.
*/

load("modal-basis")$
load("out-scripts")$

dirs : [vx, vy, vz]$

generateFpoVlasovDiffVol(fname, funcNm, cdim, basisFun, polyOrder) := block(
  [vdim, varsC, bC, varsP, bP, NC, fh, f_lst, f_e, D_xx_e, D_xy_e, D_xz_e, D_yx_e, D_yy_e, D_yz_e,
  D_zx_e, D_zy_e, D_zz_e, D_comps, dv1_sq_comps, kernel, zr, polyFact, facDiff_mid, facDiff_e],

  if (polyOrder = 1) then ( basisFun : "hyb" ),

  /* FPO is always 3V */
  vdim : 3,

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bP),

  disp(printf(false, "Creating ~a", fname)),

  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h> ~%~%"),
  printf(fh, "GKYL_CU_DH double ~a(const double* dxv, const double *diff_coeff, const double* f, double* GKYL_RESTRICT out) { ~%", funcNm),

  printf(fh, "  // dxv[NDIM]: Cell spacing in each direction. ~%"),
  printf(fh, "  // f: Distribution function. ~%"),
  printf(fh, "  // out: Incremented output. ~%~%"),
  printf(fh, "  return 0.0; ~%"),
  printf(fh, "} ~%"),
  close(fh)
)$
