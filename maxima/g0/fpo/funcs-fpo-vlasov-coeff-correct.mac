/* 
  Set matrices for linear solve of equations to correct drag and diffusion coefficients
  for momentum and energy conservation in the FPO.
*/

load("modal-basis");
load("out-scripts");
load(stringproc);
fpprec : 24$

setMatValue(A, row, col, val) := block(
  [],
  printf(fh, sconcat("  gkyl_mat_set(", A, ", ", row, ", ", col, ", ", val, "); ~%"))
)$

dirs : [x,y,z]$

setFpoConservationMatrices(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [],

  /* FPO is always 3V */
  vdim : 3,

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),

  numMat : NC*(vdim+1),

  printf(fh, "GKYL_CU_DH void ~a(struct gkyl_mat *lhs, struct gkyl_mat *rhs, const double *fpo_moms, const double *boundary_corrections, const double *moms) ~%{~%", funcNm),
  printf(fh, "  // lhs: Matrix to be inverted to solve Ax = rhs. ~%"),
  printf(fh, "  // rhs: Right-hand-side of linear system. ~%"),
  printf(fh, "  // fpo_moms: Volume correction moments for FPO conservation ~%"),
  printf(fh, "  // boundary_corrections: Boundary correction moments for FPO conservation ~%"),
  printf(fh, "  // moms: m0, m1i, and m2 ~%"),
  printf(fh, " ~%"),

  printf(fh, "  // Index into moment array ~%"),
  printf(fh, "  const double *m0 = &moms[~a]; ~%", 0*NC),
  printf(fh, "  const double *m1x = &moms[~a]; ~%", 1*NC),
  printf(fh, "  const double *m1y = &moms[~a]; ~%", 2*NC),
  printf(fh, "  const double *m1z = &moms[~a]; ~%", 3*NC),
  printf(fh, " ~%"),

  printf(fh, "  // Index into volume and boundary correction moments ~%"),
  printf(fh, "  const double *vol_corr_ax = &fpo_moms[~a]; ~%", 0*NC),
  printf(fh, "  const double *vol_corr_ay = &fpo_moms[~a]; ~%", 1*NC),
  printf(fh, "  const double *vol_corr_az = &fpo_moms[~a]; ~%", 2*NC),
  printf(fh, "  const double *vol_corr_energy = &fpo_moms[~a]; ~%", 3*NC),
  printf(fh, " ~%"),
  printf(fh, "  const double *bcorr_ax = &boundary_corrections[~a]; ~%", 0*NC),
  printf(fh, "  const double *bcorr_ay = &boundary_corrections[~a]; ~%", 1*NC),
  printf(fh, "  const double *bcorr_az = &boundary_corrections[~a]; ~%", 2*NC),
  printf(fh, "  const double *bcorr_energy = &boundary_corrections[~a]; ~%", 3*NC),
  printf(fh, "  const double *bcorr_ax_D_ij = &boundary_corrections[~a]; ~%", 4*NC),
  printf(fh, "  const double *bcorr_ay_D_ij = &boundary_corrections[~a]; ~%", 5*NC),
  printf(fh, "  const double *bcorr_az_D_ij = &boundary_corrections[~a]; ~%", 6*NC),
  printf(fh, "  const double *bcorr_energy_D_ij = &boundary_corrections[~a]; ~%", 7*NC),
  printf(fh, " ~%"),

  bcorr_ai : [bcorr_ax, bcorr_ay, bcorr_az],

  /* Expansions of moments */
  m0_e : doExpand1(m0, bC),
  m1x_e : doExpand1(m1x, bC),
  m1y_e : doExpand1(m1y, bC),
  m1z_e : doExpand1(m1z, bC),
  m1_e_lst : [m1x_e, m1y_e, m1z_e],

  /* Expansions and lists of corrections to drag and diffusion coefficients */
  acorr_x_c : makelist(acorr_x[i], i, 0, NC-1),
  acorr_y_c : makelist(acorr_y[i], i, 0, NC-1),
  acorr_z_c : makelist(acorr_z[i], i, 0, NC-1),
  Dcorr_c : makelist(Dcorr[i], i, 0, NC-1),
  acorr_c_lst : [acorr_x_c, acorr_y_c, acorr_z_c],

  acorr_x_e : doExpand1(acorr_x, bC),
  acorr_y_e : doExpand1(acorr_y, bC),
  acorr_z_e : doExpand1(acorr_z, bC),
  Dcorr_e : doExpand1(Dcorr, bC),
  acorr_e_lst : [acorr_x_e, acorr_y_e, acorr_z_e],

  /* Expansions of volume corrections */
  vol_corr_ai_lst : [vol_corr_ax, vol_corr_ay, vol_corr_az],

  /* Expansions of boundary corrections */
  bcorr_ax_e : doExpand1(bcorr_ax, bC),
  bcorr_ay_e : doExpand1(bcorr_ay, bC),
  bcorr_az_e : doExpand1(bcorr_az, bC),
  bcorr_ai_lst : [bcorr_ax_e, bcorr_ay_e, bcorr_az_e],

  bcorr_energy_e : doExpand1(bcorr_energy, bC),
  bcorr_ai_D_ij_lst : [bcorr_ax_D_ij, bcorr_ay_D_ij, bcorr_az_D_ij],

  /* Blocks from weak multiply of M0 with drag coeff correction */
  for d : 1 thru vdim do (
    acorr_e : acorr_e_lst[d],
    acorr_c : acorr_c_lst[d],
    block_offset : (d-1)*NC,

    printf(fh, "  // Block from weak multiply of M0 with drag_coeff_corr_v~a. ~%", dirs[d]),
    weak_mul_c : calcInnerProdList(varsC, acorr_e, bC, m0_e),
    weak_mul_mat : fullratsimp(coefmatrix(weak_mul_c, acorr_c)),
    weak_mul_mat_flat : float(expand(list_matrix_entries(weak_mul_mat))),
    for i : 1 thru NC do (
      for j : 1 thru NC do (
        setMatValue(lhs, i-1+block_offset, j-1+block_offset, weak_mul_mat_flat[NC*(i-1) + j])
      )
    ),
    printf(fh, " ~%")
  ), 

  /* Block from weak multiply of M1i with drag coeff correction */
  for d : 1 thru vdim do (
    acorr_e : acorr_e_lst[d],
    acorr_c : acorr_c_lst[d],
    m1i_e : m1_e_lst[d],
    block_offset_row : 3*NC,
    block_offset_col : (d-1)*NC,

    printf(fh, "  // Block from weak multiply of M1~a with drag_coeff_corr_v~a. ~%", 
      dirs[d], dirs[d]),
    weak_mul_c : calcInnerProdList(varsC, acorr_e, bC, m1i_e),
    weak_mul_mat : fullratsimp(coefmatrix(weak_mul_c, acorr_c)),
    weak_mul_mat_flat : float(expand(list_matrix_entries(weak_mul_mat))),
    for i : 1 thru NC do (
      for j : 1 thru NC do (
        setMatValue(lhs, i-1+block_offset_row, j-1+block_offset_col, 
          weak_mul_mat_flat[NC*(i-1) + j])
      )
    ),
    printf(fh, " ~%")
  ),

  /* Block from weak multiply of boundary corrections with diff coeff correction */
  for d : 1 thru vdim do (
    bcorr_ai_e : bcorr_ai_lst[d],
    block_offset_row : (d-1)*NC,
    block_offset_col : 3*NC,

    printf(fh, "  // Block from weak multiply of -bcorr_a~a with diff_coeff_corr. ~%", dirs[d]),
    weak_mul_c : calcInnerProdList(varsC, Dcorr_e, bC, -bcorr_ai_e),
    weak_mul_mat : fullratsimp(coefmatrix(weak_mul_c, Dcorr_c)),
    weak_mul_mat_flat : float(expand(list_matrix_entries(weak_mul_mat))),
    for i : 1 thru NC do (
      for j : 1 thru NC do (
        setMatValue(lhs, i-1+block_offset_row, j-1+block_offset_col, 
          weak_mul_mat_flat[NC*(i-1) + j])
      )
    ),
    printf(fh, " ~%")
  ),

  /* Block from weak multiply of boundary corrections and M0 with diff coeff correction */ 
  block_offset : 3*NC,
  printf(fh, "  // Block from weak multiply of (vdim*M0-bcorr_energy) with diff_coeff_corr. ~%"),
  weak_mul_c : calcInnerProdList(varsC, Dcorr_e, bC, vdim*m0_e - bcorr_energy_e),
  weak_mul_mat : fullratsimp(coefmatrix(weak_mul_c, Dcorr_c)),
  weak_mul_mat_flat : float(expand(list_matrix_entries(weak_mul_mat))),
  for i : 1 thru NC do (
    for j : 1 thru NC do (
      setMatValue(lhs, i-1+block_offset, j-1+block_offset, 
        weak_mul_mat_flat[NC*(i-1) + j])
    )
  ),
  printf(fh, " ~%"),

  /* Set rhs vector elements */
  /* -Volume ai correction + boundary ai D_ij correction */
  printf(fh, "  // Set rhs vector. ~%"),
  for d : 1 thru vdim do (
    for i : 1 thru NC do (
      setMatValue(rhs, i-1+(d-1)*NC, 0, bcorr_ai_D_ij_lst[d][i-1] - vol_corr_ai_lst[d][i-1]) 
    )
  ),
 
  /* -Volume energy correction + boundary energy D_ij correction */
  for i : 1 thru NC do (
    setMatValue(rhs, i-1 + vdim*NC, 0, bcorr_energy_D_ij[i-1] - vol_corr_energy[i-1])
  ),

  printf(fh, "}~%"),
  close(fh)
)$


accumulateFpoConservationCorrs(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [],

  /* FPO is always 3V */
  vdim : 3,

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  surfVarsvx : delete(vx, varsP),
  surfVarsvy : delete(vy, varsP),
  surfVarsvz : delete(vz, varsP),

  bSurfvx : basisFromVars(basisFun, surfVarsvx, polyOrder),
  bSurfvy : basisFromVars(basisFun, surfVarsvy, polyOrder),
  bSurfvz : basisFromVars(basisFun, surfVarsvz, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  numSurf : length(bSurfvx),
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a(const double *drag_diff_coeff_corrs, double *drag_coeff, double *drag_coeff_surf, double *diff_coeff, double *diff_coeff_surf) ~%{~%", funcNm),
  printf(fh, "  // drag_diff_coeff_corrs: Corrections to be added to coeffs, function of config space only. ~%"),
  printf(fh, "  // drag_coeff: FPO drag coefficient. ~%"),
  printf(fh, "  // diff_coeff: FPO diffusion coefficient. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  // Index into drag and diffusion coefficients. ~%"),
  printf(fh, "  double *ax = &drag_coeff[~a]; ~%", 0*NP),
  printf(fh, "  double *ay = &drag_coeff[~a]; ~%", 1*NP),
  printf(fh, "  double *az = &drag_coeff[~a]; ~%", 2*NP),
  printf(fh, "  double *Dxx = &diff_coeff[~a]; ~%", 0*NP),
  printf(fh, "  double *Dyy = &diff_coeff[~a]; ~%", 4*NP),
  printf(fh, "  double *Dzz = &diff_coeff[~a]; ~%", 8*NP),
  printf(fh, " ~%"),
  printf(fh, "  // Index into surface expansions. ~%"),
  printf(fh, "  double *ax_surf = &drag_coeff_surf[~a]; ~%", 0*numSurf),
  printf(fh, "  double *ay_surf = &drag_coeff_surf[~a]; ~%", 1*numSurf),
  printf(fh, "  double *az_surf = &drag_coeff_surf[~a]; ~%", 2*numSurf),
  printf(fh, "  double *Dxx_surf = &diff_coeff_surf[~a]; ~%", 0*numSurf),
  printf(fh, "  double *Dyy_surf = &diff_coeff_surf[~a]; ~%", 8*numSurf),
  printf(fh, "  double *Dzz_surf = &diff_coeff_surf[~a]; ~%", 16*numSurf),
  printf(fh, " ~%"),

  printf(fh, "  // Index into correction array. ~%"),
  printf(fh, "  const double* ax_corr = &drag_diff_coeff_corrs[~a]; ~%", 0*NC),
  printf(fh, "  const double* ay_corr = &drag_diff_coeff_corrs[~a]; ~%", 1*NC),
  printf(fh, "  const double* az_corr = &drag_diff_coeff_corrs[~a]; ~%", 2*NC),
  printf(fh, "  const double* D_corr = &drag_diff_coeff_corrs[~a]; ~%", 3*NC),
  printf(fh, " ~%"),

  ax_corr_e : doExpand1(ax_corr, bC),
  ay_corr_e : doExpand1(ay_corr, bC),
  az_corr_e : doExpand1(az_corr, bC),
  D_corr_e : doExpand1(D_corr, bC),

  /* Accumulate corrections onto volume expansions of drag and diffusion coefficients */
  ax_accum_out_c : calcInnerProdList(varsP, 1, bP, ax_corr_e),
  ay_accum_out_c : calcInnerProdList(varsP, 1, bP, ay_corr_e),
  az_accum_out_c : calcInnerProdList(varsP, 1, bP, az_corr_e),

  D_accum_out_c : calcInnerProdList(varsP, 1, bP, D_corr_e),

  writeCIncrExprs1(ax, ax_accum_out_c),
  printf(fh, " ~%"),
  writeCIncrExprs1(ay, ay_accum_out_c),
  printf(fh, " ~%"),
  writeCIncrExprs1(az, az_accum_out_c),
  printf(fh, " ~%"),
  
  writeCIncrExprs1(Dxx, D_accum_out_c),
  printf(fh, " ~%"),
  writeCIncrExprs1(Dyy, D_accum_out_c),
  printf(fh, " ~%"),
  writeCIncrExprs1(Dzz, D_accum_out_c),
  printf(fh, " ~%"),

  /* Accumulate corrections onto surface expansions of drag and diffusion coefficients */
  ax_surf_accum_out_c : calcInnerProdList(surfVarsvx, 1, bSurfvx, ax_corr_e),
  ay_surf_accum_out_c : calcInnerProdList(surfVarsvy, 1, bSurfvy, ay_corr_e),
  az_surf_accum_out_c : calcInnerProdList(surfVarsvz, 1, bSurfvz, az_corr_e),

  Dxx_surf_accum_out_c : calcInnerProdList(surfVarsvx, 1, bSurfvx, D_corr_e),
  Dyy_surf_accum_out_c : calcInnerProdList(surfVarsvy, 1, bSurfvy, D_corr_e),
  Dzz_surf_accum_out_c : calcInnerProdList(surfVarsvz, 1, bSurfvz, D_corr_e),

  writeCIncrExprs1(ax_surf, ax_surf_accum_out_c),
  printf(fh, " ~%"),
  writeCIncrExprs1(ay_surf, ay_surf_accum_out_c),
  printf(fh, " ~%"),
  writeCIncrExprs1(az_surf, az_surf_accum_out_c),
  printf(fh, " ~%"),

  writeCIncrExprs1(Dxx_surf, Dxx_surf_accum_out_c),
  printf(fh, " ~%"),
  writeCIncrExprs1(Dyy_surf, Dyy_surf_accum_out_c),
  printf(fh, " ~%"),
  writeCIncrExprs1(Dzz_surf, Dzz_surf_accum_out_c),

  printf(fh, "} ~%"),
  printf(fh, "~%"),
  close(fh)
)$
