load("recovery") $
load ("modal-basis") $
load(stringproc)$

dirs : [vx, vy, vz] $

writeD(recov, dirFace, vars, bas, nm, fh) := block(
  [proj],
  proj : calcInnerProdList(vars, 1, bas, subst(dirFace=0, recov)),
  printf(fh, "  double ~a[~a];~%", nm, length(bas)),
  for i : 1 thru length(bas) do (
    printf(fh, "  ~a[~a] = ~a;~%", nm, i-1, float(expand(proj[i])))
    ),
  printf(fh, "~%")
  ) $

writeF(recov, dirFace, derDir, numDer, vars, bas, nm, fh) := block(
  [proj],
  proj : calcInnerProdList(vars, 1, bas,
    subst(dirFace=0, diff(recov, derDir, numDer))),
  printf(fh, "  double ~a[~a];~%", nm, length(bas)),
  for i : 1 thru length(bas) do (
    printf(fh, "  ~a[~a] = ~a;~%", nm, i-1, float(expand(proj[i])))
    ),
  printf(fh, "~%")
  ) $

getLists(numBasis) := block(
  /* This is a not always necessary step and one could in most cases
  use directly 'dg(qlll)' instead of dg(lst_qlll) but this does prevent
  potential super nasty aliasing!  */
  [],
  lst_Dllc : makelist(Dllc[i], i, 0, numBasis-1),
  lst_Dlcl : makelist(Dlcl[i], i, 0, numBasis-1),
  lst_Dlcc : makelist(Dlcc[i], i, 0, numBasis-1),
  lst_Dlcu : makelist(Dlcu[i], i, 0, numBasis-1),
  lst_Dluc : makelist(Dluc[i], i, 0, numBasis-1),
  
  lst_Dcll : makelist(Dcll[i], i, 0, numBasis-1),
  lst_Dclc : makelist(Dclc[i], i, 0, numBasis-1),
  lst_Dclu : makelist(Dclu[i], i, 0, numBasis-1),
  lst_Dccl : makelist(Dccl[i], i, 0, numBasis-1),
  lst_Dccc : makelist(Dccc[i], i, 0, numBasis-1),
  lst_Dccu : makelist(Dccu[i], i, 0, numBasis-1),
  lst_Dcul : makelist(Dcul[i], i, 0, numBasis-1),
  lst_Dcuc : makelist(Dcuc[i], i, 0, numBasis-1),
  lst_Dcuu : makelist(Dcuu[i], i, 0, numBasis-1),
  
  lst_Dulc : makelist(Dulc[i], i, 0, numBasis-1),
  lst_Ducl : makelist(Ducl[i], i, 0, numBasis-1),
  lst_Ducc : makelist(Ducc[i], i, 0, numBasis-1),
  lst_Ducu : makelist(Ducu[i], i, 0, numBasis-1),
  lst_Duuc : makelist(Duuc[i], i, 0, numBasis-1),


  lst_fllc : makelist(fllc[i], i, 0, numBasis-1),
  lst_flcl : makelist(flcl[i], i, 0, numBasis-1),
  lst_flcc : makelist(flcc[i], i, 0, numBasis-1),
  lst_flcu : makelist(flcu[i], i, 0, numBasis-1),
  lst_fluc : makelist(fluc[i], i, 0, numBasis-1),
  
  lst_fcll : makelist(fcll[i], i, 0, numBasis-1),
  lst_fclc : makelist(fclc[i], i, 0, numBasis-1),
  lst_fclu : makelist(fclu[i], i, 0, numBasis-1),
  lst_fccl : makelist(fccl[i], i, 0, numBasis-1),
  lst_fccc : makelist(fccc[i], i, 0, numBasis-1),
  lst_fccu : makelist(fccu[i], i, 0, numBasis-1),
  lst_fcul : makelist(fcul[i], i, 0, numBasis-1),
  lst_fcuc : makelist(fcuc[i], i, 0, numBasis-1),
  lst_fcuu : makelist(fcuu[i], i, 0, numBasis-1),
  
  lst_fulc : makelist(fulc[i], i, 0, numBasis-1),
  lst_fucl : makelist(fucl[i], i, 0, numBasis-1),
  lst_fucc : makelist(fucc[i], i, 0, numBasis-1),
  lst_fucu : makelist(fucu[i], i, 0, numBasis-1),
  lst_fuuc : makelist(fuuc[i], i, 0, numBasis-1)
) $


getRecoveries(vars, polyOrder, bName) := block(
  [],
  Dl_rec2 : [
  'calcRecov2CellGen(bName, vx, vars, polyOrder,
    dg(lst_Dlcc), dg(lst_Dccc)),
  'calcRecov2CellGen(bName, vy, vars, polyOrder,
    dg(lst_Dclc), dg(lst_Dccc)),
  'calcRecov2CellGen(bName, vz, vars, polyOrder,
    dg(lst_Dccl), dg(lst_Dccc))
  ],

  Du_rec2 : [
  'calcRecov2CellGen(bName, vx, vars, polyOrder,
    dg(lst_Dccc), dg(lst_Ducc)),
  'calcRecov2CellGen(bName, vy, vars, polyOrder,
    dg(lst_Dccc), dg(lst_Dcuc)),
  'calcRecov2CellGen(bName, vz, vars, polyOrder,
    dg(lst_Dccc), dg(lst_Dccu))
  ],

  fl_rec2 : [
  'calcRecov2CellGen(bName, vx, vars, polyOrder,
    dg(lst_flcc), dg(lst_fccc)),
  'calcRecov2CellGen(bName, vy, vars, polyOrder,
    dg(lst_fclc), dg(lst_fccc)),
  'calcRecov2CellGen(bName, vz, vars, polyOrder,
    dg(lst_fccl), dg(lst_fccc))
  ],

  fu_rec2 : [
  'calcRecov2CellGen(bName, vx, vars, polyOrder,
    dg(lst_fccc), dg(lst_fucc)),
  'calcRecov2CellGen(bName, vy, vars, polyOrder,
    dg(lst_fccc), dg(lst_fcuc)),
  'calcRecov2CellGen(bName, vz, vars, polyOrder,
    dg(lst_fccc), dg(lst_fccu))
  ],

  fl_rec6 : [
  [
  false,
  'calcRecovFaceGen(bName, [vx, vy], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_fllc), dg(lst_fclc)),
    dg(dg(lst_flcc), dg(lst_fccc)),
    dg(dg(lst_fluc), dg(lst_fcuc))),
  'calcRecovFaceGen(bName, [vx, vz], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_flcl), dg(lst_fccl)),
    dg(dg(lst_flcc), dg(lst_fccc)),
    dg(dg(lst_flcu), dg(lst_fccu)))
  ],
  [
  'calcRecovFaceGen(bName, [vy, vx], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_fllc), dg(lst_flcc)),
    dg(dg(lst_fclc), dg(lst_fccc)),
    dg(dg(lst_fulc), dg(lst_fucc))),
  false,
  'calcRecovFaceGen(bName, [vy, vz], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_fcll), dg(lst_fccl)),
    dg(dg(lst_fclc), dg(lst_fccc)),
    dg(dg(lst_fclu), dg(lst_fccu)))
  ],
  [
  'calcRecovFaceGen(bName, [vz, vx], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_flcl), dg(lst_flcc)),
    dg(dg(lst_fccl), dg(lst_fccc)),
    dg(dg(lst_fucl), dg(lst_fucc))),
  'calcRecovFaceGen(bName, [vz, vy], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_fcll), dg(lst_fclc)),
    dg(dg(lst_fccl), dg(lst_fccc)),
    dg(dg(lst_fcul), dg(lst_fcuc))),
  false
  ]
  ],

  fu_rec6 : [
  [
  false,
  'calcRecovFaceGen(bName, [vx, vy], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_fclc), dg(lst_fulc)),
    dg(dg(lst_fccc), dg(lst_fucc)),
    dg(dg(lst_fcuc), dg(lst_fuuc))),
  'calcRecovFaceGen(bName, [vx, vz], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_fccl), dg(lst_fucl)),
    dg(dg(lst_fccc), dg(lst_fucc)),
    dg(dg(lst_fccu), dg(lst_fucu)))
  ],
  [
  'calcRecovFaceGen(bName, [vy, vx], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_flcc), dg(lst_fluc)),
    dg(dg(lst_fccc), dg(lst_fcuc)),
    dg(dg(lst_fucc), dg(lst_fuuc))),
  false,
  'calcRecovFaceGen(bName, [vy, vz], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_fccl), dg(lst_fcul)),
    dg(dg(lst_fccc), dg(lst_fcuc)),
    dg(dg(lst_fccu), dg(lst_fcuu)))
  ],
  [
  'calcRecovFaceGen(bName, [vz, vx], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_flcc), dg(lst_flcu)),
    dg(dg(lst_fccc), dg(lst_fccu)),
    dg(dg(lst_fucc), dg(lst_fucu))),
  'calcRecovFaceGen(bName, [vz, vy], vars, 0, 0, polyOrder, 0,
    dg(dg(lst_fclc), dg(lst_fclu)),
    dg(dg(lst_fccc), dg(lst_fccu)),
    dg(dg(lst_fcuc), dg(lst_fcuu))),
  false
  ]
  ]
) $
  
calcFpoDiffSurf1x3v(polyOrder, bName, d1, d2) := block(
  [dir1, dir2,
  fname, fh,
  ba, numBasis,
  lst_lcu, cnt],
  load(sconcat("basis-precalc/basis", bName, "1x3v")),
  ba : basisP[polyOrder],
  numBasis : length(ba),
  dir1 : dirs[d1],
  dir2 : dirs[d2],
  
  kname : sconcat("fpo_vlasov_diff_surf", dir1, dir2,
    "_1x3v_", sdowncase(bName), "_p", polyOrder),
  print("Generating:", kname),
  fname : sconcat("~/max-out/", kname, ".c"),
  fh : openw(fname),
  printf(fh, "#include <gkyl_fpo_vlasov_kernels.h>~%~%"),
  printf(fh, "GKYL_CU_DH void~%"),
  printf(fh, sconcat(kname,
      "(const double* w, const double* dx,~%")),
  printf(fh, "  const double* D[], const double* f[], double* GKYL_RESTRICT out) ~%"),
  printf(fh, "{~%"),
  printf(fh, "  // w[NDIM]: Cell-center coordinates~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing~%"),
  printf(fh, "  // D: ~%"),
  printf(fh, "  // f: Input distribution function~%"),
  printf(fh, "  // out: Incremented output~%~%"),
  
  printf(fh, sconcat("  const double J", dir1, dir2,
      " = 4/dx[", d1, "]/dx[", d2, "];~%~%")),
  
  lst_lcu : ["l", "c", "u"],
  cnt : 0, /* C starts with 0 */
  idx : if d1=1 then 0 else d1,
  idx : (idx + d2-1)*numBasis,
  for i : 1 thru 3 do (
    for j : 1 thru 3 do (
      for k : 1 thru 3 do (
        printf(fh, "  const double* D~a~a~a = D[~a] + ~a;~%",
          lst_lcu[i], lst_lcu[j], lst_lcu[k], cnt, idx),
        printf(fh, "  const double* f~a~a~a = f[~a];~%",
          lst_lcu[i], lst_lcu[j], lst_lcu[k], cnt),
        cnt : cnt + 1
      )
    )
  ),
  printf(fh, "~%"),
  
  surfVars : delete(dir1, varsP),
  /* Black magic start */
  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no dir dependence. */
  ba_surf : sqrt(2)*delete(0, fullratsimp(
      innerProd(varsP, 1, ba, subst([dir1^2=var2, var2=1/3, dir1=0], ba)))*ba),
  /* Black magic ends */
  numSurfBasis : length(ba_surf),

  rec : ev(Dl_rec2[d1], nouns),
  writeD(rec, dir1, surfVars, ba_surf, "D_proj1_l", fh),
  kill(rec),
  lst_D_proj1_l : makelist(D_proj1_l[i], i, 0, numSurfBasis-1),
  
  rec : ev(Du_rec2[d1], nouns),
  writeD(rec, dir1, surfVars, ba_surf, "D_proj1_u", fh),
  kill(rec),
  lst_D_proj1_u : makelist(D_proj1_u[i], i, 0, numSurfBasis-1),
  
  if d1 = d2 then (
    rec : ev(fl_rec2[d1], nouns),
    writeF(rec, dir1, dir1, 1, surfVars, ba_surf, "df_proj1_l", fh),
    kill(rec),
    lst_df_proj1_l : makelist(df_proj1_l[i], i, 0, numSurfBasis-1),
    
    rec : ev(fu_rec2[d1], nouns),
    writeF(rec, dir1, dir1, 1, surfVars, ba_surf, "df_proj1_u", fh),
    kill(rec),
    lst_df_proj1_u : makelist(df_proj1_u[i], i, 0, numSurfBasis-1)
  ) else (
    rec : ev(fl_rec6[d1][d2], nouns),
    writeF(rec, dir1, dir2, 1, surfVars, ba_surf, "df_proj1_l", fh),
    kill(rec),
    lst_df_proj1_l : makelist(df_proj1_l[i], i, 0, numSurfBasis-1),
    
    rec : ev(fu_rec6[d1][d2], nouns),
    writeF(rec, dir1, dir2, 1, surfVars, ba_surf, "df_proj1_u", fh),
    kill(rec),
    lst_df_proj1_u : makelist(df_proj1_u[i], i, 0, numSurfBasis-1)
  ),
  
  surf1_l : calcInnerProdList(surfVars, 1, subst(dir1=-1, ba),
    doExpand(lst_df_proj1_l, ba_surf) * doExpand(lst_D_proj1_l, ba_surf)),
  surf1_u : calcInnerProdList(surfVars, 1, subst(dir1=1, ba),
    doExpand(lst_df_proj1_u, ba_surf) * doExpand(lst_D_proj1_u, ba_surf)),
  
  
  surfVars : delete(dir2, varsP),
  /* Black magic start */
  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no dir dependence. */
  ba_surf : sqrt(2)*delete(0, fullratsimp(
      innerProd(varsP, 1, ba, subst([dir2^2=var2, var2=1/3, dir2=0], ba)))*ba),
  /* Black magic ends */
  numSurfBasis : length(ba_surf),
  
  if d1 = d2 then (
    lst_D_proj2_l : lst_D_proj1_l,
    lst_D_proj2_u : lst_D_proj1_u
  ) else (
    rec : ev(Dl_rec2[d2], nouns),
    writeD(rec, dir2, surfVars, ba_surf, "D_proj2_l", fh),
    kill(rec),
    lst_D_proj2_l : makelist(D_proj2_l[i], i, 0, numSurfBasis-1),
    
    rec : ev(Du_rec2[d2], nouns),
    writeD(rec, dir2, surfVars, ba_surf, "D_proj2_u", fh),
    kill(rec),
    lst_D_proj2_u : makelist(D_proj2_u[i], i, 0, numSurfBasis-1)
  ),
  
  rec : ev(fl_rec2[d2], nouns),
  writeF(rec, dir2, dir2, 0, surfVars, ba_surf, "f_proj2_l", fh),
  kill(rec),
  lst_f_proj2_l : makelist(f_proj2_l[i], i, 0, numSurfBasis-1),
  
  rec : ev(fu_rec2[d2], nouns),
  writeF(rec, dir2, dir2, 0, surfVars, ba_surf, "f_proj2_u", fh),
  kill(rec),
  lst_f_proj2_u : makelist(f_proj2_u[i], i, 0, numSurfBasis-1),
  
  surf2_l : calcInnerProdList(surfVars, 1, subst(dir2=-1, diff(ba, dir1)),
    doExpand(lst_f_proj2_l, ba_surf) * doExpand(lst_D_proj2_l, ba_surf)),
  surf2_u : calcInnerProdList(surfVars, 1, subst(dir2=1, diff(ba, dir1)),
    doExpand(lst_f_proj2_u, ba_surf) * doExpand(lst_D_proj2_u, ba_surf)),
  
  
  kernel : (surf1_u - surf2_u - surf1_l + surf2_l)/2,
  
  for i : 1 thru numBasis do (
    printf(fh, "  out[~a] += J~a~a*(~a);~%", i-1, dir1, dir2,
      float(expand(kernel[i])))
  ),
  printf(fh, "}~%~%"),
  kill(kernel, surf1_l, surf1_u, surf2_l, surf2_u),
  close(fh)
) $
