load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("recovery")$

surfIntegral(integrand_lower, integrand_upper, surf_var, varsP) := block(
  tmp_upper : subst(surf_var=1, integrand_upper),
  tmp_lower : subst(surf_var=-1, integrand_lower),

  remVars : delete(surf_var, varsP),
  for i : 1 thru length(remVars) do (
    tmp_upper : integrate(tmp_upper, remVars[i], -1, 1),
    tmp_lower : integrate(tmp_lower, remVars[i], -1, 1)
  ),
  return(tmp_upper - tmp_lower)
)$

calcFPODiffCoeffCrossSurfEdge(dir1, dir2, fh, funcNm, cdim, vdim, basisFunc, polyOrder) := block(
  [varsC, bC, varsP, bP, NC, recovDir1, recovDir2, pv1, pv2,
  GTL_lst, GTC_lst, GTR_lst, GCL_lst, GCC_lst, GCR_lst, GBL_lst, GBC_lst, GBR_lst,
  Grecpv1, Grecpv2_upper, Grecpv2_lower, surft1, surft2, GCC_e, vol, kernel],

  /* Clear variables for safety, then load basis */
  kill(varsC, bC, varsP, bP),
  [varsC, bC, varsP, bP] : loadPhaseBasis(basisFunc, cdim, vdim, polyOrder),

  /* Number of basis monomials */
  NC : length(bP),

  /* Variable to perform recovery in */
  recovDir1 : dir1 + cdim,
  recovDir2 : dir2 + cdim,
  pv1 : varsP[recovDir1],
  pv2 : varsP[recovDir2],
  surfVarspv1 : delete(pv1, varsP),
  surfVarspv2 : delete(pv2, varsP),
  bSurfpv1 : basisFromVars(basisFunc, surfVarspv1, polyOrder),
  bSurfpv2 : basisFromVars(basisFunc, surfVarspv2, polyOrder),

  numSurf : length(bSurfpv1),

  disp([pv1, pv2]), 
  printf(fh, "GKYL_CU_DH void ~a~a~a_~ax~av_~a_p~a(const double *dxv, int edge, const double gamma, const double* stencil[9], const double* fpo_d2gdv2_surf_stencil[9], const double* g_surf_CC, double *diff_coeff) { ~%", funcNm, pv1, pv2, cdim, vdim, basisFunc, polyOrder),
  printf(fh, "  // dxv[NDIM]: Cell spacing. ~%"),
  printf(fh, "  // GTL,GTC,...: Input potential in plane of recovery vars. L(eft), C(enter), R(ight) in ~a direction. T(op), C(enter), B(ottom) in ~a direction. ~%", pv1, pv2),

  printf(fh, "  double dv1_sq = 4.0/dxv[~a]/dxv[~a]; ~%", recovDir1-1, recovDir2-1),

  /* Index into the 9-cell stencils */
  if (dir2 > dir1) then (
    printf(fh, "  const double* GBL = stencil[0]; ~%"),
    printf(fh, "  const double* GCL = stencil[1]; ~%"),
    printf(fh, "  const double* GTL = stencil[2]; ~%"),
    printf(fh, "  const double* GBC = stencil[3]; ~%"),
    printf(fh, "  const double* GCC = stencil[4]; ~%"),
    printf(fh, "  const double* GTC = stencil[5]; ~%"),
    printf(fh, "  const double* GBR = stencil[6]; ~%"),
    printf(fh, "  const double* GCR = stencil[7]; ~%"),
    printf(fh, "  const double* GTR = stencil[8]; ~%"),
    printf(fh, "~%"),
    printf(fh, "  const double* d2g_surf_BL = stencil[0]; ~%"),
    printf(fh, "  const double* d2g_surf_CL = stencil[1]; ~%"),
    printf(fh, "  const double* d2g_surf_TL = stencil[2]; ~%"),
    printf(fh, "  const double* d2g_surf_BC = stencil[3]; ~%"),
    printf(fh, "  const double* d2g_surf_CC = stencil[4]; ~%"),
    printf(fh, "  const double* d2g_surf_TC = stencil[5]; ~%"),
    printf(fh, "  const double* d2g_surf_BR = stencil[6]; ~%"),
    printf(fh, "  const double* d2g_surf_CR = stencil[7]; ~%"),
    printf(fh, "  const double* d2g_surf_TR = stencil[8]; ~%")
  )
  elseif (dir1 > dir2) then (
    printf(fh, "  const double* GBL = stencil[0]; ~%"),
    printf(fh, "  const double* GBC = stencil[1]; ~%"),
    printf(fh, "  const double* GBR = stencil[2]; ~%"),
    printf(fh, "  const double* GCL = stencil[3]; ~%"),
    printf(fh, "  const double* GCC = stencil[4]; ~%"),
    printf(fh, "  const double* GCR = stencil[5]; ~%"),
    printf(fh, "  const double* GTL = stencil[6]; ~%"),
    printf(fh, "  const double* GTC = stencil[7]; ~%"),
    printf(fh, "  const double* GTR = stencil[8]; ~%"),
    printf(fh, "~%"),
    printf(fh, "  const double* d2g_surf_BL = stencil[0]; ~%"),
    printf(fh, "  const double* d2g_surf_BC = stencil[1]; ~%"),
    printf(fh, "  const double* d2g_surf_BR = stencil[2]; ~%"),
    printf(fh, "  const double* d2g_surf_CL = stencil[3]; ~%"),
    printf(fh, "  const double* d2g_surf_CC = stencil[4]; ~%"),
    printf(fh, "  const double* d2g_surf_CR = stencil[5]; ~%"),
    printf(fh, "  const double* d2g_surf_TL = stencil[6]; ~%"),
    printf(fh, "  const double* d2g_surf_TC = stencil[7]; ~%"),
    printf(fh, "  const double* d2g_surf_TR = stencil[8]; ~%")
  ),
  printf(fh, "  ~%"),
  printf(fh, "  double surft1_upper[~a], surft1_lower[~a]; ~%", numSurf, numSurf),
  printf(fh, "  double surft2_upper[~a], surft2_lower[~a]; ~%", numSurf, numSurf),
  printf(fh, "  ~%"),

  /* 
    Components in row major order: xx, xy, xz, yx, yy, yz, zx, zy, zz
  */
  printf(fh, "  double *diff_coeff_xy = &diff_coeff[~a]; ~%", 1*NC),
  printf(fh, "  double *diff_coeff_xz = &diff_coeff[~a]; ~%", 2*NC),
  printf(fh, "  double *diff_coeff_yx = &diff_coeff[~a]; ~%", 3*NC),
  printf(fh, "  double *diff_coeff_yz = &diff_coeff[~a]; ~%", 5*NC),
  printf(fh, "  double *diff_coeff_zx = &diff_coeff[~a]; ~%", 6*NC),
  printf(fh, "  double *diff_coeff_zy = &diff_coeff[~a]; ~%", 7*NC),  
  
  /* 
    +-----+-----+-----+
    | GTL | GTC | GTR |
    +-----+-----+-----+
    | GCL | GCC | GCR |
    +-----+-----+-----+
    | GBL | GBC | GBR |
    +-----+-----+-----+
    
    ^
    |
    pv2 / pv1 -->
  */

  GTL_lst : makelist(GTL[i], i, 0, NC-1),
  GTC_lst : makelist(GTC[i], i, 0, NC-1),
  GTR_lst : makelist(GTR[i], i, 0, NC-1),
  GCL_lst : makelist(GCL[i], i, 0, NC-1),
  GCC_lst : makelist(GCC[i], i, 0, NC-1),
  GCR_lst : makelist(GCR[i], i, 0, NC-1),
  GBL_lst : makelist(GBL[i], i, 0, NC-1),
  GBC_lst : makelist(GBC[i], i, 0, NC-1),
  GBR_lst : makelist(GBR[i], i, 0, NC-1),

  d2g_surf_BC_lst : makelist(d2g_surf_BC[i], i, 0, numSurf-1),
  d2g_surf_CC_lst : makelist(d2g_surf_CC[i], i, 0, numSurf-1),
  d2g_surf_TC_lst : makelist(d2g_surf_TC[i], i, 0, numSurf-1),

  g_surf_CC_lst : makelist(g_surf_CC[i], i, 0, numSurf-1),

  /* Surface epansions of d2G at domain boundaries in pv1 and pv2 surface basis sets */
  d2g_surf_TL_pv2_e : doExpand1(d2g_surf_TL, bSurfpv2)/dv1_sq,
  d2g_surf_TC_pv2_e : doExpand1(d2g_surf_TC, bSurfpv2)/dv1_sq,
  d2g_surf_TR_pv2_e : doExpand1(d2g_surf_TR, bSurfpv2)/dv1_sq,
  d2g_surf_BL_pv2_e : doExpand1(d2g_surf_BL, bSurfpv2)/dv1_sq,
  d2g_surf_BC_pv2_e : doExpand1(d2g_surf_BC, bSurfpv2)/dv1_sq,
  d2g_surf_BR_pv2_e : doExpand1(d2g_surf_BR, bSurfpv2)/dv1_sq,

  d2g_surf_TL_pv1_e : doExpand1(d2g_surf_TL, bSurfpv1)/dv1_sq,
  d2g_surf_CL_pv1_e : doExpand1(d2g_surf_CL, bSurfpv1)/dv1_sq,
  d2g_surf_BL_pv1_e : doExpand1(d2g_surf_BL, bSurfpv1)/dv1_sq,
  d2g_surf_TR_pv1_e : doExpand1(d2g_surf_TR, bSurfpv1)/dv1_sq,
  d2g_surf_CR_pv1_e : doExpand1(d2g_surf_CR, bSurfpv1)/dv1_sq,
  d2g_surf_BR_pv1_e : doExpand1(d2g_surf_BR, bSurfpv1)/dv1_sq,

  g_surf_CC_e : doExpand1(g_surf_CC, bSurfpv1),

  GCC_e : doExpand1(GCC, bP),
  vol : calcInnerProdList(varsP, 1, diff(diff(bP, pv1), pv2), GCC_e),

  /* 
  Edges:
    Top
    +-----+-----+-----+
    | +++ | +++ | +++ |
    +-----+-----+-----+
    | GCL | GCC | GCR |
    +-----+-----+-----+
    | GBL | GBC | GBR |
    +-----+-----+-----+
  */
  disp("Top edge"),

  /* 6-cell recovery across +/-1 interfaces in pv2 */
  Grecpv2_upper : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    dg(dg(GCL_lst), bcs([der=2, val=d2g_surf_TL_pv2_e])), dg(dg(GCC_lst), bcs([der=2, val=d2g_surf_TC_pv2_e])),
    dg(dg(GCR_lst), bcs([der=2, val=d2g_surf_TR_pv2_e]))),
  Grecpv2_lower : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    dg(dg(GBL_lst), dg(GCL_lst)), dg(dg(GBC_lst), dg(GCC_lst)), dg(dg(GBR_lst), dg(GCR_lst))),

  /* Evaluate surface projection of dG/dpv1 at pv2 boundaries */
  surft1_upper_top_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_upper, pv1)),
  surft1_lower_top_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_lower, pv1)),

  surft1_upper_e : doExpand1(surft1_upper, bSurfpv2),
  surft1_lower_e : doExpand1(surft1_lower, bSurfpv2),

  surft1 : calcInnerProdList(surfVarspv2, 1, subst(pv2=1,bP), surft1_upper_e) +
    calcInnerProdList(surfVarspv2, -1, subst(pv2=-1,bP), surft1_lower_e),

  /* 1-cell recovery across +/-1 interfaces in pv1 */
  Grecpv1_upper : calcRecov2CellGen(basisFunc, pv1, varsP, polyOrder, dg(GCC_lst), dg(GCR_lst)),
  Grecpv1_lower : calcRecov2CellGen(basisFunc, pv1, varsP, polyOrder, dg(GCL_lst), dg(GCC_lst)),

  surft2_upper_top_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_upper)),
  surft2_lower_top_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_lower)),

  surft2_upper_e : doExpand1(surft2_upper, bSurfpv1),
  surft2_lower_e : doExpand1(surft2_lower, bSurfpv1),

  surft2 : calcInnerProdList(surfVarspv1, 1, subst(pv1=1,diff(bP, pv2)), surft2_upper_e) +
    calcInnerProdList(surfVarspv1, -1,  subst(pv1=-1,diff(bP, pv2)), surft2_lower_e),

  GCC_e : doExpand1(GCC, bP),
  vol : calcInnerProdList(varsP, 1, diff(diff(bP, pv1), pv2), GCC_e),

  diff_coeff_top : surft1 - surft2 + vol,

  /*
    Bottom
    +-----+-----+-----+
    | GTL | GTC | GTR |
    +-----+-----+-----+
    | GCL | GCC | GCR |
    +-----+-----+-----+
    | +++ | +++ | +++ |
    +-----+-----+-----+
  */
  disp("Bottom edge"),
  /* 6-cell recovery across +/-1 interfaces in pv2 */
  Grecpv2_upper : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    dg(dg(GCL_lst), bcs([der=2, val=d2g_surf_TL_pv2_e])), dg(dg(GCC_lst), bcs([der=2, val=d2g_surf_TC_pv2_e])),
    dg(dg(GCR_lst), bcs([der=2, val=d2g_surf_TR_pv2_e]))),
  Grecpv2_lower : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    dg(dg(GBL_lst), dg(GCL_lst)), dg(dg(GBC_lst), dg(GCC_lst)), dg(dg(GBR_lst), dg(GCR_lst))),

  Grecpv2_upper : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    dg(dg(GCL_lst), dg(GTL_lst)), dg(dg(GCC_lst), dg(GTC_lst)), dg(dg(GCR_lst), dg(GTR_lst))),
  Grecpv2_lower :  calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    dg(bcs([der=2, val=d2g_surf_BL_pv2_e]), dg(GCL_lst)), dg(bcs([der=2, val=d2g_surf_BC_pv2_e]), dg(GCC_lst)),
    dg(bcs([der=2, val=d2g_surf_BR_pv2_e]), dg(GCR_lst))),


  /* Evaluate surface projection of dG/dpv1 at pv2 boundaries */
  surft1_upper_bottom_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_upper, pv1)),
  surft1_lower_bottom_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_lower, pv1)),

  surft1_upper_e : doExpand1(surft1_upper, bSurfpv2),
  surft1_lower_e : doExpand1(surft1_lower, bSurfpv2),

  surft1 : calcInnerProdList(surfVarspv2, 1, subst(pv2=1,bP), surft1_upper_e) +
    calcInnerProdList(surfVarspv2, -1, subst(pv2=-1,bP), surft1_lower_e),

  /* 1-cell recovery across +/-1 interfaces in pv1 */
  Grecpv1_upper : calcRecov2CellGen(basisFunc, pv1, varsP, polyOrder, dg(GCC_lst), dg(GCR_lst)),
  Grecpv1_lower : calcRecov2CellGen(basisFunc, pv1, varsP, polyOrder, dg(GCL_lst), dg(GCC_lst)),

  surft2_upper_bottom_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_upper)),
  surft2_lower_bottom_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_lower)),

  surft2_upper_e : doExpand1(surft2_upper, bSurfpv1),
  surft2_lower_e : doExpand1(surft2_lower, bSurfpv1),

  surft2 : calcInnerProdList(surfVarspv1, 1, subst(pv1=1,diff(bP, pv2)), surft2_upper_e) +
    calcInnerProdList(surfVarspv1, -1,  subst(pv1=-1,diff(bP, pv2)), surft2_lower_e),

  GCC_e : doExpand1(GCC, bP),
  vol : calcInnerProdList(varsP, 1, diff(diff(bP, pv1), pv2), GCC_e),

  diff_coeff_bottom : surft1 - surft2 + vol,

  /*
    Left
    +-----+-----+-----+
    | +++ | GTC | GTR |
    +-----+-----+-----+
    | +++ | GCC | GCR |
    +-----+-----+-----+
    | +++ | GBC | GBR |
    +-----+-----+-----+
  */ 
 
  disp("Left edge"),
  /* 6-cell recovery across +/-1 interfaces in pv2 */
  d2g_rec_upper : calcRecov2CellGen(basisFunc, pv2, surfVarspv1, polyOrder,
    dg(d2g_surf_CC_lst), dg(d2g_surf_TC_lst)),
  d2g_rec_lower : calcRecov2CellGen(basisFunc, pv2, surfVarspv1, polyOrder,
    dg(d2g_surf_BC_lst), dg(d2g_surf_CC_lst)),

  Grecpv2_upper : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    bc(D=1, N=0, val=subst(pv2=0, d2g_rec_upper)), dg(dg(GCC_lst), dg(GTC_lst)),
    dg(dg(GCR_lst), dg(GTR_lst))),
  Grecpv2_lower : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    bc(D=1, N=0, val=subst(pv2=0, d2g_rec_lower)), dg(dg(GBC_lst), dg(GCC_lst)), dg(dg(GBR_lst), dg(GCR_lst))),

  /* Evaluate surface projection of dG/dpv1 at pv2 boundaries */
  surft1_upper_left_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_upper, pv1)),
  surft1_lower_left_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_lower, pv1)),

  surft1_upper_e : doExpand1(surft1_upper, bSurfpv2),
  surft1_lower_e : doExpand1(surft1_lower, bSurfpv2),

  surft1 : calcInnerProdList(surfVarspv2, 1, subst(pv2=1,bP), surft1_upper_e) +
    calcInnerProdList(surfVarspv2, -1, subst(pv2=-1,bP), surft1_lower_e),

  /* 1-cell recovery across +/-1 interfaces in pv1 */
  Grecpv1_upper : calcRecov2CellGen(basisFunc, pv1, varsP, polyOrder, dg(GCC_lst), dg(GCR_lst)),
  Grecpv1_lower : calcRecov2CellGen(basisFunc, pv1, varsP, polyOrder, dg(GCL_lst), dg(GCC_lst)),

  surft2_upper_left_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_upper)),
  /* surft2_lower_left_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_lower)), */
  surft2_lower_left_c : g_surf_CC_lst,

  surft2_upper_e : doExpand1(surft2_upper, bSurfpv1),
  surft2_lower_e : doExpand1(surft2_lower, bSurfpv1),

  surft2 : calcInnerProdList(surfVarspv1, 1, subst(pv1=1,diff(bP, pv2)), surft2_upper_e) +
    calcInnerProdList(surfVarspv1, -1,  subst(pv1=-1,diff(bP, pv2)), surft2_lower_e),

  GCC_e : doExpand1(GCC, bP),
  vol : calcInnerProdList(varsP, 1, diff(diff(bP, pv1), pv2), GCC_e),

  diff_coeff_left : surft1 - surft2 + vol,

   /* 
    Right
    +-----+-----+-----+
    | GTL | GTC | +++ |
    +-----+-----+-----+
    | GCL | GCC | +++ |
    +-----+-----+-----+
    | GBL | GBC | +++ |
    +-----+-----+-----+
  */

  disp("Right edge"),
  /* 6-cell recovery across +/-1 interfaces in pv2 */
  d2g_rec_upper : calcRecov2CellGen(basisFunc, pv2, surfVarspv1, polyOrder,
    dg(d2g_surf_CC_lst), dg(d2g_surf_TC_lst)),
  d2g_rec_lower : calcRecov2CellGen(basisFunc, pv2, surfVarspv1, polyOrder,
    dg(d2g_surf_BC_lst), dg(d2g_surf_CC_lst)),

  Grecpv2_upper : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    dg(dg(GCL_lst), dg(GTL_lst)), dg(dg(GCC_lst), dg(GTC_lst)), 
    bc(D=1, N=0, val=subst(pv2=0, d2g_rec_upper))),
  Grecpv2_lower : calcRecovFaceGen(basisFunc, [pv2, pv1], varsP, 0, 0, polyOrder, 1,
    dg(dg(GBL_lst), dg(GCL_lst)), dg(dg(GBC_lst), dg(GCC_lst)), 
    bc(D=1, N=0, val=subst(pv2=0, d2g_rec_lower))),  

  /* Evaluate surface projection of dG/dpv1 at pv2 boundaries */
  surft1_upper_right_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_upper, pv1)),
  surft1_lower_right_c : calcInnerProdList(surfVarspv2, 1, bSurfpv2, diff(Grecpv2_lower, pv1)),

  surft1_upper_e : doExpand1(surft1_upper, bSurfpv2),
  surft1_lower_e : doExpand1(surft1_lower, bSurfpv2),

  surft1 : calcInnerProdList(surfVarspv2, 1, subst(pv2=1,bP), surft1_upper_e) +
    calcInnerProdList(surfVarspv2, -1, subst(pv2=-1,bP), surft1_lower_e),

  /* 1-cell recovery across +/-1 interfaces in pv1 */
  /*Grecpv1_upper : calcRecov2CellGen(basisFunc, pv1, varsP, polyOrder, dg(GCC_lst), dg(GCR_lst)),*/
  Grecpv1_upper : g_surf_CC_e,
  Grecpv1_lower : calcRecov2CellGen(basisFunc, pv1, varsP, polyOrder, dg(GCL_lst), dg(GCC_lst)),

  surft2_upper_right_c : g_surf_CC_lst,
/*  surft2_upper_right_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_upper)), */
  surft2_lower_right_c : calcInnerProdList(surfVarspv1, 1, bSurfpv1, subst(pv1=0, Grecpv1_lower)),

  surft2_upper_e : doExpand1(surft2_upper, bSurfpv1),
  surft2_lower_e : doExpand1(surft2_lower, bSurfpv1),

  surft2 : calcInnerProdList(surfVarspv1, 1, subst(pv1=1,diff(bP, pv2)), surft2_upper_e) +
    calcInnerProdList(surfVarspv1, -1,  subst(pv1=-1,diff(bP, pv2)), surft2_lower_e),

  GCC_e : doExpand1(GCC, bP),
  vol : calcInnerProdList(varsP, 1, diff(diff(bP, pv1), pv2), GCC_e),

  diff_coeff_right : surft1 - surft2 + vol,

 
  if (dir1=1 and dir2=2) then (
    out : diff_coeff_xy 
  )
  elseif (dir1=1 and dir2=3) then (
    out : diff_coeff_xz
  )
  elseif (dir1=2 and dir2=1) then (
    out : diff_coeff_yx
  )
  elseif (dir1=2 and dir2=3) then (
    out : diff_coeff_yz
  )
  elseif (dir1=3 and dir2=1) then (
    out : diff_coeff_zx 
  )
  elseif (dir1=3 and dir2=2) then (
    out : diff_coeff_zy
  ),

  printf(fh, "  if (edge == 0) {~%"),
  writeCExprs1(surft1_upper, surft1_upper_bottom_c),
  writeCExprs1(surft1_lower, surft1_lower_bottom_c),
  printf(fh, "~%"),
  writeCExprs1(surft2_upper, surft2_upper_bottom_c),
  writeCExprs1(surft2_lower, surft2_lower_bottom_c),
  printf(fh, "~%"),
  writeCExprs1(out, diff_coeff_bottom),
  printf(fh, "  } ~%"),

  printf(fh, "  else if (edge == 1) {~%"),
  writeCExprs1(surft1_upper, surft1_upper_left_c),
  writeCExprs1(surft1_lower, surft1_lower_left_c),
  printf(fh, "~%"),
  writeCExprs1(surft2_upper, surft2_upper_left_c),
  writeCExprs1(surft2_lower, surft2_lower_left_c),
  printf(fh, "~%"),
  writeCExprs1(out, diff_coeff_left),
  printf(fh, "  } ~%"),
  
  printf(fh, "  else if (edge == 2) {~%"),
  writeCExprs1(surft1_upper, surft1_upper_top_c),
  writeCExprs1(surft1_lower, surft1_lower_top_c),
  printf(fh, "~%"),
  writeCExprs1(surft2_upper, surft2_upper_top_c),
  writeCExprs1(surft2_lower, surft2_lower_top_c),
  printf(fh, "~%"),
  writeCExprs1(out, diff_coeff_top),
  printf(fh, "  } ~%"),

  printf(fh, "  else if (edge == 3) {~%"),
  writeCExprs1(surft1_upper, surft1_upper_right_c),
  writeCExprs1(surft1_lower, surft1_lower_right_c),
  printf(fh, "~%"),
  writeCExprs1(surft2_upper, surft2_upper_right_c),
  writeCExprs1(surft2_lower, surft2_lower_right_c),
  printf(fh, "~%"),
  writeCExprs1(out, diff_coeff_right),
  printf(fh, "  } ~%"),
  
  printf(fh, "}~%")

)$
