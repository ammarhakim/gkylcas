/* Generate kernels for the updater that computes the cross primitive moments 
   upar_ei and vtsq_ei (or upar_ie and vtsq_ie) used in the cross collision 
   terms, given the moments of electrons and ions. 
   Weak division and multiplication are employed. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions");
load(stringproc)$
fpprec : 24$

calcGKCrossPrimMomsBGK(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, NC],

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  print("gk ", cdim,"x", vdim, "v", polyOrder, "p"),
  
  /* Include the header files. */
  printf(fh, "#include <gkyl_gyrokinetic_cross_prim_moms_bgk_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_inv.h> ~%", basisFun, cdim, polyOrder),
  printf(fh, " ~%"),
  
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double delta_sr, const double betaGreenep1, const double m_self, const double *prim_moms_self, const double m_other, const double *prim_moms_other, double *prim_moms_cross) ~%{ ~%", funcNm),
  printf(fh, "  // delta_sr: Free parameter in relation between nu_sr and alpha_E. ~%"),
  printf(fh, "  // betaGreenep1: Greene's beta + 1. ~%"),
  printf(fh, "  // m_self: mass of this species. ~%"),
  printf(fh, "  // prim_moms_self: primitive moments of this species. ~%"),
  printf(fh, "  // m_other: mass of other species. ~%"),
  printf(fh, "  // prim_moms_other: primitive moments of other species. ~%"),
  printf(fh, "  // prim_moms_cross: cross primitive moments. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  const double m_s = m_self; ~%"),
  printf(fh, "  const double m_r = m_other; ~%"),
  /* Create pointers to the moments of each species. */
  printf(fh, "  const double *n_s = &prim_moms_self[~a]; ~%", 0),
  printf(fh, "  const double *upar_s = &prim_moms_self[~a]; ~%", NC),
  printf(fh, "  const double *vtsq_s = &prim_moms_self[~a]; ~%", NC*2),
  printf(fh, "  const double *n_r = &prim_moms_other[~a]; ~%", 0),
  printf(fh, "  const double *upar_r = &prim_moms_other[~a]; ~%", NC),
  printf(fh, "  const double *vtsq_r = &prim_moms_other[~a]; ~%", NC*2),
  printf(fh, " ~%"),
  /* Create pointers to the cross moments. */
  printf(fh, "  double *n_sr = &prim_moms_cross[~a]; ~%", 0),
  printf(fh, "  double *upar_sr = &prim_moms_cross[~a]; ~%", NC*1),
  printf(fh, "  double *vtsq_sr = &prim_moms_cross[~a]; ~%", NC*2),
  printf(fh, "~%"),

  /* Calculate cross density n_sr. */
  for i : 1 thru NC do (
    printf(fh, "  n_sr[~a] = n_s[~a]; ~%", i-1, i-1)
  ),
  printf(fh, " ~%"),

  /* Calculate cross parallel velocity upar_sr. */
  printf(fh, "  const double deltaTbetap1 = delta_sr*betaGreenep1;~%"),
  printf(fh, " ~%"),

  printf(fh, "  double dUpar[~a]; ~%", NC), 
  for i : 1 thru NC do (
    printf(fh, "  dUpar[~a] = upar_r[~a] - upar_s[~a]; ~%", i-1, i-1, i-1)
  ),
  for i : 1 thru NC do (
    printf(fh, "  upar_sr[~a] = upar_s[~a] + 0.5*deltaTbetap1*dUpar[~a]; ~%", i-1, i-1, i-1)
  ),
  printf(fh, " ~%"),
  
  /* Calculate cross thermal velocity square vtsq_sr. */
  printf(fh, "  const double vdimPhys = ~a; ~%", (vdim-1)*2+1),
  printf(fh, "  const double mSum = m_self + m_other;~%"),
  printf(fh, " ~%"),

  printf(fh, "  double dTemp[~a] = {0.0}; ~%", NC), 
  for i : 1 thru NC do (
    printf(fh, "  dTemp[~a] = vdimPhys * (m_r*vtsq_r[~a]-m_s*vtsq_s[~a]); ~%", i-1, i-1, i-1)
  ),

  printf(fh, "  double dUparSq[~a] = {0.0}; ~%", NC), 
  printf(fh, "  binop_mul_~ad_~a_p~a(dUpar, dUpar, dUparSq); ~%", cdim, basisFun, polyOrder),

  printf(fh, "  const double dUparSq_fac = (m_r-0.25*deltaTbetap1*mSum/vdimPhys);~%"),
  for i : 1 thru NC do (
    printf(fh, "  vtsq_sr[~a] = vtsq_s[~a] + deltaTbetap1/(vdimPhys*mSum)*(dTemp[~a]+dUparSq_fac*dUparSq[~a]); ~%", i-1, i-1, i-1, i-1)
  ),
  printf(fh, " ~%"),

  /* Turn collisions off when vtsq_sr is not positive-definite. */
  printf(fh, "  // If vtsq_sr is negative at a corner, turn off collisions.~%"),
  printf(fh, "  bool negative_cross_temp = false; ~%"),
  nodes : getNodes(basisFun, cdim, 1),
  vtsq_sr_e : doExpand1(vtsq_sr,bC),
  vtsq_sr_corners : gcfac(float(fullratsimp( evAtNodes(vtsq_sr_e,nodes,varsC) ))),
  for i : 1 thru length(nodes) do (
    printf(fh, "  if (~a < 0.0) negative_cross_temp = true; ~%", vtsq_sr_corners[i])
  ),
  printf(fh, "  if (negative_cross_temp) { ~%"),
  for j : 1 thru NC do (
    printf(fh, "    upar_sr[~a] = upar_s[~a]; ~%", j-1, j-1),
    printf(fh, "    vtsq_sr[~a] = vtsq_s[~a]; ~%", j-1, j-1)
  ),
  printf(fh, "  } ~%"),

  printf(fh, "} ~%")
)$
