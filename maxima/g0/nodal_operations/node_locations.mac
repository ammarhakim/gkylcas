load("nodal_operations/quadrature_functions")$

/* Location of Serendipity nodes in logical [-1,1]^d space,
   with d the number of dimensions.
   At least up to p=3 there's a basic algorithm that could be coded
   to generate these, but for now we simply type them up by hand. */
nodesSer1xp0 : matrix([0])$
nodesSer1xp1 : matrix([-1],[1])$
nodesSer1xp2 : matrix([-1],[0],[1])$
nodesSer1xp3 : matrix([-1],[-1/3],[1/3],[1])$
nodesSer1xp4 : matrix([-1],[-1/2],[0],[1/2],[1])$
nodesSer2xp0 : matrix([0,0])$
nodesSer2xp1 : matrix([-1,-1],[1,-1],[-1,1],[1,1])$
nodesSer2xp2 : matrix([-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1])$
nodesSer2xp3 : matrix([-1,-1],[-1/3,-1],[1/3,-1],[1,-1],[-1,-1/3],[1,-1/3],[-1,1/3],[1,1/3],[-1,1],[-1/3,1],[1/3,1],[1,1])$
nodesSer3xp0 : matrix([0,0,0])$
nodesSer3xp1 : matrix([-1,-1,-1],[1,-1,-1],[-1,1,-1],[1,1,-1],[-1,-1,1],[1,-1,1],[-1,1,1],[1,1,1])$
nodesSer3xp2 : matrix([-1,-1,-1],[0,-1,-1],[1,-1,-1],[-1,0,-1],[1,0,-1],[-1,1,-1],[0,1,-1],[1,1,-1],
                      [-1,-1,0],[1,-1,0],[-1,1,0],[1,1,0],
                      [-1,-1,1],[0,-1,1],[1,-1,1],[-1,0,1],[1,0,1],[-1,1,1],[0,1,1],[1,1,1])$
nodesSer3xp3 : matrix([-1,-1,-1],[-1/3,-1,-1],[1/3,-1,-1],[1,-1,-1],[-1,-1/3,-1],[1,-1/3,-1],[-1,1/3,-1],[1,1/3,-1],[-1,1,-1],[-1/3,1,-1],[1/3,1,-1],[1,1,-1],
                      [-1,-1,-1/3],[1,-1,-1/3],[-1,1,-1/3],[1,1,-1/3],
                      [-1,-1,1/3],[1,-1,1/3],[-1,1,1/3],[1,1,1/3],
                      [-1,-1,1],[-1/3,-1,1],[1/3,-1,1],[1,-1,1],[-1,-1/3,1],[1,-1/3,1],[-1,1/3,1],[1,1/3,1],[-1,1,1],[-1/3,1,1],[1/3,1,1],[1,1,1])$
nodesSer4xp0 : matrix([0,0,0,0])$
nodesSer4xp1 : matrix([-1,-1,-1,-1],[1,-1,-1,-1],[-1,1,-1,-1],[1,1,-1,-1],[-1,-1,1,-1],[1,-1,1,-1],[-1,1,1,-1],[1,1,1,-1],
                      [-1,-1,-1,1],[1,-1,-1,1],[-1,1,-1,1],[1,1,-1,1],[-1,-1,1,1],[1,-1,1,1],[-1,1,1,1],[1,1,1,1])$
nodesSer4xp2 : matrix([-1,-1,-1,-1],[0,-1,-1,-1],[1,-1,-1,-1],[-1,0,-1,-1],[1,0,-1,-1],[-1,1,-1,-1],[0,1,-1,-1],[1,1,-1,-1],
                      [-1,-1,0,-1],[1,-1,0,-1],[-1,1,0,-1],[1,1,0,-1],
                      [-1,-1,1,-1],[0,-1,1,-1],[1,-1,1,-1],[-1,0,1,-1],[1,0,1,-1],[-1,1,1,-1],[0,1,1,-1],[1,1,1,-1],
                      [-1,-1,-1,0],[1,-1,-1,0],[-1,1,-1,0],[1,1,-1,0],[-1,-1,1,0],[1,-1,1,0],[-1,1,1,0],[1,1,1,0],
                      [-1,-1,-1,1],[0,-1,-1,1],[1,-1,-1,1],[-1,0,-1,1],[1,0,-1,1],[-1,1,-1,1],[0,1,-1,1],[1,1,-1,1],
                      [-1,-1,0,1],[1,-1,0,1],[-1,1,0,1],[1,1,0,1],
                      [-1,-1,1,1],[0,-1,1,1],[1,-1,1,1],[-1,0,1,1],[1,0,1,1],[-1,1,1,1],[0,1,1,1],[1,1,1,1])$
nodesSer4xp3 : matrix([-1,-1,-1,-1],[-1/3,-1,-1,-1],[1/3,-1,-1,-1],[1,-1,-1,-1],[-1,-1/3,-1,-1],[1,-1/3,-1,-1],[-1,1/3,-1,-1],[1,1/3,-1,-1],[-1,1,-1,-1],[-1/3,1,-1,-1],[1/3,1,-1,-1],[1,1,-1,-1],
                      [-1,-1,-1/3,-1],[1,-1,-1/3,-1],[-1,1,-1/3,-1],[1,1,-1/3,-1],
                      [-1,-1,1/3,-1],[1,-1,1/3,-1],[-1,1,1/3,-1],[1,1,1/3,-1],
                      [-1,-1,1,-1],[-1/3,-1,1,-1],[1/3,-1,1,-1],[1,-1,1,-1],[-1,-1/3,1,-1],[1,-1/3,1,-1],[-1,1/3,1,-1],[1,1/3,1,-1],[-1,1,1,-1],[-1/3,1,1,-1],[1/3,1,1,-1],[1,1,1,-1],
                      [-1,-1,-1,-1/3],[1,-1,-1,-1/3],[-1,1,-1,-1/3],[1,1,-1,-1/3],
                      [-1,-1,1,-1/3],[1,-1,1,-1/3],[-1,1,1,-1/3],[1,1,1,-1/3],
                      [-1,-1,-1,1/3],[1,-1,-1,1/3],[-1,1,-1,1/3],[1,1,-1,1/3],
                      [-1,-1,1,1/3],[1,-1,1,1/3],[-1,1,1,1/3],[1,1,1,1/3],
                      [-1,-1,-1,1],[-1/3,-1,-1,1],[1/3,-1,-1,1],[1,-1,-1,1],[-1,-1/3,-1,1],[1,-1/3,-1,1],[-1,1/3,-1,1],[1,1/3,-1,1],[-1,1,-1,1],[-1/3,1,-1,1],[1/3,1,-1,1],[1,1,-1,1],
                      [-1,-1,-1/3,1],[1,-1,-1/3,1],[-1,1,-1/3,1],[1,1,-1/3,1],
                      [-1,-1,1/3,1],[1,-1,1/3,1],[-1,1,1/3,1],[1,1,1/3,1],
                      [-1,-1,1,1],[-1/3,-1,1,1],[1/3,-1,1,1],[1,-1,1,1],[-1,-1/3,1,1],[1,-1/3,1,1],[-1,1/3,1,1],[1,1/3,1,1],[-1,1,1,1],[-1/3,1,1,1],[1/3,1,1,1],[1,1,1,1])$
nodesSer5xp0 : matrix([0,0,0,0,0])$
nodesSer5xp1 : matrix([-1,-1,-1,-1,-1],[1,-1,-1,-1,-1],[-1,1,-1,-1,-1],[1,1,-1,-1,-1],[-1,-1,1,-1,-1],[1,-1,1,-1,-1],[-1,1,1,-1,-1],[1,1,1,-1,-1],
                      [-1,-1,-1,1,-1],[1,-1,-1,1,-1],[-1,1,-1,1,-1],[1,1,-1,1,-1],[-1,-1,1,1,-1],[1,-1,1,1,-1],[-1,1,1,1,-1],[1,1,1,1,-1],
                      [-1,-1,-1,-1,1],[1,-1,-1,-1,1],[-1,1,-1,-1,1],[1,1,-1,-1,1],[-1,-1,1,-1,1],[1,-1,1,-1,1],[-1,1,1,-1,1],[1,1,1,-1,1],
                      [-1,-1,-1,1,1],[1,-1,-1,1,1],[-1,1,-1,1,1],[1,1,-1,1,1],[-1,-1,1,1,1],[1,-1,1,1,1],[-1,1,1,1,1],[1,1,1,1,1])$
nodesSer5xp2 : matrix([-1,-1,-1,-1,-1],[0,-1,-1,-1,-1],[1,-1,-1,-1,-1],[-1,0,-1,-1,-1],[1,0,-1,-1,-1],[-1,1,-1,-1,-1],[0,1,-1,-1,-1],[1,1,-1,-1,-1],
                      [-1,-1,0,-1,-1],[1,-1,0,-1,-1],[-1,1,0,-1,-1],[1,1,0,-1,-1],
                      [-1,-1,1,-1,-1],[0,-1,1,-1,-1],[1,-1,1,-1,-1],[-1,0,1,-1,-1],[1,0,1,-1,-1],[-1,1,1,-1,-1],[0,1,1,-1,-1],[1,1,1,-1,-1],
                      [-1,-1,-1,0,-1],[1,-1,-1,0,-1],[-1,1,-1,0,-1],[1,1,-1,0,-1],[-1,-1,1,0,-1],[1,-1,1,0,-1],[-1,1,1,0,-1],[1,1,1,0,-1],
                      [-1,-1,-1,1,-1],[0,-1,-1,1,-1],[1,-1,-1,1,-1],[-1,0,-1,1,-1],[1,0,-1,1,-1],[-1,1,-1,1,-1],[0,1,-1,1,-1],[1,1,-1,1,-1],
                      [-1,-1,0,1,-1],[1,-1,0,1,-1],[-1,1,0,1,-1],[1,1,0,1,-1],
                      [-1,-1,1,1,-1],[0,-1,1,1,-1],[1,-1,1,1,-1],[-1,0,1,1,-1],[1,0,1,1,-1],[-1,1,1,1,-1],[0,1,1,1,-1],[1,1,1,1,-1],
                      [-1,-1,-1,-1,0],[1,-1,-1,-1,0],[-1,1,-1,-1,0],[1,1,-1,-1,0],[-1,-1,1,-1,0],[1,-1,1,-1,0],[-1,1,1,-1,0],[1,1,1,-1,0],
                      [-1,-1,-1,1,0],[1,-1,-1,1,0],[-1,1,-1,1,0],[1,1,-1,1,0],[-1,-1,1,1,0],[1,-1,1,1,0],[-1,1,1,1,0],[1,1,1,1,0],
                      [-1,-1,-1,-1,1],[0,-1,-1,-1,1],[1,-1,-1,-1,1],[-1,0,-1,-1,1],[1,0,-1,-1,1],[-1,1,-1,-1,1],[0,1,-1,-1,1],[1,1,-1,-1,1],
                      [-1,-1,0,-1,1],[1,-1,0,-1,1],[-1,1,0,-1,1],[1,1,0,-1,1],
                      [-1,-1,1,-1,1],[0,-1,1,-1,1],[1,-1,1,-1,1],[-1,0,1,-1,1],[1,0,1,-1,1],[-1,1,1,-1,1],[0,1,1,-1,1],[1,1,1,-1,1],
                      [-1,-1,-1,0,1],[1,-1,-1,0,1],[-1,1,-1,0,1],[1,1,-1,0,1],[-1,-1,1,0,1],[1,-1,1,0,1],[-1,1,1,0,1],[1,1,1,0,1],
                      [-1,-1,-1,1,1],[0,-1,-1,1,1],[1,-1,-1,1,1],[-1,0,-1,1,1],[1,0,-1,1,1],[-1,1,-1,1,1],[0,1,-1,1,1],[1,1,-1,1,1],
                      [-1,-1,0,1,1],[1,-1,0,1,1],[-1,1,0,1,1],[1,1,0,1,1],
                      [-1,-1,1,1,1],[0,-1,1,1,1],[1,-1,1,1,1],[-1,0,1,1,1],[1,0,1,1,1],[-1,1,1,1,1],[0,1,1,1,1],[1,1,1,1,1])$
nodesSer5xp3 : matrix([-1,-1,-1,-1,-1],[-1/3,-1,-1,-1,-1],[1/3,-1,-1,-1,-1],[1,-1,-1,-1,-1],[-1,-1/3,-1,-1,-1],[1,-1/3,-1,-1,-1],[-1,1/3,-1,-1,-1],[1,1/3,-1,-1,-1],[-1,1,-1,-1,-1],[-1/3,1,-1,-1,-1],[1/3,1,-1,-1,-1],[1,1,-1,-1,-1],
                      [-1,-1,-1/3,-1,-1],[1,-1,-1/3,-1,-1],[-1,1,-1/3,-1,-1],[1,1,-1/3,-1,-1],
                      [-1,-1,1/3,-1,-1],[1,-1,1/3,-1,-1],[-1,1,1/3,-1,-1],[1,1,1/3,-1,-1],
                      [-1,-1,1,-1,-1],[-1/3,-1,1,-1,-1],[1/3,-1,1,-1,-1],[1,-1,1,-1,-1],[-1,-1/3,1,-1,-1],[1,-1/3,1,-1,-1],[-1,1/3,1,-1,-1],[1,1/3,1,-1,-1],[-1,1,1,-1,-1],[-1/3,1,1,-1,-1],[1/3,1,1,-1,-1],[1,1,1,-1,-1],
                      [-1,-1,-1,-1/3,-1],[1,-1,-1,-1/3,-1],[-1,1,-1,-1/3,-1],[1,1,-1,-1/3,-1],
                      [-1,-1,1,-1/3,-1],[1,-1,1,-1/3,-1],[-1,1,1,-1/3,-1],[1,1,1,-1/3,-1],
                      [-1,-1,-1,1/3,-1],[1,-1,-1,1/3,-1],[-1,1,-1,1/3,-1],[1,1,-1,1/3,-1],
                      [-1,-1,1,1/3,-1],[1,-1,1,1/3,-1],[-1,1,1,1/3,-1],[1,1,1,1/3,-1],
                      [-1,-1,-1,1,-1],[-1/3,-1,-1,1,-1],[1/3,-1,-1,1,-1],[1,-1,-1,1,-1],[-1,-1/3,-1,1,-1],[1,-1/3,-1,1,-1],[-1,1/3,-1,1,-1],[1,1/3,-1,1,-1],[-1,1,-1,1,-1],[-1/3,1,-1,1,-1],[1/3,1,-1,1,-1],[1,1,-1,1,-1],
                      [-1,-1,-1/3,1,-1],[1,-1,-1/3,1,-1],[-1,1,-1/3,1,-1],[1,1,-1/3,1,-1],
                      [-1,-1,1/3,1,-1],[1,-1,1/3,1,-1],[-1,1,1/3,1,-1],[1,1,1/3,1,-1],
                      [-1,-1,1,1,-1],[-1/3,-1,1,1,-1],[1/3,-1,1,1,-1],[1,-1,1,1,-1],[-1,-1/3,1,1,-1],[1,-1/3,1,1,-1],[-1,1/3,1,1,-1],[1,1/3,1,1,-1],[-1,1,1,1,-1],[-1/3,1,1,1,-1],[1/3,1,1,1,-1],[1,1,1,1,-1],
                      [-1,-1,-1,-1,-1/3],[1,-1,-1,-1,-1/3],[-1,1,-1,-1,-1/3],[1,1,-1,-1,-1/3],
                      [-1,-1,1,-1,-1/3],[1,-1,1,-1,-1/3],[-1,1,1,-1,-1/3],[1,1,1,-1,-1/3],
                      [-1,-1,-1,1,-1/3],[1,-1,-1,1,-1/3],[-1,1,-1,1,-1/3],[1,1,-1,1,-1/3],
                      [-1,-1,1,1,-1/3],[1,-1,1,1,-1/3],[-1,1,1,1,-1/3],[1,1,1,1,-1/3],
                      [-1,-1,-1,-1,1/3],[1,-1,-1,-1,1/3],[-1,1,-1,-1,1/3],[1,1,-1,-1,1/3],
                      [-1,-1,1,-1,1/3],[1,-1,1,-1,1/3],[-1,1,1,-1,1/3],[1,1,1,-1,1/3],
                      [-1,-1,-1,1,1/3],[1,-1,-1,1,1/3],[-1,1,-1,1,1/3],[1,1,-1,1,1/3],
                      [-1,-1,1,1,1/3],[1,-1,1,1,1/3],[-1,1,1,1,1/3],[1,1,1,1,1/3],
                      [-1,-1,-1,-1,1],[-1/3,-1,-1,-1,1],[1/3,-1,-1,-1,1],[1,-1,-1,-1,1],[-1,-1/3,-1,-1,1],[1,-1/3,-1,-1,1],[-1,1/3,-1,-1,1],[1,1/3,-1,-1,1],[-1,1,-1,-1,1],[-1/3,1,-1,-1,1],[1/3,1,-1,-1,1],[1,1,-1,-1,1],
                      [-1,-1,-1/3,-1,1],[1,-1,-1/3,-1,1],[-1,1,-1/3,-1,1],[1,1,-1/3,-1,1],
                      [-1,-1,1/3,-1,1],[1,-1,1/3,-1,1],[-1,1,1/3,-1,1],[1,1,1/3,-1,1],
                      [-1,-1,1,-1,1],[-1/3,-1,1,-1,1],[1/3,-1,1,-1,1],[1,-1,1,-1,1],[-1,-1/3,1,-1,1],[1,-1/3,1,-1,1],[-1,1/3,1,-1,1],[1,1/3,1,-1,1],[-1,1,1,-1,1],[-1/3,1,1,-1,1],[1/3,1,1,-1,1],[1,1,1,-1,1],
                      [-1,-1,-1,-1/3,1],[1,-1,-1,-1/3,1],[-1,1,-1,-1/3,1],[1,1,-1,-1/3,1],
                      [-1,-1,1,-1/3,1],[1,-1,1,-1/3,1],[-1,1,1,-1/3,1],[1,1,1,-1/3,1],
                      [-1,-1,-1,1/3,1],[1,-1,-1,1/3,1],[-1,1,-1,1/3,1],[1,1,-1,1/3,1],
                      [-1,-1,1,1/3,1],[1,-1,1,1/3,1],[-1,1,1,1/3,1],[1,1,1,1/3,1],
                      [-1,-1,-1,1,1],[-1/3,-1,-1,1,1],[1/3,-1,-1,1,1],[1,-1,-1,1,1],[-1,-1/3,-1,1,1],[1,-1/3,-1,1,1],[-1,1/3,-1,1,1],[1,1/3,-1,1,1],[-1,1,-1,1,1],[-1/3,1,-1,1,1],[1/3,1,-1,1,1],[1,1,-1,1,1],
                      [-1,-1,-1/3,1,1],[1,-1,-1/3,1,1],[-1,1,-1/3,1,1],[1,1,-1/3,1,1],
                      [-1,-1,1/3,1,1],[1,-1,1/3,1,1],[-1,1,1/3,1,1],[1,1,1/3,1,1],
                      [-1,-1,1,1,1],[-1/3,-1,1,1,1],[1/3,-1,1,1,1],[1,-1,1,1,1],[-1,-1/3,1,1,1],[1,-1/3,1,1,1],[-1,1/3,1,1,1],[1,1/3,1,1,1],[-1,1,1,1,1],[-1/3,1,1,1,1],[1/3,1,1,1,1],[1,1,1,1,1])$
nodesSer6xp0 : matrix([0,0,0,0,0,0])$

/* A set of serendipity nodes without the corners. */
nodesSerNC2xp3 : matrix([-1/3,-1],[1/3,-1],[-1,-1/3],[1,-1/3],[-1,1/3],[1,1/3],[-1/3,1],[1/3,1])$
nodesSerNC3xp3 : matrix([-1/3,-1,-1],[1/3,-1,-1],[-1,-1/3,-1],[1,-1/3,-1],[-1,1/3,-1],[1,1/3,-1],[-1/3,1,-1],[1/3,1,-1],
                      [-1,-1,-1/3],[1,-1,-1/3],[-1,1,-1/3],[1,1,-1/3],
                      [-1,-1,1/3],[1,-1,1/3],[-1,1,1/3],[1,1,1/3],
                      [-1/3,-1,1],[1/3,-1,1],[-1,-1/3,1],[1,-1/3,1],[-1,1/3,1],[1,1/3,1],[-1/3,1,1],[1/3,1,1])$

/* Nodes for hybrid basis that is a Cartesian product of p=1 Ser in
   configuration space and p=2 in velocity space. */
getNodesHyb(cdim, vdim) := block([cnodes,vnodes,nodeLst],
  cnodes  : args(eval_string(sconcat("nodesSer",cdim,"xp",1))),
  vnodes  : args(eval_string(sconcat("nodesSer",vdim,"xp",2))),
  nodeLst : listify(cartesian_product(setify(cnodes),setify(vnodes))),
  nodes   : apply('matrix,makelist(flatten(nodeLst[i]),i,1,length(nodeLst))),
  return(nodes)
)$

/* Nodes for GK hybrid basis that is a Cartesian product of p=2 Ser in
   vpar and p=1 in other dimensions. */
getNodesGkHyb(cdim, vdim) := block([cnodes,vparnodes,munodes,nodeLst],
  if cdim = 0 then (
    vparnodes : args(eval_string(sconcat("nodesSer",1,"xp",2))),
    if vdim=1 then (
      nodeLst : vparnodes
    ) elseif vdim=2 then (
      munodes : args(eval_string(sconcat("nodesSer",1,"xp",1))),
      nodeLst : listify(cartesian_product(setify(vparnodes),setify(munodes)))
    )
  ) else (
    cnodes    : args(eval_string(sconcat("nodesSer",cdim,"xp",1))),
    vparnodes : args(eval_string(sconcat("nodesSer",1,"xp",2))),
    if vdim=1 then (
      nodeLst : listify(cartesian_product(setify(cnodes),setify(vparnodes)))
    ) elseif vdim=2 then (
      munodes : args(eval_string(sconcat("nodesSer",1,"xp",1))),
      nodeLst : listify(cartesian_product(setify(cnodes),setify(vparnodes),setify(munodes)))
    )
  ),
  nodes : apply('matrix,makelist(flatten(nodeLst[i]),i,1,length(nodeLst))),
  return(nodes)
)$

/* Function that returns the nodes for given basis,
   dimensionality and polynomial order.
   Note: Vlasov hybrid basis (hyb) should use getNodesHyb because those
         need cdim and vdim as inputs. GK hybrid (gkhyb) use getNodesGkHyb. */
getNodes(basisType, dim, polyOrder) := block(
  [nodes,nodes1D,n1D,d,numNodesC,numNodes,iR,n,i,newCoord],
  nodes : 0,
  if (basisType = "Ser") or (basisType = "ser") then (
    /* Serendipity basis. */
    nodes : eval_string(sconcat("nodesSer",dim,"xp",polyOrder))
  ) elseif (basisType = "Tensor") or (basisType = "tensor") then (
    /* Tensor product basis. */
    if (dim=1) or (dim=2 and polyOrder=1) then (
      nodes : eval_string(sconcat("nodesSer",dim,"xp",polyOrder))
    ) else (
      nodes1D : eval_string(sconcat("nodesSer1xp",polyOrder)),
      n1D     : length(nodes1D),
      nodes   : nodes1D,
      for d : 2 thru dim do (
        numNodesC : length(nodes),
        numNodes  : n1D^d,
        iR : 0,
        for n : 1 thru ((n1D^d-numNodesC)/n1D) do (
          for i : 1 thru n1D do (
            iR : iR+1,
            nodes : addrow(nodes,nodes[iR])
          )
        ),
        newCoord : [],
        for n : 1 thru n1D do (
          newCoord : append(newCoord,makelist(nodes1D[n][1],i,1,numNodes/n1D))
        ),
        nodes : addcol(nodes,newCoord)
      )
    )
  ) else (
    error(basisType="unknown")
  ),
  return(args(nodes))
)$

/* Nodes for tensor hybrid basis that is a Cartesian product of p=1 Tensor in
   configuration space and p=2 Tensor in velocity space. */
getNodesTenHyb(cdim, vdim) := block([cnodes,vnodes,nodeLst],
  cnodes  : getNodes("tensor", cdim, 1),
  vnodes  : getNodes("tensor", vdim, 2),
  nodeLst : listify(cartesian_product(setify(cnodes),setify(vnodes))),
  nodes   : apply('matrix,makelist(flatten(nodeLst[i]),i,1,length(nodeLst))),
  return(nodes)
)$

/* Function that returns the quadrature nodes for a given
   dimensionality and polynomial order. */
getQuadNodes(dim, polyOrder) := block([nodes],
  nodes : gaussOrd(polyOrder+1, dim),
  return(nodes)
)$
