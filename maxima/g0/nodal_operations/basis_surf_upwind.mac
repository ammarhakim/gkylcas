load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodalOperations/nodalFunctions")$
fpprec : 24$

/* ...... USER INPUTS........ */

/* Serendipity basis. */
minPolyOrder_Ser : 1$
maxPolyOrder_Ser : 2$
minCdim_Ser : 1$
minVdim_Ser : 1$    /* see begining of v loop below though. */
maxCdim_Ser : 3$
maxVdim_Ser : 3$

/* Tensor product basis. */
/* Note that Serendipity, p = 1, is equivalent to Tensor */
/* Thus no need to calculate p = 1 Tensor basis */
minPolyOrder_Tensor : 2$
maxPolyOrder_Tensor : 2$
minCdim_Tensor : 1$
minVdim_Tensor : 1$    /* see begining of v loop below though. */
maxCdim_Tensor : 2$
maxVdim_Tensor : 3$

/* ...... END OF USER INPUTS........ */

bName        : ["ser","tensor"]$
minPolyOrder : [minPolyOrder_Ser, minPolyOrder_Tensor]$
maxPolyOrder : [maxPolyOrder_Ser, maxPolyOrder_Tensor]$
minCdim      : [minCdim_Ser, minCdim_Tensor]$
minVdim      : [minVdim_Ser, minVdim_Tensor]$
maxCdim      : [maxCdim_Ser, maxCdim_Tensor]$
maxVdim      : [maxVdim_Ser, maxVdim_Tensor]$

/* Compute the surface contribution in velocity space from the acceleration term */
for bInd : 1 thru length(bName) do (
  for c : minCdim[bInd] thru maxCdim[bInd] do (
    for v : max(c,minVdim[bInd]) thru maxVdim[bInd] do (

      minPolyOrderB : minPolyOrder[bInd],
      maxPolyOrderB : maxPolyOrder[bInd],
      if (c+v>4 and maxPolyOrderB > 1) then maxPolyOrderB : 1,
      for polyOrder : minPolyOrderB thru maxPolyOrderB do (
        disp(printf(false,sconcat("Creating phase space surface quadrature evaluation ",bName[bInd]," ~ax~av_p~a"),c,v,polyOrder)),
        kill(varsC, varsP, basisC, basisP, surfVars, bSurf),
        load(sconcat("basis-precalc/basis", bName[bInd], c, "x", v, "v")),
        bP    : basisP[polyOrder],
        bC    : basisC[polyOrder],
        varsC : slcn(varsP, c),
        numC  : length(bC),
        numP  : length(bP),
        pDim  : length(varsP),
        /* Scale nodes of the nodal basis by corresponding factors to obtain the Gauss-Legendre quadrature points */
        surfNodes : getNodes("Tensor", pDim-1, polyOrder),
        if polyOrder=1 then (surfNodes:surfNodes*(1/sqrt(3))) elseif polyOrder=2 then (surfNodes:surfNodes*sqrt(3/5)),
        numNodes : length(surfNodes),
        f_e : doExpand1(f, bP),

	/* xv = variable in direction of surface update. */
	xv : varsP[c],
	/* Surface variables to integrate over. */
	surfVars : delete(xv,varsP),
	/* Generate surface basis. this produces the ndim-1 orthogonal basis with no xv dependence. */
	bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsP,1,bP,subst([xv^2=var2,var2=1/3,xv=0],bP)))*bP),

	fname : sconcat("~/max-out/gkyl_basis_",bName[bInd],"_", c, "x", v, "v_p", polyOrder, "_upwind", ".h"),
	fh : openw(fname),
	printf(fh, "GKYL_CU_DH static inline void ~%"),
	printf(fh, "~a_~ax~av_p~a_upwind(const double* fUpwindQuad, double* GKYL_RESTRICT fUpwind) { ~%", bName[bInd], c, v, polyOrder),
	if (bName[bInd] = "Tensor") or (bName[bInd] = "tensor") or (polyOrder = 1) then (
	  /* Get modal surface expansion from nodal quadrature points. */
	  nodToMod : calcNodToModWithNodes(bName[bInd], pDim-1, polyOrder, surfNodes),
	  fUp_c : gcfac(fullratsimp(nodToMod . makelist(fUpwindQuad[i-1],i,1,numNodes))),
	  fUp_c : makelist(fUp_c[i][1],i,1,numNodes),
	  /* Write coefficients of modal surface expansion fupwind. */
	  /* Clever factorization is possible for polyOrder = 1, but for higher
	     polynomial orders, factorization is *too* clever and can lead to 
	     deeply nested parentheses, not ideal for compiler optimizations */
	  if (polyOrder = 1) then (
	    writeCExprsNoExpand1(fUpwind, fUp_c)
	  ) else (
	    writeCExprs1(fUpwind, fUp_c)
	  ),
	  printf(fh, "~%"),
	  flush_output(fh)
	) else (
	  /* Make nodal expansions in nodal basis */
	  /* Only required if basis type is not tensor */
	  /* If basis type is tensor (or polyOrder = 1 Serendipity), then well-defined intermediate
	     transformation back from nodal basis to modal basis, otherwise need nodal basis for 
	     final computation of Ghat */
	  basisNodal : getVarsNodalBasisWithNodes("Tensor", pDim-1, polyOrder, surfVars, surfNodes),
	  fHatNodal_e : sum(fUpwindQuad[i-1]*basisNodal[i], i, 1, length(basisNodal)),
	  fHatModProj_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_e)),

	  /* Write out projection of tensor nodal basis onto modal basis (usually Serendipity here) */
	  writeCExprs1(fUpwind, fHatModProj_e),
	  flush_output(fh)
	),
	printf(fh, "} ~%"),
	close(fh)
      )
    ),
    minPolyOrderB : minPolyOrder[bInd],
    maxPolyOrderB : maxPolyOrder[bInd],
    /* if only 1D, don't generate configurations space upwind quadrature evaluation, since no surface to specify quad points on */
    if (c=1 and maxPolyOrderB > 1) then maxPolyOrderB : 0,
    if (c=3 and maxPolyOrderB > 1) then maxPolyOrderB : 1,
    for polyOrder : minPolyOrderB thru maxPolyOrderB do (
      disp(printf(false,sconcat("Creating configuration space surface quadrature evaluation ",bName[bInd]," ~ax_p~a"),c,polyOrder)),
      kill(varsC, basisC,surfNodes,surfVars,bSurf),
      load(sconcat("basis-precalc/basis", bName[bInd], c, "x")),
      bC : basisC[polyOrder],
      numC  : length(bC),
      /* Scale nodes of the nodal basis by corresponding factors to obtain the Gauss-Legendre quadrature points */
      surfNodes : getNodes("Tensor", c-1, polyOrder),
      if polyOrder=1 then (surfNodes:surfNodes*(1/sqrt(3))) elseif polyOrder=2 then (surfNodes:surfNodes*sqrt(3/5)),
      numNodes : length(surfNodes),    
      f_e : doExpand1(f, bC),

      /* cv = variable in direction of surface update. */
      cv : varsC[c],
      /* Surface variables to integrate over. */
      surfVars : delete(cv,varsC),
      /* Generate surface basis. this produces the ndim-1 orthogonal basis with no cv dependence. */
      bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsC,1,bC,subst([cv^2=var2,var2=1/3,cv=0],bC)))*bC),

      fname : sconcat("~/max-out/gkyl_basis_",bName[bInd],"_", c, "x_p", polyOrder, "_upwind", ".h"),
      fh : openw(fname),
      printf(fh, "GKYL_CU_DH static inline void ~%"),
      printf(fh, "~a_~ax_p~a_upwind(const double* fUpwindQuad, double* GKYL_RESTRICT fUpwind) { ~%", bName[bInd], c, polyOrder),

      if (bName[bInd] = "Tensor") or (bName[bInd] = "tensor") or (polyOrder = 1) then (
	/* Get modal surface expansion from nodal quadrature points. */
	nodToMod : calcNodToModWithNodes(bName[bInd], pDim-1, polyOrder, surfNodes),
	fUp_c : gcfac(fullratsimp(nodToMod . makelist(fUpwindQuad[i-1],i,1,numNodes))),
	fUp_c : makelist(fUp_c[i][1],i,1,numNodes),
	/* Write coefficients of modal surface expansion fupwind. */
	/* Clever factorization is possible for polyOrder = 1, but for higher
	   polynomial orders, factorization is *too* clever and can lead to 
	   deeply nested parentheses, not ideal for compiler optimizations */
	if (polyOrder = 1) then (
	  writeCExprsNoExpand1(fUpwind, fUp_c)
	) else (
	  writeCExprs1(fUpwind, fUp_c)
	),
	printf(fh, "~%"),
	flush_output(fh)
      ) else (
	/* Make nodal expansions in nodal basis */
	/* Only required if basis type is not tensor */
	/* If basis type is tensor (or polyOrder = 1 Serendipity), then well-defined intermediate
	   transformation back from nodal basis to modal basis, otherwise need nodal basis for 
	   final computation of Ghat */
	basisNodal : getVarsNodalBasisWithNodes("Tensor", pDim-1, polyOrder, surfVars, surfNodes),
	fHatNodal_e : sum(fUpwindQuad[i-1]*basisNodal[i], i, 1, length(basisNodal)),
	fHatModProj_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_e)),

	/* Write out projection of tensor nodal basis onto modal basis (usually Serendipity here) */
	writeCExprs1(fUpwind, fHatModProj_e),
	flush_output(fh)
      ),
      printf(fh, "} ~%"),
      close(fh)
    )
  )
);
