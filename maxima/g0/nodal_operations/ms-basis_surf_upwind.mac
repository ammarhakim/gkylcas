/* Generate kernels that take the upwinded f at quadrature nodes,
   and does a nodal-to-modal transformation to yield the DG
   coefficients of the upwinded f. */
load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

/* ...... USER INPUTS........ */

/* Serendipity basis. */
minPolyOrder_Ser : 1$
maxPolyOrder_Ser : 2$
minCdim_Ser : 1$
minVdim_Ser : 1$    /* see begining of v loop below though. */
maxCdim_Ser : 3$
maxVdim_Ser : 3$

/* Tensor product basis. */
/* Note that Serendipity, p = 1, is equivalent to Tensor */
/* Thus no need to calculate p = 1 Tensor basis */
minPolyOrder_Tensor : 2$
maxPolyOrder_Tensor : 2$
minCdim_Tensor : 1$
minVdim_Tensor : 1$    /* see begining of v loop below though. */
maxCdim_Tensor : 2$
maxVdim_Tensor : 3$

/* Hybrid basis. */
minCdim_hyb : 1$
maxCdim_hyb : 3$
vDims_hyb : [[1,2,3], [2,3], [3]]$  /* Vdim for each of Cdim. */

/* GK hybrid basis. */
minCdim_gk_hyb : 1$
maxCdim_gk_hyb : 3$
vDims_gk_hyb : [[1,2], [2], [2]]$  /* Vdim for each of Cdim. */

/* ...... END OF USER INPUTS........ */

bName        : ["ser","tensor"]$
minPolyOrder : [minPolyOrder_Ser, minPolyOrder_Tensor]$
maxPolyOrder : [maxPolyOrder_Ser, maxPolyOrder_Tensor]$
minCdim      : [minCdim_Ser, minCdim_Tensor]$
minVdim      : [minVdim_Ser, minVdim_Tensor]$
maxCdim      : [maxCdim_Ser, maxCdim_Tensor]$
maxVdim      : [maxVdim_Ser, maxVdim_Tensor]$

bNameHyb   : ["hyb","gk_hyb"]$
minCdimHyb : [minCdim_hyb, minCdim_gk_hyb]$
maxCdimHyb : [maxCdim_hyb, maxCdim_gk_hyb]$
vDims      : [vDims_hyb, vDims_gk_hyb]$

genSurfUpdwindQuadToModalKernel(cdim, vdim, basisName, pOrder) := block(
  [pdim,vars,basis,surfNodes,numNodes,f_e,xv,surfVars,
   bSurf,fname,fh,basisNodal,fHatNodal_e,fHatModProj_e],

  pdim : cdim+vdim,

  [vars,basis] : loadBasis(basisName, pdim, pOrder),

  /* Surface nodes given by tensor product of Gauss-Legendre quadrature points. */
  surfNodes : gaussOrd(pOrder+1, pdim-1),
  numNodes  : length(surfNodes),

  f_e : doExpand1(f, basis),
  /* xv = variable in direction of surface update.
     Note that which variable is deleted for this operation is irrelevant.
     The projection from the surface (tensor) nodal basis to the modal basis
     only depends on dimensionality  */
  xv : vars[cdim],
  /* Surface variables to integrate over. */
  surfVars : delete(xv,vars),
  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no xv dependence. */
  bSurf : basisFromVars(basisName,surfVars,pOrder),

  fname : sconcat("~/max-out/gkyl_basis_",basisName,"_", pdim, "x_p", pOrder, "_upwind_quad_to_modal", ".h"),
  fh : openw(fname),
  printf(fh, "GKYL_CU_DH static inline void ~%"),
  printf(fh, "~a_~ax_p~a_upwind_quad_to_modal(const double* fUpwindQuad, double* GKYL_RESTRICT fUpwind) { ~%", basisName, pdim, pOrder),

  /* Make nodal expansions in tensor nodal basis where nodes are Gauss-Legendre quadrature points */
  basisNodal  : getVarsNodalBasisWithNodes("Tensor", pdim-1, pOrder, surfVars, surfNodes),
  fHatNodal_e : doExpand1(fUpwindQuad,basisNodal),
  /* Project nodal basis back onto modal basis */
  fHatModProj_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_e)),

  /* Write out projection of tensor nodal basis onto modal basis */
  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then (
    writeCExprsNoExpand1(fUpwind, fHatModProj_e)
  ) else (
    writeCExprs1(fUpwind, fHatModProj_e)
  ),
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "} ~%"),
  close(fh)
)$

genSurfUpdwindQuadToModalKernelHyb(cdim, vdim, basisName) := block(
  [pdim,vars,basis,surfNodes,numNodes,f_e,xv,surfVars,
   bSurf,fname,fh,basisNodal,fHatNodal_e,fHatModProj_e],

  pdim : cdim+vdim,
  dims : [cdim,vdim],

  if basisName = "hyb" then (
    [varsC,bC,varsP,bP] : loadPhaseBasis(basisName, cdim, vdim, 1),
    dirlabels : ["xdir","vdir"]
  ) elseif basisName = "gk_hyb" then (
    [varsC,bC,varsP,bP,vsub] : loadGkBasis(basisName, cdim, vdim, 1),
    dirlabels : ["xdir","vpardir","mudir"]
  ),

  fname : sconcat("~/max-out/gkyl_basis_",basisName,"_", cdim, "x", vdim, "v_p", pOrder, "_upwind_quad_to_modal", ".h"),
  fh : openw(fname),

  f_e : doExpand1(f, bP),
  for dcurr : 1 thru length(dirlabels) do (
    /* Surface nodes given by tensor product of Gauss-Legendre quadrature points. */
    surf_cdim : cdim,  surf_vdim : vdim,
    if dcurr = 1 then (surf_cdim : cdim-1) else (surf_vdim : vdim-1),
    if basisName = "hyb" then (
      surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim)
    ) elseif basisName = "gk_hyb" then (
      surfNodes : gaussOrdGkHyb(1+1, surf_cdim, surf_vdim)
    ),
    numNodes : length(surfNodes),
  
    /* xv = variable in direction of surface update.
       Note that which variable is deleted for this operation is irrelevant.
       The projection from the surface (tensor) nodal basis to the modal basis
       only depends on dimensionality  */
    xv : varsP[dims[dcurr]],
    /* Surface variables to integrate over. */
    surfVars : delete(xv,varsP),
    /* Generate surface basis. this produces the ndim-1 orthogonal basis with no xv dependence. */
    bSurf : basisFromVars(basisName,surfVars,pOrder),
  
    printf(fh, "GKYL_CU_DH static inline void ~%"),
    printf(fh, "~a_~ax~av_p1_~a_upwind_quad_to_modal(const double* fUpwindQuad, double* GKYL_RESTRICT fUpwind) { ~%", basisName, cdim, vdim, dirlabels[dcurr]),
  
    /* Make nodal expansions in tensor nodal basis where nodes are Gauss-Legendre quadrature points */
    if dcurr=1 then
      basisNodal : getVarsNodalBasisWithNodesHyb(basisName, surf_cdim, surf_vdim, surfVars, surfNodes)
    else
      basisNodal : getVarsNodalBasisWithNodesHyb(basisName, surf_cdim, surf_vdim, surfVars, surfNodes)
    fHatNodal_e : doExpand1(fUpwindQuad,basisNodal),
    /* Project nodal basis back onto modal basis */
    fHatModProj_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_e)),
  
    /* Write out projection of tensor nodal basis onto modal basis */
    /* Clever factorization is possible for polyOrder = 1, but for higher
       polynomial orders, factorization is *too* clever and can lead to 
       deeply nested parentheses, not ideal for compiler optimizations */
    if (polyOrder = 1) then (
      writeCExprsNoExpand1(fUpwind, fHatModProj_e)
    ) else (
      writeCExprs1(fUpwind, fHatModProj_e)
    ),
    printf(fh, "~%"),
    flush_output(fh),
  
    printf(fh, "} ~%"),
    close(fh)
  )
)$

/* Generate kernels that take the upwinded f at quadrature nodes,
   and does a nodal-to-modal transformation to yield the DG
   coefficients of the upwinded f. */
for bInd : 1 thru length(bName) do (
  for c : minCdim[bInd] thru maxCdim[bInd] do (
    for v : max(c,minVdim[bInd]) thru maxVdim[bInd] do (

      minPolyOrderB : minPolyOrder[bInd],
      maxPolyOrderB : maxPolyOrder[bInd],
      if (c+v>4 and maxPolyOrderB > 1) then maxPolyOrderB : 1,
      for polyOrder : minPolyOrderB thru maxPolyOrderB do (
        disp(printf(false,sconcat("Creating quad_to_modal ",bName[bInd]," ~ax_p~a"),c+v,polyOrder)),
        genSurfUpdwindQuadToModalKernel(c, v, bName[bInd], polyOrder)
      )
    )
  )
)$

/* Generate the hybrid basis kernels. */
for bInd : 1 thru length(bNameHyb) do (
  for c : minCdimHyb[bInd] thru maxCdimHyb[bInd] do (
    vmin : xreduce(min,vDims[bInd][c]),
    vmax : xreduce(max,vDims[bInd][c]),
    for v : vmin thru vmax do (
      disp(printf(false,sconcat("Creating quad_to_modal ",bNameHyb[bInd]," ~ax~av_p1"),c,v)),
      genSurfUpdwindQuadToModalKernelHyb(c, v, bNameHyb[bInd])
    )
  )
)$
