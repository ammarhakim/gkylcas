load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("g0/nodal_operations/nodal_functions")$
fpprec : 24$

/* ...... USER INPUTS........ */

/* Serendipity basis. */
minPolyOrder_Ser : 1$
maxPolyOrder_Ser : 2$
minCdim_Ser : 1$
maxCdim_Ser : 3$

/* Tensor product basis. */
/* Note that Serendipity, p = 1, is equivalent to Tensor */
/* Thus no need to calculate p = 1 Tensor basis */
minPolyOrder_Tensor : 2$
maxPolyOrder_Tensor : 2$
minCdim_Tensor : 1$
maxCdim_Tensor : 3$

/* ...... END OF USER INPUTS........ */

bName        : ["ser","tensor"]$
minPolyOrder : [minPolyOrder_Ser, minPolyOrder_Tensor]$
maxPolyOrder : [maxPolyOrder_Ser, maxPolyOrder_Tensor]$
minCdim      : [minCdim_Ser, minCdim_Tensor]$
maxCdim      : [maxCdim_Ser, maxCdim_Tensor]$

/* Compute the surface contribution in velocity space from the acceleration term */
for bInd : 1 thru length(bName) do (
  for c : minCdim[bInd] thru maxCdim[bInd] do (
    minPolyOrderB : minPolyOrder[bInd],
    maxPolyOrderB : maxPolyOrder[bInd],

    for polyOrder : minPolyOrderB thru maxPolyOrderB do (
      disp(printf(false,sconcat("Creating configuration space surface quadrature evaluation ",bName[bInd]," ~ax_p~a"),c,polyOrder)),
      kill(bC,surfNodes,numNodes,surfVars),
      load(sconcat("basis-precalc/basis", bName[bInd], c, "x")),
      bC : basisC[polyOrder],
      /* Scale nodes of the nodal basis by corresponding factors to obtain the Gauss-Legendre quadrature points */
      surfNodes : getNodes("Tensor", c-1, polyOrder),
      if polyOrder=1 then (surfNodes:surfNodes*(1/sqrt(3))) elseif polyOrder=2 then (surfNodes:surfNodes*sqrt(3/5)),
      numNodes : length(surfNodes),    
      f_e : doExpand1(f, bC),
      for dir : 1 thru c do (
        /* xv = variable in direction of surface update. */
        cv : varsC[dir],
        /* Surface variables to integrate over. */
        surfVars : delete(cv,varsC),
        /* Evaluate f at surface quadrature nodes. */
        /* Need evaluation on left (-1) and right (+1) */
        fOrdR_n : gcfac(float(evAtNodes(subst(cv=+1,f_e),surfNodes,surfVars))),
        fOrdL_n : gcfac(float(evAtNodes(subst(cv=-1,f_e),surfNodes,surfVars))),

        fname : sconcat("~/max-out/gkyl_basis_",bName[bInd],"_", c, "x_", "p", polyOrder, "_surfx", dir, "_quad", ".h"),
        fh : openw(fname),

        for n : 1 thru length(fOrdR_n) do (
	  printf(fh, "GKYL_CU_DH static inline double ~%"),
	  printf(fh, "~a_~ax_p~a_surfx~a_quad_~a_r(const double* GKYL_RESTRICT f) { ~%", bName[bInd], c, polyOrder, dir, n-1),
	  printf(fh, "  return ~a; ~%", fOrdR_n[n]),
	  printf(fh, "} ~%"),
	  printf(fh, "GKYL_CU_DH static inline double ~%"),
	  printf(fh, "~a_~ax_p~a_surfx~a_quad_~a_l(const double* GKYL_RESTRICT f) { ~%", bName[bInd], c, polyOrder, dir, n-1),
	  printf(fh, "    return ~a; ~%", fOrdL_n[n]),
	  printf(fh, "} ~%")
        ),
        close(fh)
      ),
      disp(printf(false,sconcat("Creating phase space surface quadrature evaluation ",bName[bInd]," ~ax3v_p~a"),c,polyOrder)),
      kill(bP,surfNodes,numNodes,surfVars),
      load(sconcat("basis-precalc/basis", bName[bInd], c, "x", "3v")),
      bP    : basisP[polyOrder],
      pDim  : length(varsP),
      /* Scale nodes of the nodal basis by corresponding factors to obtain the Gauss-Legendre quadrature points */
      surfNodes : getNodes("Tensor", pDim-1, polyOrder),
      if polyOrder=1 then (surfNodes:surfNodes*(1/sqrt(3))) elseif polyOrder=2 then (surfNodes:surfNodes*sqrt(3/5)),
      numNodes : length(surfNodes),

      f_e : doExpand1(f, bP),
      for dir : 1 thru pDim do (
	/* xv = variable in direction of surface update. */
	xv : varsP[dir],
	/* Surface variables to integrate over. */
	surfVars : delete(xv,varsP),
	/* Evaluate f at surface quadrature nodes. */
	/* Need evaluation on left (-1) and right (+1) */
	fOrdR_n : gcfac(float(evAtNodes(subst(xv=+1,f_e),surfNodes,surfVars))),
	fOrdL_n : gcfac(float(evAtNodes(subst(xv=-1,f_e),surfNodes,surfVars))),

	fname : sconcat("~/max-out/gkyl_basis_",bName[bInd],"_", c+3, "x_p", polyOrder, "_surfx", dir, "_quad", ".h"),
	fh : openw(fname),

	for n : 1 thru length(fOrdR_n) do (
	  printf(fh, "GKYL_CU_DH static inline double ~%"),
	  printf(fh, "~a_~ax_p~a_surfx~a_quad_~a_r(const double* GKYL_RESTRICT f) { ~%", bName[bInd], c+3, polyOrder, dir, n-1),
	  printf(fh, "  return ~a; ~%", fOrdR_n[n]),
	  printf(fh, "} ~%"),
	  printf(fh, "GKYL_CU_DH static inline double ~%"),
	  printf(fh, "~a_~ax_p~a_surfx~a_quad_~a_l(const double* GKYL_RESTRICT f) { ~%", bName[bInd], c+3, polyOrder, dir, n-1),
	  printf(fh, "    return ~a; ~%", fOrdL_n[n]),
	  printf(fh, "} ~%")
	),
	close(fh)
      )      
    )
  )
);