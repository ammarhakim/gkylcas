/*
   Create kernels for the volume term of the gyrokinetic collisionless terms.
*/

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("utilities_gyrokinetic")$
load("utilities")$
fpprec : 24$

buildGKVolKernel(fh, funcNm, cdim, vdim, basisFun, polyOrder, varsInB, no_by) := block(
  [pDim,varsC,bC,varsP,bP,varsV,vSub,numC,numP,varLabel,d,rdx2vec,rdv2vec,allVarLabelsC,
   bmagBasis,ignoreVars,inFlds_e,cmag_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_e,BstardBmag_e,
   hamil_e,pbAuxFlds,alphaSum_e,vd,dir,dirLabel,wDir,rdDirVar2,vmap_prime_fac,dirVar,
   dirVar_phys,alpha_e,alpha_c,alphaLabel,alphaNoZero_c,alphaDotGradBasis_e,f_e,volTerm_c, 
   dH_dz_e, alphaJf_e, Jf_e, replaceListHamil, replaceListVpar,hamil2_c,isqlist,mvpar_e,mvparsq_e,
   replaceList,dvparSimp,phi_e,bmag_e,dualcurlbhatoverB_x_e,dualcurlbhatoverB_y_e,dualcurlbhatoverB_z_e,
   rtg33inv_e,bioverJB_x_e,bioverJB_y_e,bioverJB_z_e,dualcurlbhatoverB_list,bioverJB_list,
   vmapSq_e,vmap_prime_e,hamilCvar,hamilNoZero_c,hamil_c,vpardim,i,k,curvdriftdir,clst],

  kill(varsC,varsP,bC,bP),
  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  numC : length(bC),  numP : length(bP), 

  varLabel : makelist(string(varsP[d]),d,1,pDim),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *vmap, const double *vmapSq,
    const double q_, const double m_, const double *bmag, const double *phi,
    const double *dualcurlbhatoverB, const double *rtg33inv, const double *bioverJB,
    const double *fin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // vmap: velocity space mapping.~%"),
  printf(fh, "  // vmapSq: velocity space mapping squared.~%"),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // phi: electrostatic potential .~%"),
  printf(fh, "  // fin: Distribution function.~%"),
  printf(fh, "  // out: output increment.~%"),
  printf(fh, "~%"),

  /* Declare cell-center variables and variables multiplying gradients. */
  for d : 1 thru pDim do (
    printf(fh, "  double rd~a2 = 2.0/dxv[~a];~%", varLabel[d], d-1)
  ),
  printf(fh, "~%"),
  rdx2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,1,cdim),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),

  /* Declare variables with squared of cell centers and rdx2 variables (only need vpar^2). */
  printf(fh, "  double rdvpar2Sq = rdvpar2*rdvpar2;~%"),
  printf(fh, "  double dvparSq = dxv[~a]*dxv[~a];~%", cdim, cdim),
  printf(fh, "~%"),
  replaceList : [rdvpar2^2=rdvpar2Sq,dxv[cdim]^2=dvparSq,rdvpar2Sq=4/dvparSq],
  dvparSimp : append(makelist(dxv[i-1]=2/eval_string(sconcat("rd",varLabel[i],"2")),i,1,pDim),
                     [dvparSq=4/rdvpar2Sq]),

  /* Create pointers to the components of b_i. */
  allVarLabelsC : ["x","y","z"],
  for d : 1 thru 3 do (
    printf(fh, "  const double *bioverJB_~a = &bioverJB[~a]; ~%", allVarLabelsC[d], numC*(d-1))
  ),
  printf(fh, "~%"),

  /* Create pointers to the components of dualcurlbhatoverB. */
  allVarLabelsC : ["x","y","z"],
  for d : 1 thru 3 do (
    printf(fh, "  const double *dualcurlbhatoverB_~a = &dualcurlbhatoverB[~a]; ~%", allVarLabelsC[d], numC*(d-1))
  ),
  printf(fh, "~%"),

  /* Axisymmetric basis (independent of y). */
  bmagBasis : getAxisymmetricConfBasis(bC),
  /* Expand input fields for Hamiltonian calculation */
  phi_e     : doExpand1(phi,bC),
  bmag_e : doExpand1(bmag, bmagBasis),
  dualcurlbhatoverB_x_e : doExpand1(dualcurlbhatoverB_x, bmagBasis),
  dualcurlbhatoverB_y_e : doExpand1(dualcurlbhatoverB_y, bmagBasis),
  dualcurlbhatoverB_z_e : doExpand1(dualcurlbhatoverB_z, bmagBasis),
  rtg33inv_e : doExpand1(rtg33inv, bmagBasis),
  bioverJB_x_e : doExpand1(bioverJB_x, bmagBasis),
  bioverJB_y_e : doExpand1(bioverJB_y, bmagBasis),
  bioverJB_z_e : doExpand1(bioverJB_z, bmagBasis),

  dualcurlbhatoverB_list : [dualcurlbhatoverB_x_e, dualcurlbhatoverB_y_e, dualcurlbhatoverB_z_e],
  bioverJB_list : [bioverJB_x_e, bioverJB_y_e, bioverJB_z_e],

  /* Velocity mapping fields. */
  [vmap_e,vmapSq_e,vmap_prime_e] : expandVmapFields(varsP),

  /* Redefine vmap_prime to exploit the relationship between it and vmap. */
  vmap_prime_e : makelist(diff(vmap_e[d],varsP[cdim+d]),d,1,vdim),

  /* Finally write out the hamiltonian*/
  hamil_e : q_*phi_e + (1/2)*m_*vmapSq_e[1],
  if vdim > 1 then ( hamil_e : hamil_e + vmap_e[2]*bmag_e ),
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),
  printf(fh, "  double hamil[~a] = {0.}; ~%", numP),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  hamilCvar : eval_string(sconcat("hamil")),
  writeCExprsNoExpand1(hamilCvar, gcfac(float(expand(subst(replaceList, hamil_c))))),
  printf(fh, "~%"),
  flush_output(fh),
  hamilNoZero_c : makelistNoZeros1(hamil_c, hamilCvar),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,

  /*Expand Jf*/
  Jf_e : doExpand1(fin,bP),

  /* Calculate expressions for dericatives of the hamiltonian*/
  vpardim : pDim-1,
  if vdim = 1 then ( vpardim : pDim ),
  dH_dz_e : makelist(0, i, 1, pDim),  
  for i : 1 thru vpardim do (
    if i = vpardim then (
      dH_dz_e[i] : diff(hamil_e,varsP[i])
    )
    else (
      dH_dz_e[i] : diff(hamil_e*rdx2vec[i],varsP[i])
    )
  ),

  /*Make sure to avoid having hamil[i]^2 or vmap[i]^2 in expressions*/
  replaceListVpar : [vmap[1]^2=vmap2],
  printf(fh, "  double vmap2 = vmap[1]*vmap[1]; ~%"),
  printf(fh, "~%"),

  mvpar_e : dH_dz_e[vpardim]/vmap_prime_e[1],
  mvparsq_e : mvpar_e*mvpar_e/m_,
  isqlist : [],
  for i : 1 thru numP do (
    if freeof(hamil[i]^2, expand(mvparsq_e)) = false then (
      isqlist : append(isqlist,[i])
    )
  ),

  replaceListHamil : [],
  printf(fh, "  double hamil2[~a] = {0.}; ~%", length(isqlist)),
  for i : 1 thru length(isqlist) do (
    printf(fh, "  hamil2[~a] = hamil[~a]*hamil[~a]; ~%", i-1, isqlist[i], isqlist[i]),
    replaceListHamil : append(replaceListHamil, [hamil[isqlist[i]]^2=hamil2[i-1]])
  ),
  printf(fh, "~%"),

  /* Note: no contribution from mu. */
  for dir : 1 thru cdim+1 do (

    dirLabel : varLabel[dir],

    wDir      : eval_string(sconcat("w",dirLabel)),
    rdDirVar2 : eval_string(sconcat("rd",dirLabel,"2")),
  
    dirVar    : varsP[dir],         /* Variable in current direction. */

    if dir = cdim then (
      alpha_e : rtg33inv_e*dH_dz_e[vpardim]/vmap_prime_e[1]/m_
    )
    else if dir = vpardim then (
      alpha_e : -rtg33inv_e * dH_dz_e[cdim]/m_
    )
    else (
      alpha_e : 0
    ),


    if no_by = false then (
      if cdim = 3 then (
        curvdriftdir : dir
      ),
      if cdim = 2 then (
        if dir = 1 then (
          curvdriftdir : dir
        ),
        if dir = 2 then (
          curvdriftdir : 3
        )
      ),
      if cdim = 1 then (
        curvdriftdir : 3
      ),

      if dir < vpardim then (
        alpha_e : alpha_e + dualcurlbhatoverB_list[curvdriftdir]*dH_dz_e[vpardim]/vmap_prime_e[1]*dH_dz_e[vpardim]/vmap_prime_e[1]/m_/q_
      ),
      if cdim = 3 then (
        if dir = 1 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[2]*dH_dz_e[3] - bioverJB_list[3]*dH_dz_e[2])
        ),
        if dir = 2 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[3]*dH_dz_e[1] - bioverJB_list[1]*dH_dz_e[3])
        ),
        if dir = 3 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[1]*dH_dz_e[2] - bioverJB_list[2]*dH_dz_e[1])
        )
      ),
      if cdim = 2 then (
        if dir = 1 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[2]*dH_dz_e[2])
        ),
        if dir = 2 then (
          alpha_e : alpha_e - 1/q_ * (bioverJB_list[2]*dH_dz_e[1])
        )
      ),
      if dir = vpardim then (
        if cdim = 3 then (
          for k : 1 thru cdim do (
            alpha_e : alpha_e - dualcurlbhatoverB_list[k]*dH_dz_e[k]*dH_dz_e[vpardim]/vmap_prime_e[1]/q_/m_
          )
        ),
        if cdim = 2 then (
            alpha_e : alpha_e - dualcurlbhatoverB_list[1]*dH_dz_e[1]*dH_dz_e[vpardim]/vmap_prime_e[1]/q_/m_ - dualcurlbhatoverB_list[3]*dH_dz_e[2]*dH_dz_e[vpardim]/vmap_prime_e[1]/q_/m_
        ),
        if cdim = 1 then (
            alpha_e : alpha_e - dualcurlbhatoverB_list[3]*dH_dz_e[1]*dH_dz_e[vpardim]/vmap_prime_e[1]/q_/m_
        )
      )

    ),

    if dir < vpardim then (
      alpha_e : alpha_e*rdx2vec[dir]
    )
    else if dir = vpardim then (
      alpha_e : alpha_e/vmap_prime_e[1]
    ),

    /* Project alpha on basis and write to array. */
    printf(fh, "  double alpha~a[~a] = {0.}; ~%", dirLabel, numP),
    alpha_c : fullratsimp(calcInnerProdList(varsP, 1, bP, alpha_e)),
    alpha_c : subst(replaceList, alpha_c),
    alpha_c : subst(replaceListHamil, alpha_c),
    alpha_c : subst(replaceListVpar, alpha_c),
    alpha_c : subst(dvparSimp, alpha_c),
    alphaLabel : eval_string(sconcat(alpha, dirLabel)),
    clst : [rdx2vec, rdv2vec, m_, q_, wvpar, rdvpar2Sq,
            makelist(dxv[i-1],i,1,pDim), makelist(vmap[i-1],i,1,2*length(vmap_e[1]))],
    writeCExprsCollect1(alphaLabel, alpha_c, clst),
    printf(fh, "~%"),
    flush_output(fh),
    alphaNoZero_c : makelistNoZeros1(alpha_c, alphaLabel),
    alpha_e       : doExpand(alphaNoZero_c, bP),

    alphaJf_e : alpha_e*Jf_e,

    printf(fh, "~%"),
    volTerm_c : fullratsimp(calcInnerProdList(varsP, 1, diff(bP,varsP[dir]), alphaJf_e)),
    volTerm_c : subst(replaceList, volTerm_c),
    writeCIncrExprsNoExpand(gcfac(float(expand(volTerm_c)))),
    flush_output(fh),
    printf(fh, "~%")

  ),

  printf(fh, "  return 0.; ~%"),
  printf(fh, "} ~%")

)$

addAparGKEMVolKernel(fh, funcNm, cdim, vdim, basisFun, polyOrder, varsInB, no_by) := block(
  [pDim,varsC,bC,varsP,bP,varsV,vSub,numC,numP,varLabel,d,rdx2vec,rdv2vec,allVarLabelsC,
   bmagBasis,ignoreVars,inFlds_e,cmag_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_e,BstardBmag_e,
   hamil_e,pbAuxFlds,alphaSum_e,vd,dir,dirLabel,wDir,rdDirVar2,vmap_prime_fac,dirVar,
   dirVar_phys,alpha_e,alpha_c,alphaLabel,alphaNoZero_c,alphaDotGradBasis_e,f_e,volTerm_c, dH_dz_e, alphaJf_e, Jf_e, replaceListHamil, replaceListVpar,hamil2_c,isqlist,mvpar_e,mvparsq_e,
   replaceList,dvparSimp,phi_e,bmag_e,rtg33inv_e,bioverJB_x_e,bioverJB_y_e,bioverJB_z_e,bioverJB_list,
   vmapSq_e,vmap_prime_e,hamil_c,hamilCvar,hamilNoZero_c,vpardim,i,k,Apar_e,
   dBperpoverB_x,dBperpoverB_y,dBperpoverB_z,dBperpoverB_list,curvdriftdir,clst],

  kill(varsC,varsP,bC,bP),
  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  numC : length(bC),  numP : length(bP), 

  varLabel : makelist(string(varsP[d]),d,1,pDim),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *vmap, const double *vmapSq,
    const double q_, const double m_, const double *bmag, const double *jacobtot_inv,
    const double *b_i, const double *phi, const double *apar, const double *fin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // vmap: velocity space mapping.~%"),
  printf(fh, "  // vmapSq: velocity space mapping squared.~%"),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // jacobtot_inv: reciprocal of the conf-space jacobian time the guiding center coordinate Jacobian.~%"),
  printf(fh, "  // b_i: covariant components of the field aligned unit vector.~%"),
  printf(fh, "  // apar: parallel component of magnetic vector potential.~%"),
  printf(fh, "  // phi: electrostatic potential .~%"),
  printf(fh, "  // fin: Distribution function.~%"),
  printf(fh, "  // out: output increment.~%"),
  printf(fh, "~%"),

  /* Declare cell-center variables and variables multiplying gradients. */
  for d : 1 thru pDim do (
    printf(fh, "  double rd~a2 = 2.0/dxv[~a];~%", varLabel[d], d-1)
  ),
  printf(fh, "~%"),
  rdx2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,1,cdim),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),

  /* Declare variables with squared of cell centers and rdx2 variables (only need vpar^2). */
  printf(fh, "  double rdvpar2Sq = rdvpar2*rdvpar2;~%"),
  printf(fh, "  double dvparSq = dxv[~a]*dxv[~a];~%", cdim, cdim),
  printf(fh, "~%"),
  replaceList : [rdvpar2^2=rdvpar2Sq,dxv[cdim]^2=dvparSq,rdvpar2Sq=4/dvparSq],
  dvparSimp : append(makelist(dxv[i-1]=2/eval_string(sconcat("rd",varLabel[i],"2")),i,1,pDim),
                     [dvparSq=4/rdvpar2Sq]),

  allVarLabelsC : ["x","y","z"],
  for d : 1 thru 3 do (
    printf(fh, "  const double *b_~a = &b_i[~a];~%", allVarLabelsC[d], numC*(d-1))
  ),
  printf(fh, "~%"),

  /* Axisymmetric basis (independent of y). */
  bmagBasis : getAxisymmetricConfBasis(bC),
  /* Expand input fields for Hamiltonian calculation */
  phi_e     : doExpand1(phi,bC),
  bmag_e : doExpand1(bmag, bmagBasis),
  rtg33inv_e : doExpand1(rtg33inv, bmagBasis),
  bioverJB_x_e : doExpand1(bioverJB_x, bmagBasis),
  bioverJB_y_e : doExpand1(bioverJB_y, bmagBasis),
  bioverJB_z_e : doExpand1(bioverJB_z, bmagBasis),
  b_x_e : doExpand1(b_x, bmagBasis),
  b_y_e : doExpand1(b_y, bmagBasis),
  if (no_by or cdim = 1) then (b_y_e : 0),
  b_z_e : doExpand1(b_z, bmagBasis),
  jacobTotInv_e : doExpand1(jacobtot_inv, bmagBasis),

  bioverJB_list : [bioverJB_x_e, bioverJB_y_e, bioverJB_z_e],

  /* Velocity mapping fields. */
  [vmap_e,vmapSq_e,vmap_prime_e] : expandVmapFields(varsP),

  /* Redefine vmap_prime to exploit the relationship between it and vmap. */
  vmap_prime_e : makelist(diff(vmap_e[d],varsP[cdim+d]),d,1,vdim),

  /* Finally write out the hamiltonian*/
  hamil_e : q_*phi_e + (1/2)*m_*vmapSq_e[1],
  if vdim > 1 then ( hamil_e : hamil_e + vmap_e[2]*bmag_e ),
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),
  printf(fh, "  double hamil[~a] = {0.}; ~%", numP),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  hamilCvar : eval_string(sconcat("hamil")),
  writeCExprsNoExpand1(hamilCvar, gcfac(float(expand(subst(replaceList, hamil_c))))),
  printf(fh, "~%"),
  flush_output(fh),
  hamilNoZero_c : makelistNoZeros1(hamil_c, hamilCvar),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,

  /*Expand Jf*/
  Jf_e : doExpand1(fin,bP),

  /* Calculate expressions for dericatives of the hamiltonian*/
  vpardim : pDim-1,
  if vdim = 1 then ( vpardim : pDim ),
  dH_dz_e : makelist(0, i, 1, pDim),  
  for i : 1 thru vpardim do (
    if i = vpardim then (
      dH_dz_e[i] : diff(hamil_e,varsP[i])
    )
    else (
      dH_dz_e[i] : diff(hamil_e*rdx2vec[i],varsP[i])
    )
  ),

  /*Make sure to avoid having hamil[i]^2 or vmap[i]^2 in expressions*/
  replaceListVpar : [vmap[1]^2=vmap2],
  printf(fh, "  double vmap2 = vmap[1]*vmap[1]; ~%"),
  printf(fh, "~%"),

  mvpar_e : dH_dz_e[vpardim]/vmap_prime_e[1],
  mvparsq_e : mvpar_e*mvpar_e/m_,
  isqlist : [],
  for i : 1 thru numP do (
    if freeof(hamil[i]^2, expand(mvparsq_e)) = false then (
      isqlist : append(isqlist,[i])
    )
  ),

  replaceListHamil : [],
  printf(fh, "  double hamil2[~a] = {0.}; ~%", length(isqlist)),
  for i : 1 thru length(isqlist) do (
    printf(fh, "  hamil2[~a] = hamil[~a]*hamil[~a]; ~%", i-1, isqlist[i], isqlist[i]),
    replaceListHamil : append(replaceListHamil, [hamil[isqlist[i]]^2=hamil2[i-1]])
  ),
  printf(fh, "~%"),

  /* Expand Apar.*/
  Apar_e : doExpand1(apar,bC),

  /* Expand dBperp/Bmag. */
  dBperpoverB_x : (rdy2*diff(Apar_e*b_z_e,y) - rdz2*diff(Apar_e*b_y_e,z))*jacobTotInv_e,
  dBperpoverB_y : (rdz2*diff(Apar_e*b_x_e,z) - rdx2*diff(Apar_e*b_z_e,x))*jacobTotInv_e,
  dBperpoverB_z : (rdx2*diff(Apar_e*b_y_e,x) - rdy2*diff(Apar_e*b_x_e,y))*jacobTotInv_e,
  dBperpoverB_list : [dBperpoverB_x, dBperpoverB_y, dBperpoverB_z],

  /* Note: no contribution from mu. */
  for dir : 1 thru cdim+1 do (

    dirLabel : varLabel[dir],

    wDir      : eval_string(sconcat("w",dirLabel)),
    rdDirVar2 : eval_string(sconcat("rd",dirLabel,"2")),
  
    dirVar    : varsP[dir],         /* Variable in current direction. */

    alpha_e : 0,

    if no_by = false then (
      if cdim = 3 then (
        curvdriftdir : dir
      ),
      if cdim = 2 then (
        if dir = 1 then (
          curvdriftdir : dir
        ),
        if dir = 2 then (
          curvdriftdir : 3
        )
      ),
      if cdim = 1 then (
        curvdriftdir : 3
      ),

      if dir < vpardim then (
        alpha_e : alpha_e + dBperpoverB_list[curvdriftdir]/m_ * mvpar_e
      ),
      if dir = vpardim then (
        if cdim = 3 then (
          for k : 1 thru cdim do (
            alpha_e : alpha_e - dBperpoverB_list[k]/m_ * dH_dz_e[k]
          )
        ),
        if cdim = 2 then (
            alpha_e : alpha_e - dBperpoverB_list[1]/m_ * dH_dz_e[1] - dBperpoverB_list[3]/m_ * dH_dz_e[2]
        ),
        if cdim = 1 then (
            alpha_e : alpha_e - dBperpoverB_list[3]/m_ * dH_dz_e[1]
        )
      )
    ),

    if dir < vpardim then (
      alpha_e : alpha_e*rdx2vec[dir]
    )
    else if dir = vpardim then (
      alpha_e : alpha_e/vmap_prime_e[1]
    ),

    /* Project alpha on basis and write to array. */
    printf(fh, "  double alpha~a[~a] = {0.}; ~%", dirLabel, numP),
    alpha_c : fullratsimp(calcInnerProdList(varsP, 1, bP, alpha_e)),
    alpha_c : subst(replaceList, alpha_c),
    alpha_c : subst(replaceListHamil, alpha_c),
    alpha_c : subst(replaceListVpar, alpha_c),
    alpha_c : subst(dvparSimp, alpha_c),
    alphaLabel : eval_string(sconcat(alpha, dirLabel)),
    clst : [rdx2vec, rdv2vec, m_, q_, wvpar, rdvpar2Sq,
            makelist(dxv[i-1],i,1,pDim), makelist(vmap[i-1],i,1,2*length(vmap_e[1]))],
    writeCExprsCollect1(alphaLabel, alpha_c, clst),
    printf(fh, "~%"),
    flush_output(fh),
    alphaNoZero_c : makelistNoZeros1(alpha_c, alphaLabel),
    alpha_e       : doExpand(alphaNoZero_c, bP),

    alphaJf_e : alpha_e*Jf_e,

    printf(fh, "~%"),
    volTerm_c : fullratsimp(calcInnerProdList(varsP, 1, diff(bP,varsP[dir]), alphaJf_e)),
    volTerm_c : subst(replaceList, volTerm_c),
    writeCIncrExprsNoExpand(gcfac(float(expand(volTerm_c)))),
    flush_output(fh),
    printf(fh, "~%")

  ),

  printf(fh, "  return 0.; ~%"),
  printf(fh, "} ~%")

)$

addApardotGKEMVolKernel(fh, funcNm, cdim, vdim, basisFun, polyOrder, varsInB, no_by) := block(
  [pDim,varsC,bC,varsP,bP,varsV,vSub,numC,numP,varLabel,d,rdx2vec,rdv2vec,allVarLabelsC,
   bmagBasis,ignoreVars,inFlds_e,cmag_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_e,BstardBmag_e,
   hamil_e,pbAuxFlds,alphaSum_e,vd,dir,dirLabel,wDir,rdDirVar2,vmap_prime_fac,dirVar,
   dirVar_phys,alpha_e,alpha_c,alphaLabel,alphaNoZero_c,alphaDotGradBasis_e,f_e,volTerm_c, dH_dz_e, 
   alphaJf_e, Jf_e, replaceListHamil, replaceListVpar,hamil2_c,isqlist,mvpar_e,mvparsq_e,
   vmapSq_e,vmap_prime_e,apardot_e,clst],

  kill(varsC,varsP,bC,bP),
  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  numC : length(bC),  numP : length(bP), 

  varLabel : makelist(string(varsP[d]),d,1,pDim),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(const double q_, const double m_, const double *apardot,
    const double *fin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // apardot: time derivative of parallel component of magnetic vector potential.~%"),
  printf(fh, "  // fin: Distribution function.~%"),
  printf(fh, "  // out: output increment.~%"),
  printf(fh, "~%"),

  /* Velocity mapping fields. */
  [vmap_e,vmapSq_e,vmap_prime_e] : expandVmapFields(varsP),

  /*Expand Jf*/
  Jf_e : doExpand1(fin,bP),

  /* Expand Apardot */
  apardot_e : doExpand1(apardot,bC),

  /* Note: only a vpar contribution. */
  dir : cdim+1,
  dirLabel : varLabel[dir],

  alpha_e : -q_/m_ * apardot_e,

  /* Project alpha on basis and write to array. */
  printf(fh, "  double alpha~a[~a] = {0.}; ~%", dirLabel, numP),
  alpha_c : fullratsimp(calcInnerProdList(varsP, 1, bP, alpha_e)),
  alphaLabel : eval_string(sconcat(alpha, dirLabel)),
  clst : [rdx2vec, rdv2vec, m_, q_, wvpar, rdvpar2Sq,
          makelist(dxv[i-1],i,1,pDim), makelist(vmap[i-1],i,1,2*length(vmap_e[1]))],
  writeCExprsCollect1(alphaLabel, alpha_c, clst),
  printf(fh, "~%"),
  flush_output(fh),
  alphaNoZero_c : makelistNoZeros1(alpha_c, alphaLabel),
  alpha_e       : doExpand(alphaNoZero_c, bP),

  alphaJf_e : alpha_e*Jf_e,

  printf(fh, "~%"),
  volTerm_c : fullratsimp(calcInnerProdList(varsP, 1, diff(bP,varsP[dir]), alphaJf_e)),
  writeCIncrExprsNoExpand(gcfac(float(expand(volTerm_c)))),
  flush_output(fh),
  printf(fh, "~%"),

  printf(fh, "  return 0.; ~%"),
  printf(fh, "} ~%")

)$