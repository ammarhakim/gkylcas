load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("utilities_gyrokinetic")$
fpprec : 24$

buildGKFluxVparESKernel(surfDir, fh, funcNm, cdim, vdim, basisFun, polyOrder, no_by, edge) := block(
  [pDim,varsC,bC,varsP,bP,vSub,numC,numP,surfVar,varLabel,dirLabel,surfIntVars,surf_cvars,surf_vvars,
   surfIntVarsC,bSurfC,surfNodes,nodeVars,bSurf,basisNodal,configNodes,numSurfNodes,numConfigNodes,
   numVelNodes,tempVars,tempBasis,NSurfIndexing,numNodesIndexing,d,rdx2vec,rdv2vec,rdSurfVar2,
   bmagBasis,phi_e,bmag_e,vmap_e,vmapSq_e,vmap_prime_e,evPoint,hamil_e,hamil_c,replaceList,
   hamilCvar,hamilNoZero_c,JfL_e,JfR_e,JfL_c,JfR_c,JfL_nodes,JfR_nodes,vmap_prime_nodes,vpardim,
   dH_dz_nodes,i,j,j0index,j1index,pOrderCFL,vprimeStr
  ],

  kill(varsC,varsP,bC,bP),
  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  numC : length(bC),  numP : length(bP), 

  surfVar  : varsP[surfDir],         /* Surface variable. */
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  surfIntVars : delete(surfVar,varsP), 
  surf_cvars  : delete(surfVar, makelist(varsP[i],i,1,cdim)),
  surf_vvars  : delete(surfVar, makelist(varsP[cdim+i],i,1,vdim)),

  surfIntVarsC : delete(surfVar,varsC), 
  bSurfC       : basisFromVars(basisFun,surfIntVarsC,polyOrder),
  
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    surfNodes : gaussOrdGkHyb(1+1, surf_cvars, surf_vvars),
    nodeVars  : surfIntVars, 
    bSurf     : basisFromVars("gkhyb",surfIntVars,polyOrder),
    basisNodal  : getVarsNodalBasisWithNodesHyb("gkhyb", cdim, vdim-1, surfIntVars, surfNodes)
  ) else (
    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    nodeVars  : surfIntVars,
    bSurf     : basisFromVars(basisFun,surfIntVars,polyOrder)
  ),
  configNodes : gaussOrd(polyOrder+1, cdim),
  numSurfNodes : length(surfNodes),  
  numConfigNodes : length(configNodes), 
  numVelNodes : numSurfNodes/numConfigNodes, 

  /* if polyOrder = 1, we need to be careful about
     indexing input arrays since the surface hybrid basis has a different size in the
     vparallel surfaces and/or we are more directly exploiting the sparsity of 
     alpha (e.g., in the x and z direction when no toroidal field, by=0) 
     and thus utilize fewer coefficients to reduce the number of operations */
  if (polyOrder = 1) then (
    tempVars         : delete(x,varsP), 
    tempBasis        : basisFromVars("gkhyb",tempVars,polyOrder),
    NSurfIndexing    : length(tempBasis),
    numNodesIndexing : length(tempBasis)
  ) else (
    NSurfIndexing    : NSurf,
    numNodesIndexing : numNodes
  ),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(
    const double *w, const double *dxv, 
    const double *vmap_prime_l, const double *vmap_prime_r,
    const double *vmap, const double *vmapSq, const double q_, const double m_,
    const struct gkyl_dg_vol_geom *dgv, const struct gkyl_gk_dg_vol_geom *gkdgv,
    const double *bmag, const double *phi, const double *JfL, const double *JfR,
    double* GKYL_RESTRICT flux_surf) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // vmap_prime_l,vmap_prime_r: velocity space mapping derivative in left and right cells.~%"),
  printf(fh, "  // vmap: velocity space mapping.~%"),
  printf(fh, "  // vmapSq: velocity space mapping squared.~%"),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // dgv: volume DG geometry.~%"),
  printf(fh, "  // gkdgv: gyrokinetic volume DG geometry.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // phi: electrostatic potential.~%"),
  printf(fh, "  // JfL: distribution times total jacobian in left cell.~%"),
  printf(fh, "  // JfR: distribution times total jacobian in right cell.~%"),
  printf(fh, "  // flux_surf: output surface phase space flux in each direction (cdim + 1 components).~%"),
  printf(fh, "  //            Note: Each cell owns their *lower* edge surface evaluation.~%"),
  printf(fh, "~%"),

  /* Declare cell-center variables and variables multiplying gradients. */
  for d : 1 thru cdim+1 do (
    printf(fh, "  double rd~a2 = 2.0/dxv[~a];~%", varLabel[d], d-1)
  ),
  printf(fh, "~%"),
  rdx2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,1,cdim),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),

  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  /* Axisymmetric basis (independent of y). */
  bmagBasis : getAxisymmetricConfBasis(bC),

  /* Expand input fields for Hamiltonian calculation */
  phi_e  : doExpand1(phi,bC),
  bmag_e : doExpand1(bmag, bmagBasis),

  /* Velocity mapping fields. */
  [vmap_e,vmapSq_e,vmap_prime_e] : expandVmapFields(varsP),

  /* Redefine vmap_prime to exploit the relationship between it and vmap. */
  /*vmap_prime_e : makelist((2/dxv[cdim+d-1])*diff(vmap_e[d],varsP[cdim+d]),d,1,vdim),*/
  vmap_prime_e : makelist(diff(vmap_e[d],varsP[cdim+d]),d,1,vdim),

  if edge = true then (
    evPoint : 1
  ) else (
    evPoint : -1
  ),

  /* Finally write out the hamiltonian*/
  hamil_e : q_*phi_e + (1/2)*m_*vmapSq_e[1],
  if vdim > 1 then ( hamil_e : hamil_e + vmap_e[2]*bmag_e ),
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),
  printf(fh, "  double hamil[~a] = {0.}; ~%", numP),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  hamilCvar : eval_string(sconcat("hamil")),
  writeCExprsNoExpand1(hamilCvar, gcfac(float(expand(subst(replaceList, hamil_c))))),
  printf(fh, "~%"),
  flush_output(fh),
  hamilNoZero_c : makelistNoZeros1(hamil_c, hamilCvar),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,
  /*hamil_e : subst(surfVar=evPoint,hamil_e),*/

  /*fl and fr */
  JfL_e : doExpand1(JfL, bP),
  JfR_e : doExpand1(JfR, bP),
  JfL_c : calcInnerProdList(varsP, 1, bP, JfL_e),
  JfR_c : calcInnerProdList(varsP, 1, bP, JfR_e),
   
  JfL_e : subst(surfVar=1,JfL_e),
  JfR_e : subst(surfVar=-1,JfR_e),

  JfL_nodes : float(evAtNodes(JfL_e,surfNodes,surfIntVars)),
  JfR_nodes : float(evAtNodes(JfR_e,surfNodes,surfIntVars)),

  vmap_prime_nodes : float(evAtNodes(vmap_prime_e[1],surfNodes,surfIntVars)),

  vpardim : pDim-1,
  if vdim = 1 then ( vpardim : pDim ),
  dH_dz_nodes : makelist(0, i, 1, pDim),  
  for i : 1 thru vpardim do (
    if i = vpardim then (
      dH_dz_nodes[i] : float(evAtNodes(diff(hamil_e,varsP[i]),surfNodes,surfIntVars)),
      dH_dz_nodes[i] : subst(surfVar=evPoint, dH_dz_nodes[i])
    )
    else (
      dH_dz_nodes[i] : float(evAtNodes(diff(hamil_e*rdx2vec[i],varsP[i]),surfNodes,surfIntVars))
    )
  ),

  /* Now calculate apha at all quadrature nodes */
  /*printf(fh, "  double flux_surf_nodal[~a]= {0.0}; ~%", numSurfNodes),*/
  printf(fh, "  double *flux_surf_nodal = &flux_surf[~a]; ~%", NSurfIndexing*(surfDir-1)),
  printf(fh, "  double cfl = 0.0; ~%"),
  printf(fh, "  double bmag_quad = 0.0; ~%"),
  printf(fh, "  double B3_quad = 0.0; ~%"),
  printf(fh, "  double Jc_quad = 0.0; ~%"),
  printf(fh, "  double dualcurlbhat_quad[3] = {0.0}; ~%"),

  printf(fh, "  double alpha_quad = 0.0; ~%"),
  printf(fh, "  double JfL_quad = 0.0; ~%"),
  printf(fh, "  double JfR_quad = 0.0; ~%"),
  printf(fh, "  double Jfavg_quad = 0.0; ~%"),
  printf(fh, "  double Jfjump_quad = 0.0; ~%"),
  printf(fh, "~%"),

  for i : 1 thru numConfigNodes do (
    printf(fh, "  bmag_quad = gkdgv[~a].bmag; ~%", i-1), 
    printf(fh, "  B3_quad = gkdgv[~a].B3; ~%", i-1), 
    printf(fh, "  Jc_quad = dgv[~a].Jc; ~%", i-1), 
    printf(fh, "  dualcurlbhat_quad[0] = gkdgv[~a].dualcurlbhat.x[0]; ~%", i-1), 
    printf(fh, "  dualcurlbhat_quad[1] = gkdgv[~a].dualcurlbhat.x[1]; ~%", i-1), 
    printf(fh, "  dualcurlbhat_quad[2] = gkdgv[~a].dualcurlbhat.x[2]; ~%", i-1), 
    printf(fh, "~%"),
    for j : 1 thru numVelNodes do (
      j0index : j-1+(i-1)*numVelNodes,
      j1index : j+(i-1)*numVelNodes,
      printf(fh, "~%"),
      if no_by = true then (
        printf(fh, "  alpha_quad = -(~a)/m_/bmag_quad * B3_quad ;~%", dH_dz_nodes[cdim][j1index])
      ),
      if no_by = false then (
        printf(fh, "  alpha_quad = -(~a)/m_/bmag_quad * B3_quad ", dH_dz_nodes[cdim][j1index]),
         if cdim = 3 then (
           for k : 1 thru cdim do (
             printf(fh, "-(~a)/m_/bmag_quad * 1/q_*dualcurlbhat_quad[~a]*(~a)", dH_dz_nodes[k][j1index], k-1, dH_dz_nodes[vpardim][j1index]/vmap_prime_nodes[j1index])
           )
         ),
         if cdim = 2 then (
             printf(fh, "-(~a)/m_/bmag_quad * 1/q_*dualcurlbhat_quad[~a]*(~a)", dH_dz_nodes[1][j1index], 0, dH_dz_nodes[vpardim][j1index]/vmap_prime_nodes[j1index]),
             printf(fh, "-(~a)/m_/bmag_quad * 1/q_*dualcurlbhat_quad[~a]*(~a)", dH_dz_nodes[2][j1index], 2, dH_dz_nodes[vpardim][j1index]/vmap_prime_nodes[j1index])
         ),
         if cdim = 1 then (
             printf(fh, "-(~a)/m_/bmag_quad * 1/q_*dualcurlbhat_quad[~a]*(~a)", dH_dz_nodes[1][j1index], 2, dH_dz_nodes[vpardim][j1index]/vmap_prime_nodes[j1index])
         ),
        printf(fh, ";~%")
      ),

      printf(fh, "~%"),
      printf(fh, "  cfl = fmax(fabs(alpha_quad), fabs(cfl)) ;~%", j0index),
      printf(fh, "  JfL_quad =  (~a)/~a;~%", JfL_nodes[j1index], vmap_prime_l[surfDir-cdim-1]),
      printf(fh, "  JfR_quad =  (~a)/~a;~%", JfR_nodes[j1index], vmap_prime_r[surfDir-cdim-1]),
      printf(fh, "  Jfavg_quad = (JfL_quad + JfR_quad)/2.0 ;~%"),
      printf(fh, "  Jfjump_quad = (JfR_quad - JfL_quad)/2.0 ;~%"),
      printf(fh, "  flux_surf_nodal[~a] = alpha_quad*Jfavg_quad - fabs(alpha_quad)*Jfjump_quad ;~%", j0index)
    ),
    printf(fh, "~%")
  ),

  /* Do the quad nodal to modal ops directly here*/ 
  /*printf(fh, "~%"),
  printf(fh, "  double *fmodal = &flux_surf[~a]; ~%", NSurfIndexing*(surfDir-1)),
  flux_surf_nodal_e : doExpand1(flux_surf_nodal,basisNodal),
  fmodproj_e : fullratsimp(calcInnerProdList(surfIntVars, 1, bSurf, flux_surf_nodal_e)),

  for i : 1 thru length(fmodproj_e) do (
    printf(fh, "  fmodal[~a] = ~a; ~%", i-1, float(expand(fmodproj_e[i])))
  ),

  printf(fh, "~%"),*/
  /*Calculate the cfl*/
  pOrderCFL : polyOrder,
  if polyOrder=1 then ( pOrderCFL : 2 ),
  printf(fh, "  double vmap_prime_min = fmin(fabs(~a),fabs(~a));~%",vmap_prime_l[surfDir-cdim-1],vmap_prime_r[surfDir-cdim-1]),
  vprimeStr : "/vmap_prime_min",
  printf(fh, "~%"),
  printf(fh, "  return cfl~a*~a; ~%", vprimeStr, float(0.5*(2*pOrderCFL+1)*rdSurfVar2)),

  printf(fh, "~%"),
  flush_output(fh),
  printf(fh, "} ~%")

)$


AddAparGKEMFluxVparKernel(surfDir, fh, funcNm, cdim, vdim, basisFun, polyOrder, edge) := block(
  [pDim,varsC,bC,varsP,bP,vSub,numC,numP,surfVar,varLabel,dirLabel,surfIntVars,surf_cvars,surf_vvars,
   surfIntVarsC,bSurfC,surfNodes,nodeVars,bSurf,basisNodal,configNodes,numSurfNodes,numConfigNodes,
   numVelNodes,tempVars,tempBasis,NSurfIndexing,numNodesIndexing,d,rdx2vec,rdv2vec,rdSurfVar2,
   bmagBasis,phi_e,bmag_e,vmap_e,vmapSq_e,vmap_prime_e,evPoint,hamil_e,hamil_c,replaceList,
   hamilCvar,hamilNoZero_c,JfL_e,JfR_e,JfL_c,JfR_c,JfL_nodes,JfR_nodes,vmap_prime_nodes,vpardim,
   dH_dz_nodes,i,j,j0index,j1index,pOrderCFL,vprimeStr
  ],

  kill(varsC,varsP,bC,bP),
  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  numC : length(bC),  numP : length(bP), 

  surfVar  : varsP[surfDir],         /* Surface variable. */
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  surfIntVars : delete(surfVar,varsP), 
  surf_cvars  : delete(surfVar, makelist(varsP[i],i,1,cdim)),
  surf_vvars  : delete(surfVar, makelist(varsP[cdim+i],i,1,vdim)),

  surfIntVarsC : delete(surfVar,varsC), 
  bSurfC       : basisFromVars(basisFun,surfIntVarsC,polyOrder),
  
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    surfNodes : gaussOrdGkHyb(1+1, surf_cvars, surf_vvars),
    nodeVars  : surfIntVars, 
    bSurf     : basisFromVars("gkhyb",surfIntVars,polyOrder),
    basisNodal  : getVarsNodalBasisWithNodesHyb("gkhyb", cdim, vdim-1, surfIntVars, surfNodes)
  ) else (
    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    nodeVars  : surfIntVars,
    bSurf     : basisFromVars(basisFun,surfIntVars,polyOrder)
  ),
  configNodes : gaussOrd(polyOrder+1, cdim),
  numSurfNodes : length(surfNodes),  
  numConfigNodes : length(configNodes), 
  numVelNodes : numSurfNodes/numConfigNodes, 

  /* if polyOrder = 1, we need to be careful about
     indexing input arrays since the surface hybrid basis has a different size in the
     vparallel surfaces and/or we are more directly exploiting the sparsity of 
     alpha (e.g., in the x and z direction when no toroidal field, by=0) 
     and thus utilize fewer coefficients to reduce the number of operations */
  if (polyOrder = 1) then (
    tempVars         : delete(x,varsP), 
    tempBasis        : basisFromVars("gkhyb",tempVars,polyOrder),
    NSurfIndexing    : length(tempBasis),
    numNodesIndexing : length(tempBasis)
  ) else (
    NSurfIndexing    : NSurf,
    numNodesIndexing : numNodes
  ),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(
    const double *w, const double *dxv, 
    const double *vmap_prime_l, const double *vmap_prime_r,
    const double *vmap, const double *vmapSq, const double q_, const double m_,
    const struct gkyl_dg_vol_geom *dgv, const struct gkyl_gk_dg_vol_geom *gkdgv,
    const double *bmag, const double *phi, const double *apar, const double *JfL, const double *JfR,
    double* GKYL_RESTRICT flux_surf) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // vmap_prime_l,vmap_prime_r: velocity space mapping derivative in left and right cells.~%"),
  printf(fh, "  // vmap: velocity space mapping.~%"),
  printf(fh, "  // vmapSq: velocity space mapping squared.~%"),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // dgv: volume DG geometry.~%"),
  printf(fh, "  // gkdgv: gyrokinetic volume DG geometry.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // phi: electrostatic potential.~%"),
  printf(fh, "  // apar: parallel component of vector potential.~%"),
  printf(fh, "  // JfL: distribution times total jacobian in left cell.~%"),
  printf(fh, "  // JfR: distribution times total jacobian in right cell.~%"),
  printf(fh, "  // flux_surf: output surface phase space flux in each direction (cdim + 1 components).~%"),
  printf(fh, "  //            Note: Each cell owns their *lower* edge surface evaluation.~%"),
  printf(fh, "~%"),

  /* Declare cell-center variables and variables multiplying gradients. */
  for d : 1 thru cdim+1 do (
    printf(fh, "  double rd~a2 = 2.0/dxv[~a];~%", varLabel[d], d-1)
  ),
  printf(fh, "~%"),
  rdx2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,1,cdim),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),

  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  /* Axisymmetric basis (independent of y). */
  bmagBasis : getAxisymmetricConfBasis(bC),

  /* Expand input fields for Hamiltonian calculation */
  phi_e  : doExpand1(phi,bC),
  bmag_e : doExpand1(bmag, bmagBasis),

  /* Velocity mapping fields. */
  [vmap_e,vmapSq_e,vmap_prime_e] : expandVmapFields(varsP),

  /* Redefine vmap_prime to exploit the relationship between it and vmap. */
  /*vmap_prime_e : makelist((2/dxv[cdim+d-1])*diff(vmap_e[d],varsP[cdim+d]),d,1,vdim),*/
  vmap_prime_e : makelist(diff(vmap_e[d],varsP[cdim+d]),d,1,vdim),

  if edge = true then (
    evPoint : 1
  ) else (
    evPoint : -1
  ),

  /* Finally write out the hamiltonian*/
  hamil_e : q_*phi_e + (1/2)*m_*vmapSq_e[1],
  if vdim > 1 then ( hamil_e : hamil_e + vmap_e[2]*bmag_e ),
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),
  printf(fh, "  double hamil[~a] = {0.}; ~%", numP),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  hamilCvar : eval_string(sconcat("hamil")),
  writeCExprsNoExpand1(hamilCvar, gcfac(float(expand(subst(replaceList, hamil_c))))),
  printf(fh, "~%"),
  flush_output(fh),
  hamilNoZero_c : makelistNoZeros1(hamil_c, hamilCvar),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,
  /*hamil_e : subst(surfVar=evPoint,hamil_e),*/

  /* Expand Apar */
  apar_e : doExpand1(apar, bC),
  /* I don't know if this is necessary but let's copy the Hamiltonian treatment */
  apar_c : calcInnerProdList(varsP, 1, bP, apar_e),
  apar_e : apar_c . bP, 
  apar_nodes : makelist(0, i, 1, cdim),  
  for i : 1 thru cdim do (
    apar_nodes[i] : float(evAtNodes(apar_e,surfNodes,surfIntVars))
  ),
  /* Compute gradient of Aparallel */
  dA_dx_nodes : makelist(0, i, 1, cdim),  
  for i : 1 thru cdim do (
    dA_dx_nodes[i] : float(evAtNodes(diff(apar_e*rdx2vec[i],varsP[i]),surfNodes,surfIntVars))
  ),

  /*fl and fr */
  JfL_e : doExpand1(JfL, bP),
  JfR_e : doExpand1(JfR, bP),
  JfL_c : calcInnerProdList(varsP, 1, bP, JfL_e),
  JfR_c : calcInnerProdList(varsP, 1, bP, JfR_e),
   
  JfL_e : subst(surfVar=1,JfL_e),
  JfR_e : subst(surfVar=-1,JfR_e),

  JfL_nodes : float(evAtNodes(JfL_e,surfNodes,surfIntVars)),
  JfR_nodes : float(evAtNodes(JfR_e,surfNodes,surfIntVars)),

  vmap_prime_nodes : float(evAtNodes(vmap_prime_e[1],surfNodes,surfIntVars)),

  vpardim : pDim-1,
  if vdim = 1 then ( vpardim : pDim ),
  dH_dz_nodes : makelist(0, i, 1, pDim),  
  for i : 1 thru vpardim do (
    if i = vpardim then (
      dH_dz_nodes[i] : float(evAtNodes(diff(hamil_e,varsP[i]),surfNodes,surfIntVars)),
      dH_dz_nodes[i] : subst(surfVar=evPoint, dH_dz_nodes[i])
    )
    else (
      dH_dz_nodes[i] : float(evAtNodes(diff(hamil_e*rdx2vec[i],varsP[i]),surfNodes,surfIntVars))
    )
  ),

  /* Now calculate apha at all quadrature nodes */
  /*printf(fh, "  double flux_surf_nodal[~a]= {0.0}; ~%", numSurfNodes),*/
  printf(fh, "  double *flux_surf_nodal = &flux_surf[~a]; ~%", NSurfIndexing*(surfDir-1)),
  printf(fh, "  double cfl = 0.0; ~%"),
  printf(fh, "  double bmag_quad = 0.0; ~%"),
  printf(fh, "  double B3_quad = 0.0; ~%"),
  printf(fh, "  double Jc_quad = 0.0; ~%"),
  printf(fh, "  double dualcurlbhat_quad[3] = {0.0}; ~%"),
  printf(fh, "  double m_bmag_inv = 0.0; ~%"),
  printf(fh, "  double mvpar_over_q = 0.0; ~%"),

  printf(fh, "  double alpha_quad = 0.0; ~%"),
  printf(fh, "  double JfL_quad = 0.0; ~%"),
  printf(fh, "  double JfR_quad = 0.0; ~%"),
  printf(fh, "  double Jfavg_quad = 0.0; ~%"),
  printf(fh, "  double Jfjump_quad = 0.0; ~%"),
  printf(fh, "~%"),

  for i : 1 thru numConfigNodes do (
    printf(fh, "  bmag_quad = gkdgv[~a].bmag; ~%", i-1), 
    printf(fh, "  B3_quad = gkdgv[~a].B3; ~%", i-1), 
    printf(fh, "  Jc_quad = dgv[~a].Jc; ~%", i-1), 
    printf(fh, "  dualcurlbhat_quad[0] = gkdgv[~a].dualcurlbhat.x[0]; ~%", i-1), 
    printf(fh, "  dualcurlbhat_quad[1] = gkdgv[~a].dualcurlbhat.x[1]; ~%", i-1), 
    printf(fh, "  dualcurlbhat_quad[2] = gkdgv[~a].dualcurlbhat.x[2]; ~%", i-1), 

    printf(fh, "  m_bmag_inv = 1.0/(m_*bmag_quad); ~%"),
    /* 
      We develop the component grad(Apar) x b as
        e^m . grad(Apar) x b = e^m x grad(Apar) . b = e^m x e^i dApar/dx^i . e_3/|e_3| 
      which gives 
        coeff * (g_33 dApar/dx2 - g_23 dApar/dx3) for m=1
        coeff * (g_13 dApar/dx3 - g_33 dApar/dx1) for m=2
        coeff * (g_23 dApar/dx1 - g_13 dApar/dx2) for m=3
      with 
        coeff = Jc/sqrt(g_33)
    */
    printf(fh, "  g_13 = 1.0; ~%"), /* need to pass them */
    printf(fh, "  g_23 = 1.0; ~%"),
    printf(fh, "  g_33 = 1.0; ~%"),
    printf(fh, "  mag_e_3 = 1.0; ~%"), /* I need |e_3|=sqrt(g_33) here */

    printf(fh, "~%"),
    for j : 1 thru numVelNodes do (
      j0index : j-1+(i-1)*numVelNodes,
      j1index : j+(i-1)*numVelNodes,
      printf(fh, "~%"),
      printf(fh, "  mvpar_over_q = (~a)/q_; ~%", dH_dz_nodes[vpardim][j1index]/vmap_prime_nodes[j1index]),

      printf(fh, "  alpha_quad = 0.0; ~%"),
      if cdim = 3 then (
        /* Terms related to Aparallel following curl(Apar*b) = Apar * curl(b) grad(Apar) x b */
        for k : 1 thru cdim do (
          /* Apar * curl(b) */
          printf(fh, "alpha_quad += -(~a)*m_bmag_inv * (~a)*dualcurlbhat_quad[~a]; ~%", dH_dz_nodes[k][j1index], apar_nodes[k][j1index], k-1)
        ),
        /* grad(Apar) x b */
        printf(fh, "alpha_quad += -(~a)*m_bmag_inv * Jc_quad/mag_e_3 * (g_33 * (~a) - g_23 * (~a)); ~%", dH_dz_nodes[1][j1index], dA_dx_nodes[2][j1index], dA_dx_nodes[3][j1index]),
        printf(fh, "alpha_quad += -(~a)*m_bmag_inv * Jc_quad/mag_e_3 * (g_13 * (~a) - g_33 * (~a)); ~%", dH_dz_nodes[2][j1index], dA_dx_nodes[3][j1index], dA_dx_nodes[1][j1index]),
        printf(fh, "alpha_quad += -(~a)*m_bmag_inv * Jc_quad/mag_e_3 * (g_23 * (~a) - g_13 * (~a)); ~%", dH_dz_nodes[3][j1index], dA_dx_nodes[1][j1index], dA_dx_nodes[2][j1index])
      ),
      if cdim = 2 then (
        /* Terms related to Aparallel following curl(Apar*b) = Apar * curl(b) grad(Apar) x b */
        /* Apar * curl(b) */
        printf(fh, "alpha_quad += -(~a)*m_bmag_inv * (~a)*dualcurlbhat_quad[~a]; ~%", dH_dz_nodes[1][j1index], apar_nodes[1][j1index], 0),
        printf(fh, "alpha_quad += -(~a)*m_bmag_inv * (~a)*dualcurlbhat_quad[~a]; ~%", dH_dz_nodes[2][j1index], apar_nodes[2][j1index], 2),
        /* grad(Apar) x b */
        printf(fh, "alpha_quad += -(~a)*m_bmag_inv * Jc_quad/mag_e_3 * (-g_23 * (~a)); ~%", dH_dz_nodes[1][j1index], dA_dx_nodes[2][j1index]),
        printf(fh, "alpha_quad += -(~a)*m_bmag_inv * Jc_quad/mag_e_3 * ( g_23 * (~a)); ~%", dH_dz_nodes[2][j1index], dA_dx_nodes[1][j1index])
      ),
      if cdim = 1 then (
        /* Terms related to Aparallel following curl(Apar*b) = Apar * curl(b) grad(Apar) x b */
        /* Apar * curl(b) */
        printf(fh, "alpha_quad += -(~a)*m_bmag_inv * (~a)*dualcurlbhat_quad[~a]; ~%", dH_dz_nodes[1][j1index], apar_nodes[1][j1index], 2)
        /* grad(Apar) x b */
        /* none */
      ),

      printf(fh, "~%"),
      printf(fh, "  cfl = fmax(fabs(alpha_quad), fabs(cfl)) ;~%", j0index),
      printf(fh, "  JfL_quad =  (~a)/~a;~%", JfL_nodes[j1index], vmap_prime_l[surfDir-cdim-1]),
      printf(fh, "  JfR_quad =  (~a)/~a;~%", JfR_nodes[j1index], vmap_prime_r[surfDir-cdim-1]),
      printf(fh, "  Jfavg_quad = (JfL_quad + JfR_quad)/2.0 ;~%"),
      printf(fh, "  Jfjump_quad = (JfR_quad - JfL_quad)/2.0 ;~%"),
      printf(fh, "  flux_surf_nodal[~a] += alpha_quad*Jfavg_quad - fabs(alpha_quad)*Jfjump_quad ;~%", j0index)
    ),
    printf(fh, "~%")
  ),

  printf(fh, "~%"),
  /*Calculate the cfl*/
  pOrderCFL : polyOrder,
  if polyOrder=1 then ( pOrderCFL : 2 ),
  printf(fh, "  double vmap_prime_min = fmin(fabs(~a),fabs(~a));~%",vmap_prime_l[surfDir-cdim-1],vmap_prime_r[surfDir-cdim-1]),
  vprimeStr : "/vmap_prime_min",
  printf(fh, "~%"),
  printf(fh, "  return cfl~a*~a; ~%", vprimeStr, float(0.5*(2*pOrderCFL+1)*rdSurfVar2)),

  printf(fh, "~%"),
  flush_output(fh),
  printf(fh, "} ~%")

)$

AddApardotGKEMFluxVparKernel(surfDir, fh, funcNm, cdim, vdim, basisFun, polyOrder, edge) := block(
  [pDim,varsC,bC,varsP,bP,surfVar,varLabel,dirLabel,surfIntVars,surf_cvars,surf_vvars,
   surfNodes,configNodes,numSurfNodes,numConfigNodes,
   numVelNodes,tempVars,tempBasis,NSurfIndexing,numNodesIndexing,d,rdSurfVar2,
   JfL_e,JfR_e,JfL_nodes,JfR_nodes,i,j,j0index,j1index,pOrderCFL,vprimeStr
  ],

  kill(varsC,varsP,bC,bP),
  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),

  surfVar  : varsP[surfDir],         /* Surface variable. */
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  surfIntVars : delete(surfVar,varsP), 
  surf_cvars  : delete(surfVar, makelist(varsP[i],i,1,cdim)),
  surf_vvars  : delete(surfVar, makelist(varsP[cdim+i],i,1,vdim)),

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    surfNodes : gaussOrdGkHyb(1+1, surf_cvars, surf_vvars)
  ) else (
    surfNodes : gaussOrd(polyOrder+1, pDim-1)
  ),
  configNodes : gaussOrd(polyOrder+1, cdim),
  numSurfNodes : length(surfNodes),  
  numConfigNodes : length(configNodes), 
  numVelNodes : numSurfNodes/numConfigNodes, 

  /* if polyOrder = 1, we need to be careful about
     indexing input arrays since the surface hybrid basis has a different size in the
     vparallel surfaces and/or we are more directly exploiting the sparsity of 
     alpha (e.g., in the x and z direction when no toroidal field, by=0) 
     and thus utilize fewer coefficients to reduce the number of operations */
  if (polyOrder = 1) then (
    tempVars         : delete(x,varsP), 
    tempBasis        : basisFromVars("gkhyb",tempVars,polyOrder),
    NSurfIndexing    : length(tempBasis),
    numNodesIndexing : length(tempBasis)
  ) else (
    NSurfIndexing    : NSurf,
    numNodesIndexing : numNodes
  ),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(
    const double *w, const double *dxv, 
    const double *vmap_prime_l, const double *vmap_prime_r,
    const double *vmap, const double *vmapSq, const double q_, const double m_,
    const struct gkyl_dg_vol_geom *dgv, const struct gkyl_gk_dg_vol_geom *gkdgv,
    const double *bmag, const double *phi, const double *apardot, const double *JfL, const double *JfR,
    double* GKYL_RESTRICT flux_surf) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // vmap_prime_l,vmap_prime_r: velocity space mapping derivative in left and right cells.~%"),
  printf(fh, "  // vmap: velocity space mapping.~%"),
  printf(fh, "  // vmapSq: velocity space mapping squared.~%"),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // dgv: volume DG geometry.~%"),
  printf(fh, "  // gkdgv: gyrokinetic volume DG geometry.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // phi: electrostatic potential.~%"),
  printf(fh, "  // apardot: time derivative of the parallel component of vector potential.~%"),
  printf(fh, "  // JfL: distribution times total jacobian in left cell.~%"),
  printf(fh, "  // JfR: distribution times total jacobian in right cell.~%"),
  printf(fh, "  // flux_surf: output surface phase space flux in each direction (cdim + 1 components).~%"),
  printf(fh, "  //            Note: Each cell owns their *lower* edge surface evaluation.~%"),
  printf(fh, "~%"),

  /* Declare cell-center variables and variables multiplying gradients. */
  for d : 1 thru cdim+1 do (
    printf(fh, "  double rd~a2 = 2.0/dxv[~a];~%", varLabel[d], d-1)
  ),
  printf(fh, "~%"),

  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  printf(fh, "~%"),
  flush_output(fh),

  /* Expand Apardot */
  apardot_e : doExpand1(apardot, bC),
  /* I don't know if this is necessary but let's copy the Hamiltonian treatment */
  apardot_c : calcInnerProdList(varsP, 1, bP, apardot_e),
  apardot_e : apardot_c . bP, 
  apardot_nodes : float(evAtNodes(apardot_e,surfNodes,surfIntVars)),

  /*fl and fr */
  JfL_e : doExpand1(JfL, bP),
  JfR_e : doExpand1(JfR, bP),
   
  JfL_e : subst(surfVar=1,JfL_e),
  JfR_e : subst(surfVar=-1,JfR_e),

  JfL_nodes : float(evAtNodes(JfL_e,surfNodes,surfIntVars)),
  JfR_nodes : float(evAtNodes(JfR_e,surfNodes,surfIntVars)),

  /* Now calculate alpha at all quadrature nodes */
  printf(fh, "  double *flux_surf_nodal = &flux_surf[~a]; ~%", NSurfIndexing*(surfDir-1)),
  printf(fh, "  double cfl = 0.0; ~%"),

  printf(fh, "  double alpha_quad = 0.0; ~%"),
  printf(fh, "  double JfL_quad = 0.0; ~%"),
  printf(fh, "  double JfR_quad = 0.0; ~%"),
  printf(fh, "  double Jfavg_quad = 0.0; ~%"),
  printf(fh, "  double Jfjump_quad = 0.0; ~%"),
  printf(fh, "~%"),

  for i : 1 thru numConfigNodes do (
    printf(fh, "~%"),
    for j : 1 thru numVelNodes do (
      j0index : j-1+(i-1)*numVelNodes,
      j1index : j+(i-1)*numVelNodes,
      printf(fh, "~%"),

      /* Compute the contribution of Apardot */
      printf(fh, "  alpha_quad = -q_/m_*(~a); ~%", apardot_nodes[j1index]),

      printf(fh, "~%"),
      printf(fh, "  cfl = fmax(fabs(alpha_quad), fabs(cfl)) ;~%", j0index),
      printf(fh, "  JfL_quad =  (~a)/~a;~%", JfL_nodes[j1index], vmap_prime_l[surfDir-cdim-1]),
      printf(fh, "  JfR_quad =  (~a)/~a;~%", JfR_nodes[j1index], vmap_prime_r[surfDir-cdim-1]),
      printf(fh, "  Jfavg_quad = (JfL_quad + JfR_quad)/2.0 ;~%"),
      printf(fh, "  Jfjump_quad = (JfR_quad - JfL_quad)/2.0 ;~%"),
      printf(fh, "  flux_surf_nodal[~a] += alpha_quad*Jfavg_quad - fabs(alpha_quad)*Jfjump_quad ;~%", j0index)
    ),
    printf(fh, "~%")
  ),

  printf(fh, "~%"),
  /*Calculate the cfl*/
  pOrderCFL : polyOrder,
  if polyOrder=1 then ( pOrderCFL : 2 ),
  printf(fh, "  double vmap_prime_min = fmin(fabs(~a),fabs(~a));~%",vmap_prime_l[surfDir-cdim-1],vmap_prime_r[surfDir-cdim-1]),
  vprimeStr : "/vmap_prime_min",
  printf(fh, "~%"),
  printf(fh, "  return cfl~a*~a; ~%", vprimeStr, float(0.5*(2*pOrderCFL+1)*rdSurfVar2)),

  printf(fh, "~%"),
  flush_output(fh),
  printf(fh, "} ~%")
)$
