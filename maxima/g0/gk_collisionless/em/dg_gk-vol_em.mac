/*
   Create kernels for the volume term of the gyrokinetic collisionless terms.
*/

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("utilities_gyrokinetic")$
load("utilities")$
fpprec : 24$

buildGKAddEMVolKernel(fh, funcNm, cdim, vdim, basisFun, polyOrder, varsInB, no_by) := block(
  [pDim,varsC,bC,varsP,bP,varsV,vSub,numC,numP,varLabel,d,rdx2vec,rdv2vec,allVarLabelsC,
   bmagBasis,ignoreVars,inFlds_e,cmag_e,b_x_e,b_y_e,b_z_e,jacobTotInv_e,vmap_e,BstardBmag_e,
   hamil_e,pbAuxFlds,alphaSum_e,vd,dir,dirLabel,wDir,rdDirVar2,vmap_prime_fac,dirVar,
   dirVar_phys,alpha_e,alpha_c,alphaLabel,alphaNoZero_c,alphaDotGradBasis_e,f_e,volTerm_c, dH_dz_e, alphaJf_e, Jf_e, replaceListHamil, replaceListVpar,hamil2_c,isqlist,mvpar_e,mvparsq_e],

  kill(varsC,varsP,bC,bP),
  pDim : cdim+vdim,

  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  numC : length(bC),  numP : length(bP), 

  varLabel : makelist(string(varsP[d]),d,1,pDim),

  print("Working on ", funcNm),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *vmap, const double *vmapSq,
    const double q_, const double m_, const double *bmag, const double *phi,
    const double *apar, const double *rtg33inv, const double *bioverJB,
    const double *fin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[NDIM]: cell-center.~%"),
  printf(fh, "  // dxv[NDIM]: cell length.~%"),
  printf(fh, "  // vmap: velocity space mapping.~%"),
  printf(fh, "  // vmapSq: velocity space mapping squared.~%"),
  printf(fh, "  // q_,m_: species charge and mass.~%"),
  printf(fh, "  // bmag: magnetic field amplitude.~%"),
  printf(fh, "  // phi: electrostatic potential .~%"),
  printf(fh, "  // apar: parallel component of vector potential.~%"),
  printf(fh, "  // fin: Distribution function.~%"),
  printf(fh, "  // out: output increment.~%"),
  printf(fh, "~%"),


  /* Declare cell-center variables and variables multiplying gradients. */
  for d : 1 thru pDim do (
    printf(fh, "  double rd~a2 = 2.0/dxv[~a];~%", varLabel[d], d-1)
  ),
  printf(fh, "~%"),
  rdx2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,1,cdim),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),

  /* Declare variables with squared of cell centers and rdx2 variables (only need vpar^2). */
  printf(fh, "  double rdvpar2Sq = rdvpar2*rdvpar2;~%"),
  printf(fh, "  double dvparSq = dxv[~a]*dxv[~a];~%", cdim, cdim),
  printf(fh, "~%"),
  replaceList : [rdvpar2^2=rdvpar2Sq,dxv[cdim]^2=dvparSq,rdvpar2Sq=4/dvparSq],
  dvparSimp : append(makelist(dxv[i-1]=2/eval_string(sconcat("rd",varLabel[i],"2")),i,1,pDim),
                     [dvparSq=4/rdvpar2Sq]),

  /* Create pointers to the components of b_i. */
  allVarLabelsC : ["x","y","z"],
  for d : 1 thru 3 do (
    printf(fh, "  const double *bioverJB_~a = &bioverJB[~a]; ~%", allVarLabelsC[d], numC*(d-1))
  ),
  printf(fh, "~%"),

  /* Create pointers to the components of dualcurlbhatoverB. */
  allVarLabelsC : ["x","y","z"],
  for d : 1 thru 3 do (
    printf(fh, "  const double *dualcurlbhatoverB_~a = &dualcurlbhatoverB[~a]; ~%", allVarLabelsC[d], numC*(d-1))
  ),
  printf(fh, "~%"),

  /* Axisymmetric basis (independent of y). */
  bmagBasis : getAxisymmetricConfBasis(bC),
  /* Expand input fields for Hamiltonian calculation */
  phi_e     : doExpand1(phi,bC),
  apar_e    : doExpand1(apar,bC),
  bmag_e : doExpand1(bmag, bmagBasis),


  /* dualcurlbhatoverB_x_e : doExpand1(dualcurlbhatoverB_x, bmagBasis),
  dualcurlbhatoverB_y_e : doExpand1(dualcurlbhatoverB_y, bmagBasis),
  dualcurlbhatoverB_z_e : doExpand1(dualcurlbhatoverB_z, bmagBasis), */
  /* Zero out some terms below to avoid the discontinuity of alpha in the
     parallel direction (due to the discontinuity of Apar). Otherwise some
     other treatment of some Apar terms or alpha may be needed. Initially we
     had a step averaging alpha across the surface (just for the parallel
     direction), but NRM suspects this might've caused instability in some
     cases. Hence the zeros below. */
  discontFac : 0,
  if cdim > 1 then (rdy2 : rdx2vec[2]) else (rdy2 : 0),
  if cdim > 2 then (rdz2 : rdx2vec[3]) else (rdz2 : 0),
  /* Expand e^x . \nabla \times A_\parallel / Bmag on basis. */
  dualcurlbAparoverB_x_e : (rdy2*diff(apar_e*b_z_e,y) - discontFac*rdz2*diff(apar_e*b_y_e,z))*jacobTotInv_e,
  /* Expand e^y . \nabla \times A_\parallel / Bmag on basis. */
  dualcurlbAparoverB_y_e : (discontFac*rdz2*diff(apar_e*b_x_e,z) - rdx2vec[1]*diff(apar_e*b_z_e,x))*jacobTotInv_e,
  /* Expand e^z . \nabla \times A_\parallel / Bmag on basis. */
  dualcurlbAparoverB_z_e : (discontFac*(rdx2vec[1]*diff(apar_e*b_y_e,x) - rdy2*diff(apar_e*b_x_e,y)))*jacobTotInv_e,

  varsP : listofvars(bP),
  numP  : length(bP),

  /* Project Bstar's onto basis, and print to arrays. */
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  if cdim > 1 then (
    dualcurlbAparoverB_c : calcInnerProdList(varsP, 1, bP, dualcurlbAparoverB_x_e),
    if (surfDir = 0 or surfDir = 1 or surfDir = cdim+1) then (
      printf(fh, "  double dualcurlbAparoverB~a[~a] = {0.}; ~%", sideStr,numP),
      writeCExprsNoExpand1(eval_string(sconcat("dualcurlbAparoverB",sideStr)), gcfac(subst(replaceList, dualcurlbAparoverB_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    dualcurlbAparoverB_noZero_c : makelistNoZeros1(dualcurlbAparoverB_c, eval_string(sconcat("dualcurlbAparoverB",sideStr))),
    dualcurlbAparoverB_e : dualcurlbAparoverB_noZero_c . bP,

    dualcurlbAparoverB_y_c : calcInnerProdList(varsP, 1, bP, dualcurlbAparoverB_y_e),
    if (surfDir = 0 or surfDir = 2 or surfDir = cdim+1) then (
      printf(fh, "  double dualcurlbAparoverB_y~a[~a] = {0.}; ~%", sideStr, numP),
      writeCExprsNoExpand1(eval_string(sconcat("dualcurlbAparoverB_y",sideStr)), gcfac(subst(replaceList, dualcurlbAparoverB_y_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    dualcurlbAparoverB_y_noZero_c : makelistNoZeros1(dualcurlbAparoverB_y_c, eval_string(sconcat("dualcurlbAparoverB_y",sideStr))),
    dualcurlbAparoverB_y_e : dualcurlbAparoverB_y_noZero_c . bP
  ),
  if cdim # 2 then (
    dualcurlbAparoverB_z_c : calcInnerProdList(varsP, 1, bP, dualcurlbAparoverB_z_e),
    if (surfDir=0 or surfDir>=cdim) then (
      printf(fh, "  double dualcurlbAparoverB_z~a[~a] = {0.}; ~%", sideStr, numP),
      writeCExprsNoExpand1(eval_string(sconcat("dualcurlbAparoverB_z",sideStr)), gcfac(subst(replaceList, dualcurlbAparoverB_z_c))),
      printf(fh, "~%"),
      flush_output(fh)
    ),
    dualcurlbAparoverB_z_noZero_c : makelistNoZeros1(dualcurlbAparoverB_z_c, eval_string(sconcat("dualcurlbAparoverB_z",sideStr))),
    dualcurlbAparoverB_z_e : dualcurlbAparoverB_z_noZero_c . bP
  ),

  /* Make Bstar/Bmag vector. */
  /* if cdim = 1 then (
    dualcurlbAparoverB_list : [dualcurlbAparoverB_z_e]
  ) elseif cdim = 2 then (
    dualcurlbAparoverB_list : [dualcurlbAparoverB_x_e, dualcurlbAparoverB_y_e]
  ) elseif cdim = 3 then (
    dualcurlbAparoverB_list : [dualcurlbAparoverB_x_e, dualcurlbAparoverB_y_e, dualcurlbAparoverB_z_e]
  ), */

  rtg33inv_e : doExpand1(rtg33inv, bmagBasis),
  bioverJB_x_e : doExpand1(bioverJB_x, bmagBasis),
  bioverJB_y_e : doExpand1(bioverJB_y, bmagBasis),
  bioverJB_z_e : doExpand1(bioverJB_z, bmagBasis),

  dualcurlbAparoverB_list : [dualcurlbAparoverB_x_e, dualcurlbAparoverB_y_e, dualcurlbAparoverB_z_e],
  bioverJB_list : [bioverJB_x_e, bioverJB_y_e, bioverJB_z_e],

  /* Velocity mapping fields. */
  [vmap_e,vmapSq_e,vmap_prime_e] : expandVmapFields(varsP),

  /* Redefine vmap_prime to exploit the relationship between it and vmap. */
  vmap_prime_e : makelist(diff(vmap_e[d],varsP[cdim+d]),d,1,vdim),

  /* Finally write out the hamiltonian*/
  hamil_e : q_*phi_e + (1/2)*m_*vmapSq_e[1],
  if vdim > 1 then ( hamil_e : hamil_e + vmap_e[2]*bmag_e ),
  hamil_c : calcInnerProdList(varsP, 1, bP, hamil_e),
  printf(fh, "  double hamil[~a] = {0.}; ~%", numP),
  replaceList : [wvpar^2=wvparSq, rdvpar2^2=rdvpar2Sq, rdx2^2=rdx2Sq, m_^2=mSq, q_^2=qSq],
  hamilCvar : eval_string(sconcat("hamil")),
  writeCExprsNoExpand1(hamilCvar, gcfac(float(expand(subst(replaceList, hamil_c))))),
  printf(fh, "~%"),
  flush_output(fh),
  hamilNoZero_c : makelistNoZeros1(hamil_c, hamilCvar),
  /* Expand projected Hamiltonian on basis. */
  hamil_e : hamilNoZero_c . bP,

  /*Expand Jf*/
  Jf_e : doExpand1(fin,bP),

  /* Calculate expressions for dericatives of the hamiltonian*/
  vpardim : pDim-1,
  if vdim = 1 then ( vpardim : pDim ),
  dH_dz_e : makelist(0, i, 1, pDim),  
  for i : 1 thru vpardim do (
    if i = vpardim then (
      dH_dz_e[i] : diff(hamil_e,varsP[i])
    )
    else (
      dH_dz_e[i] : diff(hamil_e*rdx2vec[i],varsP[i])
    )
  ),

  /*Make sure to avoid having hamil[i]^2 or vmap[i]^2 in expressions*/
  replaceListVpar : [vmap[1]^2=vmap2],
  printf(fh, "  double vmap2 = vmap[1]*vmap[1]; ~%"),
  printf(fh, "~%"),

  mvpar_e : dH_dz_e[vpardim]/vmap_prime_e[1],
  mvparsq_e : mvpar_e*mvpar_e/m_,
  isqlist : [],
  for i : 1 thru numP do (
    if freeof(hamil[i]^2, expand(mvparsq_e)) = false then (
      isqlist : append(isqlist,[i])
    )
  ),

  replaceListHamil : [],
  printf(fh, "  double hamil2[~a] = {0.}; ~%", length(isqlist)),
  for i : 1 thru length(isqlist) do (
    printf(fh, "  hamil2[~a] = hamil[~a]*hamil[~a]; ~%", i-1, isqlist[i], isqlist[i]),
    replaceListHamil : append(replaceListHamil, [hamil[isqlist[i]]^2=hamil2[i-1]])
  ),
  printf(fh, "~%"),

  /* Note: no contribution from mu. */
  for dir : 1 thru cdim+1 do (

    dirLabel : varLabel[dir],

    wDir      : eval_string(sconcat("w",dirLabel)),
    rdDirVar2 : eval_string(sconcat("rd",dirLabel,"2")),
  
    dirVar    : varsP[dir],         /* Variable in current direction. */

    if dir = cdim then (
      alpha_e : rtg33inv_e*dH_dz_e[vpardim]/vmap_prime_e[1]/m_
    )
    else if dir = vpardim then (
      alpha_e : -rtg33inv_e * dH_dz_e[cdim]/m_
    )
    else (
      alpha_e : 0
    ),


    if no_by = false then (
      if cdim = 3 then (
        curvdriftdir : dir
      ),
      if cdim = 2 then (
        if dir = 1 then (
          curvdriftdir : dir
        ),
        if dir = 2 then (
          curvdriftdir : 3
        )
      ),
      if cdim = 1 then (
        curvdriftdir : 3
      ),

      if dir < vpardim then (
        alpha_e : alpha_e + dualcurlbAparoverB_list[curvdriftdir]*dH_dz_e[vpardim]/vmap_prime_e[1]*dH_dz_e[vpardim]/vmap_prime_e[1]/m_/q_
      ),
      if cdim = 3 then (
        if dir = 1 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[2]*dH_dz_e[3] - bioverJB_list[3]*dH_dz_e[2])
        ),
        if dir = 2 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[3]*dH_dz_e[1] - bioverJB_list[1]*dH_dz_e[3])
        ),
        if dir = 3 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[1]*dH_dz_e[2] - bioverJB_list[2]*dH_dz_e[1])
        )
      ),
      if cdim = 2 then (
        if dir = 1 then (
          alpha_e : alpha_e + 1/q_ * (bioverJB_list[2]*dH_dz_e[2])
        ),
        if dir = 2 then (
          alpha_e : alpha_e - 1/q_ * (bioverJB_list[2]*dH_dz_e[1])
        )
      ),
      if dir = vpardim then (
        if cdim = 3 then (
          for k : 1 thru cdim do (
            alpha_e : alpha_e - dualcurlbAparoverB_list[k]*dH_dz_e[k]*dH_dz_e[vpardim]/vmap_prime_e[1]/q_/m_
          )
        ),
        if cdim = 2 then (
            alpha_e : alpha_e - dualcurlbAparoverB_list[1]*dH_dz_e[1]*dH_dz_e[vpardim]/vmap_prime_e[1]/q_/m_ - dualcurlbAparoverB_list[3]*dH_dz_e[2]*dH_dz_e[vpardim]/vmap_prime_e[1]/q_/m_
        ),
        if cdim = 1 then (
            alpha_e : alpha_e - dualcurlbAparoverB_list[3]*dH_dz_e[1]*dH_dz_e[vpardim]/vmap_prime_e[1]/q_/m_
        )
      )

    ),

    if dir < vpardim then (
      alpha_e : alpha_e*rdx2vec[dir]
    )
    else if dir = vpardim then (
      alpha_e : alpha_e/vmap_prime_e[1]
    ),

    /* Project alpha on basis and write to array. */
    printf(fh, "  double alpha~a[~a] = {0.}; ~%", dirLabel, numP),
    alpha_c : fullratsimp(calcInnerProdList(varsP, 1, bP, alpha_e)),
    alpha_c : subst(replaceList, alpha_c),
    alpha_c : subst(replaceListHamil, alpha_c),
    alpha_c : subst(replaceListVpar, alpha_c),
    alpha_c : subst(dvparSimp, alpha_c),
    alphaLabel : eval_string(sconcat(alpha, dirLabel)),
    clst : [rdx2vec, rdv2vec, m_, q_, wvpar, rdvpar2Sq,
            makelist(dxv[i-1],i,1,pDim), makelist(vmap[i-1],i,1,2*length(vmap_e[1]))],
    writeCExprsCollect1(alphaLabel, alpha_c, clst),
    printf(fh, "~%"),
    flush_output(fh),
    alphaNoZero_c : makelistNoZeros1(alpha_c, alphaLabel),
    alpha_e       : doExpand(alphaNoZero_c, bP),

    alphaJf_e : alpha_e*Jf_e,

    printf(fh, "~%"),
    volTerm_c : fullratsimp(calcInnerProdList(varsP, 1, diff(bP,varsP[dir]), alphaJf_e)),
    volTerm_c : subst(replaceList, volTerm_c),
    writeCIncrExprsNoExpand(gcfac(float(expand(volTerm_c)))),
    flush_output(fh),
    printf(fh, "~%")

  ),


  printf(fh, "  return 0.; ~%"),
  printf(fh, "} ~%")
)$