/* Generate kernels that perform weak multiplication of two
   fields, say if C = A*B where A, B, and C are DG fields. */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("nodal_operations/nodal_functions")$

fpprec : 24$

calcBinOpConfMultiply(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [bType, pOrder, varsC, basisC, bW, varsW, wdim, N, f_e, g_e, fg_c],

  if (basisFun="ser") then bType : "Ser"
  elseif (basisFun="tensor") then bType : "Tensor",

  if polyOrder>0 then pOrder : polyOrder else pOrder : 1,

  [varsC, bC, varsP, bP] : loadPhaseBasis(bType, cdim, vdim, pOrder),

  N  : length(bP),

  wdim  : cdim,
    
  if (cdim = 2 and vdim = 2) then (
      varsSub : [vx=y, vy=vx, vz=vy],
      bP : subst(varsSub, copylist(bP)),
      varsP : subst(varsSub, copylist(varsP))
  ),
  if (cdim = 3 and vdim = 1) then (
        varsSub : [vx=y, vy=z, vz=vx],
        bP : subst(varsSub, copylist(bP)),
        varsP : subst(varsSub, copylist(varsP))
  ),  
  if (cdim = 3 and vdim = 2) then (
        varsSub : [vx=z, vy=vx, vz=vy],
        bP : subst(varsSub, copylist(bP)),
        varsP : subst(varsSub, copylist(varsP))
  ),

  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH~%"),
  printf(fh, "void~%"),
  printf(fh, "~a(const double *f, const double *g, double *fg, int linc2) ~%{ ~%", funcNm),
  
  
  printf(fh, "  // f:  First input DG field. ~%"),
  printf(fh, "  // g:  Second input DG field. ~%"),  
  printf(fh, "  // fg: Output DG field f*g using weak multiplication. ~%"),
  printf(fh, " ~%"),

  f_e : doExpand1(f, bC),
  g_e : doExpand1(g, bP),

  fg_c : calcInnerProdList(varsP, 1, bP, f_e*g_e),

  printf(fh, "  switch (linc2) { ~%"), 
  for i : 1 thru length(fg_c) do (
    printf(fh, "    case ~a: ~%", i-1),
    printf(fh, "      fg[~a] = ~a; ~%", i-1, float(expand(fg_c[i])))
  ),
  flush_output(fh),
  printf(fh, "  } ~%"),
  printf(fh, "} ~%")
)$

calcBinOpConfMultiplyHyb(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [bType, pOrder, varsC, basisC, bW, varsW, wdim, N, f_e, g_e, fg_c],

  if basisFun = "hyb" then (
    [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, 1)
  ) elseif basisFun = "gkhyb" then (
    [varsC,bC,varsP,bP,vsub] : loadGkBasis(basisFun, cdim, vdim, 1)
  ),
  N  : length(bP),

  wdim  : cdim,

  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH~%"),
  printf(fh, "void~%"),
  printf(fh, "~a(const double *f, const double *g, double *fg, int linc2) ~%{ ~%", funcNm),
  
  
  printf(fh, "  // f:  First input DG field. ~%"),
  printf(fh, "  // g:  Second input DG field. ~%"),  
  printf(fh, "  // fg: Output DG field f*g using weak multiplication. ~%"),
  printf(fh, " ~%"),

  f_e : doExpand1(f, bC),
  g_e : doExpand1(g, bP),

  fg_c : calcInnerProdList(varsP, 1, bP, f_e*g_e),

  printf(fh, "  switch (linc2) { ~%"), 
  for i : 1 thru length(fg_c) do (
    printf(fh, "    case ~a: ~%", i-1),
    printf(fh, "      fg[~a] = ~a; ~%", i-1, float(expand(fg_c[i])))
  ),
  flush_output(fh),
  printf(fh, "  } ~%"),
  printf(fh, "} ~%")
)$