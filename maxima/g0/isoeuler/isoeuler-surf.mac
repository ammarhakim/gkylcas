load("modal-basis");
load("out-scripts");
fpprec : 24$
ratprint: false$

cvars : [X, Y, Z]$
cvars_name : ["x","y","z"]$
svars : [rho, rhou0, rhou1, rhou2]$
svarsl : [rhol,rhou0l,rhou1l,rhou2l]$
svarsc : [rhoc,rhou0c,rhou1c,rhou2c]$
svarsr : [rhor,rhou0r,rhou1r,rhou2r]$
svarsll : [rholl,rhou0ll,rhou1ll,rhou2ll]$
svarscl : [rhocl,rhou0cl,rhou1cl,rhou2cl]$
svarsrl : [rhorl,rhou0rl,rhou1rl,rhou2rl]$

uvar : [uvar0,uvar1,uvar2]$
uvarl : [uvar0l,uvar1l,uvar2l]$
uvarc : [uvar0c,uvar1c,uvar2c]$
uvarr : [uvar0r,uvar1r,uvar2r]$
uvarle : [uvar0le,uvar1le,uvar2le]$
uvarce : [uvar0ce,uvar1ce,uvar2ce]$
uvarre : [uvar0re,uvar1re,uvar2re]$

doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

ExpandRho(cell,cellside) := block([F,svars,setemp],
  if(cell = "l")then(svars : svarsl),
  if(cell = "c")then(svars : svarsc),
  if(cell = "r")then(svars : svarsr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(svars[1],bC),
  F : subst(cv=substval, setemp),

  return (F)
);

ExpandRhoUi(dir,cell,cellside) := block([F,svars,setemp],
  if(cell = "l")then(svars : svarsl),
  if(cell = "c")then(svars : svarsc),
  if(cell = "r")then(svars : svarsr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(svars[dir+1],bC),
  F : subst(cv=substval, setemp),

  return (F)
);

ExpandUi(dir,cell,cellside) := block([F,svars,sltemp],
  if(cell = "l")then(uvar : uvarl),
  if(cell = "c")then(uvar : uvarc),
  if(cell = "r")then(uvar : uvarr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(uvar[dir],bC),
  F : subst(cv=substval, setemp),

  return (F)
);

calcNetFluxRho(idir,centercellside) := block([],
  if(centercellside = "l")then(avg_rhoui : 0.5*(ExpandRhoUi(idir,"l","r")+ExpandRhoUi(idir,"c","l"))),
  if(centercellside = "r")then(avg_rhoui : 0.5*(ExpandRhoUi(idir,"c","r")+ExpandRhoUi(idir,"r","l"))),

  if(centercellside = "l")then(jump_rho : 0.5*(ExpandRho("c","l")-ExpandRho("l","r"))),
  if(centercellside = "r")then(jump_rho : 0.5*(ExpandRho("r","l")-ExpandRho("c","r"))),

  if(centercellside = "l")then(umax : tempu_max_l),
  if(centercellside = "r")then(umax : tempu_max_r),

  ghat_rho_exp : avg_rhoui-umax*jump_rho,

  return (ghat_rho_exp)
)$

calcNetFluxRhoUi(ighat_rho_exp,idir,centercellside) := block([],
  if(centercellside = "l")then(avg_ui : 0.5*(ExpandUi(idir,"l","r")+ExpandUi(idir,"c","l"))),
  if(centercellside = "r")then(avg_ui : 0.5*(ExpandUi(idir,"c","r")+ExpandUi(idir,"r","l"))),

  if(centercellside = "l")then(avg_rho : 0.5*(ExpandRho("l","r")+ExpandRho("c","l"))),
  if(centercellside = "r")then(avg_rho : 0.5*(ExpandRho("c","r")+ExpandRho("r","l"))),

  if(idir = dir) then (ghat_rhoui_exp : ighat_rho_exp*avg_ui+vthsq*avg_rho)
  else (ghat_rhoui_exp : ighat_rho_exp*avg_ui),

  /*disp term test*/
  if(centercellside = "l")then(jump_rhoui : 0.5*(ExpandRhoUi(idir,"c","l")-ExpandRhoUi(idir,"l","r"))),
  if(centercellside = "r")then(jump_rhoui : 0.5*(ExpandRhoUi(idir,"r","l")-ExpandRhoUi(idir,"c","r"))),

  if(centercellside = "l")then(umax : tempu_max_l),
  if(centercellside = "r")then(umax : tempu_max_r),

  ghat_rhoui_exp : ghat_rhoui_exp-umax*jump_rhoui,

  return (ghat_rhoui_exp)

)$

calcIsoEulerUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, pOrder) := block([modNm, basisConstant, i, bP, bC, numC, nbasis, cid, vid,
cv, vv, surfVars, substval, avg_rhoui, jump_rho, umax, ghat_rho_exp,
ghat_rho_l_exp, ghat_rho_r_exp, incr_rho_l, incr_rho_r, setemp, avg_ui,
avg_rho, ghat_rhoui_exp, incr_rhoux_l, incr_rhoux_r, incr_rhouy_l,
incr_rhouy_r, incr_rhouz_l, incr_rhouz_r, outvars, surfTerms, surf, varsC,
basisC],
  kill(varsC, varsP, basisC, basisP),

  /* load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")), */
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x"),
  load(modNm),

  i : pOrder,
  bP    : basisP[i],
  bC    : basisC[i],
  numC  : length(bC),
  nbasis : length(bC),
  printf(fh, "GKYL_CU_DH void ~a_p~a(const double *w, const double *dxv, double vth, const double *uvarl, const double *uvarc, const double *uvarr, const double *statevecl, const double *statevecc, const double *statevecr, double* GKYL_RESTRICT out)  ~%{ ~%", funcNm, pOrder),
  printf(fh, "  // w: Cell-center coordinates. dxv[NDIM]: Cell spacing. statevec(l/c/r): [rho, rho ux, rho uy, rho uz] in (left/center/right) cell, uvar(l/c/r): [ux, uv, uz]  in (left/center/right) cell~%"),
  printf(fh, "  // out: output in center cell ~%"),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),

  printf(fh, "  const double *rhol = &statevecl[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0l = &statevecl[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1l = &statevecl[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2l = &statevecl[~a]; ~%", 3*numC),

  printf(fh, "  const double *rhoc = &statevecc[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0c = &statevecc[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1c = &statevecc[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2c = &statevecc[~a]; ~%", 3*numC),

  printf(fh, "  const double *rhor = &statevecr[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0r = &statevecr[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1r = &statevecr[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2r = &statevecr[~a]; ~%", 3*numC),

  printf(fh, "  const double *uvar0l = &uvarl[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1l = &uvarl[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2l = &uvarl[~a]; ~%", 2*numC),

  printf(fh, "  const double *uvar0c = &uvarc[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1c = &uvarc[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2c = &uvarc[~a]; ~%", 2*numC),

  printf(fh, "  const double *uvar0r = &uvarr[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1r = &uvarr[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2r = &uvarr[~a]; ~%", 2*numC),

  printf(fh, "  double *outrho = &out[~a]; ~%",   0*numC),
  printf(fh, "  double *outrhoux = &out[~a]; ~%", 1*numC),
  printf(fh, "  double *outrhouy = &out[~a]; ~%", 2*numC),
  printf(fh, "  double *outrhouz = &out[~a]; ~%", 3*numC),

  printf(fh, "  double incr[~a]; ~%~%", nbasis),

  printf(fh, "  double vthsq = vth*vth; ~%"), /*maxima will write out vth^2 in c/cpp code, but the ^ operator is the XOR operator, this is a quick workaround*/

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  cv : varsC[dir],
  vv : varsV[dir],
  surfVars : delete(cv,varsC),

  if(cdim = 1) then(
    printf(fh, "  double u_l_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uvar0l); ~%", basisFun, cdim, pOrder),
    printf(fh, "  double u_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uvar0c); ~%", basisFun, cdim, pOrder),
    printf(fh, "  double u_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uvar0c); ~%", basisFun, cdim, pOrder),
    printf(fh, "  double u_r_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uvar0r); ~%", basisFun, cdim, pOrder),
    printf(fh, "  double u_max_l = fmax(fabs(u_l_r), fabs(u_c_l)); ~%"),
    printf(fh, "  double u_max_r = fmax(fabs(u_c_r), fabs(u_r_l)); ~%")
  )
  else(
    bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsC,1,bC,subst([cv^2=var2,var2=1/3,cv=0],bC)))*bC), /*TODO: check if this is innerProd or calcInnerProdList*/

    surfNodes : gaussOrd(pOrder+1, cdim-1),
    numNodes : length(surfNodes),

    /* printf(fh, "  double umax_l[~a] = {0.0};~%", length(bSurf)),
    printf(fh, "  double umax_r[~a] = {0.0};~%", length(bSurf)), */

    /* printf(fh, "  double umax_l[~a] = {0.0};~%", numNodes),
    printf(fh, "  double umax_r[~a] = {0.0};~%", numNodes), */

    printf(fh, "  double umax_l[~a] = {0.0};~%", cdim),
    printf(fh, "  double umax_r[~a] = {0.0};~%", cdim), /*TODO: right now we are assuming umax is const on surf, which is false, so we should fix that*/

    printf(fh, "  double ghat_rho_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double ghat_rho_r[~a] = {0.0}; ~%", length(bSurf)),

    printf(fh, "  double u_l_r = 0.0; ~%"),
    printf(fh, "  double u_c_l = 0.0; ~%"),
    printf(fh, "  double u_c_r = 0.0; ~%"),
    printf(fh, "  double u_r_l = 0.0; ~%"),
    printf(fh, "~%"),
    for i : 1 thru numNodes do (
      printf(fh, "  u_l_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(uvar~al); ~%", basisFun, cdim, pOrder, dir, i-1, dir-1),
      printf(fh, "  u_c_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(uvar~ac); ~%", basisFun, cdim, pOrder, dir, i-1, dir-1),
      printf(fh, "  u_c_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(uvar~ac); ~%", basisFun, cdim, pOrder, dir, i-1, dir-1),
      printf(fh, "  u_r_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(uvar~ar); ~%", basisFun, cdim, pOrder, dir, i-1, dir-1),

      printf(fh, "  umax_l[~a] = fmax(fabs(u_l_r), fabs(u_c_l)); ~%", i-1),
      printf(fh, "  umax_r[~a] = fmax(fabs(u_c_r), fabs(u_r_l)); ~%", i-1)
    )
  ),

  if(cdim = 1) then(
    ghat_rho_l_exp : subst(tempu_max_l=u_max_l,calcNetFluxRho(dir,"l")),
    ghat_rho_r_exp : subst(tempu_max_r=u_max_r,calcNetFluxRho(dir,"r")),

    ghat_rhoux_l : subst(tempu_max_l=u_max_l,calcNetFluxRhoUi(ghat_rho_l,1,"l")),
    ghat_rhoux_r : subst(tempu_max_r=u_max_r,calcNetFluxRhoUi(ghat_rho_r,1,"r")),

    ghat_rhouy_l : subst(tempu_max_l=u_max_l,calcNetFluxRhoUi(ghat_rho_l,2,"l")),
    ghat_rhouy_r : subst(tempu_max_r=u_max_r,calcNetFluxRhoUi(ghat_rho_r,2,"r")),

    ghat_rhouz_l : subst(tempu_max_l=u_max_l,calcNetFluxRhoUi(ghat_rho_l,3,"l")),
    ghat_rhouz_r : subst(tempu_max_r=u_max_r,calcNetFluxRhoUi(ghat_rho_r,3,"r")),

    printf(fh, "  double ghat_rho_l = ~a; ~%", float(expand(ghat_rho_l_exp))),
    printf(fh, "  double ghat_rho_r = ~a; ~%", float(expand(ghat_rho_r_exp))),

    incr_rho_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rho_l),
    incr_rho_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rho_r),

    incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhoux_l),
    incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhoux_r),

    incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhouy_l),
    incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhouy_r),

    incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhouz_l),
    incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhouz_r)
  )
  else (

    /* Create expansions of u_max (|u_max| evaluated at the surface) on the left and right in the surface basis. */
    /*TODO: use umax instaed of uquad for disp terms*/
    /* umax_l_e : doExpand1(umax_l, bSurf),
    umax_r_e : doExpand1(umax_r, bSurf), */

    /* Density flux */
    tempghat_rho_l : calcNetFluxRho(dir,"l"),
    tempghat_rho_l : subst(tempu_max_l=umax_l[dir-1],tempghat_rho_l),
    ghat_rho_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, tempghat_rho_l)),
    writeCExprs1(ghat_rho_l, ghat_rho_l_c),
    printf(fh, "~%"),
    flush_output(fh),
    ghat_rho_l_e : doExpandLst(doMakeExprLst(ghat_rho_l_c, ghat_rho_l), bSurf),     /* Zero out components of ghat which are empty. */

    tempghat_rho_r : calcNetFluxRho(dir,"r"),
    tempghat_rho_r : subst(tempu_max_r=umax_r[dir-1],tempghat_rho_r),
    ghat_rho_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, tempghat_rho_r)),
    writeCExprs1(ghat_rho_r, ghat_rho_r_c),
    printf(fh, "~%"),
    flush_output(fh),
    ghat_rho_r_e : doExpandLst(doMakeExprLst(ghat_rho_r_c, ghat_rho_r), bSurf),     /* Zero out components of ghat which are empty. */

    incr_rho_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rho_l_e),
    incr_rho_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rho_r_e),

    ghat_rhoux_l : calcNetFluxRhoUi(ghat_rho_l_e,1,"l"),
    ghat_rhoux_r : calcNetFluxRhoUi(ghat_rho_r_e,1,"r"),
    ghat_rhoux_l : subst(tempu_max_l=umax_l[dir-1],ghat_rhoux_l),
    ghat_rhoux_r : subst(tempu_max_r=umax_r[dir-1],ghat_rhoux_r),
    /* ghat_rhoux_l : fullratsimp(innerProd(surfVars, 1, bSurf, ghat_rhoux_l)),
    ghat_rhoux_r : fullratsimp(innerProd(surfVars, -1, bSurf, ghat_rhoux_r)), */
    incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhoux_l),
    incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhoux_r),

    ghat_rhouy_l : calcNetFluxRhoUi(ghat_rho_l_e,2,"l"),
    ghat_rhouy_r : calcNetFluxRhoUi(ghat_rho_r_e,2,"r"),
    ghat_rhouy_l : subst(tempu_max_l=umax_l[dir-1],ghat_rhouy_l),
    ghat_rhouy_r : subst(tempu_max_r=umax_r[dir-1],ghat_rhouy_r),
    /* ghat_rhouy_l : fullratsimp(innerProd(surfVars, 1, bSurf, ghat_rhouy_l)),
    ghat_rhouy_r : fullratsimp(innerProd(surfVars, -1, bSurf, ghat_rhouy_r)), */
    incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhouy_l),
    incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhouy_r),

    ghat_rhouz_l : calcNetFluxRhoUi(ghat_rho_l_e,3,"l"),
    ghat_rhouz_r : calcNetFluxRhoUi(ghat_rho_r_e,3,"r"),
    ghat_rhouz_l : subst(tempu_max_l=umax_l[dir-1],ghat_rhouz_l),
    ghat_rhouz_r : subst(tempu_max_r=umax_r[dir-1],ghat_rhouz_r),
    /* ghat_rhouz_l : fullratsimp(innerProd(surfVars, 1, bSurf, ghat_rhouz_l)),
    ghat_rhouz_r : fullratsimp(innerProd(surfVars, 1, bSurf, ghat_rhouz_r)), */
    incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhouz_l),
    incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhouz_r)
  ),


  /*TODO kerns can have the number of operations reduced if we simplify "better"*/
  outvars : [outrho,outrhoux,outrhouy,outrhouz],
  surfTerms : [incr_rho_l + incr_rho_r,incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r],
  for m : 1 thru 4 do (
    surf : surfTerms[m],
    writeCIncrExprs1(outvars[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);

calcIsoEulerSurfUpdater(fh, cdim, vdim, basisFun, pOrder) := block([dir],
  /* printf(fh, "#include <IsoEulerModDecl.h> ~%"), */
  printf(fh, "#include <gkyl_isoeuler_kernels.h> ~%"),
  for dir : 1 thru cdim do (
    printf(fh, "#include <gkyl_basis_~a_~ax_p~a_surfx~a_eval_quad.h> ~%", "ser", cdim, pOrder, dir),
    funcName : sconcat("isoeuler_surf",cvars_name[dir],"_", c, "x", "_", "ser"),
    calcIsoEulerUpdateInDir(dir, fh, funcName, cdim, vdim, basisFun, pOrder)
  )
)$

pmax:2$
cmax:3$
for c : 1 thru cmax do (
  for pOrder : 1 thru pmax do (
    v : c,
    fname : sconcat("~/max-out/isoeuler_surf",cvars_name[c],"_", c, "x", "_p", pOrder, ".c"),
    fh : openw(fname),
    calcIsoEulerSurfUpdater(fh, c, v, "ser", pOrder),
    close(fh)
  )
);
