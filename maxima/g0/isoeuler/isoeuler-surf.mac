load("modal-basis");
load("out-scripts");
fpprec : 24$
ratprint: false$

cvars : [X, Y, Z]$
cvars_name : ["x","y","z"]$
svars : [rho, rhou0, rhou1, rhou2]$
svarsl : [rhol,rhou0l,rhou1l,rhou2l]$
svarsc : [rhoc,rhou0c,rhou1c,rhou2c]$
svarsr : [rhor,rhou0r,rhou1r,rhou2r]$
svarsll : [rholl,rhou0ll,rhou1ll,rhou2ll]$
svarscl : [rhocl,rhou0cl,rhou1cl,rhou2cl]$
svarsrl : [rhorl,rhou0rl,rhou1rl,rhou2rl]$

uvar : [uvar0,uvar1,uvar2]$
uvarl : [uvar0l,uvar1l,uvar2l]$
uvarc : [uvar0c,uvar1c,uvar2c]$
uvarr : [uvar0r,uvar1r,uvar2r]$
uvarle : [uvar0le,uvar1le,uvar2le]$
uvarce : [uvar0ce,uvar1ce,uvar2ce]$
uvarre : [uvar0re,uvar1re,uvar2re]$

ExpandRho(cell,cellside) := block([F,svars,setemp],
  if(cell = "l")then(svars : svarsl),
  if(cell = "c")then(svars : svarsc),
  if(cell = "r")then(svars : svarsr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(svars[1],bC), /*TODO: don't use "l" to denote expansion*/
  F : subst(cv=substval, setemp),

  return (F)
);

ExpandRhoUi(dir,cell,cellside) := block([F,svars,setemp],
  if(cell = "l")then(svars : svarsl),
  if(cell = "c")then(svars : svarsc),
  if(cell = "r")then(svars : svarsr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(svars[dir+1],bC),
  F : subst(cv=substval, setemp),

  return (F)
);

ExpandUi(dir,cell,cellside) := block([F,svars,sltemp],
  if(cell = "l")then(uvar : uvarl),
  if(cell = "c")then(uvar : uvarc),
  if(cell = "r")then(uvar : uvarr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(uvar[dir],bC),
  F : subst(cv=substval, setemp),

  return (F)
);

calcNetFluxRho(idir,centercellside) := block([],
  if(centercellside = "l")then(avg_rhoui : 0.5*(ExpandRhoUi(idir,"l","r")+ExpandRhoUi(idir,"c","l"))),
  if(centercellside = "r")then(avg_rhoui : 0.5*(ExpandRhoUi(idir,"c","r")+ExpandRhoUi(idir,"r","l"))),

  if(centercellside = "l")then(jump_rho : 0.5*(ExpandRho("c","l")-ExpandRho("l","r"))),
  if(centercellside = "r")then(jump_rho : 0.5*(ExpandRho("r","l")-ExpandRho("c","r"))),

  if(centercellside = "l")then(umax : u_max_l),
  if(centercellside = "r")then(umax : u_max_r),

  ghat_rho_exp : avg_rhoui-umax*jump_rho,

  return (ghat_rho_exp)
)$

calcNetFluxRhoUi(ighat_rho_exp,idir,centercellside) := block([],
  if(centercellside = "l")then(avg_ui : 0.5*(ExpandUi(idir,"l","r")+ExpandUi(idir,"c","l"))),
  if(centercellside = "r")then(avg_ui : 0.5*(ExpandUi(idir,"c","r")+ExpandUi(idir,"r","l"))),

  if(centercellside = "l")then(avg_rho : 0.5*(ExpandRho("l","r")+ExpandRho("c","l"))),
  if(centercellside = "r")then(avg_rho : 0.5*(ExpandRho("c","r")+ExpandRho("r","l"))),

  if(idir = dir) then (ghat_rhoui_exp : ighat_rho_exp*avg_ui+vthsq*avg_rho)
  else (ghat_rhoui_exp : ighat_rho_exp*avg_ui),

  return (ghat_rhoui_exp)

)$

calcIsoEulerUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, pOrder) := block([modNm, basisConstant, i, bP, bC, numC, nbasis, cid, vid,
cv, vv, surfVars, substval, avg_rhoui, jump_rho, umax, ghat_rho_exp,
ghat_rho_l_exp, ghat_rho_r_exp, incr_rho_l, incr_rho_r, setemp, avg_ui,
avg_rho, ghat_rhoui_exp, incr_rhoux_l, incr_rhoux_r, incr_rhouy_l,
incr_rhouy_r, incr_rhouz_l, incr_rhouz_r, outvars, surfTerms, surf, varsC,
basisC],
  kill(varsC, varsP, basisC, basisP),

  /* load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")), */
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x"),
  load(modNm),

  i : pOrder,
  bP    : basisP[i],
  bC    : basisC[i],
  numC  : length(bC),
  nbasis : length(bC),
  printf(fh, "GKYL_CU_DH void ~a_p~a(const double *w, const double *dxv, double vth, const double *uvarl, const double *uvarc, const double *uvarr, const double *statevecl, const double *statevecc, const double *statevecr, double* GKYL_RESTRICT out)  ~%{ ~%", funcNm, pOrder),
  printf(fh, "  // w: Cell-center coordinates. dxv[NDIM]: Cell spacing. statevec(l/c/r): [rho, rho ux, rho uy, rho uz] in (left/center/right) cell, uvar(l/c/r): [ux, uv, uz]  in (left/center/right) cell~%"),
  printf(fh, "  // out: output in center cell ~%"),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),

  printf(fh, "  const double *rhol = &statevecl[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0l = &statevecl[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1l = &statevecl[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2l = &statevecl[~a]; ~%", 3*numC),

  printf(fh, "  const double *rhoc = &statevecc[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0c = &statevecc[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1c = &statevecc[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2c = &statevecc[~a]; ~%", 3*numC),

  printf(fh, "  const double *rhor = &statevecr[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0r = &statevecr[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1r = &statevecr[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2r = &statevecr[~a]; ~%", 3*numC),

  printf(fh, "  const double *uvar0l = &uvarl[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1l = &uvarl[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2l = &uvarl[~a]; ~%", 2*numC),

  printf(fh, "  const double *uvar0c = &uvarc[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1c = &uvarc[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2c = &uvarc[~a]; ~%", 2*numC),

  printf(fh, "  const double *uvar0r = &uvarr[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1r = &uvarr[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2r = &uvarr[~a]; ~%", 2*numC),

  printf(fh, "  double *outrho = &out[~a]; ~%",   0*numC),
  printf(fh, "  double *outrhoux = &out[~a]; ~%", 1*numC),
  printf(fh, "  double *outrhouy = &out[~a]; ~%", 2*numC),
  printf(fh, "  double *outrhouz = &out[~a]; ~%", 3*numC),

  printf(fh, "  double incr[~a]; ~%~%", nbasis),

  printf(fh, "  double vthsq = vth*vth; ~%"), /*maxima will write out vth^2 in c/cpp code, but the ^ operator is the XOR operator, this is a quick workaround*/

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  cv : varsC[dir],
  vv : varsV[dir],
  surfVars : delete(cv,varsC),

  printf(fh, "  double u_l_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uvar0l); ~%", basisFun, cdim, pOrder),
  printf(fh, "  double u_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uvar0c); ~%", basisFun, cdim, pOrder),
  printf(fh, "  double u_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uvar0c); ~%", basisFun, cdim, pOrder),
  printf(fh, "  double u_r_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uvar0r); ~%", basisFun, cdim, pOrder),
  printf(fh, "  double u_max_l = fmax(fabs(u_l_r), fabs(u_c_l)); ~%"),
  printf(fh, "  double u_max_r = fmax(fabs(u_c_r), fabs(u_r_l)); ~%"),

  printf(fh, "  //FluxRho; ~%"),
  ghat_rho_l_exp : calcNetFluxRho(dir,"l"),
  ghat_rho_r_exp : calcNetFluxRho(dir,"r"),

  printf(fh, "  double ghat_rho_l = ~a; ~%", float(expand(ghat_rho_l_exp))),
  printf(fh, "  double ghat_rho_r = ~a; ~%", float(expand(ghat_rho_r_exp))),

  incr_rho_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rho_l),
  incr_rho_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rho_r),

  incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), calcNetFluxRhoUi(ghat_rho_l,1,"l")),
  incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), calcNetFluxRhoUi(ghat_rho_r,1,"r")),

  incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), calcNetFluxRhoUi(ghat_rho_l,2,"l")),
  incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), calcNetFluxRhoUi(ghat_rho_r,2,"r")),

  incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), calcNetFluxRhoUi(ghat_rho_l,3,"l")),
  incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), calcNetFluxRhoUi(ghat_rho_r,3,"r")),

  outvars : [outrho,outrhoux,outrhouy,outrhouz],
  surfTerms : [incr_rho_l + incr_rho_r,incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r],
  for m : 1 thru 4 do (
    surf : surfTerms[m],
    writeCIncrExprs1(outvars[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);

calcIsoEulerSurfUpdater(fh, cdim, vdim, basisFun, pOrder) := block([dir],
  /* printf(fh, "#include <IsoEulerModDecl.h> ~%"), */
  printf(fh, "#include <gkyl_isoeuler_kernels.h> ~%"),
  for dir : 1 thru cdim do (
    printf(fh, "#include <gkyl_basis_~a_~ax_p~a_surfx~a_eval_quad.h> ~%", "ser", dir, pOrder, dir), /*TODO: do 2d 3d kerns*/
    funcName : sconcat("isoeuler_surf",cvars_name[dir],"_", c, "x", "_", "ser"),
    calcIsoEulerUpdateInDir(dir, fh, funcName, cdim, vdim, basisFun, pOrder)
  )
)$

pmax:2$
cmax:3$
for c : 1 thru cmax do (
  for pOrder : 1 thru pmax do (
    v : c,
    fname : sconcat("~/max-out/isoeuler_surf",cvars_name[c],"_", c, "x", "_p", pOrder, ".c"),
    fh : openw(fname),
    calcIsoEulerSurfUpdater(fh, c, v, "ser", pOrder),
    close(fh)
  )
);
