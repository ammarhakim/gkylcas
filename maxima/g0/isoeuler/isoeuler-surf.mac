load("modal-basis");
load("out-scripts");
fpprec : 24$
ratprint: false$

cvars : [X, Y, Z]$
cvars_name : ["x","y","z"]$
svars : [rho, rhou0, rhou1, rhou2]$
svarsl : [rhol,rhou0l,rhou1l,rhou2l]$
svarsr : [rhor,rhou0r,rhou1r,rhou2r]$
svarsll : [rholl,rhou0ll,rhou1ll,rhou2ll]$
svarsrl : [rhorl,rhou0rl,rhou1rl,rhou2rl]$

uvar : [uvar0,uvar1,uvar2]$
uvarl : [uvar0l,uvar1l,uvar2l]$
uvarr : [uvar0r,uvar1r,uvar2r]$
uvarll : [uvar0ll,uvar1ll,uvar2ll]$
uvarrl : [uvar0rl,uvar1rl,uvar2rl]$

RoeDissipativeTerms(dir,svaridx) := block([qvars,Amat,Bmat,Cmat,alphalist,kvecs], /*disp term is far right term in eq (11.29) of Toro E. F. 2009 */
  /*construct flux mat*/
  if(dir = 1)then(dirvec : [1,0,0]),
  if(dir = 2)then(dirvec : [0,1,0]),
  if(dir = 3)then(dirvec : [0,0,1]),
  frho : [svars[2],svars[3],svars[4]],
  frhoux : [svars[2]*uvar[1]+vthterm(rho),svars[2]*uvar[2],svars[2]*uvar[3]],
  frhouy : [svars[3]*uvar[1],svars[3]*uvar[2]+vthterm(rho),svars[3]*uvar[3]],
  frhouz : [svars[4]*uvar[1],svars[4]*uvar[2],svars[4]*uvar[3]+vthterm(rho)],
  fvec : [frho[dir],frhoux[dir],frhouy[dir],frhouz[dir]],
  fvecsubset : makelist(fvec[tempidx],tempidx,1,cdim+1),
  svarsubset : makelist(svars[tempidx],tempidx,1,cdim+1),

  /* print("frhoux"),
  print(frhoux),

  print("fvecsubset"),
  print(fvecsubset), */

  /* Compute Jacobian  TOD: check if we can assume the rho matrix is equal to the jacobian*/
  Amat : jacobian(fvecsubset,svarsubset),

  /*maxima cant compute vth term, so we add it here*/
  print("WARNING: assuming pOrder = 1 in disp term calc..."),   /* TODO: handle higher order terms, where thermal pressure term does not go to zero */
  Amat : subst(diff(vthterm(rho),rho)=0,Amat), /*vth term goes to zero as (d/drho)(d/dxi(rho)) = d^2/dx^2(rho)/[d/dx(rho)] */

  /*Get eigen values*/
  [vals, vecs] : eigenvectors (Amat),

  /*maxima has only 1 entry for eval/evec pairs with multiplicity >= 1, so we have to 'remap' the output here */
  /*this code block might have errors with edge cases regarding the multiplicity of evecs, but it works here*/
  numevals : sum(vals[2][itemp],itemp,1,length(vals[2])),
  valsmap : makelist(0,tempidx,1,numevals),
  vecsmap : makelist(0,tempidx,1,numevals), /*don't need this TODO: remove*/
  mapidxevals : 1, /*idx used to map original output format to new output format, where eval/evec pairs are repeated */
  mapidxevecs : 1,
  for numevalsidx : 1 thru numevals do(
    valsmap[numevalsidx] : vals[1][mapidxevals],
    vecsmap[numevalsidx] : vecs[mapidxevals][mapidxevecs],
    if(vals[2][mapidxevals] = 1)then(mapidxevals : mapidxevals + 1, mapidxevecs : 1)
    else(vals[2][mapidxevals] : vals[2][mapidxevals] - 1,
      if(mapidxevecs = length(vecs[mapidxevals]))then(mapidxevecs : mapidxevecs)
      else(mapidxevecs : mapidxevecs + 1)
    )
  ),

  print("vals"),
  print(valsmap),
  print("vecs"),
  print(vecsmap),

  /*get our values in appropriate form*/
  sublist : makelist(svars[tempidx]=svarsr[tempidx]-svarsl[tempidx],tempidx,1,3),
  sublist2 : makelist(uvar[tempidx]=uvarr[tempidx]-uvarl[tempidx],tempidx,1,3), /*TODO: check defn of \tilde(U), \tilde(rho) etc.. and confirm that this is correct */
  vecsmap : subst(sublist,vecsmap),
  vecsmap : subst(sublist2,vecsmap),
  valsmap : subst(sublist,valsmap),
  valsmap : subst(sublist2,valsmap),

  /*TODO: we will need to compute alpha_i when pOrder > 1*/
  /*WARNING: if eval contains division, our weak formulation doesnt work. TODO: check evals for division for pOrder > 1*/
  /*otherwise, we can just scale by the appropriate eigenval, as other terms are zero*/
  delS : svarsr-svarsl,

  /*dispterm : abs(valsmap[svaridx])*delS[svaridx],*/  /*TODO: convert to sum when pOrder > 1; see 11.29; */ /*TODO: handle abs term in weak formulation*/
  dispterm : valsmap[svaridx]*delS[svaridx],

  /*break up term into each multiplication term*/ /*TODO: check that this works for polys of order > 1 */
  disptermparts[1] : part(dispterm,1),
  disptermparts[2] : part(dispterm,2),
  if(disptermparts[1]*disptermparts[2] # dispterm)then(print("ERROR, could not parse dispterm solution correctly!!!!")), /*TODO: add line to break computation */

  /*TODO: expand, and do weak operations to find disp term */
  /* for
    doExpand1(disptermparts[1],bC);
    doExpand1(disptermparts[2],bC); */





  /*TODO: sub in weak formulation (not sure of order of ops for weak formulation esp with jacobian and evals)*/
  print("dispterm"),
  print(dispterm),
  disptermtemp : 0,




  print("dispterm subbed in"),
  print(dispterm),

  return (disptermtemp)
);

FluxRho(dir,l_or_r) := block([F,svars,sltemp],
  if(l_or_r = "l")then(substval : 1, svars : svarsl),
  if(l_or_r = "r")then(substval :-1, svars : svarsr),

  sltemp : doExpand1(svars[dir+1],bC),
  F : subst(cv=substval, sltemp),

  return (F)
);

FluxRhoUi(dir,l_or_r,idir) := block([F,svars,sltemp,rltemp,uvars,ultemp], /* idir is the U_i (note: this var starts indexing at 1)*/
  if(l_or_r = "l")then(substval : 1, svars : svarsl, uvars : uvarl),
  if(l_or_r = "r")then(substval :-1, svars : svarsr, uvars : uvarr),

  F : 0,
  if(dir = idir)then(
    rltemp : doExpand1(svars[1],bC),
    sltemp : doExpand1(svars[dir+1],bC),
    ultemp : doExpand1(uvars[dir],bC),

    F : innerProd(surfVars,1,rltemp,ultemp) + vthsq*innerProd(surfVars,1,bC,diff(rltemp,varsC[dir]))
  ),

  F : subst(cv=substval, F),

  return (F)
)$

FluxRhoUx(dir,l_or_r) := block([],FluxRhoUi(dir,l_or_r,1))$
FluxRhoUy(dir,l_or_r) := block([],FluxRhoUi(dir,l_or_r,2))$
FluxRhoUz(dir,l_or_r) := block([],FluxRhoUi(dir,l_or_r,3))$

calcFluxRoeAvg(dir,Flux,svaridx) := block([F],

  F : 0.5*(Flux(dir,"l")+Flux(dir,"r")) /*-0.5*RoeDissipativeTerms(dir,svaridx)*/,   /*TODO: add dissipative term i.e. far right term eq 2.30; right now we are using central fluxes as dispterm = 0*/

  return (F)
)$

calcIsoEulerUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, pOrder) := block([],
  kill(varsC, varsP, basisC, basisP),

  /* load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")), */
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x"),
  load(modNm),

  i : pOrder,
  bP    : basisP[i],
  bC    : basisC[i],
  numC  : length(bC),
  nbasis : length(bC),
  printf(fh, "GKYL_CU_DH void ~a_p~a(const double *w, const double *dxv, double vth, const double *uvarl, const double *uvarc, const double *uvarr, const double *statevecl, const double *statevecc, const double *statevecr, double* GKYL_RESTRICT out)  ~%{ ~%", funcNm, pOrder),
  printf(fh, "  // w: Cell-center coordinates. dxv[NDIM]: Cell spacing. statevec(l/c/r): [rho, rho ux, rho uy, rho uz] in (left/center/right) cell, uvar(l/c/r): [ux, uv, uz]  in (left/center/right) cell~%"),
  printf(fh, "  // out: output in left/right cells ~%"),

  printf(fh, "  const double dxl1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "  const double dxr1 = 2.0/dxv[~a]; ~%", dir-1),

  printf(fh, "  const double *rhol = &statevecl[~a]; ~%", 0*numC),
  if (cdim >= 1) then (printf(fh, "  const double *rhou0l = &statevecl[~a]; ~%", 1*numC)),
  if (cdim >= 2) then (printf(fh, "  const double *rhou1l = &statevecl[~a]; ~%", 2*numC)),
  if (cdim >= 3) then (printf(fh, "  const double *rhou2l = &statevecl[~a]; ~%", 3*numC)),

  printf(fh, "  const double *rhor = &statevecr[~a]; ~%", 0*numC),
  if (cdim >= 1) then (printf(fh, "  const double *rhou0r = &statevecr[~a]; ~%", 1*numC)),
  if (cdim >= 2) then (printf(fh, "  const double *rhou1r = &statevecr[~a]; ~%", 2*numC)),
  if (cdim >= 3) then (printf(fh, "  const double *rhou2r = &statevecr[~a]; ~%", 3*numC)),

  if (cdim >= 1) then (printf(fh, "  const double *uvar0l = &uvarl[~a]; ~%", 0*numC)),
  if (cdim >= 2) then (printf(fh, "  const double *uvar1l = &uvarl[~a]; ~%", 1*numC)),
  if (cdim >= 3) then (printf(fh, "  const double *uvar2l = &uvarl[~a]; ~%", 2*numC)),

  if (cdim >= 1) then (printf(fh, "  const double *uvar0r = &uvarr[~a]; ~%", 0*numC)),
  if (cdim >= 2) then (printf(fh, "  const double *uvar1r = &uvarr[~a]; ~%", 1*numC)),
  if (cdim >= 3) then (printf(fh, "  const double *uvar2r = &uvarr[~a]; ~%", 2*numC)),

  printf(fh, "  double *outlrho = &out[~a]; ~%", 0*numC),
  if (cdim >= 1) then (printf(fh, "  double *outlrhoux = &out[~a]; ~%", 1*numC)),
  if (cdim >= 2) then (printf(fh, "  double *outlrhouy = &out[~a]; ~%", 2*numC)),
  if (cdim >= 3) then (printf(fh, "  double *outlrhouz = &out[~a]; ~%", 3*numC)),

  printf(fh, "  double *outrrho = &out[~a]; ~%", 0*numC+numC*(cdim+1)),
  if (cdim >= 1) then (printf(fh, "  double *outrrhoux = &out[~a]; ~%", 1*numC+numC*(cdim+1))),
  if (cdim >= 2) then (printf(fh, "  double *outrrhouy = &out[~a]; ~%", 2*numC+numC*(cdim+1))),
  if (cdim >= 3) then (printf(fh, "  double *outrrhouz = &out[~a]; ~%", 3*numC+numC*(cdim+1))),

  printf(fh, "  double incr[~a]; ~%~%", nbasis),

  printf(fh, "  double vthsq = vth*vth; ~%"), /*maxima will write out vth^2 in c/cpp code, but the ^ operator is the XOR operator, this is a quick workaround*/

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  cv : varsC[dir],
  vv : varsV[dir],
  surfVars : delete(cv,varsC),

  FluxFuncs : [FluxRho, FluxRhoUx, FluxRhoUy, FluxRhoUz],
  outlvars : [outlrho,outlrhoux,outlrhouy,outlrhouz],
  outrvars : [outrrho,outrrhoux,outrrhouy,outrrhouz],
  for m : 1 thru cdim+1 do (
    printf(fh, "  //~a; ~%", FluxFuncs[m]),
    Flux : FluxFuncs[m],
    fhat : calcFluxRoeAvg(dir,Flux,m),

    incr_r : innerProd(surfVars, 1, subst(cv=-1, bC), fhat),
    writeCExprs1(incr, incr_r),
    printf(fh, "~%"),
    incr_s : makelist(incr[i-1], i, 1, nbasis),
    outrvarstemp : outrvars[m],
    writeCIncrExprs1(outrvarstemp, dxr1*incr_s),
    printf(fh, "~%"),

    incr_l : -innerProd(surfVars, 1, subst(cv=1, bC), fhat),

    /*sometimes incr_r has zero terms, so computing signs as signs : fullratsimp(incr_l/incr_r) leads to undefined operations*/
    nincr_r : length(incr_r),
    for idx : 1 thru nincr_r do (
      if (listp(incr_r[idx])) then (
        nincr_r_idx : length(incr_r[idx]),
        for idx2 : 1 thru nincr_r_idx do (
          signs[idx] : makelist(0,idxtemp_,1,nincr_r_idx),
          if(incr_r[idx][idx2] = 0) then (
            signs[idx][idx2] : 0
          )
          else(
            signs[idx][idx2] : fullratsimp(incr_l[idx][idx2]/incr_r[idx][idx2])
          )
        )
      )else(
        if(incr_r[idx] = 0) then (
          signs[idx] : 0
        )
        else(
          signs[idx] : fullratsimp(incr_l[idx]/incr_r[idx])
        )
      )
    ),

    /*TODO: try after implementing 'lambda' term in roe averaging */
    /* signs : fullratsimp(incr_l/incr_r),  */
    incr_s : makelist(signs[i]*incr[i-1], i, 1, nbasis),
    outlvarstemp : outlvars[m],
    writeCIncrExprs1(outlvarstemp, dxl1*incr_s),
    printf(fh, "~% ~%")
  ),

  /* TODO: figure out if anything needs to be returned... */
  printf(fh, "} ~%")
);

calcIsoEulerSurfUpdater(fh, cdim, vdim, basisFun, pOrder) := block([dir],
  /* printf(fh, "#include <IsoEulerModDecl.h> ~%"), */
  printf(fh, "#include <gkyl_isoeuler_kernels.h> ~%"),
  for dir : 1 thru cdim do (
    funcName : sconcat("isoeuler_surf",cvars_name[dir],"_", c, "x", c, "v_", "ser"),
    calcIsoEulerUpdateInDir(dir, fh, funcName, cdim, vdim, basisFun, pOrder) 
  )
)$

pmax:3$
cmax:3$
for c : 1 thru cmax do (
  for pOrder : 1 thru pmax do (
    v : c,
    fname : sconcat("~/max-out/isoeuler_surf",cvars_name[c],"_", c, "x", c, "v_p", pOrder, ".c"),
    fh : openw(fname),
    calcIsoEulerSurfUpdater(fh, c, v, "Ser", pOrder),
    close(fh)
  )
);