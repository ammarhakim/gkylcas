kill(all) $/*TODO: remove this and fix var leak when header and then vol kern script is called before this one"*/

load("modal-basis");
load("out-scripts");
load("recovery")$
load("nodal_operations/node_locations")$ /*TODO: fix pathing to this file in init and change this pathing to match the relative pathing of other scripts*/
fpprec : 24$
ratprint: false$

cvars : [X, Y, Z]$
cvars_name : ["x","y","z"]$
svars : [rho, rhou0, rhou1, rhou2]$
svarsl : [rhol,rhou0l,rhou1l,rhou2l]$
svarsc : [rhoc,rhou0c,rhou1c,rhou2c]$
svarsr : [rhor,rhou0r,rhou1r,rhou2r]$
svarsll : [rholl,rhou0ll,rhou1ll,rhou2ll]$
svarscl : [rhocl,rhou0cl,rhou1cl,rhou2cl]$
svarsrl : [rhorl,rhou0rl,rhou1rl,rhou2rl]$

uvar : [uvar0,uvar1,uvar2]$
uvarl : [uvar0l,uvar1l,uvar2l]$
uvarc : [uvar0c,uvar1c,uvar2c]$
uvarr : [uvar0r,uvar1r,uvar2r]$
uvarle : [uvar0le,uvar1le,uvar2le]$
uvarce : [uvar0ce,uvar1ce,uvar2ce]$
uvarre : [uvar0re,uvar1re,uvar2re]$

doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

ExpandRho(cell,cellside) := block([F,svars,setemp],
  if(cell = "l")then(svars : svarsl),
  if(cell = "c")then(svars : svarsc),
  if(cell = "r")then(svars : svarsr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(svars[1],bC),
  F : subst(cv=substval, setemp),

  return (F)
);

ExpandRhoUi(dir,cell,cellside) := block([F,svars,setemp],
  if(cell = "l")then(svars : svarsl),
  if(cell = "c")then(svars : svarsc),
  if(cell = "r")then(svars : svarsr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(svars[dir+1],bC),
  F : subst(cv=substval, setemp),

  return (F)
);

ExpandUi(dir,cell,cellside) := block([F,svars,sltemp],
  if(cell = "l")then(uvar : uvarl),
  if(cell = "c")then(uvar : uvarc),
  if(cell = "r")then(uvar : uvarr),

  if(cellside = "l")then(substval : -1),
  if(cellside = "r")then(substval : 1),

  setemp : doExpand1(uvar[dir],bC),
  F : subst(cv=substval, setemp),

  return (F)
);

calcNetFluxRho(idir,centercellside) := block([],
  if(cdim > 1)then(
    urec_l_temp : [urec_0_l_e,urec_1_l_e,urec_2_l_e],
    urec_r_temp : [urec_0_r_e,urec_1_r_e,urec_2_r_e],
    rhourec_l_temp : [rhourec_0_l_e,rhourec_1_l_e,rhourec_2_l_e],
    rhourec_r_temp : [rhourec_0_r_e,rhourec_1_r_e,rhourec_2_r_e],
    rhorec_l_temp : rhorec_l_e,
    rhorec_r_temp : rhorec_r_e
  )
  else
  (
    urec_l_temp : [urec_0_l,urec_1_l,urec_2_l],
    urec_r_temp : [urec_0_r,urec_1_r,urec_2_r],
    rhourec_l_temp : [rhourec_0_l,rhourec_1_l,rhourec_2_l],
    rhourec_r_temp : [rhourec_0_r,rhourec_1_r,rhourec_2_r],
    rhorec_l_temp : rhorec_l,
    rhorec_r_temp : rhorec_r
  ),
  if(centercellside = "l")then(avg_rhoui : rhourec_l_temp[idir]),
  if(centercellside = "r")then(avg_rhoui : rhourec_r_temp[idir]),

  if(centercellside = "l")then(jump_rho : 0.5*(ExpandRho("c","l")-ExpandRho("l","r"))),
  if(centercellside = "r")then(jump_rho : 0.5*(ExpandRho("r","l")-ExpandRho("c","r"))),

  if(centercellside = "l")then(umax : tempu_max_l),
  if(centercellside = "r")then(umax : tempu_max_r),

  ghat_rho_exp : avg_rhoui-umax*jump_rho,

  return (ghat_rho_exp)
)$

calcNetFluxRhoUi(ighat_rho_exp,idir,centercellside) := block([],
  if(cdim > 1)then(
    urec_l_temp : [urec_0_l_e,urec_1_l_e,urec_2_l_e],
    urec_r_temp : [urec_0_r_e,urec_1_r_e,urec_2_r_e],
    rhourec_l_temp : [rhourec_0_l_e,rhourec_1_l_e,rhourec_2_l_e],
    rhourec_r_temp : [rhourec_0_r_e,rhourec_1_r_e,rhourec_2_r_e],
    rhorec_l_temp : rhorec_l_e,
    rhorec_r_temp : rhorec_r_e
  )
  else
  (
    urec_l_temp : [urec_0_l,urec_1_l,urec_2_l],
    urec_r_temp : [urec_0_r,urec_1_r,urec_2_r],
    rhourec_l_temp : [rhourec_0_l,rhourec_1_l,rhourec_2_l],
    rhourec_r_temp : [rhourec_0_r,rhourec_1_r,rhourec_2_r],
    rhorec_l_temp : rhorec_l,
    rhorec_r_temp : rhorec_r
  ),
  if(centercellside = "l")then(avg_ui : urec_l_temp[idir]),
  if(centercellside = "r")then(avg_ui : urec_r_temp[idir]),

  if(centercellside = "l")then(avg_rho : rhorec_l_temp),
  if(centercellside = "r")then(avg_rho : rhorec_r_temp),

  if(idir = dir) then (ghat_rhoui_exp : ighat_rho_exp*avg_ui+vthsq*avg_rho)
  else (ghat_rhoui_exp : ighat_rho_exp*avg_ui),

  /*disp term test*/
  if(centercellside = "l")then(jump_rhoui : 0.5*(ExpandRhoUi(idir,"c","l")-ExpandRhoUi(idir,"l","r"))),
  if(centercellside = "r")then(jump_rhoui : 0.5*(ExpandRhoUi(idir,"r","l")-ExpandRhoUi(idir,"c","r"))),

  if(centercellside = "l")then(umax : tempu_max_l),
  if(centercellside = "r")then(umax : tempu_max_r),

  ghat_rhoui_exp : ghat_rhoui_exp-umax*jump_rhoui,

  return (ghat_rhoui_exp)

)$

calcIsoEulerUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, pOrder) := block([modNm, basisConstant, i, bP, bC, numC, nbasis, cid, vid,
cv, vv, surfVars, substval, avg_rhoui, jump_rho, umax, ghat_rho_exp,
ghat_rho_l_exp, ghat_rho_r_exp, incr_rho_l, incr_rho_r, setemp, avg_ui,
avg_rho, ghat_rhoui_exp, incr_rhoux_l, incr_rhoux_r, incr_rhouy_l,
incr_rhouy_r, incr_rhouz_l, incr_rhouz_r, outvars, surfTerms, surf, varsC,
basisC,nodesSer1xp0, nodesSer1xp1, nodesSer1xp2, nodesSer1xp3, nodesSer1xp4,
nodesSer2xp0, nodesSer2xp1, nodesSer2xp2, nodesSer2xp3, nodesSer3xp0,
nodesSer3xp1, nodesSer3xp2, nodesSer3xp3, nodesSer4xp0, nodesSer4xp1,
nodesSer4xp2, nodesSer4xp3, nodesSer5xp0, nodesSer5xp1, nodesSer5xp2,
nodesSer5xp3, nodesSer6xp0, cvars, cvars_name, svars, svarsl, svarsc, svarsr,
svarsll, svarscl, svarsrl, uvar, uvarl, uvarc, uvarr, uvarle, uvarce, uvarre,
lst_rho_l, lst_rho_c, lst_rho_r,
lst_rhou_0_l, lst_rhou_0_c, lst_rhou_0_r, lst_rhou_1_l, lst_rhou_1_c,
lst_rhou_1_r, lst_rhou_2_l, lst_rhou_2_c, lst_rhou_2_r, lst_u_0_l, lst_u_0_c,
lst_u_0_r, lst_u_1_l, lst_u_1_c, lst_u_1_r, lst_u_2_l, lst_u_2_c, lst_u_2_r,
u_0_rec_l, u_0_rec_r, u_1_rec_l, u_1_rec_r, u_2_rec_l, u_2_rec_r,
rhou_0_rec_l, rhou_0_rec_r, rhou_1_rec_l, rhou_1_rec_r, rhou_2_rec_l,
rhou_2_rec_r, rho_rec_l, rho_rec_r, urec_l_temp, urec_r_temp, rhourec_l_temp,
rhourec_r_temp, rhorec_l_temp, rhorec_r_temp, jump_rhoui, ghat_rhoux_l,
ghat_rhoux_r, ghat_rhouy_l, ghat_rhouy_r, ghat_rhouz_l, ghat_rhouz_r, bSurf,
surfNodes, numNodes, urec_0_l_c, urec_1_l_c, urec_2_l_c, rhourec_0_l_c,
rhourec_1_l_c, rhourec_2_l_c, rhorec_l_c, urec_0_r_c, urec_1_r_c, urec_2_r_c,
rhourec_0_r_c, rhourec_1_r_c, rhourec_2_r_c, rhorec_r_c, urec_0_l_e,
urec_1_l_e, urec_2_l_e, rhourec_0_l_e, rhourec_1_l_e, rhourec_2_l_e,
rhorec_l_e, urec_0_r_e, urec_1_r_e, urec_2_r_e, rhourec_0_r_e, rhourec_1_r_e,
rhourec_2_r_e, rhorec_r_e, umax_l_e, umax_r_e, tempghat_rho_l, ghat_rho_l_c,
ghat_rho_l_e, tempghat_rho_r, ghat_rho_r_c, ghat_rho_r_e],
  kill(varsC, varsP, basisC, basisP),

  /* load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")), */
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x"),
  load(modNm),

  i : pOrder,
  bP    : basisP[i],
  bC    : basisC[i],
  numC  : length(bC),
  nbasis : length(bC),
  printf(fh, "GKYL_CU_DH void ~a_p~a(const double *w, const double *dxv, double vth, const double *uvarl, const double *uvarc, const double *uvarr, const double *statevecl, const double *statevecc, const double *statevecr, double* GKYL_RESTRICT out)  ~%{ ~%", funcNm, pOrder),
  printf(fh, "  // w: Cell-center coordinates. dxv[NDIM]: Cell spacing. statevec(l/c/r): [rho, rho ux, rho uy, rho uz] in (left/center/right) cell, uvar(l/c/r): [ux, uv, uz]  in (left/center/right) cell~%"),
  printf(fh, "  // out: output in center cell ~%"),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),

  printf(fh, "  const double *rhol = &statevecl[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0l = &statevecl[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1l = &statevecl[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2l = &statevecl[~a]; ~%", 3*numC),

  printf(fh, "  const double *rhoc = &statevecc[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0c = &statevecc[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1c = &statevecc[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2c = &statevecc[~a]; ~%", 3*numC),

  printf(fh, "  const double *rhor = &statevecr[~a]; ~%",   0*numC),
  printf(fh, "  const double *rhou0r = &statevecr[~a]; ~%", 1*numC),
  printf(fh, "  const double *rhou1r = &statevecr[~a]; ~%", 2*numC),
  printf(fh, "  const double *rhou2r = &statevecr[~a]; ~%", 3*numC),

  printf(fh, "  const double *uvar0l = &uvarl[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1l = &uvarl[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2l = &uvarl[~a]; ~%", 2*numC),

  printf(fh, "  const double *uvar0c = &uvarc[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1c = &uvarc[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2c = &uvarc[~a]; ~%", 2*numC),

  printf(fh, "  const double *uvar0r = &uvarr[~a]; ~%", 0*numC),
  printf(fh, "  const double *uvar1r = &uvarr[~a]; ~%", 1*numC),
  printf(fh, "  const double *uvar2r = &uvarr[~a]; ~%", 2*numC),

  printf(fh, "  double *outrho = &out[~a]; ~%",   0*numC),
  printf(fh, "  double *outrhoux = &out[~a]; ~%", 1*numC),
  printf(fh, "  double *outrhouy = &out[~a]; ~%", 2*numC),
  printf(fh, "  double *outrhouz = &out[~a]; ~%", 3*numC),

  printf(fh, "  double incr[~a]; ~%~%", nbasis),

  printf(fh, "  double vthsq = vth*vth; ~%"), /*maxima will write out vth^2 in c/cpp code, but the ^ operator is the XOR operator, this is a quick workaround*/

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  cv : varsC[dir],
  vv : varsV[dir],
  surfVars : delete(cv,varsC),

  /* We use recovery to compute the interface u and p values for momentum fluxes */
  /* Create safety lists for recovery */
  lst_rho_l : makelist(rhol[i], i, 0, numC-1),
  lst_rho_c : makelist(rhoc[i], i, 0, numC-1),
  lst_rho_r : makelist(rhor[i], i, 0, numC-1),

  lst_rhou_0_l : makelist(rhou0l[i], i, 0, numC-1),
  lst_rhou_0_c : makelist(rhou0c[i], i, 0, numC-1),
  lst_rhou_0_r : makelist(rhou0r[i], i, 0, numC-1),

  lst_rhou_1_l : makelist(rhou1l[i], i, 0, numC-1),
  lst_rhou_1_c : makelist(rhou1c[i], i, 0, numC-1),
  lst_rhou_1_r : makelist(rhou1r[i], i, 0, numC-1),

  lst_rhou_2_l : makelist(rhou2l[i], i, 0, numC-1),
  lst_rhou_2_c : makelist(rhou2c[i], i, 0, numC-1),
  lst_rhou_2_r : makelist(rhou2r[i], i, 0, numC-1),

  lst_u_0_l : makelist(uvar0l[i], i, 0, numC-1),
  lst_u_0_c : makelist(uvar0c[i], i, 0, numC-1),
  lst_u_0_r : makelist(uvar0r[i], i, 0, numC-1),

  lst_u_1_l : makelist(uvar1l[i], i, 0, numC-1),
  lst_u_1_c : makelist(uvar1c[i], i, 0, numC-1),
  lst_u_1_r : makelist(uvar1r[i], i, 0, numC-1),

  lst_u_2_l : makelist(uvar2l[i], i, 0, numC-1),
  lst_u_2_c : makelist(uvar2c[i], i, 0, numC-1),
  lst_u_2_r : makelist(uvar2l[i], i, 0, numC-1),

  /* Recovery */
  u_0_rec_l : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_u_0_l), dg(lst_u_0_c)),
  u_0_rec_r : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_u_0_c), dg(lst_u_0_r)),

  u_1_rec_l : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_u_1_l), dg(lst_u_1_c)),
  u_1_rec_r : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_u_1_c), dg(lst_u_1_r)),

  u_2_rec_l : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_u_2_l), dg(lst_u_2_c)),
  u_2_rec_r : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_u_2_c), dg(lst_u_2_r)),

  rhou_0_rec_l : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_rhou_0_l), dg(lst_rhou_0_c)),
  rhou_0_rec_r : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_rhou_0_c), dg(lst_rhou_0_r)),

  rhou_1_rec_l : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_rhou_1_l), dg(lst_rhou_1_c)),
  rhou_1_rec_r : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_rhou_1_c), dg(lst_rhou_1_r)),

  rhou_2_rec_l : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_rhou_2_l), dg(lst_rhou_2_c)),
  rhou_2_rec_r : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_rhou_2_c), dg(lst_rhou_2_r)),

  rho_rec_l : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_rho_l), dg(lst_rho_c)),
  rho_rec_r : calcRecov2CellGen(basisFun, cv, varsC, pOrder,
    dg(lst_rho_c), dg(lst_rho_r)),

  if(cdim = 1) then(
    printf(fh, "  double u_l_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uvar0l); ~%", basisFun, cdim, pOrder),
    printf(fh, "  double u_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uvar0c); ~%", basisFun, cdim, pOrder),
    printf(fh, "  double u_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uvar0c); ~%", basisFun, cdim, pOrder),
    printf(fh, "  double u_r_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uvar0r); ~%", basisFun, cdim, pOrder),
    printf(fh, "  double u_max_l = fmax(fabs(u_l_r), fabs(u_c_l)); ~%"),
    printf(fh, "  double u_max_r = fmax(fabs(u_c_r), fabs(u_r_l)); ~%"),

    printf(fh, "~%"),

    printf(fh, "  double urec_0_l = ~a; ~%", float(expand(subst(cv=0, u_0_rec_l)))),
    printf(fh, "  double urec_0_r = ~a; ~%", float(expand(subst(cv=0, u_0_rec_r)))),
    printf(fh, "  double urec_1_l = ~a; ~%", float(expand(subst(cv=0, u_1_rec_l)))),
    printf(fh, "  double urec_1_r = ~a; ~%", float(expand(subst(cv=0, u_1_rec_r)))),
    printf(fh, "  double urec_2_l = ~a; ~%", float(expand(subst(cv=0, u_2_rec_l)))),
    printf(fh, "  double urec_2_r = ~a; ~%", float(expand(subst(cv=0, u_2_rec_r)))),
    printf(fh, "  double rhourec_0_l = ~a; ~%", float(expand(subst(cv=0, rhou_0_rec_l)))),
    printf(fh, "  double rhourec_0_r = ~a; ~%", float(expand(subst(cv=0, rhou_0_rec_r)))),
    printf(fh, "  double rhourec_1_l = ~a; ~%", float(expand(subst(cv=0, rhou_1_rec_l)))),
    printf(fh, "  double rhourec_1_r = ~a; ~%", float(expand(subst(cv=0, rhou_1_rec_r)))),
    printf(fh, "  double rhourec_2_l = ~a; ~%", float(expand(subst(cv=0, rhou_2_rec_l)))),
    printf(fh, "  double rhourec_2_r = ~a; ~%", float(expand(subst(cv=0, rhou_2_rec_r)))),
    printf(fh, "  double rhorec_l = ~a; ~%", float(expand(subst(cv=0, rho_rec_l)))),
    printf(fh, "  double rhorec_r = ~a; ~%", float(expand(subst(cv=0, rho_rec_r)))),

    printf(fh, "~%")
  )
  else(
    bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsC,1,bC,subst([cv^2=var2,var2=1/3,cv=0],bC)))*bC), /*TODO: check if this is innerProd or calcInnerProdList*/

    surfNodes : gaussOrd(pOrder+1, cdim-1),
    numNodes : length(surfNodes),

    printf(fh, "  double umax_l[~a] = {0.0};~%", length(bSurf)),
    printf(fh, "  double umax_r[~a] = {0.0};~%", length(bSurf)),
    printf(fh, "  double uquad_l[~a] = {0.0};~%", numNodes),
    printf(fh, "  double uquad_r[~a] = {0.0};~%", numNodes),

    printf(fh, "  double urec_0_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double urec_0_r[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double urec_1_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double urec_1_r[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double urec_2_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double urec_2_r[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double rhourec_0_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double rhourec_0_r[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double rhourec_1_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double rhourec_1_r[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double rhourec_2_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double rhourec_2_r[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double rhorec_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double rhorec_r[~a] = {0.0}; ~%", length(bSurf)),

    printf(fh, "  double ghat_rho_l[~a] = {0.0}; ~%", length(bSurf)),
    printf(fh, "  double ghat_rho_r[~a] = {0.0}; ~%", length(bSurf)),

    printf(fh, "  double u_l_r = 0.0; ~%"),
    printf(fh, "  double u_c_l = 0.0; ~%"),
    printf(fh, "  double u_c_r = 0.0; ~%"),
    printf(fh, "  double u_r_l = 0.0; ~%"),
    printf(fh, "~%"),
    for i : 1 thru numNodes do (
      printf(fh, "  u_l_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(uvar~al); ~%", basisFun, cdim, pOrder, dir, i-1, dir-1),
      printf(fh, "  u_c_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(uvar~ac); ~%", basisFun, cdim, pOrder, dir, i-1, dir-1),
      printf(fh, "  u_c_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(uvar~ac); ~%", basisFun, cdim, pOrder, dir, i-1, dir-1),
      printf(fh, "  u_r_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(uvar~ar); ~%", basisFun, cdim, pOrder, dir, i-1, dir-1),

      printf(fh, "  uquad_l[~a] = fmax(fabs(u_l_r), fabs(u_c_l)); ~%", i-1),
      printf(fh, "  uquad_r[~a] = fmax(fabs(u_c_r), fabs(u_r_l)); ~%", i-1)
    ),

    printf(fh, "~%"),
    printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uquad_l, umax_l); ~%", basisFun, cdim, pOrder),
    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(uquad_r, umax_r); ~%", basisFun, cdim, pOrder),
    printf(fh, "~%"),

    /* Print C exprs for the recovery of u and p across surface boundary, (l = LEFT BOUNDARY, r = RIGHT BOUNDARY) */
    urec_0_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, u_0_rec_l))),
    urec_1_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, u_1_rec_l))),
    urec_2_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, u_2_rec_l))),
    rhourec_0_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, rhou_0_rec_l))),
    rhourec_1_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, rhou_1_rec_l))),
    rhourec_2_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, rhou_2_rec_l))),
    rhorec_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, rho_rec_l))),

    urec_0_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, u_0_rec_r))),
    urec_1_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, u_1_rec_r))),
    urec_2_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, u_2_rec_r))),
    rhourec_0_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, rhou_0_rec_r))),
    rhourec_1_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, rhou_1_rec_r))),
    rhourec_2_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, rhou_2_rec_r))),
    rhorec_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, rho_rec_r))),

    writeCExprs1(urec_0_l, urec_0_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(urec_1_l, urec_1_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(urec_2_l, urec_2_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(rhourec_0_l, rhourec_0_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(rhourec_1_l, rhourec_1_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(rhourec_2_l, rhourec_2_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(rhorec_l, rhorec_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(urec_0_r, urec_0_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(urec_1_r, urec_1_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(urec_2_r, urec_2_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(rhourec_0_r, rhourec_0_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(rhourec_1_r, rhourec_1_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(rhourec_2_r, rhourec_2_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(rhorec_r, rhorec_r_c),
    printf(fh, "~%"),
    flush_output(fh)
  ),

  if(cdim = 1) then(
    ghat_rho_l_exp : subst(tempu_max_l=u_max_l,calcNetFluxRho(dir,"l")),
    ghat_rho_r_exp : subst(tempu_max_r=u_max_r,calcNetFluxRho(dir,"r")),

    ghat_rhoux_l : subst(tempu_max_l=u_max_l,calcNetFluxRhoUi(ghat_rho_l,1,"l")),
    ghat_rhoux_r : subst(tempu_max_r=u_max_r,calcNetFluxRhoUi(ghat_rho_r,1,"r")),

    ghat_rhouy_l : subst(tempu_max_l=u_max_l,calcNetFluxRhoUi(ghat_rho_l,2,"l")),
    ghat_rhouy_r : subst(tempu_max_r=u_max_r,calcNetFluxRhoUi(ghat_rho_r,2,"r")),

    ghat_rhouz_l : subst(tempu_max_l=u_max_l,calcNetFluxRhoUi(ghat_rho_l,3,"l")),
    ghat_rhouz_r : subst(tempu_max_r=u_max_r,calcNetFluxRhoUi(ghat_rho_r,3,"r")),

    printf(fh, "  double ghat_rho_l = ~a; ~%", float(expand(ghat_rho_l_exp))),
    printf(fh, "  double ghat_rho_r = ~a; ~%", float(expand(ghat_rho_r_exp))),

    incr_rho_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rho_l),
    incr_rho_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rho_r),

    incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhoux_l),
    incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhoux_r),

    incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhouy_l),
    incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhouy_r),

    incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhouz_l),
    incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhouz_r)
  )
  else (
    /* Zero out components of recovered functions which are empty and make new expansions. */
    urec_0_l_e : doExpandLst(doMakeExprLst(urec_0_l_c, urec_0_l), bSurf),
    urec_1_l_e : doExpandLst(doMakeExprLst(urec_1_l_c, urec_1_l), bSurf),
    urec_2_l_e : doExpandLst(doMakeExprLst(urec_2_l_c, urec_2_l), bSurf),
    rhourec_0_l_e : doExpandLst(doMakeExprLst(rhourec_0_l_c, rhourec_0_l), bSurf),
    rhourec_1_l_e : doExpandLst(doMakeExprLst(rhourec_1_l_c, rhourec_1_l), bSurf),
    rhourec_2_l_e : doExpandLst(doMakeExprLst(rhourec_2_l_c, rhourec_2_l), bSurf),
    rhorec_l_e : doExpandLst(doMakeExprLst(rhorec_l_c, rhorec_l), bSurf),

    urec_0_r_e : doExpandLst(doMakeExprLst(urec_0_r_c, urec_0_r), bSurf),
    urec_1_r_e : doExpandLst(doMakeExprLst(urec_1_r_c, urec_1_r), bSurf),
    urec_2_r_e : doExpandLst(doMakeExprLst(urec_2_r_c, urec_2_r), bSurf),
    rhourec_0_r_e : doExpandLst(doMakeExprLst(rhourec_0_r_c, rhourec_0_r), bSurf),
    rhourec_1_r_e : doExpandLst(doMakeExprLst(rhourec_1_r_c, rhourec_1_r), bSurf),
    rhourec_2_r_e : doExpandLst(doMakeExprLst(rhourec_2_r_c, rhourec_2_r), bSurf),
    rhorec_r_e : doExpandLst(doMakeExprLst(rhorec_r_c, rhorec_r), bSurf),

    /* Create expansions of u_max (|u_max| evaluated at the surface) on the left and right in the surface basis. */
    umax_l_e : doExpand1(umax_l, bSurf),
    umax_r_e : doExpand1(umax_r, bSurf),

    /* Density flux */
    tempghat_rho_l : calcNetFluxRho(dir,"l"),
    tempghat_rho_l : subst(tempu_max_l=umax_l_e,tempghat_rho_l),
    ghat_rho_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, tempghat_rho_l)),
    writeCExprs1(ghat_rho_l, ghat_rho_l_c),
    printf(fh, "~%"),
    flush_output(fh),
    ghat_rho_l_e : doExpandLst(doMakeExprLst(ghat_rho_l_c, ghat_rho_l), bSurf),     /* Zero out components of ghat which are empty. */

    tempghat_rho_r : calcNetFluxRho(dir,"r"),
    tempghat_rho_r : subst(tempu_max_r=umax_r_e,tempghat_rho_r),
    ghat_rho_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, tempghat_rho_r)),
    writeCExprs1(ghat_rho_r, ghat_rho_r_c),
    printf(fh, "~%"),
    flush_output(fh),
    ghat_rho_r_e : doExpandLst(doMakeExprLst(ghat_rho_r_c, ghat_rho_r), bSurf),     /* Zero out components of ghat which are empty. */

    incr_rho_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rho_l_e),
    incr_rho_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rho_r_e),

    ghat_rhoux_l : calcNetFluxRhoUi(ghat_rho_l_e,1,"l"),
    ghat_rhoux_r : calcNetFluxRhoUi(ghat_rho_r_e,1,"r"),
    ghat_rhoux_l : subst(tempu_max_l=umax_l_e,ghat_rhoux_l),
    ghat_rhoux_r : subst(tempu_max_r=umax_r_e,ghat_rhoux_r),
    incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhoux_l),
    incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhoux_r),

    ghat_rhouy_l : calcNetFluxRhoUi(ghat_rho_l_e,2,"l"),
    ghat_rhouy_r : calcNetFluxRhoUi(ghat_rho_r_e,2,"r"),
    ghat_rhouy_l : subst(tempu_max_l=umax_l_e,ghat_rhouy_l),
    ghat_rhouy_r : subst(tempu_max_r=umax_r_e,ghat_rhouy_r),
    incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhouy_l),
    incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhouy_r),

    ghat_rhouz_l : calcNetFluxRhoUi(ghat_rho_l_e,3,"l"),
    ghat_rhouz_r : calcNetFluxRhoUi(ghat_rho_r_e,3,"r"),
    ghat_rhouz_l : subst(tempu_max_l=umax_l_e,ghat_rhouz_l),
    ghat_rhouz_r : subst(tempu_max_r=umax_r_e,ghat_rhouz_r),
    incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), ghat_rhouz_l),
    incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), ghat_rhouz_r)
  ),


  /*TODO kerns can have the number of operations reduced if we simplify "better"*/
  outvars : [outrho,outrhoux,outrhouy,outrhouz],
  surfTerms : [incr_rho_l + incr_rho_r,incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r],
  for m : 1 thru 4 do (
    surf : surfTerms[m],
    writeCIncrExprs1(outvars[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);

calcIsoEulerSurfUpdater(fh, cdim, vdim, basisFun, pOrder) := block([dir],
  /* printf(fh, "#include <IsoEulerModDecl.h> ~%"), */
  printf(fh, "#include <gkyl_isoeuler_kernels.h> ~%"),
  if(cdim > 1) then (printf(fh, "#include <gkyl_basis_~a_~ax_p~a_upwind_quad_to_modal.h> ~%", "ser", cdim, pOrder)),
  for dir : 1 thru cdim do (
    printf(fh, "#include <gkyl_basis_~a_~ax_p~a_surfx~a_eval_quad.h> ~%", "ser", cdim, pOrder, dir),
    funcName : sconcat("isoeuler_surf",cvars_name[dir],"_", c, "x", "_", "ser"),
    calcIsoEulerUpdateInDir(dir, fh, funcName, cdim, vdim, basisFun, pOrder)
  )
)$

pmax:2$
cmax:3$
print("TODO: consider using recovu*recov*rho for rhoflux")$
for c : 1 thru cmax do (
  for pOrder : 1 thru pmax do (
    v : c,
    fname : sconcat("~/max-out/isoeuler_surf",cvars_name[c],"_", c, "x", "_p", pOrder, ".c"),
    fh : openw(fname),
    calcIsoEulerSurfUpdater(fh, c, v, "ser", pOrder),
    close(fh)
  )
);
