/* This script generates the kernels for the boundary surface term
   of the advection in velocity space for the Vlasov equation
   in the parallel-kinetic-perpendicular-moment (pkpm) model */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

dvdx : [dvpardx0, dvpardx1, dvpardx2]$
wdx  : [wpardx0, wpardx1, wpardx2]$

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

calcVlasovPKPMBoundaryAccelUpdate(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NP, pDim, cid, vid, surfVars, bSurf, surfNodes, numNodes,
   fl_e, fc_e, fr_e, acc_e,
   ux_e, uy_e, uz_e, Pxx_e, Pxy_e, Pxz_e, Pyy_e, Pyz_e, Pzz_e, 
   bx_e, by_e, bz_e, bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e, 
   rho_inv_bx_e, rho_inv_by_e, rho_inv_bz_e, 
   alphaSurf_l_c, alphaSurf_r_c, alst_l, alst_r, alphaSurf_l_e, alphaSurf_r_e,
   alphaOrd_l_n, alphaOrd_r_n, 
   fHatSurf_l_e,fHatSurf_r_e,Ghat_l_c,GhatNoZero_l,
   Ghat_l_e,GhatNoZero_r,Ghat_r_e,incr_l,incr_r],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim  : length(varsP),

  printf(fh, "GKYL_CU_DH void ~a_~ax~av_~a_p~a(const double *w, const double *dxv, 
     const double *u_i, const double *p_ij, const double *bvar, const double *rho_inv_b, 
     const int edge, const double *fEdge, const double *fSkin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // u_i:      bulk flow velocity (ux, uy, uz).~%"),
  printf(fh, "  // p_ij:     pressure tensor (P_xx, P_xy, P_xz, P_yy, P_yz, P_zz).~%"),
  printf(fh, "  // bvar:      magnetic field unit vector (nine components; first three components, b_i, other six components, b_i b_j.) ~%"),
  printf(fh, "  // rho_inv_b: b_i/rho (for pressure force 1/rho * b . div(P)).~%"),
  printf(fh, "  // edge:        Determines if the update is for the left edge (-1) or right edge (+1).~%"),
  printf(fh, "  // fSkin/fEdge: Input Distribution function in skin cell/last edge cell ~%"),
  printf(fh, "  // out:       Incremented distribution function in center cell.~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* grid spacing in v_parallel and v_parallel coordinate */
  printf(fh, "  const double dv1par = 2.0/dxv[~a]; ~%", cdim),
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),
  /* access flow, pressure tensor, and magnetic field unit vector data */
  printf(fh, "  const double *ux = &u_i[~a]; ~%", 0),
  printf(fh, "  const double *uy = &u_i[~a]; ~%", NC),
  printf(fh, "  const double *uz = &u_i[~a]; ~%", NC*2),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxx = &p_ij[~a]; ~%", 0),
  printf(fh, "  const double *Pxy = &p_ij[~a]; ~%", NC),
  printf(fh, "  const double *Pxz = &p_ij[~a]; ~%", NC*2),
  printf(fh, "  const double *Pyy = &p_ij[~a]; ~%", NC*3),
  printf(fh, "  const double *Pyz = &p_ij[~a]; ~%", NC*4),
  printf(fh, "  const double *Pzz = &p_ij[~a]; ~%", NC*5),

  printf(fh, "~%"),

  printf(fh, "  const double *bx = &bvar[~a]; ~%", 0),
  printf(fh, "  const double *by = &bvar[~a]; ~%", NC),
  printf(fh, "  const double *bz = &bvar[~a]; ~%", NC*2),
  printf(fh, "  const double *bxbx = &bvar[~a]; ~%", NC*3),
  printf(fh, "  const double *bxby = &bvar[~a]; ~%", NC*4),
  printf(fh, "  const double *bxbz = &bvar[~a]; ~%", NC*5),
  printf(fh, "  const double *byby = &bvar[~a]; ~%", NC*6),
  printf(fh, "  const double *bybz = &bvar[~a]; ~%", NC*7),
  printf(fh, "  const double *bzbz = &bvar[~a]; ~%", NC*8),

  printf(fh, "~%"),

  printf(fh, "  const double *rho_inv_bx = &rho_inv_b[~a]; ~%", 0),
  printf(fh, "  const double *rho_inv_by = &rho_inv_b[~a]; ~%", NC),
  printf(fh, "  const double *rho_inv_bz = &rho_inv_b[~a]; ~%", NC*2),

  printf(fh, "~%"),

  /* Expand u, P, and b in configuration space basis */
  ux_e : doExpand1(ux, bC),
  uy_e : doExpand1(uy, bC),
  uz_e : doExpand1(uz, bC),
  u_e : [ux_e, uy_e, uz_e],

  Pxx_e : doExpand1(Pxx, bC),
  Pxy_e : doExpand1(Pxy, bC),
  Pxz_e : doExpand1(Pxz, bC),
  Pyy_e : doExpand1(Pyy, bC),
  Pyz_e : doExpand1(Pyz, bC),
  Pzz_e : doExpand1(Pzz, bC),
  P_e : [Pxx_e, Pxy_e, Pxz_e, Pyy_e, Pyz_e, Pzz_e],

  bx_e : doExpand1(bx, bC),
  by_e : doExpand1(by, bC),
  bz_e : doExpand1(bz, bC),
  b_e : [bx_e, by_e, bz_e],

  bxbx_e : doExpand1(bxbx, bC),
  bxby_e : doExpand1(bxby, bC),
  bxbz_e : doExpand1(bxbz, bC),
  byby_e : doExpand1(byby, bC),
  bybz_e : doExpand1(bybz, bC),
  bzbz_e : doExpand1(bzbz, bC),
  bb_e : [bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e],

  rho_inv_bx_e : doExpand1(rho_inv_bx, bC),
  rho_inv_by_e : doExpand1(rho_inv_by, bC),
  rho_inv_bz_e : doExpand1(rho_inv_bz, bC),

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  /* alpha_vdim = [1/rho * b . div(P) - v_parallel bb : grad(u)] df/dvpar */
  if cdim = 1 then (
    acc_e : rho_inv_bx_e*diff(Pxx_e,varsC[1]) + rho_inv_by_e*diff(Pxy_e,varsC[1]) + rho_inv_bz_e*diff(Pxz_e,varsC[1]) 
            - (vx*dvpar/2.0+wvpar)*(bxbx_e*diff(ux_e, varsC[1]) + bxby_e*diff(uy_e, varsC[1]) + bxbz_e*diff(uz_e, varsC[1]))
  )
  elseif cdim = 2 then (
    acc_e : rho_inv_bx_e*diff(Pxx_e,varsC[1]) + rho_inv_by_e*diff(Pxy_e,varsC[1]) + rho_inv_bz_e*diff(Pxz_e,varsC[1]) 
            + rho_inv_bx_e*diff(Pxy_e,varsC[2]) + rho_inv_by_e*diff(Pyy_e,varsC[2]) + rho_inv_bz_e*diff(Pyz_e,varsC[2])
            - (vx*dvpar/2.0+wvpar)*(bxbx_e*diff(ux_e, varsC[1]) + bxby_e*diff(uy_e, varsC[1]) + bxbz_e*diff(uz_e, varsC[1])
            + bxby_e*diff(ux_e, varsC[2]) + byby_e*diff(uy_e, varsC[2]) + bybz_e*diff(uz_e, varsC[2]))
  )
  else (
    acc_e : rho_inv_bx_e*diff(Pxx_e,varsC[1]) + rho_inv_by_e*diff(Pxy_e,varsC[1]) + rho_inv_bz_e*diff(Pxz_e,varsC[1]) 
            + rho_inv_bx_e*diff(Pxy_e,varsC[2]) + rho_inv_by_e*diff(Pyy_e,varsC[2]) + rho_inv_bz_e*diff(Pyz_e,varsC[2]) 
            + rho_inv_bx_e*diff(Pxz_e,varsC[3]) + rho_inv_by_e*diff(Pyz_e,varsC[3]) + rho_inv_bz_e*diff(Pzz_e,varsC[3]) 
            - (vx*dvpar/2.0+wvpar)*(bxbx_e*diff(ux_e, varsC[1]) + bxby_e*diff(uy_e, varsC[1]) + bxbz_e*diff(uz_e, varsC[1])
            + bxby_e*diff(ux_e, varsC[2]) + byby_e*diff(uy_e, varsC[2]) + bybz_e*diff(uz_e, varsC[2])   
            + bxbz_e*diff(ux_e, varsC[3]) + bybz_e*diff(uy_e, varsC[3]) + bzbz_e*diff(uz_e, varsC[3]))
  ),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* Surface variables to integrate over. */
  surfVars : delete(vx,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vx dependence. */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),

  /* Project alpha evaluated at interior surface onto surf basis. */
  alphaSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=-1,acc_e))),
  alphaSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=1,acc_e))),
  alst_l          : doMakeExprLst(alphaSurf_l_c, alphaSurf),
  alst_r          : doMakeExprLst(alphaSurf_r_c, alphaSurf),
  alphaSurf_l_e : doExpand(alst_l, bSurf),
  alphaSurf_r_e : doExpand(alst_r, bSurf),

  /* Surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    surf_cdim : cdim,  surf_vdim : 0,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim)
  ) else (
    surfNodes : gaussOrd(polyOrder+1, pDim-1)
  ),
  numNodes : length(surfNodes),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     We still require a alpha_l (w - dv/2) and alpha_r (w + dv/2) for the two sides of the cell */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaSurf_r_e,surfNodes,surfVars))),

  printf(fh, "  double alphaSurf[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double fUpwindQuad[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind[~a] = {0.0};;~%", length(bSurf)),
  printf(fh, "  double Ghat[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "~%"),
  /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evaluated at +1 */
  /* In addition we need the drag term evaluated at +1 (so alpha evaluated on the right) */
  printf(fh, "  if (edge == -1) { ~%~%"),
  /* Write out drag term for far left edge boundary.
     Need alpha evaluated at +1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far left boundary, no drag term on -1 surface */
  writeCExprs1(alphaSurf, alphaSurf_r_c),
  printf(fh, "~%"),
  /* Write out fUpwindQuad for the far left edge */
  /* Within the skin cell, we need alpha_r (alpha evaluated at +1)
     just like how the skin cell is evaluated at +1 */

  for i : 1 thru length(alphaOrd_r_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_r_n[i]),
    printf(fh, "    fUpwindQuad[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(fSkin); ~%", i-1, basisFun, pDim, polyOrder, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpwindQuad[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(fEdge); ~%", i-1, basisFun, pDim, polyOrder, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),

  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then  /* Force p=1 to use hybrid basis. */
    printf(fh, "  hyb_~ax~av_p1_vdir_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", cdim, 1)
  else
    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", basisFun, cdim+1, polyOrder),
  printf(fh, "~%"),

  /* Create expansions of f_hat (upwinded f) on the left and right in the surface basis. */
  fHatSurf_e : doExpand1(fUpwind, bSurf),

  Ghat_c : calcInnerProdList(surfVars,alphaSurf_r_e,bSurf,fHatSurf_e),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  writeCExprs1(Ghat, Ghat_c),
  printf(fh, "~%"),
  flush_output(fh),

  glst1  : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpand(glst1, bSurf),

  /* Increments to the far left skin cell (some dimensional factors missing). */
  incr : calcInnerProdList(surfVars, -1.0, subst(vx=1.0, bP), Ghat_e),

  /* Write out contribution */
  writeCIncrExprs1(out, dv1par*incr),

  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "~%  } else { ~%~%"),
  /* Write out drag term for far right edge boundary.
     Need alpha evaluated at -1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far right boundary, no drag term on +1 surface */
  writeCExprs1(alphaSurf, alphaSurf_l_c),
  printf(fh, "~%"),
  /* Write out fUpwindQuad for the far right edge */
  /* Within the skin cell, we need alpha_l (alpha evaluated at -1)
     just like how the skin cell is evaluated at -1 */

  for i : 1 thru length(alphaOrd_l_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_l_n[i]),
    printf(fh, "    fUpwindQuad[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(fEdge); ~%", i-1, basisFun, pDim, polyOrder, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpwindQuad[~a] = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(fSkin); ~%", i-1, basisFun, pDim, polyOrder, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),

  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then  /* Force p=1 to use hybrid basis. */
    printf(fh, "  hyb_~ax~av_p1_vdir_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", cdim, 1)
  else
    printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", basisFun, cdim+1, polyOrder),
  printf(fh, "~%"),

  /* Create expansions of f_hat (upwinded f) on the left and right in the surface basis. */
  fHatSurf_e : doExpand1(fUpwind, bSurf),

  Ghat_c : calcInnerProdList(surfVars,alphaSurf_l_e,bSurf,fHatSurf_e),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  writeCExprs1(Ghat, Ghat_c),
  printf(fh, "~%"),
  flush_output(fh),

  glst1  : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpand(glst1, bSurf),

  /* Increments to the far right edge skin cell (some dimensional factors missing). */
  incr : calcInnerProdList(surfVars, 1, subst(vx=-1, bP), Ghat_e),

  /* Write out contribution. */
  writeCIncrExprs1(out, dv1par*incr),
  printf(fh, "~%"),
  printf(fh, "  } ~%"),
  printf(fh, "} ~%")
);
