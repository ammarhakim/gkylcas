load("modal-basis")$
load("out-scripts");
load(stringproc)$
load("nodalOperations/nodalFunctions")$
load("recovery")$

fpprec : 24$

/* This script generates the kernels for the surface term
   drag contribution from Lenard Bernstein operator. */

cvars : [x, y, z]$
vvars : [vx, vy, vz]$
nuUSumx : [sumNuUx, sumNuUy, sumNuUz]$
vidx(cdim,vdim)  := makelist(i,i,cdim+1,cdim+vdim)$
vidx1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

load ("scifac")$

writeCExprsCollect1c(lhs, rhs, clst) := block([expr],
  expr : float(expand(rhs)), 
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e : apply(collectterms, param),
      printf(fh, "  ~a = ~a; ~%", lhs[i-1], gcfac(e))
    )
  )
)$

writeCExprsCollect1s(lhs, rhs, clst) := block([expr],
  expr : float(expand(rhs)), 
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e : apply(collectterms, param),
      printf(fh, "    ~a = ~a; ~%", lhs[i-1], gcfac(e))
    )
  )
)$

writeCIncrExprs1s(lhs, rhs) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then printf(fh, "    ~a += ~a; ~%", lhs[i-1], expr[i])
  )
)$

calcDragUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, numFluxOp, isNonuniform) := block(
  [modNm,vid,vid1,vv,surfVars,bP,bC,NP,NC,bPp,hOrder,h_e,hsol],
  
  if (basisFun="ser") then basisFun:"Ser",
  if (basisFun="tensor") then basisFun:"Tensor",
  kill(varsC, varsP, basisC, basisP),
  /* Load basis of dimensionality requested. */
  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),
  pDim : cdim+vdim,
  /* Variables. */
  vid  : vidx(cdim,vdim),
  vid1 : vidx1(cdim,vdim),
  vv   : vvars[dir],
  surfVars : delete(vv,varsP),
  /* Polynomial basis and its derivatives. */
  bP  : basisP[polyOrder],  NP : length(bP),
  bC  : basisC[polyOrder],  NC : length(bC),
  bPp : diff(bP,vv),

  if (basisFun="Ser") then basisFun:"ser",
  if (basisFun="Tensor") then basisFun:"tensor",
  /*............. RECOVERY DONE ..............................*/
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *nuSum, const double *nuUSum, const double *nuVtSqSum, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:         cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:       cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nuSum:         collisionalities added (self and cross species collisionalities). ~%"),
  printf(fh, "  // nuUSum[~a]:    sum of bulk velocities times their respective collisionalities. ~%", vdim*NC),
  printf(fh, "  // nuVtSqSum[~a]: sum of thermal speeds squared time their respective collisionalities. ~%", NC),
  printf(fh, "  // fl/fc/fr:      distribution function in cells ~%"),
  printf(fh, "  // out:           incremented distribution function in cell ~%"),
  printf(fh, "  double rdv2 = 2.0/dxv[~a]; ~%", vid1[dir]),
  printf(fh, "  double rdvSq4 = 4.0/(dxv[~a]*dxv[~a]); ~%", vid1[dir], vid1[dir]),
  printf(fh, "~%"),
    
  /* First compute the contribution coming from the second
     differentiation by parts to left and right cells. */
  nuVtSqSum_e : doExpand1(nuVtSqSum,bC),
  nuSum_e : doExpand1(nuSum,bC),
  /* Now do the contribution from the generalized flux Ghat. */
  basisFlip : subst(vv=-1*vv, bP),
  signs : fullratsimp(basisFlip/bP),
  /* Expand the mean flow speed in the configuration basis. */
  nuUSum_e : doExpand1(nuUSumx[dir],bC),
  /* Create pointer to component of u relevant to this surface. */
  printf(fh, "  const double *sumNuU~a = &nuUSum[~a]; ~%", cvars[dir], NC*(dir-1)),
  printf(fh, "~%"),
  /* Calculate the alpha-velocity due to drag. */
  alphaDr : nuSum_e*((1/2)*dxv[vid1[dir]]*vv+w[vid1[dir]])-nuUSum_e,
    
  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),
  /* Surface basis. Equivalent to basis of one lower
     dimensionality without surface variable. */
  bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsP,1,bP,subst([vv^2=var2,var2=1/3,vv=0],bP)))*bP),
  /* Project alphaDrag evaluated at interior surface onto surf basis. */
  alphaDrSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=-1,alphaDr))),
  alphaDrSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=1,alphaDr))),
  alst_l          : doMakeExprLst(alphaDrSurf_l_c, alphaDrSurf_l),
  alst_r          : doMakeExprLst(alphaDrSurf_r_c, alphaDrSurf_r),
  alphaDrSurf_l_e : doExpand(alst_l, bSurf),
  alphaDrSurf_r_e : doExpand(alst_r, bSurf),
  printf(fh, "  double alphaDrSurf_l[~a] = {0.0}; ~%", length(bSurf)),
  writeCExprs1(alphaDrSurf_l, alphaDrSurf_l_c),
  printf(fh, "~%"),
  printf(fh, "  double alphaDrSurf_r[~a] = {0.0}; ~%", length(bSurf)),
  writeCExprs1(alphaDrSurf_r, alphaDrSurf_r_c),
  printf(fh, "~%"),
  /* Upwind the drag term using quadrature point evaluation. */
  /* Scale nodes of the nodal basis by corresponding factors to obtain the Gauss-Legendre quadrature points */
  /* We always use tensor basis for the quadrature and resulting nodal basis, regardless of base basis type */
  surfNodes : getNodes("Tensor", pDim-1, polyOrder),
  if polyOrder=1 then (surfNodes:surfNodes*(1/sqrt(3))) elseif polyOrder=2 then (surfNodes:surfNodes*sqrt(3/5)),
  numNodes : length(surfNodes),
  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     We still require a alpha_l (w - dv/2) and alpha_r (w + dv/2) for the two sides of the cell */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaDrSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaDrSurf_r_e,surfNodes,surfVars))),
  printf(fh, "  double fUpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind_l[~a] = {0.0};;~%", length(bSurf)),
  printf(fh, "  double fUpwind_r[~a] = {0.0};~%", length(bSurf)),
  printf(fh, "  double Gdrag_l[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double Gdrag_r[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "~%"),
  for i : 1 thru length(alphaOrd_l_n) do (
    /* This subst eliminates the need for another variable, and removes
        the common factor (for p=1) which is not needed to determine
        sign (not working for p>1). */
    if polyOrder=1 then (
      rcoFac : 1./(content(alphaOrd_l_n[1],alphaDrSurf_l[0])[1]),
      printf(fh, "  if (~a < 0) { ~%", fullratsimp(alphaOrd_l_n[i]*rcoFac)),
      printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fl); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fc); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    ) else (
      printf(fh, "  if (~a < 0) { ~%", alphaOrd_l_n[i]),
      printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fl); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fc); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    )
  ),
  for i : 1 thru length(alphaOrd_r_n) do (
    /* This subst eliminates the need for another variable, and removes
        the common factor (for p=1) which is not needed to determine
        sign (not working for p>1). */
    if polyOrder=1 then (
      rcoFac : 1./(content(alphaOrd_r_n[1],alphaDrSurf_r[0])[1]),
      printf(fh, "  if (~a < 0) { ~%", fullratsimp(alphaOrd_r_n[i]*rcoFac)),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fc); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fr); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    ) else (
      printf(fh, "  if (~a < 0) { ~%", alphaOrd_r_n[i]),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fc); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fr); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    )
  ),
  if (basisFun = "Tensor") or (basisFun = "tensor") or (polyOrder = 1) then (
    if (basisFun="ser") then basisFun:"Ser",
    if (basisFun="tensor") then basisFun:"Tensor",
    /* Get modal surface expansion from nodal quadrature points. */
    nodToMod : calcNodToModWithNodes(basisFun, pDim-1, polyOrder, surfNodes),
    fUp_l_c : gcfac(fullratsimp(nodToMod . makelist(fUpwindQuad_l[i-1],i,1,numNodes))),
    fUp_l_c : makelist(fUp_l_c[i][1],i,1,numNodes),
    /* Write coefficients of modal surface expansion fupwind. */
    /* Clever factorization is possible for polyOrder = 1, but for higher
       polynomial orders, factorization is *too* clever and can lead to 
       deeply nested parentheses, not ideal for compiler optimizations */
    if (polyOrder = 1) then (
      writeCExprsNoExpand1(fUpwind_l, fUp_l_c)
    ) else (
      writeCExprs1(fUpwind_l, fUp_l_c)
    ),
    printf(fh, "~%"),
    flush_output(fh),
    fHatSurf_l_e : doExpand1(fUpwind_l,bSurf),
    fUp_r_c : gcfac(fullratsimp(nodToMod . makelist(fUpwindQuad_r[i-1],i,1,numNodes))),
    fUp_r_c : makelist(fUp_r_c[i][1],i,1,numNodes),
    /* Write coefficients of modal surface expansion fupwind. */
    /* Clever factorization is possible for polyOrder = 1, but for higher
       polynomial orders, factorization is *too* clever and can lead to 
       deeply nested parentheses, not ideal for compiler optimizations */
    if (polyOrder = 1) then (
      writeCExprsNoExpand1(fUpwind_r, fUp_r_c)
    ) else (
      writeCExprs1(fUpwind_r, fUp_r_c)
    ),
    printf(fh, "~%"),
    flush_output(fh),
    fHatSurf_r_e : doExpand1(fUpwind_r,bSurf)
  ) else (
    /* Make nodal expansions in nodal basis */
    /* Only required if basis type is not tensor */
    /* If basis type is tensor (or polyOrder = 1 Serendipity), then well-defined intermediate
       transformation back from nodal basis to modal basis, otherwise need nodal basis for 
       final computation of Ghat */
    basisNodal : getVarsNodalBasisWithNodes("Tensor", pDim-1, polyOrder, surfVars, surfNodes),
    fHatNodal_l_e : sum(fUpwindQuad_l[i-1]*basisNodal[i], i, 1, length(basisNodal)),
    fHatNodal_r_e : sum(fUpwindQuad_r[i-1]*basisNodal[i], i, 1, length(basisNodal)),
    fHatModProj_l_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_l_e)),
    fHatModProj_r_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_r_e)),
    
    /* Write out projection of tensor nodal basis onto modal basis (usually Serendipity here) */
    writeCExprs1(fUpwind_l, fHatModProj_l_e),
    printf(fh, "~%"),
    writeCExprs1(fUpwind_r, fHatModProj_r_e),
    printf(fh, "~%"),
    /* Zero out components of fUpwind_l/r which are empty and make new lists with right variable name. */
    fHatModProj_l_NoZero : doMakeExprLst(fHatModProj_l_e, fUpwind_l),
    fHatSurf_l_e : doExpandLst(fHatModProj_l_NoZero, bSurf),
    fHatModProj_r_NoZero : doMakeExprLst(fHatModProj_r_e, fUpwind_r),
    fHatSurf_r_e : doExpandLst(fHatModProj_r_NoZero, bSurf)
  ),  
  GhatDrag_l_c : calcInnerProdList(surfVars,alphaDrSurf_l_e,bSurf,fHatSurf_l_e),
  GhatDrag_r_c : calcInnerProdList(surfVars,alphaDrSurf_r_e,bSurf,fHatSurf_r_e),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  glst1_l      : doMakeExprLst(GhatDrag_l_c, Gdrag_l),
  GhatDrag_l_e     : doExpandLst(glst1_l, bSurf),
  glst1_r      : doMakeExprLst(GhatDrag_r_c, Gdrag_r),
  GhatDrag_r_e     : doExpandLst(glst1_r, bSurf),
  drag_incr_r :  calcInnerProdList(surfVars, 1, subst(vv=1, bP), GhatDrag_r_e),
  drag_incr_l :  calcInnerProdList(surfVars, -1, subst(vv=-1, bP), GhatDrag_l_e),

  /* Populate Ghat including the diffusion term. */
  clst_l: append([rdv2DiffFac], makelist(alphaDrag_l[i],i,0,NC-1)),
  tempVars : writeCExprsCollect1(Gdrag_l, GhatDrag_l_c, clst_l),
  printf(fh, "~%"),
  flush_output(fh),
    
  clst_r : append([rdv2DiffFac], makelist(alphaDrag_r[i],i,0,NC-1)),
  tempVars : writeCExprsCollect1(Gdrag_r, GhatDrag_r_c, clst_r),
  printf(fh, "~%"),
  flush_output(fh),
  
  writeCIncrExprs1(out, rdv2*drag_incr_r + rdv2*drag_incr_l), 
  printf(fh, "} ~%")
);


