load("modal-basis")$
load("out-scripts");
load(stringproc)$
load("g0/nodal_operations/nodal_functions")$
load("recovery")$

fpprec : 24$

/* This script generates the kernels for the surface term
   drag contribution from Lenard Bernstein operator. */

cvars : [x, y, z]$
vvars : [vx, vy, vz]$
nuUSumx : [sumNuUx, sumNuUy, sumNuUz]$
vidx(cdim,vdim)  := makelist(i,i,cdim+1,cdim+vdim)$
vidx1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

load ("scifac")$

writeCExprsCollect1c(lhs, rhs, clst) := block([expr],
  expr : float(expand(rhs)), 
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e : apply(collectterms, param),
      printf(fh, "  ~a = ~a; ~%", lhs[i-1], gcfac(e))
    )
  )
)$

writeCExprsCollect1s(lhs, rhs, clst) := block([expr],
  expr : float(expand(rhs)), 
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e : apply(collectterms, param),
      printf(fh, "    ~a = ~a; ~%", lhs[i-1], gcfac(e))
    )
  )
)$

writeCIncrExprs1s(lhs, rhs) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then printf(fh, "    ~a += ~a; ~%", lhs[i-1], expr[i])
  )
)$

calcDragUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, numFluxOp, isNonuniform) := block(
  [modNm,vid,vid1,vv,surfVars,surfNodes,surfNodesConfig,numNodes,numNodesConfig,numNodesVel,bP,bC,NP,NC,bPp,hOrder,h_e,hsol],
  
  if (basisFun="ser") then basisFun:"Ser",
  if (basisFun="tensor") then basisFun:"Tensor",
  kill(varsC, varsP, basisC, basisP),
  /* Load basis of dimensionality requested. */
  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),
  pDim : cdim+vdim,
  /* Variables. */
  vid  : vidx(cdim,vdim),
  vid1 : vidx1(cdim,vdim),
  vv   : vvars[dir],
  surfVars : delete(vv,varsP),
  /* Polynomial basis and its derivatives. */
  bP  : basisP[polyOrder],  NP : length(bP),
  bC  : basisC[polyOrder],  NC : length(bC),

  if (basisFun="Ser") then basisFun:"ser",
  if (basisFun="Tensor") then basisFun:"tensor",

  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *nuSum, const double *nuUSum, const double *nuVtSqSum, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:         cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:       cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nuSum:         collisionalities added (self and cross species collisionalities). ~%"),
  printf(fh, "  // nuUSum[~a]:    sum of bulk velocities times their respective collisionalities. ~%", vdim*NC),
  printf(fh, "  // nuVtSqSum[~a]: sum of thermal speeds squared time their respective collisionalities. ~%", NC),
  printf(fh, "  // fl/fc/fr:      distribution function in cells ~%"),
  printf(fh, "  // out:           incremented distribution function in cell ~%"),
  printf(fh, "  double rdv2 = 2.0/dxv[~a]; ~%", vid1[dir]),
  printf(fh, "~%"),

  nuSum_e : doExpand1(nuSum,bC),
  /* Expand the mean flow speed in the configuration basis. */
  nuUSum_e : doExpand1(nuUSumx[dir],bC),
  /* Create pointer to component of u relevant to this surface. */
  printf(fh, "  const double *sumNuU~a = &nuUSum[~a]; ~%", cvars[dir], NC*(dir-1)),
  printf(fh, "~%"),
  /* Calculate the alpha-velocity due to drag. */
  alphaDr : nuSum_e*((1/2)*dxv[vid1[dir]]*vv+w[vid1[dir]])-nuUSum_e,
    
  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),
  /* Surface basis. Equivalent to basis of one lower
     dimensionality without surface variable. */
  bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsP,1,bP,subst([vv^2=var2,var2=1/3,vv=0],bP)))*bP),
  /* Project alphaDrag evaluated at interior surface onto surf basis. */
  alphaDrSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=-1,alphaDr))),
  alphaDrSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=1,alphaDr))),
  alst_l          : doMakeExprLst(alphaDrSurf_l_c, alphaDrSurf_l),
  alst_r          : doMakeExprLst(alphaDrSurf_r_c, alphaDrSurf_r),
  alphaDrSurf_l_e : doExpand(alst_l, bSurf),
  alphaDrSurf_r_e : doExpand(alst_r, bSurf),
  printf(fh, "  double alphaDrSurf_l[~a] = {0.0}; ~%", length(bSurf)),
  writeCExprs1(alphaDrSurf_l, alphaDrSurf_l_c),
  printf(fh, "~%"),
  printf(fh, "  double alphaDrSurf_r[~a] = {0.0}; ~%", length(bSurf)),
  writeCExprs1(alphaDrSurf_r, alphaDrSurf_r_c),
  printf(fh, "~%"),
  /* Upwind the drag term using quadrature point evaluation. */
  /* Scale nodes of the nodal basis by corresponding factors to obtain the Gauss-Legendre quadrature points */
  /* We always use tensor basis for the quadrature and resulting nodal basis, regardless of base basis type */
  surfNodes : getNodes("Tensor", pDim-1, polyOrder),
  if polyOrder=1 then (surfNodes:surfNodes*(1/sqrt(3))) elseif polyOrder=2 then (surfNodes:surfNodes*sqrt(3/5)),
  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     We still require a alpha_l (w - dv/2) and alpha_r (w + dv/2) for the two sides of the cell */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaDrSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaDrSurf_r_e,surfNodes,surfVars))),
  /* Drag term flux does not depend on velocity space surface on which it sits
     i.e., drag term in vx does not depend on vy and vz
     so sort quadrature points between configuration space and velocity space */
  /* Get number of configuration space nodes */
  surfNodesConfig : getNodes("Tensor", cdim, polyOrder),
  numNodesConfig : length(surfNodesConfig),
  numNodes : length(surfNodes),
  numNodesVel : numNodes/numNodesConfig,
  printf(fh, "  double fUpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind_l[~a] = {0.0};~%", length(bSurf)),
  printf(fh, "  double fUpwind_r[~a] = {0.0};~%", length(bSurf)),
  printf(fh, "  double Gdrag_l[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double Gdrag_r[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "~%"),
  for i : 1 thru numNodesConfig do (
    if polyOrder=1 then (
      /* This subst eliminates the need for another variable, and removes
         the common factor (for p=1) which is not needed to determine
         sign (not working for p>1). */
      rcoFac_l : 1./(content(alphaOrd_l_n[1],alphaDrSurf_l[0])[1]),
      rcoFac_r : 1./(content(alphaOrd_r_n[1],alphaDrSurf_r[0])[1]),
      /* Drag term on left side of interface */
      printf(fh, "  if (~a < 0) { ~%", fullratsimp(alphaOrd_l_n[i]*rcoFac_l)),  
      for j : 1 thru numNodesVel do (
        printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax_p~a_surfx~a_quad_~a_r(fl); ~%", (j-1)*numNodesConfig+(i-1), basisFun, cdim+vdim, polyOrder, cdim+dir, (j-1)*numNodesConfig+(i-1))
      ),
      printf(fh, "  } else { ~%"),
      for j : 1 thru numNodesVel do (
        printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax_p~a_surfx~a_quad_~a_l(fc); ~%", (j-1)*numNodesConfig+(i-1), basisFun, cdim+vdim, polyOrder, cdim+dir, (j-1)*numNodesConfig+(i-1))
      ),
      printf(fh, "  } ~%"),
      /* Drag term on right side of interface */
      printf(fh, "  if (~a < 0) { ~%", fullratsimp(alphaOrd_r_n[i]*rcoFac_r)),  
      for j : 1 thru numNodesVel do (
        printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax_p~a_surfx~a_quad_~a_r(fc); ~%", (j-1)*numNodesConfig+(i-1), basisFun, cdim+vdim, polyOrder, cdim+dir, (j-1)*numNodesConfig+(i-1))
      ),
      printf(fh, "  } else { ~%"),
      for j : 1 thru numNodesVel do (
        printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax_p~a_surfx~a_quad_~a_l(fr); ~%", (j-1)*numNodesConfig+(i-1), basisFun, cdim+vdim, polyOrder, cdim+dir, (j-1)*numNodesConfig+(i-1))
      ),
      printf(fh, "  } ~%")
    /* If polyOrder > 1, we just evaluate alpha at the quadrature points with no further substitutions */
    ) else (
      printf(fh, "  if (~a < 0) { ~%", alphaOrd_l_n[i]),
      for j : 1 thru numNodesVel do (
        printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax_p~a_surfx~a_quad_~a_r(fl); ~%", (j-1)*numNodesConfig+(i-1), basisFun, cdim+vdim, polyOrder, cdim+dir, (j-1)*numNodesConfig+(i-1))
      ),
      printf(fh, "  } else { ~%"),
      for j : 1 thru numNodesVel do (
        printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax_p~a_surfx~a_quad_~a_l(fc); ~%", (j-1)*numNodesConfig+(i-1), basisFun, cdim+vdim, polyOrder, cdim+dir, (j-1)*numNodesConfig+(i-1))
      ),
      printf(fh, "  } ~%"),
      /* Drag term on right side of interface */
      printf(fh, "  if (~a < 0) { ~%", alphaOrd_r_n[i]),  
      for j : 1 thru numNodesVel do (
        printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax_p~a_surfx~a_quad_~a_r(fc); ~%", (j-1)*numNodesConfig+(i-1), basisFun, cdim+vdim, polyOrder, cdim+dir, (j-1)*numNodesConfig+(i-1))
      ),
      printf(fh, "  } else { ~%"),
      for j : 1 thru numNodesVel do (
        printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax_p~a_surfx~a_quad_~a_l(fr); ~%", (j-1)*numNodesConfig+(i-1), basisFun, cdim+vdim, polyOrder, cdim+dir, (j-1)*numNodesConfig+(i-1))
      ),
      printf(fh, "  } ~%")
    )
  ),

  printf(fh, "~%"),
  printf(fh, "  // Project nodal basis back onto modal basis. ~%"),
  printf(fh, "  ~a_~ax_p~a_upwind(fUpwindQuad_l, fUpwind_l); ~%", basisFun, cdim+vdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_upwind(fUpwindQuad_r, fUpwind_r); ~%", basisFun, cdim+vdim, polyOrder),
  printf(fh, "~%"),

  /* Create expansions of f_hat (upwinded f) on the left and right in the surface basis. */
  fHatSurf_l_e : doExpand1(fUpwind_l, bSurf),
  fHatSurf_r_e : doExpand1(fUpwind_r, bSurf),

  GhatDrag_l_c : calcInnerProdList(surfVars,alphaDrSurf_l_e,bSurf,fHatSurf_l_e),
  GhatDrag_r_c : calcInnerProdList(surfVars,alphaDrSurf_r_e,bSurf,fHatSurf_r_e),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  glst1_l : doMakeExprLst(GhatDrag_l_c, Gdrag_l),
  GhatDrag_l_e : doExpandLst(glst1_l, bSurf),
  glst1_r : doMakeExprLst(GhatDrag_r_c, Gdrag_r),
  GhatDrag_r_e : doExpandLst(glst1_r, bSurf),
  drag_incr_r : calcInnerProdList(surfVars, 1, subst(vv=1, bP), GhatDrag_r_e),
  drag_incr_l : calcInnerProdList(surfVars, -1, subst(vv=-1, bP), GhatDrag_l_e),

  clst_l : makelist(alphaDrag_l[i],i,0,NC-1),
  tempVars : writeCExprsCollect1(Gdrag_l, GhatDrag_l_c, clst_l),
  printf(fh, "~%"),
  flush_output(fh),
    
  clst_r : makelist(alphaDrag_r[i],i,0,NC-1),
  tempVars : writeCExprsCollect1(Gdrag_r, GhatDrag_r_c, clst_r),
  printf(fh, "~%"),
  flush_output(fh),
  
  writeCIncrExprs1(out, rdv2*drag_incr_r + rdv2*drag_incr_l), 
  printf(fh, "} ~%")
);

