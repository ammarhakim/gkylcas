load("modal-basis")$
load("out-scripts");
load("nodal_operations/nodal_functions")$
load("recovery")$
load("utilities")$
load(stringproc)$
fpprec : 24$

/* This script generates the kernels for the surface term
   drag contribution from Lenard Bernstein operator when 
   coupled to the Vlasov parallel-kinetic-perpendicular-moment (pkpm) model. */

varsCAll : [x, y, z]$
vvarsAll : [vx, vy, vz]$
vidx1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

calcVlasovPKPMLBODragSurfUpdater(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,NP,NC,pDim,vid1,vv,surfVars,nuSum_e,nuUSum_e,alphaDr,fl_e,fc_e,fr_e,
   bSurf,alphaDrSurf_l_c,alphaDrSurf_r_c,alst_l,alst_r,alphaDrSurf_l_e,alphaDrSurf_r_e,
   surf_cdim,surf_vdim,surfNodes,numNodes,alphaOrd_l_n,alphaOrd_r_n,surfNodesConfig,
   numNodesConfig,numNodesVel,i,rcoFac_l,rcoFac_r,j,fHatSurf_l_e,fHatSurf_r_e,Ghat_l_c,
   Ghat_r_c,glst1_l,Ghat_l_e,glst1_r,Ghat_r_e,drag_incr_r,drag_incr_l],
  
  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),  NC : length(bC),

  pDim : cdim+vdim,
  /* Variables. */
  surfVars : delete(vx,varsP),

  printf(fh, "#include <gkyl_lbo_vlasov_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *nu, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:         cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:       cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nu:         collisionalities added (self and cross species collisionalities). ~%"),
  printf(fh, "  // fl/fc/fr:      distribution function in cells ~%"),
  printf(fh, "  // out:           incremented distribution function in cell ~%"),
  printf(fh, "~%"),

  /* grid spacing in v_parallel and v_parallel coordinate */
  printf(fh, "  const double dv1par = 2.0/dxv[~a]; ~%", cdim),
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),

  nu_e : doExpand1(nu,bC),
  printf(fh, "~%"),
  /* Calculate the alpha-velocity due to drag. */
  alphaDr : nu_e*((1.0/2.0)*dvpar*vx+wvpar),
    
  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  /* Surface basis. Equivalent to basis of one lower
     dimensionality without surface variable. */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),

  /* Project alphaDrag evaluated at interior surface onto surf basis. */
  alphaDrSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=-1,alphaDr))),
  alphaDrSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=1,alphaDr))),
  alst_l          : doMakeExprLst(alphaDrSurf_l_c, alphaDrSurf_l),
  alst_r          : doMakeExprLst(alphaDrSurf_r_c, alphaDrSurf_r),
  alphaDrSurf_l_e : doExpand(alst_l, bSurf),
  alphaDrSurf_r_e : doExpand(alst_r, bSurf),
  printf(fh, "  double alphaDrSurf_l[~a] = {0.0}; ~%", length(bSurf)),
  writeCExprs1(alphaDrSurf_l, alphaDrSurf_l_c),
  printf(fh, "~%"),
  printf(fh, "  double alphaDrSurf_r[~a] = {0.0}; ~%", length(bSurf)),
  writeCExprs1(alphaDrSurf_r, alphaDrSurf_r_c),
  printf(fh, "~%"),

  printf(fh, "  double Ghat_r[~a]; ~%", length(bSurf)),
  printf(fh, "  double Ghat_l[~a]; ~%", length(bSurf)),
  
  printf(fh, "  if (~a>0) { ~%~%",wvpar),

  /* Because v > 0, need left edge value */
  /* Evaluate surface projection of Ghat_r = nu*v f_r (v evaluated at +1). */
  Ghat_r_c : calcInnerProdList(surfVars, alphaDrSurf_r_e, bSurf, subst(vx=-1, fr_e)),
  writeCExprsCollect1lhsc(Ghat_r, radcan(Ghat_r_c)),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero_r : doMakeExprLst(Ghat_r_c, Ghat_r),
  Ghat_r_e     : doExpand(GhatNoZero_r, bSurf),

  /* Evaluate surface projection of Ghat_l = nu*v f_c (v evaluated at -1). */
  Ghat_l_c : calcInnerProdList(surfVars, alphaDrSurf_l_e, bSurf, subst(vx=-1, fc_e)),
  writeCExprsCollect1lhsc(Ghat_l, radcan(Ghat_l_c)),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of Ghat which are empty. */
  GhatNoZero_l : doMakeExprLst(Ghat_l_c, Ghat_l),
  Ghat_l_e     : doExpand(GhatNoZero_l, bSurf),

  printf(fh, "  } else { ~%~%"),
  
  /* Because v < 0, need right edge value */
  /* Evaluate surface projection of Ghat_r = v f_r. */
  Ghat_r_c : calcInnerProdList(surfVars, alphaDrSurf_r_e, bSurf, subst(vx=1, fc_e)),

  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then (
    writeCExprsNoExpand1(Ghat_r, Ghat_r_c)
  ) else (
    writeCExprs1(Ghat_r, Ghat_r_c)
  ),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of Ghat which are empty. */
  GhatNoZero_r : doMakeExprLst(Ghat_r_c, Ghat_r),
  Ghat_r_e     : doExpand(GhatNoZero_r, bSurf),

  /* Evaluate surface projection of Ghat_l = v f_c. */
  Ghat_l_c : calcInnerProdList(surfVars, alphaDrSurf_l_e, bSurf, subst(vx=1, fl_e)),

  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then (
    writeCExprsNoExpand1(Ghat_l, Ghat_l_c)
  ) else (
    writeCExprs1(Ghat_l, Ghat_l_c)
  ),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of Ghat which are empty. */
  GhatNoZero_l : doMakeExprLst(Ghat_l_c, Ghat_l),
  Ghat_l_e     : doExpand(GhatNoZero_l, bSurf),
  
  printf(fh, "  } ~%"),
  /* Compute surface contribution integral(phi^- Ghat) on the right. */
  incr_l : calcInnerProdList(surfVars, -1, subst(vx=-1.0, bP), Ghat_l_e),
  incr_r : calcInnerProdList(surfVars, 1, subst(vx=1.0, bP), Ghat_r_e),
  writeCIncrExprsCollect1lhsc(out, dv1par*incr_l + dv1par*incr_r),    
  printf(fh, "} ~%")
);

