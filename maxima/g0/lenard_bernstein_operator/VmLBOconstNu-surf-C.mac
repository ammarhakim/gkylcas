load("modal-basis")$

load("out-scripts");

load(stringproc)$

load("nodalOperations/nodalFunctions")$

load("recovery")$

fpprec : 24$

/* This script generates the kernels for the surface term
   contribution from Lenard Bernstein operator using
   two integrations by parts for the diffusive term and
   a constant collisionality nu. */

varsV : [vx, vy, vz]$

cvars : [x, y, z]$

vvars : [vx, vy, vz]$

nuUSumx : [sumNuUx, sumNuUy, sumNuUz]$

vidx(cdim,vdim)  := makelist(i,i,cdim+1,cdim+vdim)$

vidx1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

load ("scifac")$

writeCExprsCollect1c(lhs, rhs, clst) := block([expr],
  expr : float(expand(rhs)), 
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e : apply(collectterms, param),
      printf(fh, "  ~a = ~a; ~%", lhs[i-1], gcfac(e))
    )
  )
)$

writeCExprsCollect1s(lhs, rhs, clst) := block([expr],
  expr : float(expand(rhs)), 
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e : apply(collectterms, param),
      printf(fh, "    ~a = ~a; ~%", lhs[i-1], gcfac(e))
    )
  )
)$

writeCIncrExprs1s(lhs, rhs) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then printf(fh, "    ~a += ~a; ~%", lhs[i-1], expr[i])
  )
)$

calcConstNuUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, numFluxOp, isNonuniform) := block(
  [modNm,vid,vid1,vv,surfVars,bP,bC,NP,NC,bPp,hOrder,h_e,hsol],
  
  if (basisFun="ser") then basisFun:"Ser",
  if (basisFun="tensor") then basisFun:"Tensor",
  kill(varsC, varsP, basisC, basisP),
  /* Load basis of dimensionality requested. */
  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),

  pDim : cdim+vdim,

  /* Variables. */
  vid  : vidx(cdim,vdim),
  vid1 : vidx1(cdim,vdim),
  vv   : varsV[dir],
  surfVars : delete(vv,varsP),

  /* Polynomial basis and its derivatives. */
  bP  : basisP[polyOrder],  NP : length(bP),
  bC  : basisC[polyOrder],  NC : length(bC),
  bPp : diff(bP,vv),

  /* Construct the recovery polynomial */
  hOrder : 2*polyOrder+1,
  if isNonuniform then (
    recDxv_l : makelist(2,i,1,pDim),  recDxv_l[cdim+dir] : dxvl[vid1[dir]],
    recDxvC : makelist(2,i,1,pDim),  recDxvC[cdim+dir] : dxvc[vid1[dir]],
    recDxv_r : makelist(2,i,1,pDim),  recDxv_r[cdim+dir] : dxvr[vid1[dir]],
    hl_e : fullratsimp(calcRecov2CellGenNonuniform(basisFun,vv,varsP,polyOrder,recDxv_l,recDxvC,
                                                  dg(makelist(fl[i-1],i,1,NP)), dg(makelist(fc[i-1],i,1,NP)))),
    hr_e : fullratsimp(calcRecov2CellGenNonuniform(basisFun,vv,varsP,polyOrder,recDxvC,recDxv_r,
                                                  dg(makelist(fc[i-1],i,1,NP)), dg(makelist(fr[i-1],i,1,NP)))),
    rdv2DiffFac : 1
  ) else (
    hl_e : calcRecov2CellGen(basisFun,vv,varsP,polyOrder,dg(makelist(fl[i-1],i,1,NP)), dg(makelist(fc[i-1],i,1,NP))),
    hr_e : calcRecov2CellGen(basisFun,vv,varsP,polyOrder,dg(makelist(fc[i-1],i,1,NP)), dg(makelist(fr[i-1],i,1,NP))),
    rdv2DiffFac : rdv2
  ),
  hsol_l : cons(subst(vv=0,hl_e),makelist(subst(vv=0,diff(hl_e,vv,ord)/(ord!)),ord,1,hOrder)),
  hsol_r : cons(subst(vv=0,hr_e),makelist(subst(vv=0,diff(hr_e,vv,ord)/(ord!)),ord,1,hOrder)),
  if (basisFun="Ser") then basisFun:"ser",
  if (basisFun="Tensor") then basisFun:"tensor",

  /*............. RECOVERY DONE ..............................*/

  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *nuSum, const double *nuUSum, const double *nuVtSqSum, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:         cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:       cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nuSum:         collisionalities added (self and cross species collisionalities). ~%"),
  printf(fh, "  // nuUSum[~a]:    sum of bulk velocities times their respective collisionalities. ~%", vdim*NC),
  printf(fh, "  // nuVtSqSum[~a]: sum of thermal speeds squared time their respective collisionalities. ~%", NC),
  printf(fh, "  // fl/fc/fr:      distribution function in cells ~%"),
  printf(fh, "  // out:           incremented distribution function in cell ~%"),
  printf(fh, "  double rdv2 = 2.0/dxv[~a]; ~%", vid1[dir]),
  printf(fh, "  double rdvSq4 = 4.0/(dxv[~a]*dxv[~a]); ~%", vid1[dir], vid1[dir]),
  printf(fh, "~%"),
    
  /* First compute the contribution coming from the second
     differentiation by parts to left and right cells. */
  nuVtSqSum_e : doExpand1(nuVtSqSum,bC),
  nuSum_e : doExpand1(nuSum,bC),

  /* Now do the contribution from the generalized flux Ghat. */
  basisFlip : subst(vv=-1*vv, bP),
  signs : fullratsimp(basisFlip/bP),

  /* Expand the mean flow speed in the configuration basis. */
  nuUSum_e : doExpand1(nuUSumx[dir],bC),

  /* Create pointer to component of u relevant to this surface. */
  printf(fh, "  const double *sumNuU~a = &nuUSum[~a]; ~%", cvars[dir], NC*(dir-1)),
  printf(fh, "~%"),

  /* Calculate the alpha-velocity due to drag. */
  alphaDr : nuSum_e*((1/2)*dxv[vid1[dir]]*vv+w[vid1[dir]])-nuUSum_e,
    
  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  /* Surface basis. Equivalent to basis of one lower
     dimensionality without surface variable. */
  bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsP,1,bP,subst([vv^2=var2,var2=1/3,vv=0],bP)))*bP),

  /* Project alphaDrag evaluated at interior surface onto surf basis. */
  alphaDrSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=-1,alphaDr))),
  alphaDrSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=1,alphaDr))),
  alst_l          : doMakeExprLst(alphaDrSurf_l_c, alphaDrSurf_l),
  alst_r          : doMakeExprLst(alphaDrSurf_r_c, alphaDrSurf_r),
  alphaDrSurf_l_e : doExpand(alst_l, bSurf),
  alphaDrSurf_r_e : doExpand(alst_r, bSurf),

  printf(fh, "  double alphaDrSurf_l[~a] = {0.0}; ~%", length(bSurf)),
  writeCExprs1(alphaDrSurf_l, alphaDrSurf_l_c),
  printf(fh, "~%"),
  printf(fh, "  double alphaDrSurf_r[~a] = {0.0}; ~%", length(bSurf)),
  writeCExprs1(alphaDrSurf_r, alphaDrSurf_r_c),
  printf(fh, "~%"),

  /* Upwind the drag term using quadrature point evaluation. */
  /* Scale nodes of the nodal basis by corresponding factors to obtain the Gauss-Legendre quadrature points */
  /* We always use tensor basis for the quadrature and resulting nodal basis, regardless of base basis type */
  surfNodes : getNodes("Tensor", pDim-1, polyOrder),
  if polyOrder=1 then (surfNodes:surfNodes*(1/sqrt(3))) elseif polyOrder=2 then (surfNodes:surfNodes*sqrt(3/5)),
  numNodes : length(surfNodes),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     We still require a alpha_l (w - dv/2) and alpha_r (w + dv/2) for the two sides of the cell */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaDrSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaDrSurf_r_e,surfNodes,surfVars))),

  printf(fh, "  double fUpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind_l[~a] = {0.0};;~%", length(bSurf)),
  printf(fh, "  double fUpwind_r[~a] = {0.0};~%", length(bSurf)),
  printf(fh, "  double Ghat_l[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double Ghat_r[~a] = {0.0}; ~%", length(bSurf)),
  /* Write the diffusive part of Ghat into its own variable. */
  printf(fh, "  double Gdiff_l[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double Gdiff_r[~a] = {0.0}; ~%", length(bSurf)),
  /* Declare variable with contribution from second integration by parts. */
  printf(fh, "  double Gdiff2_l[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double Gdiff2_r[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "~%"),
  for i : 1 thru length(alphaOrd_l_n) do (
    /* This subst eliminates the need for another variable, and removes
        the common factor (for p=1) which is not needed to determine
        sign (not working for p>1). */
    if polyOrder=1 then (
      rcoFac : 1./(content(alphaOrd_l_n[1],alphaDrSurf_l[0])[1]),
      printf(fh, "  if (~a < 0) { ~%", fullratsimp(alphaOrd_l_n[i]*rcoFac)),
      printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fl); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fc); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    ) else (
      printf(fh, "  if (~a < 0) { ~%", alphaOrd_l_n[i]),
      printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fl); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad_l[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fc); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    )
  ),
  for i : 1 thru length(alphaOrd_r_n) do (
    /* This subst eliminates the need for another variable, and removes
        the common factor (for p=1) which is not needed to determine
        sign (not working for p>1). */
    if polyOrder=1 then (
      rcoFac : 1./(content(alphaOrd_r_n[1],alphaDrSurf_r[0])[1]),
      printf(fh, "  if (~a < 0) { ~%", fullratsimp(alphaOrd_r_n[i]*rcoFac)),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fc); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fr); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    ) else (
      printf(fh, "  if (~a < 0) { ~%", alphaOrd_r_n[i]),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fc); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad_r[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fr); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    )
  ),
  if (basisFun = "Tensor") or (basisFun = "tensor") or (polyOrder = 1) then (
    if (basisFun="ser") then basisFun:"Ser",
    if (basisFun="tensor") then basisFun:"Tensor",
    /* Get modal surface expansion from nodal quadrature points. */
    nodToMod : calcNodToModWithNodes(basisFun, pDim-1, polyOrder, surfNodes),
    fUp_l_c : gcfac(fullratsimp(nodToMod . makelist(fUpwindQuad_l[i-1],i,1,numNodes))),
    fUp_l_c : makelist(fUp_l_c[i][1],i,1,numNodes),
    /* Write coefficients of modal surface expansion fupwind. */
    /* Clever factorization is possible for polyOrder = 1, but for higher
       polynomial orders, factorization is *too* clever and can lead to 
       deeply nested parentheses, not ideal for compiler optimizations */
    if (polyOrder = 1) then (
      writeCExprsNoExpand1(fUpwind_l, fUp_l_c)
    ) else (
      writeCExprs1(fUpwind_l, fUp_l_c)
    ),
    printf(fh, "~%"),
    flush_output(fh),
    fHatSurf_l_e : doExpand1(fUpwind_l,bSurf),

    fUp_r_c : gcfac(fullratsimp(nodToMod . makelist(fUpwindQuad_r[i-1],i,1,numNodes))),
    fUp_r_c : makelist(fUp_r_c[i][1],i,1,numNodes),
    /* Write coefficients of modal surface expansion fupwind. */
    /* Clever factorization is possible for polyOrder = 1, but for higher
       polynomial orders, factorization is *too* clever and can lead to 
       deeply nested parentheses, not ideal for compiler optimizations */
    if (polyOrder = 1) then (
      writeCExprsNoExpand1(fUpwind_r, fUp_r_c)
    ) else (
      writeCExprs1(fUpwind_r, fUp_r_c)
    ),
    printf(fh, "~%"),
    flush_output(fh),
    fHatSurf_r_e : doExpand1(fUpwind_r,bSurf)
  ) else (
    /* Make nodal expansions in nodal basis */
    /* Only required if basis type is not tensor */
    /* If basis type is tensor (or polyOrder = 1 Serendipity), then well-defined intermediate
       transformation back from nodal basis to modal basis, otherwise need nodal basis for 
       final computation of Ghat */
    basisNodal : getVarsNodalBasisWithNodes("Tensor", pDim-1, polyOrder, surfVars, surfNodes),
    fHatNodal_l_e : sum(fUpwindQuad_l[i-1]*basisNodal[i], i, 1, length(basisNodal)),
    fHatNodal_r_e : sum(fUpwindQuad_r[i-1]*basisNodal[i], i, 1, length(basisNodal)),
    fHatModProj_l_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_l_e)),
    fHatModProj_r_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_r_e)),
    
    /* Write out projection of tensor nodal basis onto modal basis (usually Serendipity here) */
    writeCExprs1(fUpwind_l, fHatModProj_l_e),
    printf(fh, "~%"),
    writeCExprs1(fUpwind_r, fHatModProj_r_e),
    printf(fh, "~%"),

    /* Zero out components of fUpwind_l/r which are empty and make new lists with right variable name. */
    fHatModProj_l_NoZero : doMakeExprLst(fHatModProj_l_e, fUpwind_l),
    fHatSurf_l_e : doExpandLst(fHatModProj_l_NoZero, bSurf),
    fHatModProj_r_NoZero : doMakeExprLst(fHatModProj_r_e, fUpwind_r),
    fHatSurf_r_e : doExpandLst(fHatModProj_r_NoZero, bSurf)
  ),  

  GhatDrag_l_c : calcInnerProdList(surfVars,alphaDrSurf_l_e,bSurf,fHatSurf_l_e),
  GhatDrag_r_c : calcInnerProdList(surfVars,alphaDrSurf_r_e,bSurf,fHatSurf_r_e),

  /* Separate out diffusion part of Ghat to simplify Ghat assignment.
     Leave the rdv factor out for later multiplication. */
  Gdiff_l_c : calcInnerProdList(surfVars,1,bSurf,nuVtSqSum_e*hsol_l[2]),
  Gdiff_r_c : calcInnerProdList(surfVars,1,bSurf,nuVtSqSum_e*hsol_r[2]),
  alst_l    : doMakeExprLst(Gdiff_l_c, Gdiff_l),
  alst_r    : doMakeExprLst(Gdiff_r_c, Gdiff_r),
  Gdiff_l_e : doExpand(alst_l, bSurf),
  Gdiff_r_e : doExpand(alst_r, bSurf),
  Gdiff2_l_c : calcInnerProdList(surfVars,1,bSurf,nuVtSqSum_e*hsol_l[1]),
  Gdiff2_r_c : calcInnerProdList(surfVars,1,bSurf,nuVtSqSum_e*hsol_r[1]),
  alst_l2    : doMakeExprLst(Gdiff2_l_c, Gdiff2_l),
  alst_r2    : doMakeExprLst(Gdiff2_r_c, Gdiff2_r),
  Gdiff2_l_e : doExpand(alst_l2, bSurf),
  Gdiff2_r_e : doExpand(alst_r2, bSurf),

  /* Calculate Ghat projected on the phase basis. */
  Ghat_l_c  : fullratsimp(GhatDrag_l_c+rdv2DiffFac*calcInnerProdList(surfVars,1,bSurf,Gdiff_l_e)),
  Ghat_r_c  : fullratsimp(GhatDrag_r_c+rdv2DiffFac*calcInnerProdList(surfVars,1,bSurf,Gdiff_r_e)),

  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  glst1_l      : doMakeExprLst(Ghat_l_c, Ghat_l),
  Ghat_l_e     : doExpandLst(glst1_l, bSurf),
  Ghat_l_final : subst(vv=1, Ghat_l_e),
  glst1_r      : doMakeExprLst(Ghat_r_c, Ghat_r),
  Ghat_r_e     : doExpandLst(glst1_r, bSurf),
  Ghat_r_final : subst(vv=1, Ghat_r_e),

  /* Increments to the right cell (some dimensional factors missing).
  Here incr_r1 and incr_r2 have separate left/right symmetry. */
  incr_r1 :  calcInnerProdList(surfVars, -1, subst(vv=1, bP), Ghat_r_final),
  incr_r2 : -calcInnerProdList(surfVars, -1, subst(vv=1, bPp), Gdiff2_r_e),

  /* Increments to the left cell (some dimensional factors missing). */
  incr_l1 :  calcInnerProdList(surfVars, 1, subst(vv=-1, bP), Ghat_l_final),
  incr_l2 : -calcInnerProdList(surfVars, 1, subst(vv=-1, bPp), Gdiff2_l_e),

  tempVars : writeCExprs1(Gdiff2_l, radcan(Gdiff2_l_c)),
  printf(fh, "~%"),
  tempVars : writeCExprs1(Gdiff2_r, radcan(Gdiff2_r_c)),
  printf(fh, "~%"),

  tempVars : writeCExprs1(Gdiff_l, Gdiff_l_c),
  printf(fh, "~%"),
  tempVars : writeCExprs1(Gdiff_r, Gdiff_r_c),
  printf(fh, "~%"),

  /* Populate Ghat including the diffusion term. */
  clst_l: append([rdv2DiffFac], makelist(alphaDrag_l[i],i,0,NC-1)),
  tempVars : writeCExprsCollect1(Ghat_l, Ghat_l_c, clst_l),
  printf(fh, "~%"),
  flush_output(fh),
    
  clst_r : append([rdv2DiffFac], makelist(alphaDrag_r[i],i,0,NC-1)),
  tempVars : writeCExprsCollect1(Ghat_r, Ghat_r_c, clst_r),
  printf(fh, "~%"),
  flush_output(fh),
  
  /* Write out contribution right cell. */
  writeCIncrExprs1(out, rdv2*incr_r1+rdvSq4*incr_r2 + rdv2*incr_l1+rdvSq4*incr_l2), 

  printf(fh, "} ~%")
);

calcConstNuBoundaryUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, numFluxOp, isNonuniform) := block(
  [modNm,vid,vid1,vv,surfVars,bP,bC,NP,NC,bPp,hOrder,h_e,hsol],

  if (basisFun="ser") then basisFun:"Ser",
  if (basisFun="tensor") then basisFun:"Tensor",
  kill(varsC, varsP, basisC, basisP),
  /* Load basis of dimensionality requested. */
  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),

  pDim : cdim+vdim,

  /* Variables. */
  vid  : vidx(cdim,vdim),
  vid1 : vidx1(cdim,vdim),
  vv   : varsV[dir],
  surfVars : delete(vv,varsP),

  /* Polynomial basis and its derivatives. */
  bP  : basisP[polyOrder],  NP : length(bP),
  bC  : basisC[polyOrder],  NC : length(bC),
  bPp : diff(bP,vv),

  /* Construct the recovery polynomial */
  /* NOTE: for the boundary surface term, the left recovery is for the FAR RIGHT edge, because 
     it involves the skin cell evaluated at -1. Likewise, right recovery is for the FAR LEFT 
     edge because it involves the skin cell evaluated at +1 */
  hOrder : 2*polyOrder+1,
  if isNonuniform then (
    recDxv_l : makelist(2,i,1,pDim),  recDxv_l[cdim+dir] : dxvl[vid1[dir]],
    recDxvC : makelist(2,i,1,pDim),  recDxvC[cdim+dir] : dxvc[vid1[dir]],
    recDxv_r : makelist(2,i,1,pDim),  recDxv_r[cdim+dir] : dxvr[vid1[dir]],
    hl_e : fullratsimp(calcRecov2CellGenNonuniform(basisFun,vv,varsP,polyOrder,recDxv_l,recDxvC,
                                                  dg(makelist(fEdge[i-1],i,1,NP)), dg(makelist(fSkin[i-1],i,1,NP)))),
    hr_e : fullratsimp(calcRecov2CellGenNonuniform(basisFun,vv,varsP,polyOrder,recDxvC,recDxv_r,
                                                  dg(makelist(fSkin[i-1],i,1,NP)), dg(makelist(fEdge[i-1],i,1,NP)))),
    rdv2DiffFac : 1
  ) else (
    hl_e : calcRecov2CellGen(basisFun,vv,varsP,polyOrder,dg(makelist(fEdge[i-1],i,1,NP)), dg(makelist(fSkin[i-1],i,1,NP))),
    hr_e : calcRecov2CellGen(basisFun,vv,varsP,polyOrder,dg(makelist(fSkin[i-1],i,1,NP)), dg(makelist(fEdge[i-1],i,1,NP))),
    /*REVISION: Maybe ask about this. Why rdv2_l (because if not nonuniform both should be equal so it shouldn't matter)? In any case, should probably use center cell size*/
    /*rdv2DiffFac : rdv2_l*/
    rdv2DiffFac : rdv2
  ),
  hsol_l : cons(subst(vv=0,hl_e),makelist(subst(vv=0,diff(hl_e,vv,ord)/(ord!)),ord,1,hOrder)),
  hsol_r : cons(subst(vv=0,hr_e),makelist(subst(vv=0,diff(hr_e,vv,ord)/(ord!)),ord,1,hOrder)),
  if (basisFun="Ser") then basisFun:"ser",
  if (basisFun="Tensor") then basisFun:"tensor",

  /*............. RECOVERY DONE ..............................*/

  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *nuSum, const double *nuUSum, const double *nuVtSqSum, const int edge, const double *fSkin, const double *fEdge, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:         Cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:       Cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nuSum:         collisionalities added (self and cross species collisionalities). ~%"),
  printf(fh, "  // nuUSum[~a]:    sum of bulk velocities times their respective collisionalities. ~%", vdim*NC),
  printf(fh, "  // nuVtSqSum[~a]: sum of thermal speeds squared time their respective collisionalities. ~%", NC),
  printf(fh, "  // fSkin/Edge:    Distribution function in cells ~%"),
  printf(fh, "  // out:           Incremented distribution function in cell ~%"),
  printf(fh, "  double rdv2 = 2.0/dxv[~a]; ~%", vid1[dir]),
  printf(fh, "  double rdvSq4 = 4.0/(dxv[~a]*dxv[~a]); ~%", vid1[dir], vid1[dir]),
  printf(fh, "~%"),

  /* First compute the contribution coming from the second
     differentiation by parts to left and right cells. */
  nuVtSqSum_e : doExpand1(nuVtSqSum,bC),
  nuSum_e : doExpand1(nuSum,bC),

  /* Now do the contribution from the generalized flux Ghat. */
  basisFlip : subst(vv=-1*vv, bP),
  signs     : fullratsimp(basisFlip/bP),

  /* Expand the mean flow speed in the configuration basis. */
  nuUSum_e : doExpand1(nuUSumx[dir],bC),

  /* Create pointer to component of u relevant to this surface. */
  printf(fh, "  const double *sumNuU~a = &nuUSum[~a]; ~%", cvars[dir], NC*(dir-1)),
  printf(fh, "~%"),

  /* Create expansions of f_skin, f_edge on volume basis. */
  fEdge_e : doExpand1(fEdge, bP),
  fSkin_e : doExpand1(fSkin, bP),
  /* Surface basis. Equivalent to basis of one lower
     dimensionality without surface variable. */
  bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsP,1,bP,subst([vv^2=var2,var2=1/3,vv=0],bP)))*bP),

  /* Calculate the alpha-velocity due to drag. */
  alphaDr : nuSum_e*((1/2)*dxv[vid1[dir]]*vv+w[vid1[dir]])-nuUSum_e,
  /* Project alphaDrag evaluated at interior surface onto surf basis. */
  alphaDrSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=-1,alphaDr))),
  alphaDrSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=1,alphaDr))),
  alst_l          : doMakeExprLst(alphaDrSurf_l_c, alphaDrSurf),
  alst_r          : doMakeExprLst(alphaDrSurf_r_c, alphaDrSurf),
  alphaDrSurf_l_e : doExpand(alst_l, bSurf),
  alphaDrSurf_r_e : doExpand(alst_r, bSurf),

  /* Upwind the drag term using quadrature point evaluation. */
  /* Scale nodes of the nodal basis by corresponding factors to obtain the Gauss-Legendre quadrature points */
  /* We always use tensor basis for the quadrature and resulting nodal basis, regardless of base basis type */
  surfNodes : getNodes("Tensor", pDim-1, polyOrder),
  if polyOrder=1 then (surfNodes:surfNodes*(1/sqrt(3))) elseif polyOrder=2 then (surfNodes:surfNodes*sqrt(3/5)),
  numNodes : length(surfNodes),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     We still require a alpha_l (w - dv/2) and alpha_r (w + dv/2) for the two sides of the cell */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaDrSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaDrSurf_r_e,surfNodes,surfVars))),

  /* Separate out diffusion part of Ghat to simplify Ghat assignment.
     Leave the rdv factor out for later multiplication. 
     Note that because we have already computed the recovery, we
     will just compute these inner products now in Maxima *before* 
     we select whether we are at the far left or far right edge. */
  Gdiff_l_c : calcInnerProdList(surfVars,1,bSurf,nuVtSqSum_e*hsol_l[2]),
  Gdiff_r_c : calcInnerProdList(surfVars,1,bSurf,nuVtSqSum_e*hsol_r[2]),
  alst_l    : doMakeExprLst(Gdiff_l_c, Gdiff),
  alst_r    : doMakeExprLst(Gdiff_r_c, Gdiff),
  Gdiff_l_e : doExpand(alst_l, bSurf),
  Gdiff_r_e : doExpand(alst_r, bSurf),
  Gdiff2_l_c : calcInnerProdList(surfVars,1,bSurf,nuVtSqSum_e*hsol_l[1]),
  Gdiff2_r_c : calcInnerProdList(surfVars,1,bSurf,nuVtSqSum_e*hsol_r[1]),
  alst_l2    : doMakeExprLst(Gdiff2_l_c, Gdiff2),
  alst_r2    : doMakeExprLst(Gdiff2_r_c, Gdiff2),
  Gdiff2_l_e : doExpand(alst_l2, bSurf),
  Gdiff2_r_e : doExpand(alst_r2, bSurf),

  printf(fh, "  double alphaDrSurf[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double fUpwindQuad[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind[~a] = {0.0};;~%", length(bSurf)),
  printf(fh, "  double Ghat[~a] = {0.0}; ~%", length(bSurf)),
  /* Write the diffusive part of Ghat into its own variable. */
  printf(fh, "  double Gdiff[~a] = {0.0}; ~%", length(bSurf)),
  /* Declare variable with contribution from second integration by parts.
     This second integration by parts is only for the interior surface.
     The other contribution comes from the evaluation of the skin cell at 
     the correct interface (-1 for far left edge, +1 for far right edge). */
  printf(fh, "  double Gdiff2[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "~%"),

  /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evauluated at +1 */
  /* In addition we need the drag term evaluated at +1 (so alphaDr evaluated on the right) */
  printf(fh, "  if (edge == -1) { ~%~%"),

  /* Write out drag term for far left edge boundary.
     Need alpha evaluated at +1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far left boundary, no drag term on -1 surface */
  writeCExprsNoExpand1(alphaDrSurf, alphaDrSurf_r_c),
  printf(fh, "~%"),

  /* Write out fUpwindQuad for the far left edge */
  /* Within the skin cell, we need alpha_r (alpha evaluated at +1)
     just like how the skin cell is evaluated at +1 */
  for i : 1 thru length(alphaOrd_r_n) do (
    /* This subst eliminates the need for another variable, and removes
        the common factor (for p=1) which is not needed to determine
        sign (not working for p>1). */
    if polyOrder=1 then (
      rcoFac : 1./(content(alphaOrd_r_n[1],alphaDrSurf[0])[1]),
      printf(fh, "  if (~a < 0) { ~%", fullratsimp(alphaOrd_r_n[i]*rcoFac)),
      printf(fh, "    fUpwindQuad[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fSkin); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%~%"),
      printf(fh, "    fUpwindQuad[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fEdge); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    ) else (
      printf(fh, "  if (~a < 0) { ~%", alphaOrd_r_n[i]),
      printf(fh, "    fUpwindQuad[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fSkin); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fEdge); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    )
  ),
  printf(fh, "~%"),
  if (basisFun = "Tensor") or (basisFun = "tensor") or (polyOrder = 1) then (
    if (basisFun="ser") then basisFun:"Ser",
    if (basisFun="tensor") then basisFun:"Tensor",
    /* Get modal surface expansion from nodal quadrature points. */
    nodToMod : calcNodToModWithNodes(basisFun, pDim-1, polyOrder, surfNodes),
    fUp_c : gcfac(fullratsimp(nodToMod . makelist(fUpwindQuad[i-1],i,1,numNodes))),
    fUp_c : makelist(fUp_c[i][1],i,1,numNodes),
    /* Write coefficients of modal surface expansion fupwind. */
    /* Clever factorization is possible for polyOrder = 1, but for higher
       polynomial orders, factorization is *too* clever and can lead to 
       deeply nested parentheses, not ideal for compiler optimizations */
    if (polyOrder = 1) then (
      writeCExprsNoExpand1(fUpwind, fUp_c)
    ) else (
      writeCExprs1(fUpwind, fUp_c)
    ),
    printf(fh, "~%"),
    flush_output(fh),
    fHatSurf_e : doExpand1(fUpwind,bSurf)
  ) else (
    /* Make nodal expansions in nodal basis */
    /* Only required if basis type is not tensor */
    /* If basis type is tensor (or polyOrder = 1 Serendipity), then well-defined intermediate
       transformation back from nodal basis to modal basis, otherwise need nodal basis for 
       final computation of Ghat */
    basisNodal : getVarsNodalBasisWithNodes("Tensor", pDim-1, polyOrder, surfVars, surfNodes),
    fHatNodal_e : sum(fUpwindQuad[i-1]*basisNodal[i], i, 1, length(basisNodal)),
    fHatModProj_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_e)),
    
    /* Write out projection of tensor nodal basis onto modal basis (usually Serendipity here) */
    writeCExprs1(fUpwind, fHatModProj_e),
    printf(fh, "~%"),

    /* Zero out components of fUpwind which are empty and make new lists with right variable name. */
    fHatModProj_NoZero : doMakeExprLst(fHatModProj_e, fUpwind),
    fHatSurf_e : doExpandLst(fHatModProj_NoZero, bSurf)
  ),
  GhatDrag_c : calcInnerProdList(surfVars,alphaDrSurf_r_e,bSurf,fHatSurf_e),
    
  /* Calculate Ghat projected on the phase basis. */
  /* Need Gdiff_r because skin cell is evaluated at +1 */
  Ghat_c  : fullratsimp(GhatDrag_c+rdv2DiffFac*calcInnerProdList(surfVars,-1,bSurf,Gdiff_r_e)),

  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  glst1      : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e     : doExpandLst(glst1, bSurf),
  Ghat_final : subst(vv=1, Ghat_e),

  /* Increments to the right cell (some dimensional factors missing).
  ** Here incr_r1 and incr_r2 have separate left/right symmetry. */
  incr_r1 :  calcInnerProdList(surfVars, -1, subst(vv=1, bP), Ghat_final),
  incr_r2 : -calcInnerProdList(surfVars, -1, subst(vv=1, bPp), Gdiff2_r_e),
  /* Additional term coming from second integration by parts at the zero-flux boundary */
  incr_l3 : -calcInnerProdList(surfVars, 1, subst(vv=-1, bPp), subst(vv=-1,nuVtSqSum_e*fSkin_e)),

  tempVars : writeCExprs1(Gdiff2, Gdiff2_r_c),
  printf(fh, "~%"),

  tempVars : writeCExprs1(Gdiff, Gdiff_r_c),
  printf(fh, "~%"),

  /* Populate Ghat including the diffusion term. */
  clst: append([rdv2DiffFac], makelist(alphaDrag_r[i],i,0,NC-1)),
  tempVars : writeCExprsCollect1(Ghat, Ghat_c, clst),
  printf(fh, "~%"),
  flush_output(fh),
  
  /* Write out contribution right cell. */
  writeCIncrExprs1(out, rdv2*incr_r1+rdvSq4*incr_r2+rdvSq4*incr_l3),

  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "~%  } else { ~%~%"),

  /* Write out drag term for far right edge boundary.
     Need alpha evaluated at -1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far right boundary, no drag term on +1 surface */
  writeCExprsNoExpand1(alphaDrSurf, alphaDrSurf_r_c),
  printf(fh, "~%"),
  if (basisFun="Ser") then basisFun:"ser",
  if (basisFun="Tensor") then basisFun:"tensor",

  /* Write out fUpwindQuad for the far left edge */
  /* Within the skin cell, we need alpha_l (alpha evaluated at -1)
     just like how the skin cell is evaluated at -1 */
  for i : 1 thru length(alphaOrd_l_n) do (
    /* This subst eliminates the need for another variable, and removes
        the common factor (for p=1) which is not needed to determine
        sign (not working for p>1). */
    if polyOrder=1 then (
      rcoFac : 1./(content(alphaOrd_l_n[1],alphaDrSurf[0])[1]),
      printf(fh, "  if (~a < 0) { ~%", fullratsimp(alphaOrd_l_n[i]*rcoFac)),
      printf(fh, "    fUpwindQuad[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fEdge); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fSkin); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    ) else (
      printf(fh, "  if (~a < 0) { ~%", alphaOrd_l_n[i]),
      printf(fh, "    fUpwindQuad[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(1, fEdge); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } else { ~%"),
      printf(fh, "    fUpwindQuad[~a] = ~a_~ax~av_p~a_surf~a_quad_~a(-1, fSkin); ~%", i-1, basisFun, cdim, vdim, polyOrder, vvars[dir], i-1),
      printf(fh, "  } ~%")
    )
  ),
  printf(fh, "~%"),
  if (basisFun = "Tensor") or (basisFun = "tensor") or (polyOrder = 1) then (
    if (basisFun="ser") then basisFun:"Ser",
    if (basisFun="tensor") then basisFun:"Tensor",
    /* Get modal surface expansion from nodal quadrature points. */
    nodToMod : calcNodToModWithNodes(basisFun, pDim-1, polyOrder, surfNodes),
    fUp_c : gcfac(fullratsimp(nodToMod . makelist(fUpwindQuad[i-1],i,1,numNodes))),
    fUp_c : makelist(fUp_c[i][1],i,1,numNodes),
    /* Write coefficients of modal surface expansion fupwind. */
    /* Clever factorization is possible for polyOrder = 1, but for higher
       polynomial orders, factorization is *too* clever and can lead to 
       deeply nested parentheses, not ideal for compiler optimizations */
    if (polyOrder = 1) then (
      writeCExprsNoExpand1(fUpwind, fUp_c)
    ) else (
      writeCExprs1(fUpwind, fUp_c)
    ),
    printf(fh, "~%"),
    flush_output(fh),
    fHatSurf_e : doExpand1(fUpwind,bSurf)
  ) else (
    /* Make nodal expansions in nodal basis */
    /* Only required if basis type is not tensor */
    /* If basis type is tensor (or polyOrder = 1 Serendipity), then well-defined intermediate
       transformation back from nodal basis to modal basis, otherwise need nodal basis for 
       final computation of Ghat */
    basisNodal : getVarsNodalBasisWithNodes("Tensor", pDim-1, polyOrder, surfVars, surfNodes),
    fHatNodal_e : sum(fUpwindQuad[i-1]*basisNodal[i], i, 1, length(basisNodal)),
    fHatModProj_e : fullratsimp(calcInnerProdList(surfVars, 1, bSurf, fHatNodal_e)),
    
    /* Write out projection of tensor nodal basis onto modal basis (usually Serendipity here) */
    writeCExprs1(fUpwind, fHatModProj_e),
    printf(fh, "~%"),

    /* Zero out components of fUpwind which are empty and make new lists with right variable name. */
    fHatModProj_NoZero : doMakeExprLst(fHatModProj_e, fUpwind),
    fHatSurf_e : doExpandLst(fHatModProj_NoZero, bSurf)
  ),
  GhatDrag_c : calcInnerProdList(surfVars,alphaDrSurf_l_e,bSurf,fHatSurf_e),
    
  /* Calculate Ghat projected on the phase basis. */
  /* Need Gdiff_l because skin cell is evaluated at -1 */
  Ghat_c  : fullratsimp(GhatDrag_c+rdv2DiffFac*calcInnerProdList(surfVars,1,bSurf,Gdiff_l_e)),

  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  glst1      : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e     : doExpandLst(glst1, bSurf),
  Ghat_final : subst(vv=1, Ghat_e),

  /* Increments to the left cell (some dimensional factors missing). */
  incr_l1 :  calcInnerProdList(surfVars, 1, subst(vv=-1, bP), Ghat_final),
  incr_l2 : -calcInnerProdList(surfVars, 1, subst(vv=-1, bPp), Gdiff2_l_e),
  /* Additional term coming from second integration by parts at the zero-flux boundary */
  incr_r3 : -calcInnerProdList(surfVars, -1, subst(vv=1, bPp), subst(vv=1,nuVtSqSum_e*fSkin_e)),

  tempVars : writeCExprs1(Gdiff2, Gdiff2_l_c),
  printf(fh, "~%"),

  tempVars : writeCExprs1(Gdiff, Gdiff_l_c),
  printf(fh, "~%"),

  /* Populate Ghat including the diffusion term. */
  clst: append([rdv2DiffFac], makelist(alphaDrag_r[i],i,0,NC-1)),
  tempVars : writeCExprsCollect1(Ghat, Ghat_c, clst),
  printf(fh, "~%"),
  flush_output(fh),
  
  /* Write out contribution right cell. */
  writeCIncrExprs1(out, rdv2*incr_l1+rdvSq4*incr_l2 + rdvSq4*incr_r3),
  printf(fh, "~%"),

  printf(fh, "  } ~%"),

  printf(fh, "} ~%")
);


