load("modal-basis")$
load("out-scripts");
load(stringproc)$
load("nodalOperations/nodalFunctions")$
load("recovery")$

fpprec : 24$

/* This script generates the kernels for the boundary surface term
   diffusion contribution from Lenard Bernstein operator. */

cvars : [x, y, z]$
vvars : [vx, vy, vz]$
vidx(cdim,vdim)  := makelist(i,i,cdim+1,cdim+vdim)$
vidx1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

load ("scifac")$

writeCIncrExprs1s(lhs, rhs) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then printf(fh, "  ~a += ~a; ~%", lhs[i-1], expr[i])
  )
)$

calcBoundaryDiffUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, numFluxOp, isNonuniform) := block(
  [modNm,vid,vid1,vv,surfVars,bP,bC,NP,NC,bPp,hOrder,h_e,hsol],
  if (basisFun="ser") then basisFun:"Ser",
  if (basisFun="tensor") then basisFun:"Tensor",
  kill(varsC, varsP, basisC, basisP),
  /* Load basis of dimensionality requested. */
  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),
  pDim : cdim+vdim,
  /* Variables. */
  vid  : vidx(cdim,vdim),
  vid1 : vidx1(cdim,vdim),
  vv   : vvars[dir],
  surfVars : delete(vv,varsP),
  /* Polynomial basis and its derivatives. */
  bP  : basisP[polyOrder],  NP : length(bP),
  bC  : basisC[polyOrder],  NC : length(bC),
  bPp : diff(bP,vv),
  fEdge_e : doExpand(makelist(fEdge[i-1],i,1,NP), bP),
  fSkin_e : doExpand(makelist(fSkin[i-1],i,1,NP), bP),
  /* Construct the recovery polynomial */
  hOrder : 2*polyOrder+1,
  hl_e : calcRecov2CellGen(basisFun,vv,varsP,polyOrder,dg(makelist(fEdge[i-1],i,1,NP)), dg(makelist(fSkin[i-1],i,1,NP))),
  hr_e : calcRecov2CellGen(basisFun,vv,varsP,polyOrder,dg(makelist(fSkin[i-1],i,1,NP)), dg(makelist(fEdge[i-1],i,1,NP))),
  hsol_l : cons(subst(vv=0,hl_e),makelist(subst(vv=0,diff(hl_e,vv,ord)/(ord!)),ord,1,hOrder)),
  hsol_r : cons(subst(vv=0,hr_e),makelist(subst(vv=0,diff(hr_e,vv,ord)/(ord!)),ord,1,hOrder)),
  if (basisFun="Ser") then basisFun:"ser",
  if (basisFun="Tensor") then basisFun:"tensor",
  /*............. RECOVERY DONE ..............................*/
        
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *nuSum, const double *nuUSum, const double *nuVtSqSum, const int edge, const double *fSkin, const double *fEdge, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:         Cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:       Cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nuSum:         collisionalities added (self and cross species collisionalities). ~%"),
  printf(fh, "  // nuUSum[~a]:    sum of bulk velocities times their respective collisionalities. ~%", vdim*NC),
  printf(fh, "  // nuVtSqSum[~a]: sum of thermal speeds squared time their respective collisionalities. ~%", NC),
  printf(fh, "  // fSkin/Edge:    Distribution function in cells ~%"),
  printf(fh, "  // out:           Incremented distribution function in cell ~%"),
  printf(fh, "  double rdvSq4 = 4.0/(dxv[~a]*dxv[~a]); ~%", vid1[dir], vid1[dir]),
  printf(fh, "~%"),
  /* First compute the contribution coming from the second
     differentiation by parts to left and right cells. */
  nuVtSqSum_e : doExpand1(nuVtSqSum,bC),
  bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsP,1,bP,subst([vv^2=var2,var2=1/3,vv=0],bP)))*bP),
     
  /* facDiff = < psi, nuVtSqSum >. */
  facDiff_c : calcInnerProdList(varsC, 1, bC, nuVtSqSum_e),
  zr : makelist(varsP[d]=0, d, 1, length(varsP)),

  if polyOrder>1 then (
    /* facDiff = nuVtSqSum. Only used in increment if polyOrder>1. */
    printf(fh, "  double facDiff[~a]; ~%", NC),
    /* Write out the components of facDiff's expansion. */
    printf(fh, "  // Expand nuVtSqSum in phase basis.~%"),
    expr : gcfac(float(expand(radcan(facDiff_c)))),
    for i : 1 thru NC do (
      if expr[i] # 0.0 then printf(fh, "  ~a = ~a; ~%", facDiff[i-1], expr[i])
    ),
    printf(fh, "~%"),

    /* Zero out components of alpha which are empty. */
    facDiff_NoZero : doMakeExprLst(facDiff_c, facDiff)
  ) else (
    /* Zero out components of alpha which are empty. */
    facDiff_NoZero : doMakeExprLst(facDiff_c, nuVtSqSum)
  ),

  facDiff_NoZero_e : doExpandLst(facDiff_NoZero, bC),
  /* Evaluate facDiff at zr to approximate max(abs(facDiff))/dv_i */
  polyFact : ((polyOrder+1)^2)/(2*polyOrder+1),

  /* Volume increment from configuration space. */
  vol_incr_e : rdvSq4*subst(a0=0,calcInnerProdList(varsP, 1, diff(bP,varsV[dir],2), facDiff_NoZero_e*fSkin_e)),
    
  Gdiff_l_c : calcInnerProdList(surfVars,1,bSurf,hsol_l[2]),
  Gdiff_r_c : calcInnerProdList(surfVars,1,bSurf,hsol_r[2]),
  alst_l    : doMakeExprLst(Gdiff_l_c, Gdiff),
  alst_r    : doMakeExprLst(Gdiff_r_c, Gdiff),
  Gdiff_l_e : doExpandLst(Gdiff_l_c, bSurf),
  Gdiff_r_e : doExpandLst(Gdiff_r_c, bSurf),

  Gdiff2_l_c : calcInnerProdList(surfVars,1,bSurf,hsol_l[1]),
  Gdiff2_r_c : calcInnerProdList(surfVars,1,bSurf,hsol_r[1]),
  alst_l2    : doMakeExprLst(Gdiff2_l_c, Gdiff2),
  alst_r2    : doMakeExprLst(Gdiff2_r_c, Gdiff2),
  Gdiff2_l_e : doExpandLst(Gdiff2_l_c, bSurf),
  Gdiff2_r_e : doExpandLst(Gdiff2_r_c, bSurf),

  temp_diff_le : fullratsimp(calcInnerProdList(surfVars, -1, subst(vv=-1, bP), Gdiff_l_e) - calcInnerProdList(surfVars, -1, subst(vv=-1, bPp), Gdiff2_l_e)),
  temp_diff_re : fullratsimp(calcInnerProdList(surfVars, 1, subst(vv=1, bP), Gdiff_r_e) - calcInnerProdList(surfVars, 1, subst(vv=1, bPp), Gdiff2_r_e)),
  temp_edge_le : -calcInnerProdList(surfVars, -1, subst(vv=-1, bPp), subst(vv=-1, fSkin_e)),
  temp_edge_re : -calcInnerProdList(surfVars, 1, subst(vv=1, bPp), subst(vv=1, fSkin_e)),
  diff_incr_le : calcInnerProdList(varsP, nuVtSqSum_e, bP, doExpand1(temp_diff, bP)),
  diff_incr_re : calcInnerProdList(varsP, nuVtSqSum_e, bP, doExpand1(temp_diff, bP)),
  edge_incr_le : calcInnerProdList(varsP, nuVtSqSum_e, bP, doExpand1(temp_edge, bP)),
  edge_incr_re : calcInnerProdList(varsP, nuVtSqSum_e, bP, doExpand1(temp_edge, bP)),
  printf(fh, "  double temp_diff[~a] = {0.0}; ~%", length(bP)),
  printf(fh, "  double temp_edge[~a] = {0.0}; ~%", length(bP)),
  printf(fh, "  double diff_incr[~a] = {0.0}; ~%", length(bP)),
  printf(fh, "  double edge_incr[~a] = {0.0}; ~%", length(bP)),
  printf(fh, "  double vol_incr[~a] = {0.0}; ~%", length(bP)),
  printf(fh, "~%"),
  tempVars : writeCExprs1(vol_incr, vol_incr_e),
  printf(fh, "~%"),
  printf(fh, "  if (edge == -1) { ~%~%"),
    
  tempVars : writeCExprs1(temp_diff, temp_diff_re),
  printf(fh, "~%"),
    
  tempVars : writeCExprs1(temp_edge, temp_edge_le),
  printf(fh, "~%"),
    
  tempVars : writeCExprs1(diff_incr, diff_incr_re),
  printf(fh, "~%"),
  tempVars : writeCExprs1(edge_incr, edge_incr_le),
  printf(fh, "~%"),
  
  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "~%  } else { ~%~%"),
  
   tempVars : writeCExprs1(temp_diff, temp_diff_le),
  printf(fh, "~%"),
    
  tempVars : writeCExprs1(temp_edge, temp_edge_re),
  printf(fh, "~%"),
    
  tempVars : writeCExprs1(diff_incr, diff_incr_le),
  printf(fh, "~%"),
  tempVars : writeCExprs1(edge_incr, edge_incr_re),
  printf(fh, "~%"),
  printf(fh, "  } ~%"),
  printf(fh, "~%"),

  vol_out : makelist(vol_incr[i-1],i,1,NP),
  diff_out : makelist(diff_incr[i-1],i,1,NP),
  edge_out : makelist(edge_incr[i-1],i,1,NP),
  writeCIncrExprs1(out, rdvSq4*(diff_out + edge_out) + vol_out),
  printf(fh, "} ~%")
);


