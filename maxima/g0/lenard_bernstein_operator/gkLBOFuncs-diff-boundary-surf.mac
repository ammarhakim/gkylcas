load("modal-basis")$
load("out-scripts");
load("recovery")$
load("utilities")$
load(stringproc)$
fpprec : 24$

/* This script generates the kernels for the boundary surface term
   diffusion contribution from Lenard Bernstein operator for the
   gyrokinetic equation. */

varsVAll : [vpar, mu]$

vIndex1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

calcGkLBOBoundaryDiffUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder, isNonuniform) := block(
  [varsC,bC,varsP,bP,vSub,NC,NP,pDim,vidx1,surfVar,surfIntVars,bPp,fEdge_e,fSkin_e,bType,hl_e,hr_e,
   hOrder,hsol_l,hsol_r,surfVarPhys,nuVtSqSum_e,bSurf,facDiff_e,basisFac,GhatPhaseFac_l,
   GhatPhaseFac_r,ibpPhaseFac_l,ibpPhaseFac_r,vfSkin_l,vfSkin_r,BmagInv_e,surfVar_l,surfVar_r,
   facDiff_c,expr,i,facDiff_NoZero,vol_incr_c,Gdiff_l_c,Gdiff_r_c,Gdiff_l_e,Gdiff_r_e,Gdiff2_l_c,
   Gdiff2_r_c,Gdiff2_l_e,Gdiff2_r_e,temp_diff_rc,temp_edge_lc,diff_incr_rc,edge_incr_lc,temp_diff_lc,
   temp_edge_rc,diff_incr_lc,edge_incr_rc,vol_out,diff_out,edge_out],

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bC),  NP : length(bP),

  pDim    : cdim+vdim,
  vidx1   : vIndex1(cdim,vdim),
  surfVar : varsVAll[dir],
  surfIntVars : delete(surfVar,varsP),

  bPp : diff(bP,surfVar),  /* Basis derivative. */

  fEdge_e : doExpand1(fedge, bP),
  fSkin_e : doExpand1(fskin, bP),

  /* Construct the recovery polynomial */
  if polyOrder=1 then /* Force p=1 to mean hybrid. */
    bType : "gkhyb"
  else
    bType : basisFun,
  hl_e : calcRecov2CellGen(bType,surfVar,varsP,polyOrder,dg(makelist(fedge[i-1],i,1,NP)), dg(makelist(fskin[i-1],i,1,NP))),
  hr_e : calcRecov2CellGen(bType,surfVar,varsP,polyOrder,dg(makelist(fskin[i-1],i,1,NP)), dg(makelist(fedge[i-1],i,1,NP))),
  /* Derivatives of recovery polynomials. */
  hOrder : 2*polyOrder+1,
  hsol_l : cons(subst(surfVar=0,hl_e),makelist(subst(surfVar=0,diff(hl_e,surfVar,ord)/(ord!)),ord,1,hOrder)),
  hsol_r : cons(subst(surfVar=0,hr_e),makelist(subst(surfVar=0,diff(hr_e,surfVar,ord)/(ord!)),ord,1,hOrder)),
  /*............. RECOVERY DONE ..............................*/
        
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double m_, const double *bmag_inv, const double *nuSum, const double *nuUSum, const double *nuVtSqSum, const int edge, const double *fedge, const double *fskin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:         Cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:       Cell spacing. ~%", cdim+vdim),
  printf(fh, "  // m_:           species mass.~%"),
  printf(fh, "  // bmag_inv:     1/(magnetic field magnitude). ~%"),
  printf(fh, "  // nuSum:        collisionalities added (self and cross species collisionalities). ~%"),
  printf(fh, "  // nuUSum[~a]:    sum of bulk velocities times their respective collisionalities. ~%", vdim*NC),
  printf(fh, "  // nuVtSqSum[~a]: sum of thermal speeds squared time their respective collisionalities. ~%", NC),
  printf(fh, "  // fskin/edge:   Distribution function in cells ~%"),
  printf(fh, "  // out:          Incremented distribution function in cell ~%"),
  printf(fh, "  double rdvSq4 = 4.0/(dxv[~a]*dxv[~a]); ~%", vidx1[dir], vidx1[dir]),
  printf(fh, "~%"),

  surfVarPhys : (dxv[vidx1[dir]]/2)*surfVar+w[vidx1[dir]],
                
  /* First compute the contribution coming from the second
     differentiation by parts to left and right cells. */
  nuVtSqSum_e : doExpand1(nuVtSqSum,bC),

  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("gkhyb",surfIntVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfIntVars,polyOrder)
  ),
     
  /* facDiff_c = < psi, nuVtSqSum > for vpar term,
               < psi, (2*m/B)*nuVtSqSum > for mu term.
     basisFac: factor multiplying facDiff in volume term.
     GhatPhaseFac : phase-space dependent factor in hat{G} (surface term).
     ibpPhaseFac : phase-space dependent factor in surface term from 2nd IBP. */
  if dir=1 then (
    facDiff_e : nuVtSqSum_e,
    basisFac  : diff(bP,surfVar,2),
    GhatPhaseFac_l : hsol_l[2],
    GhatPhaseFac_r : hsol_r[2],
    ibpPhaseFac_l  : hsol_l[1],
    ibpPhaseFac_r  : hsol_r[1],
    vfSkin_l       : subst(surfVar=-1, fSkin_e),
    vfSkin_r       : subst(surfVar=1, fSkin_e)
  ) elseif dir=2 then (
    BmagInv_e : doExpand1(bmag_inv,bC),
    facDiff_e : 2*m_*BmagInv_e*nuVtSqSum_e,
    basisFac  : diff(surfVarPhys*diff(bP,surfVar),surfVar),
    surfVar_l : subst(surfVar=-1, surfVarPhys),
    surfVar_r : subst(surfVar=1, surfVarPhys),
    GhatPhaseFac_l : surfVar_l*hsol_l[2],
    GhatPhaseFac_r : surfVar_r*hsol_r[2],
    ibpPhaseFac_l  : surfVar_l*hsol_l[1],
    ibpPhaseFac_r  : surfVar_r*hsol_r[1],
    vfSkin_l       : subst(surfVar=-1, surfVarPhys*fSkin_e),
    vfSkin_r       : subst(surfVar=1, surfVarPhys*fSkin_e)
  ),
  facDiff_c : calcInnerProdList(varsC, 1, bC, facDiff_e),

  if dir=2 then (
    /* facDiff = 2*m*nu*vtSq/B. */
    printf(fh, "  double facDiff[~a]; ~%", NC),
    /* Write out the components of facDiff's expansion. */
    printf(fh, "  // Expand diffusion coefficient in conf basis.~%"),
    expr : gcfac(float(expand(radcan(facDiff_c)))),
    for i : 1 thru NC do (
      if expr[i] # 0.0 then printf(fh, "  ~a = ~a; ~%", facDiff[i-1], expr[i])
    ),
    printf(fh, "~%"),

    /* Zero out components of alpha which are empty. */
    facDiff_NoZero : doMakeExprLst(facDiff_c, facDiff)
  ) else (
    /* Zero out components of alpha which are empty. */
    facDiff_NoZero : doMakeExprLst(facDiff_c, nuVtSqSum)
  ),
  facDiff_e : doExpand(facDiff_NoZero, bC),

  /* Volume increment. */
  vol_incr_c : rdvSq4*calcInnerProdList(varsP, 1, basisFac, facDiff_e*fSkin_e),
  printf(fh, "  double vol_incr[~a] = {0.0};~%", NP),
  writeCExprs1(vol_incr, vol_incr_c),
  printf(fh, "~%"),
    
  Gdiff_l_c : calcInnerProdList(surfIntVars,1,bSurf,GhatPhaseFac_l),
  Gdiff_r_c : calcInnerProdList(surfIntVars,1,bSurf,GhatPhaseFac_r),
  Gdiff_l_e : doExpand(Gdiff_l_c, bSurf),
  Gdiff_r_e : doExpand(Gdiff_r_c, bSurf),

  Gdiff2_l_c : calcInnerProdList(surfIntVars,1,bSurf,ibpPhaseFac_l),
  Gdiff2_r_c : calcInnerProdList(surfIntVars,1,bSurf,ibpPhaseFac_r),
  Gdiff2_l_e : doExpand(Gdiff2_l_c, bSurf),
  Gdiff2_r_e : doExpand(Gdiff2_r_c, bSurf),

  printf(fh, "  double temp_diff[~a] = {0.0}; ~%", NP),
  printf(fh, "  double temp_edge[~a] = {0.0}; ~%", NP),
  printf(fh, "  double diff_incr[~a] = {0.0}; ~%", NP),
  printf(fh, "  double edge_incr[~a] = {0.0}; ~%", NP),
  printf(fh, "~%"),
  printf(fh, "  if (edge == -1) { ~%~%"),
    
  temp_diff_rc : fullratsimp(calcInnerProdList(surfIntVars, 1, subst(surfVar=1, bP), Gdiff_r_e)
                            -calcInnerProdList(surfIntVars, 1, subst(surfVar=1, bPp), Gdiff2_r_e)),
  writeCExprs1(temp_diff, temp_diff_rc),
  printf(fh, "~%"),
    
  temp_edge_lc : -calcInnerProdList(surfIntVars, -1, subst(surfVar=-1, bPp), vfSkin_l),
  writeCExprs1(temp_edge, temp_edge_lc),
  printf(fh, "~%"),
    
  diff_incr_rc : calcInnerProdList(varsP, facDiff_e, bP, doExpand1(temp_diff, bP)),
  writeCExprs1(diff_incr, diff_incr_rc),
  printf(fh, "~%"),

  edge_incr_lc : calcInnerProdList(varsP, facDiff_e, bP, doExpand1(temp_edge, bP)),
  writeCExprs1(edge_incr, edge_incr_lc),
  printf(fh, "~%"),
  
  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evaluated at -1 */
  printf(fh, "~%  } else { ~%~%"),
  
  temp_diff_lc : fullratsimp(calcInnerProdList(surfIntVars, -1, subst(surfVar=-1, bP), Gdiff_l_e)
                            -calcInnerProdList(surfIntVars, -1, subst(surfVar=-1, bPp), Gdiff2_l_e)),
  writeCExprs1(temp_diff, temp_diff_lc),
  printf(fh, "~%"),
    
  temp_edge_rc : -calcInnerProdList(surfIntVars, 1,  subst(surfVar=1, bPp), vfSkin_r),
  writeCExprs1(temp_edge, temp_edge_rc),
  printf(fh, "~%"),
    
  diff_incr_lc : calcInnerProdList(varsP, facDiff_e, bP, doExpand1(temp_diff, bP)),
  writeCExprs1(diff_incr, diff_incr_lc),
  printf(fh, "~%"),

  edge_incr_rc : calcInnerProdList(varsP, facDiff_e, bP, doExpand1(temp_edge, bP)),
  writeCExprs1(edge_incr, edge_incr_rc),
  printf(fh, "~%"),
  printf(fh, "  } ~%"),
  printf(fh, "~%"),

  vol_out  : makelist(vol_incr[i-1],i,1,NP),
  diff_out : makelist(diff_incr[i-1],i,1,NP),
  edge_out : makelist(edge_incr[i-1],i,1,NP),
  writeCIncrExprs1(out, rdvSq4*(diff_out + edge_out) + vol_out),

  printf(fh, "} ~%")
);


