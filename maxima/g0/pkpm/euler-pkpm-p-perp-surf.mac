/* This script generates the kernels for the surface term of Euler's equations
   for the parallel-kinetic-perpendicular-moment (pkpm) model */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
load("recovery")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx10, dx11, dx12]$

euler_pkpm : [rhou0, rhou1, rhou2]$
lhs : [outrhou0, outrhou1, outrhou2]$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

let(uxl_r^2, uxl_r_sq)$
let(uxc_l^2, uxc_l_sq)$
let(uxc_r^2, uxc_r_sq)$
let(uxr_l^2, uxr_l_sq)$

/* 1D Euler special since only involves evaluations */
calcEulerPKPM1xUpdateInDir(dir, fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC,NC,cid,cv,surfVars,
  rhouxl_e,rhouyl_e,rhouzl_e,rhol_e,
  rhouxc_e,rhouyc_e,rhouzc_e,rhoc_e,
  rhouxr_e,rhouyr_e,rhouzr_e,rhor_e,
  rhouxl_r,rhouyl_r,rhouzl_r,rhol_r,
  rhouxc_l,rhouyc_l,rhouzc_l,rhoc_l,
  rhouxc_r,rhouyc_r,rhouzc_r,rhoc_r,
  rhouxr_l,rhouyr_l,rhouzr_l,rhor_l,
  avg_rho_l, avg_rho_r, avg_ux_l, avg_ux_r, avg_uy_l, avg_uy_r, avg_uz_l, avg_uz_r, 
  Ghat_rho_l_exp, Ghat_rho_r_exp, jump_rhoux_l, jump_rhoux_r, jump_rhouy_l, jump_rhouy_r, jump_rhouz_l, jump_rhouz_r, 
  Ghat_rhoux_l_exp,Ghat_rhoux_r_exp,Ghat_rhouy_l_exp,Ghat_rhouy_r_exp,Ghat_rhouz_l_exp,Ghat_rhouz_r_exp,
  incr_rhoux_l,incr_rhoux_r,incr_rhouy_l,incr_rhouy_r,incr_rhouz_l,incr_rhouz_r],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  printf(fh, "GKYL_CU_DH void ~a~a_~ax_~a_p~a(const double *w, const double *dxv, 
  const double *vlasov_pkpm_momsl, const double *vlasov_pkpm_momsc, const double *vlasov_pkpm_momsr,
  const double *priml, const double *primc, const double *primr,
  const double *p_ijl, const double *p_ijc, const double *p_ijr,
  const double *euler_pkpml, const double *euler_pkpmc, const double *euler_pkpmr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:           Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:         Cell spacing.~%"),
  printf(fh, "  // vlasov_pkpm_momsl/vlasov_pkpm_momsc/vlasov_pkpm_momsr: Input pkpm moments in left/center/right cells.~%"),
  printf(fh, "  // priml/primc/primr: Input primitive variables [ux, uy, uz, 3*Txx/m, 3*Tyy/m, 3*Tzz/m, 1/rho div(p_par b), T_perp/m, m/T_perp] in left/center/right cells.~%"),
  printf(fh, "  // p_ijl/p_ijc/p_ijr: Input pressure tensor in left/center/right cells.~%"),
  printf(fh, "  // euler_pkpml/euler_pkpmc/euler_pkpmr: [rho ux, rho uy, rho uz], Fluid input state vector in left/center/right cells.~%"),
  printf(fh, "  // out: Incremented output.~%"),
  printf(fh, "~%"),

  /* cv = variable in direction of surface update. */
  cv : varsC[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_l = &euler_pkpml[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_l = &euler_pkpml[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_l = &euler_pkpml[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_c = &euler_pkpmc[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_c = &euler_pkpmc[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_c = &euler_pkpmc[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_r = &euler_pkpmr[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_r = &euler_pkpmr[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_r = &euler_pkpmr[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rho_l = &vlasov_pkpm_momsl[~a]; ~%", 0*NC),
  printf(fh, "  const double *rho_c = &vlasov_pkpm_momsc[~a]; ~%", 0*NC),
  printf(fh, "  const double *rho_r = &vlasov_pkpm_momsr[~a]; ~%", 0*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_l = &priml[~a]; ~%", 0*NC),
  printf(fh, "  const double *ux_c = &primc[~a]; ~%", 0*NC),
  printf(fh, "  const double *ux_r = &primr[~a]; ~%", 0*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *uy_l = &priml[~a]; ~%", 1*NC),
  printf(fh, "  const double *uy_c = &primc[~a]; ~%", 1*NC),
  printf(fh, "  const double *uy_r = &primr[~a]; ~%", 1*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *uz_l = &priml[~a]; ~%", 2*NC),
  printf(fh, "  const double *uz_c = &primc[~a]; ~%", 2*NC),
  printf(fh, "  const double *uz_r = &primr[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  /* p_ij for div(p), onle need x . P_ij in 1D */
  printf(fh, "  const double *Pxx_l = &p_ijl[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxy_l = &p_ijl[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxz_l = &p_ijl[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *Pxx_c = &p_ijc[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxy_c = &p_ijc[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxz_c = &p_ijc[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *Pxx_r = &p_ijr[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxy_r = &p_ijr[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxz_r = &p_ijr[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  /* 3*Txx/m is 3rd component of prim */
  printf(fh, "  const double *vth_sql = &priml[~a]; ~%", 3*NC),
  printf(fh, "  const double *vth_sqc = &primc[~a]; ~%", 3*NC),
  printf(fh, "  const double *vth_sqr = &primr[~a]; ~%", 3*NC),
  printf(fh, "~%"),

  printf(fh, "  double *outrhou0 = &out[~a]; ~%", 0*NC),
  printf(fh, "  double *outrhou1 = &out[~a]; ~%", 1*NC),
  printf(fh, "  double *outrhou2 = &out[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  rhouxl_e : doExpand1(rhoux_l, bC),
  rhouyl_e : doExpand1(rhouy_l, bC),
  rhouzl_e : doExpand1(rhouz_l, bC),

  rhouxc_e : doExpand1(rhoux_c, bC),
  rhouyc_e : doExpand1(rhouy_c, bC),
  rhouzc_e : doExpand1(rhouz_c, bC),

  rhouxr_e : doExpand1(rhoux_r, bC),
  rhouyr_e : doExpand1(rhouy_r, bC),
  rhouzr_e : doExpand1(rhouz_r, bC),

  Pxxl_e : doExpand1(Pxx_l, bC),
  Pxyl_e : doExpand1(Pxy_l, bC),
  Pxzl_e : doExpand1(Pxz_l, bC),

  Pxxc_e : doExpand1(Pxx_c, bC),
  Pxyc_e : doExpand1(Pxy_c, bC),
  Pxzc_e : doExpand1(Pxz_c, bC),

  Pxxr_e : doExpand1(Pxx_r, bC),
  Pxyr_e : doExpand1(Pxy_r, bC),
  Pxzr_e : doExpand1(Pxz_r, bC),

  rhol_e : doExpand1(rho_l, bC), 
  rhoc_e : doExpand1(rho_c, bC), 
  rhor_e : doExpand1(rho_r, bC), 

  rhol_r : subst(cv=1, rhol_e),
  rhoc_l : subst(cv=-1, rhoc_e),
  rhoc_r : subst(cv=1, rhoc_e),
  rhor_l : subst(cv=-1, rhor_e),

  printf(fh, "  double Ghat_rhoux_l = 0.0; ~%"),
  printf(fh, "  double Ghat_rhoux_r = 0.0; ~%"),
  printf(fh, "  double Ghat_rhouy_l = 0.0; ~%"),
  printf(fh, "  double Ghat_rhouy_r = 0.0; ~%"),
  printf(fh, "  double Ghat_rhouz_l = 0.0; ~%"),
  printf(fh, "  double Ghat_rhouz_r = 0.0; ~%"),  

  rhouxl_r : subst(cv=1, rhouxl_e),
  rhouyl_r : subst(cv=1, rhouyl_e),
  rhouzl_r : subst(cv=1, rhouzl_e),

  rhouxc_l : subst(cv=-1, rhouxc_e),
  rhouyc_l : subst(cv=-1, rhouyc_e),
  rhouzc_l : subst(cv=-1, rhouzc_e),

  rhouxc_r : subst(cv=1, rhouxc_e),
  rhouyc_r : subst(cv=1, rhouyc_e),
  rhouzc_r : subst(cv=1, rhouzc_e),

  rhouxr_l : subst(cv=-1, rhouxr_e),
  rhouyr_l : subst(cv=-1, rhouyr_e),
  rhouzr_l : subst(cv=-1, rhouzr_e),

  Pxxl_r : subst(cv=1, Pxxl_e),
  Pxyl_r : subst(cv=1, Pxyl_e),
  Pxzl_r : subst(cv=1, Pxzl_e),

  Pxxc_l : subst(cv=-1, Pxxc_e),
  Pxyc_l : subst(cv=-1, Pxyc_e),
  Pxzc_l : subst(cv=-1, Pxzc_e),

  Pxxc_r : subst(cv=1, Pxxc_e),
  Pxyc_r : subst(cv=1, Pxyc_e),
  Pxzc_r : subst(cv=1, Pxzc_e),

  Pxxr_l : subst(cv=-1, Pxxr_e),
  Pxyr_l : subst(cv=-1, Pxyr_e),
  Pxzr_l : subst(cv=-1, Pxzr_e),

  /* evaluate u at surface interfaces to find max */
  printf(fh, "  double uxl_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(ux_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uxc_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(ux_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uxc_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(ux_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uxr_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(ux_r); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),
  printf(fh, "  double uxl_r_sq = uxl_r*uxl_r; ~%"),
  printf(fh, "  double uxc_l_sq = uxc_l*uxc_l; ~%"),
  printf(fh, "  double uxc_r_sq = uxc_r*uxc_r; ~%"),
  printf(fh, "  double uxr_l_sq = uxr_l*uxr_l; ~%"),
  printf(fh, "~%"),  
  printf(fh, "  double uyl_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uy_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uyc_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uy_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uyc_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uy_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uyr_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uy_r); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),
  printf(fh, "  double uzl_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uz_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uzc_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uz_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uzc_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(uz_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double uzr_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(uz_r); ~%", basisFun, cdim, polyOrder),  
  printf(fh, "~%"),
  printf(fh, "  double vth_sq_l_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(vth_sql); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double vth_sq_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(vth_sqc); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double vth_sq_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(vth_sqc); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double vth_sq_r_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(vth_sqr); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),
  printf(fh, "  double ux_max_l = fmax(fabs(uxl_r), fabs(uxc_l)); ~%"),
  printf(fh, "  double ux_max_r = fmax(fabs(uxc_r), fabs(uxr_l)); ~%"),
  printf(fh, "  double vth_max_l = fmax(sqrt(fabs(vth_sq_l_r)), sqrt(fabs(vth_sq_c_l))); ~%"),
  printf(fh, "  double vth_max_r = fmax(sqrt(fabs(vth_sq_c_r)), sqrt(fabs(vth_sq_r_l))); ~%"),
  printf(fh, "  double max_speed_l = ux_max_l + vth_max_l; ~%"),
  printf(fh, "  double max_speed_r = ux_max_r + vth_max_r; ~%"),
  printf(fh, "~%"),

  avg_ux_l : 0.5*(uxc_l + uxl_r),
  avg_ux_r : 0.5*(uxr_l + uxc_r),

  avg_uy_l : 0.5*(uyc_l + uyl_r),
  avg_uy_r : 0.5*(uyr_l + uyc_r),

  avg_uz_l : 0.5*(uzc_l + uzl_r),
  avg_uz_r : 0.5*(uzr_l + uzc_r),

  avg_Pxx_l : 0.5*(Pxxc_l + Pxxl_r),
  avg_Pxx_r : 0.5*(Pxxr_l + Pxxc_r),

  avg_Pxy_l : 0.5*(Pxyc_l + Pxyl_r),
  avg_Pxy_r : 0.5*(Pxyr_l + Pxyc_r),

  avg_Pxz_l : 0.5*(Pxzc_l + Pxzl_r),
  avg_Pxz_r : 0.5*(Pxzr_l + Pxzc_r),

  avg_rho_l : 0.5*(rhoc_l + rhol_r),
  avg_rho_r : 0.5*(rhor_l + rhoc_r),

  Ghat_rho_l_exp : avg_rho_l*avg_ux_l,
  Ghat_rho_r_exp : avg_rho_r*avg_ux_r,

  jump_rhoux_l : 0.5*(rhouxc_l - rhouxl_r),
  jump_rhoux_r : 0.5*(rhouxr_l - rhouxc_r),

  jump_rhouy_l : 0.5*(rhouyc_l - rhouyl_r),
  jump_rhouy_r : 0.5*(rhouyr_l - rhouyc_r),

  jump_rhouz_l : 0.5*(rhouzc_l - rhouzl_r),
  jump_rhouz_r : 0.5*(rhouzr_l - rhouzc_r),

  Ghat_rhoux_l_exp : Ghat_rho_l_exp*avg_ux_l - max_speed_l*jump_rhoux_l + avg_Pxx_l,
  Ghat_rhoux_r_exp : Ghat_rho_r_exp*avg_ux_r - max_speed_r*jump_rhoux_r + avg_Pxx_r,

  Ghat_rhoux_l_exp : map(letsimp, Ghat_rhoux_l_exp),
  Ghat_rhoux_r_exp : map(letsimp, Ghat_rhoux_r_exp),

  Ghat_rhouy_l_exp : Ghat_rho_l_exp*avg_uy_l - max_speed_l*jump_rhouy_l + avg_Pxy_l,
  Ghat_rhouy_r_exp : Ghat_rho_r_exp*avg_uy_r - max_speed_r*jump_rhouy_r + avg_Pxy_r,

  Ghat_rhouz_l_exp : Ghat_rho_l_exp*avg_uz_l - max_speed_l*jump_rhouz_l + avg_Pxz_l,
  Ghat_rhouz_r_exp : Ghat_rho_r_exp*avg_uz_r - max_speed_r*jump_rhouz_r + avg_Pxz_r,

  printf(fh, "  Ghat_rhoux_l = ~a; ~%", float(expand(Ghat_rhoux_l_exp))),
  printf(fh, "  Ghat_rhouy_l = ~a; ~%", float(expand(Ghat_rhouy_l_exp))),
  printf(fh, "  Ghat_rhouz_l = ~a; ~%", float(expand(Ghat_rhouz_l_exp))),

  printf(fh, "  Ghat_rhoux_r = ~a; ~%", float(expand(Ghat_rhoux_r_exp))),
  printf(fh, "  Ghat_rhouy_r = ~a; ~%", float(expand(Ghat_rhouy_r_exp))),
  printf(fh, "  Ghat_rhouz_r = ~a; ~%", float(expand(Ghat_rhouz_r_exp))), 

  printf(fh, "~%"),

  incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rhoux_l),
  incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rhoux_r),

  incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rhouy_l),
  incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rhouy_r),

  incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rhouz_l),
  incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rhouz_r),

  surfTerms : [incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r],
  for m : 1 thru 3 do (
    surf : surfTerms[m],
    writeCIncrExprs1(lhs[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);

calcEulerPKPMUpdateInDir(dir, fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC,NC,cid,cv,surfVars,bSurf,nSurf,surfNodes,numNodes,
  rhouxl_e,rhouyl_e,rhouzl_e,rhol_e,
  rhouxc_e,rhouyc_e,rhouzc_e,rhoc_e,
  rhouxr_e,rhouyr_e,rhouzr_e,rhor_e,
  rhouxl_r,rhouyl_r,rhouzl_r,rhol_r,
  rhouxc_l,rhouyc_l,rhouzc_l,rhoc_l,
  rhouxc_r,rhouyc_r,rhouzc_r,rhoc_r,
  rhouxr_l,rhouyr_l,rhouzr_l,rhor_l,
  uxl_e,uxc_e,uxr_e,uxl_r,uxc_l,uxc_r,uxr_l,
  uyl_e,uyc_e,uyr_e,uyl_r,uyc_l,uyc_r,uyr_l,
  uzl_e,uzc_e,uzr_e,uzl_r,uzc_l,uzc_r,uzr_l,
  avg_rho_l, avg_rho_r, avg_u_l, avg_u_r, 
  flux_rho_l_c, flux_rho_r_c, flux_rho_l_e, flux_rho_r_e, 
  avg_ux_l_c, avg_ux_r_c, avg_uy_l_c, avg_uy_r_c, avg_uz_l_c, avg_uz_r_c, 
  avg_ux_l_e, avg_ux_r_e, avg_uy_l_e, avg_uy_r_e, avg_uz_l_e, avg_uz_r_e, 
  jump_rhoux_l_c, jump_rhoux_r_c, jump_rhouy_l_c, jump_rhouy_r_c, jump_rhouz_l_c, jump_rhouz_r_c, 
  jump_rhoux_l_e, jump_rhoux_r_e, jump_rhouy_l_e, jump_rhouy_r_e, jump_rhouz_l_e, jump_rhouz_r_e,
  max_speed_modal_l_e, max_speed_modal_r_e, 
  incr_rhoux_l,incr_rhoux_r,incr_rhouy_l,incr_rhouy_r,incr_rhouz_l,incr_rhouz_r],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax_~a_p~a(const double *w, const double *dxv,
  const double *vlasov_pkpm_momsl, const double *vlasov_pkpm_momsc, const double *vlasov_pkpm_momsr,
  const double *priml, const double *primc, const double *primr,
  const double *p_ijl, const double *p_ijc, const double *p_ijr,
  const double *euler_pkpml, const double *euler_pkpmc, const double *euler_pkpmr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:           Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:         Cell spacing.~%"),
  printf(fh, "  // vlasov_pkpm_momsl/vlasov_pkpm_momsc/vlasov_pkpm_momsr: Input pkpm moments in left/center/right cells.~%"),
  printf(fh, "  // priml/primc/primr: Input primitive variables in left/center/right cells.~%"),
  printf(fh, "  // p_ijl/p_ijc/p_ijr: Input pressure tensor in left/center/right cells.~%"),
  printf(fh, "  // euler_pkpml/euler_pkpmc/euler_pkpmr: [rho ux, rho uy, rho uz], Fluid input state vector in left/center/right cells.~%"),
  printf(fh, "  // out: Incremented output.~%"),
  printf(fh, "~%"),

  /* cv = variable in direction of surface update. */
  cv : varsC[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),

  bSurf : basisFromVars(basisFun,surfVars,polyOrder),
  NSurf : length(bSurf),

  /* Surface nodes given by tensor product of Gauss-Legendre quadrature points */
  surfNodes : gaussOrd(polyOrder+1, cdim-1),
  numNodes : length(surfNodes),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_l = &euler_pkpml[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_l = &euler_pkpml[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_l = &euler_pkpml[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_c = &euler_pkpmc[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_c = &euler_pkpmc[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_c = &euler_pkpmc[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_r = &euler_pkpmr[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_r = &euler_pkpmr[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_r = &euler_pkpmr[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rho_l = &vlasov_pkpm_momsl[~a]; ~%", 0*NC),
  printf(fh, "  const double *rho_c = &vlasov_pkpm_momsc[~a]; ~%", 0*NC),
  printf(fh, "  const double *rho_r = &vlasov_pkpm_momsr[~a]; ~%", 0*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_l = &priml[~a]; ~%", 0*NC),
  printf(fh, "  const double *ux_c = &primc[~a]; ~%", 0*NC),
  printf(fh, "  const double *ux_r = &primr[~a]; ~%", 0*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *uy_l = &priml[~a]; ~%", 1*NC),
  printf(fh, "  const double *uy_c = &primc[~a]; ~%", 1*NC),
  printf(fh, "  const double *uy_r = &primr[~a]; ~%", 1*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *uz_l = &priml[~a]; ~%", 2*NC),
  printf(fh, "  const double *uz_c = &primc[~a]; ~%", 2*NC),
  printf(fh, "  const double *uz_r = &primr[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  // Get another pointer for u in direction of update for ease of flux calculation. ~%"),
  printf(fh, "  const double *u_l = &priml[~a]; ~%", (dir-1)*NC),
  printf(fh, "  const double *u_c = &primc[~a]; ~%", (dir-1)*NC),
  printf(fh, "  const double *u_r = &primr[~a]; ~%", (dir-1)*NC),
  printf(fh, "~%"),

  printf(fh, "  // Get p_ij and thermal velocity in direction of update. ~%"),
  if (dir = 1) then (
    printf(fh, "  const double *Pxx_l = &p_ijl[~a]; ~%", 0*NC),
    printf(fh, "  const double *Pxy_l = &p_ijl[~a]; ~%", 1*NC),
    printf(fh, "  const double *Pxz_l = &p_ijl[~a]; ~%", 2*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *Pxx_c = &p_ijc[~a]; ~%", 0*NC),
    printf(fh, "  const double *Pxy_c = &p_ijc[~a]; ~%", 1*NC),
    printf(fh, "  const double *Pxz_c = &p_ijc[~a]; ~%", 2*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *Pxx_r = &p_ijr[~a]; ~%", 0*NC),
    printf(fh, "  const double *Pxy_r = &p_ijr[~a]; ~%", 1*NC),
    printf(fh, "  const double *Pxz_r = &p_ijr[~a]; ~%", 2*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *vth_sql = &priml[~a]; ~%", 3*NC),
    printf(fh, "  const double *vth_sqc = &primc[~a]; ~%", 3*NC),
    printf(fh, "  const double *vth_sqr = &primr[~a]; ~%", 3*NC)
  )
  else if (dir = 2) then (
    printf(fh, "  const double *Pxy_l = &p_ijl[~a]; ~%", 1*NC),
    printf(fh, "  const double *Pyy_l = &p_ijl[~a]; ~%", 3*NC),
    printf(fh, "  const double *Pyz_l = &p_ijl[~a]; ~%", 4*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *Pxy_c = &p_ijc[~a]; ~%", 1*NC),
    printf(fh, "  const double *Pyy_c = &p_ijc[~a]; ~%", 3*NC),
    printf(fh, "  const double *Pyz_c = &p_ijc[~a]; ~%", 4*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *Pxy_r = &p_ijr[~a]; ~%", 1*NC),
    printf(fh, "  const double *Pyy_r = &p_ijr[~a]; ~%", 3*NC),
    printf(fh, "  const double *Pyz_r = &p_ijr[~a]; ~%", 4*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *vth_sql = &priml[~a]; ~%", 4*NC),
    printf(fh, "  const double *vth_sqc = &primc[~a]; ~%", 4*NC),
    printf(fh, "  const double *vth_sqr = &primr[~a]; ~%", 4*NC)
  )
  else (
    printf(fh, "  const double *Pxz_l = &p_ijl[~a]; ~%", 2*NC),
    printf(fh, "  const double *Pyz_l = &p_ijl[~a]; ~%", 4*NC),
    printf(fh, "  const double *Pzz_l = &p_ijl[~a]; ~%", 5*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *Pxz_c = &p_ijc[~a]; ~%", 2*NC),
    printf(fh, "  const double *Pyz_c = &p_ijc[~a]; ~%", 4*NC),
    printf(fh, "  const double *Pzz_c = &p_ijc[~a]; ~%", 5*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *Pxz_r = &p_ijr[~a]; ~%", 2*NC),
    printf(fh, "  const double *Pyz_r = &p_ijr[~a]; ~%", 4*NC),
    printf(fh, "  const double *Pzz_r = &p_ijr[~a]; ~%", 5*NC),
    printf(fh, "~%"),
    printf(fh, "  const double *vth_sql = &priml[~a]; ~%", 5*NC),
    printf(fh, "  const double *vth_sqc = &primc[~a]; ~%", 5*NC),
    printf(fh, "  const double *vth_sqr = &primr[~a]; ~%", 5*NC)
  ),
  printf(fh, "~%"),

  printf(fh, "  double *outrhou0 = &out[~a]; ~%", 0*NC),
  printf(fh, "  double *outrhou1 = &out[~a]; ~%", 1*NC),
  printf(fh, "  double *outrhou2 = &out[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no cv dependence. */
  bSurf : basisFromVars(basisFun,surfVars,polyOrder),
  NSurf : length(bSurf),

  /* Surface nodes given by tensor product of Gauss-Legendre quadrature points */
  surfNodes : gaussOrd(polyOrder+1, cdim-1),
  numNodes : length(surfNodes),

  printf(fh, "  double flux_rho_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double flux_rho_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double avg_ux_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double avg_ux_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double avg_uy_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double avg_uy_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double avg_uz_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double avg_uz_r[~a] = {0.0}; ~%", NSurf),  

  printf(fh, "  double avg_p_ij_x_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double avg_p_ij_x_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double avg_p_ij_y_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double avg_p_ij_y_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double avg_p_ij_z_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double avg_p_ij_z_r[~a] = {0.0}; ~%", NSurf), 

  printf(fh, "  double jump_rhoux_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double jump_rhoux_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double jump_rhouy_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double jump_rhouy_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double jump_rhouz_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double jump_rhouz_r[~a] = {0.0}; ~%", NSurf),  

  printf(fh, "  double max_speed_quad_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double max_speed_quad_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double max_speed_modal_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double max_speed_modal_r[~a] = {0.0}; ~%", NSurf),

  /* Compute the flux of mass at the interface using split-form averaging */
  rhol_e : doExpand1(rho_l, bC), 
  rhoc_e : doExpand1(rho_c, bC), 
  rhor_e : doExpand1(rho_r, bC), 

  ul_e : doExpand1(u_l, bC),
  uc_e : doExpand1(u_c, bC),
  ur_e : doExpand1(u_r, bC),

  rhol_r : subst(cv=1, rhol_e),
  rhoc_l : subst(cv=-1, rhoc_e),
  rhoc_r : subst(cv=1, rhoc_e),
  rhor_l : subst(cv=-1, rhor_e),

  ul_r : subst(cv=1, ul_e),
  uc_l : subst(cv=-1, uc_e),
  uc_r : subst(cv=1, uc_e),
  ur_l : subst(cv=-1, ur_e),

  avg_rho_l : 0.5*(rhol_r + rhoc_l),
  avg_rho_r : 0.5*(rhoc_r + rhor_l),
  avg_u_l : 0.5*(ul_r + uc_l),
  avg_u_r : 0.5*(uc_r + ur_l),  

  flux_rho_l_c : calcInnerProdList(surfVars, 1, bSurf, avg_rho_l*avg_u_l),
  flux_rho_r_c : calcInnerProdList(surfVars, 1, bSurf, avg_rho_r*avg_u_r),

  writeCExprs1(flux_rho_l, flux_rho_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(flux_rho_r, flux_rho_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  flux_rho_l_e : doExpand1(flux_rho_l, bSurf),
  flux_rho_r_e : doExpand1(flux_rho_r, bSurf),

  /* Expand flow velocity and average the flow velocity at the interface */
  uxl_e : doExpand1(ux_l, bC),
  uyl_e : doExpand1(uy_l, bC),
  uzl_e : doExpand1(uz_l, bC),

  uxc_e : doExpand1(ux_c, bC),
  uyc_e : doExpand1(uy_c, bC),
  uzc_e : doExpand1(uz_c, bC),

  uxr_e : doExpand1(ux_r, bC),
  uyr_e : doExpand1(uy_r, bC),
  uzr_e : doExpand1(uz_r, bC),

  uxl_r : subst(cv=1, uxl_e),
  uyl_r : subst(cv=1, uyl_e),
  uzl_r : subst(cv=1, uzl_e),

  uxc_l : subst(cv=-1, uxc_e),
  uyc_l : subst(cv=-1, uyc_e),
  uzc_l : subst(cv=-1, uzc_e),

  uxc_r : subst(cv=1, uxc_e),
  uyc_r : subst(cv=1, uyc_e),
  uzc_r : subst(cv=1, uzc_e),

  uxr_l : subst(cv=-1, uxr_e),
  uyr_l : subst(cv=-1, uyr_e),
  uzr_l : subst(cv=-1, uzr_e),

  avg_ux_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(uxl_r + uxc_l)),
  avg_ux_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(uxc_r + uxr_l)),

  avg_uy_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(uyl_r + uyc_l)),
  avg_uy_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(uyc_r + uyr_l)),

  avg_uz_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(uzl_r + uzc_l)),
  avg_uz_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(uzc_r + uzr_l)),  

  writeCExprs1(avg_ux_l, avg_ux_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(avg_ux_r, avg_ux_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(avg_uy_l, avg_uy_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(avg_uy_r, avg_uy_r_c),
  printf(fh, "~%"),
  flush_output(fh),    

  writeCExprs1(avg_uz_l, avg_uz_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(avg_uz_r, avg_uz_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  avg_ux_l_e : doExpand1(avg_ux_l, bSurf),
  avg_ux_r_e : doExpand1(avg_ux_r, bSurf),

  avg_uy_l_e : doExpand1(avg_uy_l, bSurf),
  avg_uy_r_e : doExpand1(avg_uy_r, bSurf),    

  avg_uz_l_e : doExpand1(avg_uz_l, bSurf),
  avg_uz_r_e : doExpand1(avg_uz_r, bSurf),

  /* Expand pressure tensor (all components, will select particular components based on direction) */
  Pxxl_e : doExpand1(Pxx_l, bC),
  Pxyl_e : doExpand1(Pxy_l, bC),
  Pxzl_e : doExpand1(Pxz_l, bC),
  Pyyl_e : doExpand1(Pyy_l, bC),
  Pyzl_e : doExpand1(Pyz_l, bC),
  Pzzl_e : doExpand1(Pzz_l, bC),

  Pxxc_e : doExpand1(Pxx_c, bC),
  Pxyc_e : doExpand1(Pxy_c, bC),
  Pxzc_e : doExpand1(Pxz_c, bC),
  Pyyc_e : doExpand1(Pyy_c, bC),
  Pyzc_e : doExpand1(Pyz_c, bC),
  Pzzc_e : doExpand1(Pzz_c, bC),

  Pxxr_e : doExpand1(Pxx_r, bC),
  Pxyr_e : doExpand1(Pxy_r, bC),
  Pxzr_e : doExpand1(Pxz_r, bC),
  Pyyr_e : doExpand1(Pyy_r, bC),
  Pyzr_e : doExpand1(Pyz_r, bC),
  Pzzr_e : doExpand1(Pzz_r, bC),

  Pxxl_r : subst(cv=1, Pxxl_e),
  Pxyl_r : subst(cv=1, Pxyl_e),
  Pxzl_r : subst(cv=1, Pxzl_e),
  Pyyl_r : subst(cv=1, Pyyl_e),
  Pyzl_r : subst(cv=1, Pyzl_e),
  Pzzl_r : subst(cv=1, Pzzl_e),

  Pxxc_l : subst(cv=-1, Pxxc_e),
  Pxyc_l : subst(cv=-1, Pxyc_e),
  Pxzc_l : subst(cv=-1, Pxzc_e),
  Pyyc_l : subst(cv=-1, Pyyc_e),
  Pyzc_l : subst(cv=-1, Pyzc_e),
  Pzzc_l : subst(cv=-1, Pzzc_e),

  Pxxc_r : subst(cv=1, Pxxc_e),
  Pxyc_r : subst(cv=1, Pxyc_e),
  Pxzc_r : subst(cv=1, Pxzc_e),
  Pyyc_r : subst(cv=1, Pyyc_e),
  Pyzc_r : subst(cv=1, Pyzc_e),
  Pzzc_r : subst(cv=1, Pzzc_e),

  Pxxr_l : subst(cv=-1, Pxxr_e),
  Pxyr_l : subst(cv=-1, Pxyr_e),
  Pxzr_l : subst(cv=-1, Pxzr_e),
  Pyyr_l : subst(cv=-1, Pyyr_e),
  Pyzr_l : subst(cv=-1, Pyzr_e),
  Pzzr_l : subst(cv=-1, Pzzr_e),

  avg_Pxx_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pxxl_r + Pxxc_l)),
  avg_Pxx_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pxxc_r + Pxxr_l)),

  avg_Pxy_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pxyl_r + Pxyc_l)),
  avg_Pxy_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pxyc_r + Pxyr_l)),

  avg_Pxz_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pxzl_r + Pxzc_l)),
  avg_Pxz_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pxzc_r + Pxzr_l)),  

  avg_Pyy_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pyyl_r + Pyyc_l)),
  avg_Pyy_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pyyc_r + Pyyr_l)),

  avg_Pyz_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pyzl_r + Pyzc_l)),
  avg_Pyz_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pyzc_r + Pyzr_l)),

  avg_Pzz_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pzzl_r + Pzzc_l)),
  avg_Pzz_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(Pzzc_r + Pzzr_l)), 

  if (dir = 1) then (
    writeCExprs1(avg_p_ij_x_l, avg_Pxx_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_x_r, avg_Pxx_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_y_l, avg_Pxy_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_y_r, avg_Pxy_r_c),
    printf(fh, "~%"),
    flush_output(fh),    

    writeCExprs1(avg_p_ij_z_l, avg_Pxz_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_z_r, avg_Pxz_r_c),
    printf(fh, "~%"),
    flush_output(fh)
  )
  else if (dir = 2) then (
    writeCExprs1(avg_p_ij_x_l, avg_Pxy_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_x_r, avg_Pxy_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_y_l, avg_Pyy_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_y_r, avg_Pyy_r_c),
    printf(fh, "~%"),
    flush_output(fh),    

    writeCExprs1(avg_p_ij_z_l, avg_Pyz_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_z_r, avg_Pyz_r_c),
    printf(fh, "~%"),
    flush_output(fh)
  )
  else (
    writeCExprs1(avg_p_ij_x_l, avg_Pxz_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_x_r, avg_Pxz_r_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_y_l, avg_Pyz_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_y_r, avg_Pyz_r_c),
    printf(fh, "~%"),
    flush_output(fh),    

    writeCExprs1(avg_p_ij_z_l, avg_Pzz_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    writeCExprs1(avg_p_ij_z_r, avg_Pzz_r_c),
    printf(fh, "~%"),
    flush_output(fh)
  ),

  avg_p_ij_x_l_e : doExpand1(avg_p_ij_x_l, bSurf),
  avg_p_ij_x_r_e : doExpand1(avg_p_ij_x_r, bSurf),

  avg_p_ij_y_l_e : doExpand1(avg_p_ij_y_l, bSurf),
  avg_p_ij_y_r_e : doExpand1(avg_p_ij_y_r, bSurf),    

  avg_p_ij_z_l_e : doExpand1(avg_p_ij_z_l, bSurf),
  avg_p_ij_z_r_e : doExpand1(avg_p_ij_z_r, bSurf),

  /* Expand the momentum to compute the surface expansion of the jumps */
  rhouxl_e : doExpand1(rhoux_l, bC),
  rhouyl_e : doExpand1(rhouy_l, bC),
  rhouzl_e : doExpand1(rhouz_l, bC),

  rhouxc_e : doExpand1(rhoux_c, bC),
  rhouyc_e : doExpand1(rhouy_c, bC),
  rhouzc_e : doExpand1(rhouz_c, bC),

  rhouxr_e : doExpand1(rhoux_r, bC),
  rhouyr_e : doExpand1(rhouy_r, bC),
  rhouzr_e : doExpand1(rhouz_r, bC),

  rhouxl_r : subst(cv=1, rhouxl_e),
  rhouyl_r : subst(cv=1, rhouyl_e),
  rhouzl_r : subst(cv=1, rhouzl_e),

  rhouxc_l : subst(cv=-1, rhouxc_e),
  rhouyc_l : subst(cv=-1, rhouyc_e),
  rhouzc_l : subst(cv=-1, rhouzc_e),

  rhouxc_r : subst(cv=1, rhouxc_e),
  rhouyc_r : subst(cv=1, rhouyc_e),
  rhouzc_r : subst(cv=1, rhouzc_e),

  rhouxr_l : subst(cv=-1, rhouxr_e),
  rhouyr_l : subst(cv=-1, rhouyr_e),
  rhouzr_l : subst(cv=-1, rhouzr_e),

  jump_rhoux_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(rhouxc_l - rhouxl_r)),
  jump_rhoux_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(rhouxr_l - rhouxc_r)),

  jump_rhouy_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(rhouyc_l - rhouyl_r)),
  jump_rhouy_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(rhouyr_l - rhouyc_r)),

  jump_rhouz_l_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(rhouzc_l - rhouzl_r)),
  jump_rhouz_r_c : calcInnerProdList(surfVars, 1, bSurf, 0.5*(rhouzr_l - rhouzc_r)),  

  writeCExprs1(jump_rhoux_l, jump_rhoux_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(jump_rhoux_r, jump_rhoux_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(jump_rhouy_l, jump_rhouy_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(jump_rhouy_r, jump_rhouy_r_c),
  printf(fh, "~%"),
  flush_output(fh),    

  writeCExprs1(jump_rhouz_l, jump_rhouz_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(jump_rhouz_r, jump_rhouz_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  jump_rhoux_l_e : doExpand1(jump_rhoux_l, bSurf),
  jump_rhoux_r_e : doExpand1(jump_rhoux_r, bSurf),

  jump_rhouy_l_e : doExpand1(jump_rhouy_l, bSurf),
  jump_rhouy_r_e : doExpand1(jump_rhouy_r, bSurf),    

  jump_rhouz_l_e : doExpand1(jump_rhouz_l, bSurf),
  jump_rhouz_r_e : doExpand1(jump_rhouz_r, bSurf),

  printf(fh, "  double ul_r = 0.0; ~%"),
  printf(fh, "  double uc_l = 0.0; ~%"),
  printf(fh, "  double uc_r = 0.0; ~%"),
  printf(fh, "  double ur_l = 0.0; ~%"),

  printf(fh, "  double uQuad_l = 0.0; ~%"),
  printf(fh, "  double uQuad_r = 0.0; ~%"),
  printf(fh, "~%"),

  printf(fh, "  double vth_sql_r = 0.0; ~%"),
  printf(fh, "  double vth_sqc_l = 0.0; ~%"),
  printf(fh, "  double vth_sqc_r = 0.0; ~%"),
  printf(fh, "  double vth_sqr_l = 0.0; ~%"),

  printf(fh, "  double vthQuad_l = 0.0; ~%"),
  printf(fh, "  double vthQuad_r = 0.0; ~%"),
  printf(fh, "~%"),

  for i : 1 thru numNodes do (
    printf(fh, "  ul_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(u_l); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  uc_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(u_c); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  uc_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(u_c); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  ur_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(u_r); ~%", basisFun, cdim, polyOrder, dir, i-1),

    printf(fh, "  uQuad_l = fmax(fabs(ul_r), fabs(uc_l)); ~%"),
    printf(fh, "  uQuad_r = fmax(fabs(uc_r), fabs(ur_l)); ~%"),

    printf(fh, "  vth_sql_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(vth_sql); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  vth_sqc_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(vth_sqc); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  vth_sqc_r = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_r(vth_sqc); ~%", basisFun, cdim, polyOrder, dir, i-1),
    printf(fh, "  vth_sqr_l = ~a_~ax_p~a_surfx~a_eval_quad_node_~a_l(vth_sqr); ~%", basisFun, cdim, polyOrder, dir, i-1),

    printf(fh, "  vthQuad_l = fmax(sqrt(fabs(vth_sql_r)), sqrt(fabs(vth_sqc_l))); ~%"),
    printf(fh, "  vthQuad_r = fmax(sqrt(fabs(vth_sqc_r)), sqrt(fabs(vth_sqr_l))); ~%"),

    printf(fh, "  max_speed_quad_l[~a] = uQuad_l + vthQuad_l; ~%", i-1),
    printf(fh, "  max_speed_quad_r[~a] = uQuad_r + vthQuad_r; ~%", i-1)
  ),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(max_speed_quad_l, max_speed_modal_l); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  ~a_~ax_p~a_upwind_quad_to_modal(max_speed_quad_r, max_speed_modal_r); ~%", basisFun, cdim, polyOrder),
  max_speed_modal_l_e : doExpand1(max_speed_modal_l,bSurf),
  max_speed_modal_r_e : doExpand1(max_speed_modal_r,bSurf),

  /* Compute the increments on the left and right from Ghat expansions */
  incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), flux_rho_l_e*avg_ux_l_e - max_speed_modal_l_e*jump_rhoux_l_e + avg_p_ij_x_l_e),
  incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), flux_rho_r_e*avg_ux_r_e - max_speed_modal_r_e*jump_rhoux_r_e + avg_p_ij_x_r_e),

  incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), flux_rho_l_e*avg_uy_l_e - max_speed_modal_l_e*jump_rhouy_l_e + avg_p_ij_y_l_e),
  incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), flux_rho_r_e*avg_uy_r_e - max_speed_modal_r_e*jump_rhouy_r_e + avg_p_ij_y_r_e),

  incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), flux_rho_l_e*avg_uz_l_e - max_speed_modal_l_e*jump_rhouz_l_e + avg_p_ij_z_l_e),
  incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), flux_rho_r_e*avg_uz_r_e - max_speed_modal_r_e*jump_rhouz_r_e + avg_p_ij_z_r_e),

  surfTerms : [incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r],
  for m : 1 thru 3 do (
    surf : surfTerms[m],
    writeCIncrExprs1(lhs[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);