/* This script generates the kernels for calculating the distribution function
   in the mirror force for the T_perp/m*G = T_perp/m*(F_0 - F_1) kinetic equation,
   along with the vperp characteristics which are a pure source term in the first Laguerre moment update.
   g_dist_source = [2.0*T_perp/m*(2.0*T_perp/m G + T_perp/m (F_2 - F_0)), 
                    (-vpar div(b) + bb:grad(u) - div(u) - 2 nu) T_perp/m G + 2 nu vth^2 F_0 ]
   First output is mirror force source *distribution*, second output is *total* vperp characteristics source.
                    
   Note that T_perp/m*G is the evolved quantity for the first Laguerre moment. 
   Also outputs F_1 from T_perp/m*G for the evolution of F_2 if F_2 is present. 
   To simplify internal Gkeyll logic, kernels assume F_2 is present and outputs F_1 even if F_2 = 0.0. */

load("modal-basis")$
load("out-scripts")$
fpprec : 24$

/* Helper functions for expanding in basis functions a quantity we know should be sparse 
   For example, alpha, the phase space flow only depends on a few phase space coordinates */
/* List output is a vector with some offset off */
doMakeExprLstOff(vals, S, off)  := makelist(if vals[i] # 0 then S[off+i-1] else 0, i, 1, length(vals))$
/* List output is a scalar */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

calcPKPMDistMirrorForce(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NC, NP, clst, 
   vTrans, div_b_e, p_perp_source_e, alpha_G_1_source_c, alpha_G_1_source_NoZero, alpha_G_1_source_NoZero_e, 
   F_0_e, G_1_e, F_2_e, T_perp_over_m_e, T_perp_over_m_inv_e, 
   F_2_m_F_0_c, F_2_m_F_0_e, T_perp_F_0_c, T_perp_F_0_e, 
   T_perp_g_dist_c, T_perp_g_dist_e, out_g_dist_c, nu_vthsq_e, out_g_dist_vperp_c, 
   F_0_m_F_1_c, F_0_m_F_1_e, out_F_1_c],

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),

  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a_p~a(const double *w, const double *dxv, 
  const double* T_perp_over_m, const double* T_perp_over_m_inv, 
  const double *nu_vthsq, const double* pkpm_accel_vars, 
  const double* f, const double* F_k_p_1, double* g_dist_source, double* F_k_m_1) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // w[NDIM]:           Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:         Cell spacing.~%"),
  printf(fh, "  // T_perp_over_m:     Input p_perp/rho = T_perp/m.~%"),
  printf(fh, "  // T_perp_over_m_inv: Input (T_perp/m)^-1.~%"),
  printf(fh, "  // nu_vthsq:          Input nu*vth^2.~%"),
  printf(fh, "  // pkpm_accel_vars:   pkpm acceleration variables~%"),
  printf(fh, "  // f:                 Input distribution function [F_0, T_perp/m G = T_perp/m (F_0 - F_1)].~%"),
  printf(fh, "  // F_k_p_1:           Input k+1 distribution function. F_2 expansion is the first NP coefficients. ~%"),
  printf(fh, "  // g_dist_source:     Output [2.0*T_perp/m*(2.0*T_perp/m G + T_perp/m (F_2 - F_0)),  ~%"), 
  printf(fh, "  //                    (-vpar div(b) + bb:grad(u) - div(u) - 2 nu) T_perp/m G + 2 nu vth^2 F_0 ].~%"), 
  printf(fh, "  //                    First output is mirror force source, second output is vperp characteristics source.~%"), 
  printf(fh, "  // F_k_m_1:           Output k-1 distribution function. F_1 expansion is the first NP coefficients. ~%"),
  printf(fh, "~%"),

  /* grid spacing in v_parallel and v_parallel coordinate */
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),
  /* Coordinate transformation for velocity space */
  vTrans : vx*dvpar/2+wvpar,
  clst : [dvpar, wvpar],

  /* Access pkpm acceleration variables for forces and sources 
     Need div(b) and p_perp_source = bb:grad(u) - div(u) - 2 nu 
     for vperp characteristics source */
  printf(fh, "  const double *div_b = &pkpm_accel_vars[~a]; ~%", 0*NC),
  printf(fh, "  const double *p_perp_source = &pkpm_accel_vars[~a]; ~%", 3*NC),
  printf(fh, "~%"),

  div_b_e : doExpand1(div_b, bC),
  p_perp_source_e : doExpand1(p_perp_source, bC),

  printf(fh, "  double alpha_G_1_source[~a] = {0.0}; ~%", NP),
  printf(fh, "~%"),

  /* Note that G vperp characteristics source does not involve an integration by parts and is just a pure source term 
     alpha_G_1_source = (bb : grad(u) - div(u) - 2 nu - v_parallel div(b)) T_perp/m G 
     alpha_G_1_source consolidated as alpha_G_1_source = p_perp_source - v_parallel div(b) (p_perp_source pre-computed) 
     After computing this part of the vperp characteristics source, still need to add 2*nu*vth^2*F_0 */
  alpha_G_1_source_c : calcInnerProdList(varsP, 1, bP, p_perp_source_e - div_b_e*vTrans),
  writeCExprsCollect1(alpha_G_1_source, alpha_G_1_source_c, clst),
  printf(fh, "~%"),
  /* Zero out components of G_1 vperp source which are empty. */
  alpha_G_1_source_NoZero : doMakeExprLst(alpha_G_1_source_c, alpha_G_1_source),
  alpha_G_1_source_NoZero_e : doExpand(alpha_G_1_source_NoZero, bP),

  /* Access F_0 and T_perp/m G, first two Laguerre moments */
  printf(fh, "  const double *F_0 = &f[~a]; ~%", 0),
  printf(fh, "  const double *G_1 = &f[~a]; ~%", NP),
  printf(fh, "  const double *F_2 = &F_k_p_1[~a]; ~%", 0),  
  printf(fh, "~%"), 

  /* Access the output components of g_dist_source
     First NP components are source distribution for mirror force: 2.0*T_perp/m*(2.0*T_perp/m G + T_perp/m (F_2 - F_0))
     Second NP components are source for vperp characteristics: (-vpar div(b) + bb:grad(u) - div(u) - 2 nu) T_perp/m G + 2 nu vth^2 F_0 */
  printf(fh, "  double *out_G_1_mirror = &g_dist_source[~a]; ~%", 0),  
  printf(fh, "  double *out_G_1_vperp = &g_dist_source[~a]; ~%", NP),  

  /* Access the output components of F_k_m_1 (only first NP components are F_1) */
  printf(fh, "  double *out_F_1 = &F_k_m_1[~a]; ~%", 0), 
  printf(fh, "~%"), 

  /* Expand distribution functions F_0 and T_perp/m G in phase basis. */
  F_0_e : doExpand1(F_0, bP),
  G_1_e : doExpand1(G_1, bP),
  F_2_e : doExpand1(F_2, bP),

  T_perp_over_m_e : doExpand1(T_perp_over_m, bC),
  T_perp_over_m_inv_e : doExpand1(T_perp_over_m_inv, bC),

  printf(fh, "  double tmp_F_2_m_F_0[~a] = {0.0}; ~%", NP),
  printf(fh, "  double tmp_T_perp_F_0[~a] = {0.0}; ~%", NP),
  printf(fh, "  double tmp_T_perp_g_dist[~a] = {0.0}; ~%", NP),
  printf(fh, "  double tmp_F_0_m_F_1[~a] = {0.0}; ~%", NP),
  printf(fh, "~%"),  

  F_2_m_F_0_c : calcInnerProdList(varsP, 1, bP, F_2_e - F_0_e),
  writeCExprs1(tmp_F_2_m_F_0, F_2_m_F_0_c),
  printf(fh, "~%"),  

  F_2_m_F_0_e : doExpand1(tmp_F_2_m_F_0, bP),
  T_perp_F_0_c : calcInnerProdList(varsP, 1, bP, T_perp_over_m_e*F_2_m_F_0_e),
  writeCExprs1(tmp_T_perp_F_0, T_perp_F_0_c),
  printf(fh, "~%"),  

  T_perp_F_0_e : doExpand1(tmp_T_perp_F_0, bP),
  T_perp_g_dist_c : calcInnerProdList(varsP, 1, bP, 2.0*G_1_e + T_perp_F_0_e), 
  writeCExprs1(tmp_T_perp_g_dist, T_perp_g_dist_c),
  printf(fh, "~%"),  

  T_perp_g_dist_e : doExpand1(tmp_T_perp_g_dist, bP),
  out_g_dist_c : calcInnerProdList(varsP, 1, bP, 2.0*T_perp_over_m_e*T_perp_g_dist_e),
  writeCExprs1(out_G_1_mirror, out_g_dist_c),
  printf(fh, "~%"), 

  nu_vthsq_e : doExpand1(nu_vthsq, bC),
  out_g_dist_vperp_c : calcInnerProdList(varsP, 1, bP, alpha_G_1_source_NoZero_e*G_1_e + 2.0*nu_vthsq_e*F_0_e),
  writeCExprs1(out_G_1_vperp, out_g_dist_vperp_c),
  printf(fh, "~%"), 

  F_0_m_F_1_c : calcInnerProdList(varsP, 1, bP, T_perp_over_m_inv_e*G_1_e),
  writeCExprs1(tmp_F_0_m_F_1, F_0_m_F_1_c),
  printf(fh, "~%"),

  F_0_m_F_1_e : doExpand1(tmp_F_0_m_F_1, bP),
  out_F_1_c : calcInnerProdList(varsP, 1, bP, F_0_e - F_0_m_F_1_e),
  writeCExprs1(out_F_1, out_F_1_c),

  printf(fh, "} ~%")
)$
