/* This script generates the kernels for the gradient quantities with recovery
   for discretization of the parallel-kinetic-perpendicular-moment (pkpm)
   model. These include div(p), div(b), bb : grad(u), and p_force = 1/rho*div(p_parallel b). 
   For p_perp fluid equation, also computes p_perp div(u) - p_perp bb : grad(u).
   Used by both kinetic and fluid equations */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("recovery")$
fpprec : 24$
cvars : [x, y, z]$

calcEulerPKPMRecovery(dir, fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, cv, 
  lst_b_l, lst_b_c, lst_b_r, b_rec, 
  lst_ux_l, lst_ux_c, lst_ux_r, lst_uy_l, lst_uy_c, lst_uy_r, lst_uz_l, lst_uz_c, lst_uz_r, 
  ux_rec, uy_rec, uz_rec, 
  lst_Pxx_l, lst_Pxx_c, lst_Pxx_r, lst_Pxy_l, lst_Pxy_c, lst_Pxy_r, lst_Pxz_l, lst_Pxz_c, lst_Pxz_r, 
  lst_Pyy_l, lst_Pyy_c, lst_Pyy_r, lst_Pyz_l, lst_Pyz_c, lst_Pyz_r, lst_Pzz_l, lst_Pzz_c, lst_Pzz_r, 
  Pxx_rec, Pxy_rec, Pxz_rec, Pyy_rec, Pyz_rec, Pzz_rec, 
  lst_ppar_b_l, lst_ppar_b_c, lst_ppar_b_r, ppar_b_rec, 
  lst_rhoux_l, lst_rhoux_c, lst_rhoux_r, rhoux_rec, 
  lst_rhouy_l, lst_rhouy_c, lst_rhouy_r, rhouy_rec, 
  lst_rhouz_l, lst_rhouz_c, lst_rhouz_r, rhouz_rec, 
  grad_u_x_c, grad_u_y_c, grad_u_z_c,
  bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e,  
  grad_u_x_e, grad_u_y_e, grad_u_z_e,
  pparl_e, pparc_e, pparr_e, bl_e, bc_e, br_e, p_perp_e, 
  ppar_b_l_c, ppar_b_c_c, ppar_b_r_c, b_prime_c, div_b_e, div_b_c, 
  bb_grad_u_comp_c, div_p_x_c, div_p_y_c, div_p_z_c, 
  hyper_rhoux_c, hyper_rhouy_c, hyper_rhouz_c, bb_grad_u_e, bb_grad_u_c, div_ppar_b_c, 
  rho_inv_e, T_perp_over_m_inv_e, div_ppar_b_e, T_perp_over_m_e, nu_e, 
  p_force_c, p_perp_source_c, p_perp_div_b_c],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  /* cv = variable to perform recovery in. */
  cv : varsC[dir],
  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax_~a_p~a(const double *dxv, double nuHyp, 
  const double *bvarl, const double *bvarc, const double *bvarr, 
  const double *u_il, const double *u_ic, const double *u_ir, 
  const double *p_ijl, const double *p_ijc, const double *p_ijr, 
  const double *vlasov_pkpm_momsl, const double *vlasov_pkpm_momsc, const double *vlasov_pkpm_momsr, 
  const double *statevecl, const double *statevecc, const double *statevecr, 
  const double *rho_inv, const double *T_perp_over_m, const double *T_perp_over_m_inv, const double *nu, 
  double* div_p, double* pkpm_accel_vars) ~%{ ~%", funcNm, cvars[dir], cdim, basisFun, polyOrder),
  printf(fh, "  // dxv[NDIM]:             Cell spacing.~%"),
  printf(fh, "  // nuHyp:                 Hyper-diffusion coefficient.~%"),
  printf(fh, "  // bvarl/c/r:             Input magnetic field unit vector in left/center/right cells.~%"),
  printf(fh, "  // u_il/c/r:              Input bulk velocity (ux,uy,uz) in left/center/right cells.~%"),
  printf(fh, "  // p_ijl/c/r:             Input pressure tensor in left/center/right cells.~%"),
  printf(fh, "  // vlasov_pkpm_momsl/c/r: Input pkpm moments (rho, p_parallel, p_perp) in left/center/right cells.~%"),
  printf(fh, "  // statevecl/c/r:         [rho ux, rho uy, rho uz], Fluid input state vector in center cell.~%"),
  printf(fh, "  // T_perp_over_m_inv:     Input 1/rho in center cell.~%"),
  printf(fh, "  // T_perp_over_m:         Input p_perp/rho = T_perp/m in center cell.~%"),
  printf(fh, "  // T_perp_over_m_inv:     Input (T_perp/m)^-1 in center cell.~%"),
  printf(fh, "  // nu:                    Input collisionality in center cell.~%"),
  printf(fh, "  // div_p:                 Increment to volume expansion of div(p) in one direction; includes hyper-diffusion for momentum.~%"),
  printf(fh, "  // pkpm_accel_vars:       Increment to volume expansion of pkpm acceleration variables.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),

  /* b_hat in direction dir for div(b) */
  printf(fh, "  const double *b_l = &bvarl[~a]; ~%", (dir-1)*NC),
  printf(fh, "  const double *b_c = &bvarc[~a]; ~%", (dir-1)*NC),
  printf(fh, "  const double *b_r = &bvarr[~a]; ~%", (dir-1)*NC),
  printf(fh, "~%"),

  /* u_i and bb for bb : grad(u). Need bb in center cell. */
  printf(fh, "  const double *ux_l = &u_il[~a]; ~%", 0),
  printf(fh, "  const double *uy_l = &u_il[~a]; ~%", NC),
  printf(fh, "  const double *uz_l = &u_il[~a]; ~%", NC*2),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_c = &u_ic[~a]; ~%", 0),
  printf(fh, "  const double *uy_c = &u_ic[~a]; ~%", NC),
  printf(fh, "  const double *uz_c = &u_ic[~a]; ~%", NC*2),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_r = &u_ir[~a]; ~%", 0),
  printf(fh, "  const double *uy_r = &u_ir[~a]; ~%", NC),
  printf(fh, "  const double *uz_r = &u_ir[~a]; ~%", NC*2),
  printf(fh, "~%"),

  printf(fh, "  const double *bx = &bvarc[~a]; ~%", NC*0),
  printf(fh, "  const double *by = &bvarc[~a]; ~%", NC*1),
  printf(fh, "  const double *bz = &bvarc[~a]; ~%", NC*2),
  printf(fh, "  const double *bxbx = &bvarc[~a]; ~%", NC*3),
  printf(fh, "  const double *bxby = &bvarc[~a]; ~%", NC*4),
  printf(fh, "  const double *bxbz = &bvarc[~a]; ~%", NC*5),
  printf(fh, "  const double *byby = &bvarc[~a]; ~%", NC*6),
  printf(fh, "  const double *bybz = &bvarc[~a]; ~%", NC*7),
  printf(fh, "  const double *bzbz = &bvarc[~a]; ~%", NC*8),
  printf(fh, "~%"),

  /* p_ij for div(p) */
  printf(fh, "  const double *Pxx_l = &p_ijl[~a]; ~%", 0),
  printf(fh, "  const double *Pxy_l = &p_ijl[~a]; ~%", NC),
  printf(fh, "  const double *Pxz_l = &p_ijl[~a]; ~%", NC*2),
  printf(fh, "  const double *Pyy_l = &p_ijl[~a]; ~%", NC*3),
  printf(fh, "  const double *Pyz_l = &p_ijl[~a]; ~%", NC*4),
  printf(fh, "  const double *Pzz_l = &p_ijl[~a]; ~%", NC*5),
  printf(fh, "~%"),

  printf(fh, "  const double *Pxx_c = &p_ijc[~a]; ~%", 0),
  printf(fh, "  const double *Pxy_c = &p_ijc[~a]; ~%", NC),
  printf(fh, "  const double *Pxz_c = &p_ijc[~a]; ~%", NC*2),
  printf(fh, "  const double *Pyy_c = &p_ijc[~a]; ~%", NC*3),
  printf(fh, "  const double *Pyz_c = &p_ijc[~a]; ~%", NC*4),
  printf(fh, "  const double *Pzz_c = &p_ijc[~a]; ~%", NC*5),
  printf(fh, "~%"),

  printf(fh, "  const double *Pxx_r = &p_ijr[~a]; ~%", 0),
  printf(fh, "  const double *Pxy_r = &p_ijr[~a]; ~%", NC),
  printf(fh, "  const double *Pxz_r = &p_ijr[~a]; ~%", NC*2),
  printf(fh, "  const double *Pyy_r = &p_ijr[~a]; ~%", NC*3),
  printf(fh, "  const double *Pyz_r = &p_ijr[~a]; ~%", NC*4),
  printf(fh, "  const double *Pzz_r = &p_ijr[~a]; ~%", NC*5),
  printf(fh, "~%"),

  /* rho and p_parallel for p_force. Need rho in center cell */
  printf(fh, "  const double *ppar_l = &vlasov_pkpm_momsl[~a]; ~%", NC),
  printf(fh, "  const double *ppar_c = &vlasov_pkpm_momsc[~a]; ~%", NC),
  printf(fh, "  const double *ppar_r = &vlasov_pkpm_momsr[~a]; ~%", NC),
  printf(fh, "  const double *rho = &vlasov_pkpm_momsc[~a]; ~%", 0),
  printf(fh, "  const double *p_perp = &vlasov_pkpm_momsc[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  /* rho u_i in left/center/right cells for hyper-diffusion of momentum */
  printf(fh, "  const double *rhoux_l = &statevecl[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_l = &statevecl[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_l = &statevecl[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_c = &statevecc[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_c = &statevecc[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_c = &statevecc[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_r = &statevecr[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_r = &statevecr[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_r = &statevecr[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  double *div_p_x = &div_p[~a]; ~%", 0*NC),
  printf(fh, "  double *div_p_y = &div_p[~a]; ~%", 1*NC),
  printf(fh, "  double *div_p_z = &div_p[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  double *div_b = &pkpm_accel_vars[~a]; ~%", 0*NC),
  printf(fh, "  double *bb_grad_u = &pkpm_accel_vars[~a]; ~%", 1*NC),
  printf(fh, "  double *p_force = &pkpm_accel_vars[~a]; ~%", 2*NC),
  printf(fh, "  double *p_perp_source = &pkpm_accel_vars[~a]; ~%", 3*NC),
  printf(fh, "  double *p_perp_div_b = &pkpm_accel_vars[~a]; ~%", 4*NC),
  printf(fh, "~%"),

  /* We use recovery to compute div(b) */
  lst_b_l : makelist(b_l[i], i, 0, NC-1),
  lst_b_c : makelist(b_c[i], i, 0, NC-1),
  lst_b_r : makelist(b_r[i], i, 0, NC-1),

  b_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 0, 
    dg(lst_b_l), dg(lst_b_c), dg(lst_b_r)),

  /* Expand variables we will compute the gradients of */
  bl_e : doExpand1(b_l, bC), 
  bc_e : doExpand1(b_c, bC), 
  br_e : doExpand1(b_r, bC), 

  uxl_e : doExpand1(ux_l, bC),
  uyl_e : doExpand1(uy_l, bC),
  uzl_e : doExpand1(uz_l, bC),

  uxc_e : doExpand1(ux_c, bC),
  uyc_e : doExpand1(uy_c, bC),
  uzc_e : doExpand1(uz_c, bC),

  uxr_e : doExpand1(ux_r, bC),
  uyr_e : doExpand1(uy_r, bC),
  uzr_e : doExpand1(uz_r, bC),

  Pxxl_e : doExpand1(Pxx_l, bC),
  Pxyl_e : doExpand1(Pxy_l, bC),
  Pxzl_e : doExpand1(Pxz_l, bC),
  Pyyl_e : doExpand1(Pyy_l, bC),
  Pyzl_e : doExpand1(Pyz_l, bC),
  Pzzl_e : doExpand1(Pzz_l, bC),

  Pxxc_e : doExpand1(Pxx_c, bC),
  Pxyc_e : doExpand1(Pxy_c, bC),
  Pxzc_e : doExpand1(Pxz_c, bC),
  Pyyc_e : doExpand1(Pyy_c, bC),
  Pyzc_e : doExpand1(Pyz_c, bC),
  Pzzc_e : doExpand1(Pzz_c, bC),

  Pxxr_e : doExpand1(Pxx_r, bC),
  Pxyr_e : doExpand1(Pxy_r, bC),
  Pxzr_e : doExpand1(Pxz_r, bC),
  Pyyr_e : doExpand1(Pyy_r, bC),
  Pyzr_e : doExpand1(Pyz_r, bC),
  Pzzr_e : doExpand1(Pzz_r, bC),

  /* Evaluate expansions at left and right interfaces 
     Left cell evaluated at right interface, center cell evaluated
     at both interfaces, right cell evaluated at left interface */
  uxl_r : subst(cv=1, uxl_e),
  uyl_r : subst(cv=1, uyl_e),
  uzl_r : subst(cv=1, uzl_e),

  uxc_l : subst(cv=-1, uxc_e),
  uyc_l : subst(cv=-1, uyc_e),
  uzc_l : subst(cv=-1, uzc_e),

  uxc_r : subst(cv=1, uxc_e),
  uyc_r : subst(cv=1, uyc_e),
  uzc_r : subst(cv=1, uzc_e),

  uxr_l : subst(cv=-1, uxr_e),
  uyr_l : subst(cv=-1, uyr_e),
  uzr_l : subst(cv=-1, uzr_e),

  Pxxl_r : subst(cv=1, Pxxl_e),
  Pxyl_r : subst(cv=1, Pxyl_e),
  Pxzl_r : subst(cv=1, Pxzl_e),
  Pyyl_r : subst(cv=1, Pyyl_e),
  Pyzl_r : subst(cv=1, Pyzl_e),
  Pzzl_r : subst(cv=1, Pzzl_e),

  Pxxc_l : subst(cv=-1, Pxxc_e),
  Pxyc_l : subst(cv=-1, Pxyc_e),
  Pxzc_l : subst(cv=-1, Pxzc_e),
  Pyyc_l : subst(cv=-1, Pyyc_e),
  Pyzc_l : subst(cv=-1, Pyzc_e),
  Pzzc_l : subst(cv=-1, Pzzc_e),

  Pxxc_r : subst(cv=1, Pxxc_e),
  Pxyc_r : subst(cv=1, Pxyc_e),
  Pxzc_r : subst(cv=1, Pxzc_e),
  Pyyc_r : subst(cv=1, Pyyc_e),
  Pyzc_r : subst(cv=1, Pyzc_e),
  Pzzc_r : subst(cv=1, Pzzc_e),

  Pxxr_l : subst(cv=-1, Pxxr_e),
  Pxyr_l : subst(cv=-1, Pxyr_e),
  Pxzr_l : subst(cv=-1, Pxzr_e),
  Pyyr_l : subst(cv=-1, Pyyr_e),
  Pyzr_l : subst(cv=-1, Pyzr_e),
  Pzzr_l : subst(cv=-1, Pzzr_e),

  bl_r : subst(cv=1, bl_e),
  bc_l : subst(cv=-1, bc_e),
  bc_r : subst(cv=1, bc_e),
  br_l : subst(cv=-1, br_e),

  /* Average of variable at interface for use in surface expansion */
  avg_ux_l : 0.5*(uxc_l + uxl_r),
  avg_ux_r : 0.5*(uxr_l + uxc_r),

  avg_uy_l : 0.5*(uyc_l + uyl_r),
  avg_uy_r : 0.5*(uyr_l + uyc_r),

  avg_uz_l : 0.5*(uzc_l + uzl_r),
  avg_uz_r : 0.5*(uzr_l + uzc_r),

  avg_Pxx_l : 0.5*(Pxxc_l + Pxxl_r),
  avg_Pxx_r : 0.5*(Pxxr_l + Pxxc_r),

  avg_Pxy_l : 0.5*(Pxyc_l + Pxyl_r),
  avg_Pxy_r : 0.5*(Pxyr_l + Pxyc_r),

  avg_Pxz_l : 0.5*(Pxzc_l + Pxzl_r),
  avg_Pxz_r : 0.5*(Pxzr_l + Pxzc_r),

  avg_Pyy_l : 0.5*(Pyyc_l + Pyyl_r),
  avg_Pyy_r : 0.5*(Pyyr_l + Pyyc_r),

  avg_Pyz_l : 0.5*(Pyzc_l + Pyzl_r),
  avg_Pyz_r : 0.5*(Pyzr_l + Pyzc_r),

  avg_Pzz_l : 0.5*(Pzzc_l + Pzzl_r),
  avg_Pzz_r : 0.5*(Pzzr_l + Pzzc_r),

  avg_b_l : 0.5*(bc_l + bl_r),
  avg_b_r : 0.5*(br_l + bc_r),

  /* Volume component of gradient expansion */
  vol_ux_c : calcInnerProdList(varsC, 1, diff(bC, cv), uxc_e),
  vol_uy_c : calcInnerProdList(varsC, 1, diff(bC, cv), uyc_e),
  vol_uz_c : calcInnerProdList(varsC, 1, diff(bC, cv), uzc_e),

  vol_Pxx_c : calcInnerProdList(varsC, 1, diff(bC, cv), Pxxc_e),
  vol_Pxy_c : calcInnerProdList(varsC, 1, diff(bC, cv), Pxyc_e),
  vol_Pxz_c : calcInnerProdList(varsC, 1, diff(bC, cv), Pxzc_e),
  vol_Pyy_c : calcInnerProdList(varsC, 1, diff(bC, cv), Pyyc_e),
  vol_Pyz_c : calcInnerProdList(varsC, 1, diff(bC, cv), Pyzc_e),
  vol_Pzz_c : calcInnerProdList(varsC, 1, diff(bC, cv), Pzzc_e),

  vol_b_c : calcInnerProdList(varsC, 1, diff(bC, cv), bc_e),

  /* Surface componet of gradient expansion */
  /* Negative sign on left surface for unit normal pointing into cell */
  surf_ux_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_ux_l),
  surf_ux_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_ux_r),

  surf_uy_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_uy_l),
  surf_uy_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_uy_r),

  surf_uz_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_uz_l),
  surf_uz_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_uz_r),

  surf_Pxx_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_Pxx_l),
  surf_Pxx_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_Pxx_r),

  surf_Pxy_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_Pxy_l),
  surf_Pxy_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_Pxy_r),

  surf_Pxz_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_Pxz_l),
  surf_Pxz_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_Pxz_r),

  surf_Pyy_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_Pyy_l),
  surf_Pyy_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_Pyy_r),

  surf_Pyz_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_Pyz_l),
  surf_Pyz_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_Pyz_r),

  surf_Pzz_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_Pzz_l),
  surf_Pzz_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_Pzz_r),

  surf_b_l : calcInnerProdList(surfVars, -1, subst(cv=-1, bC), avg_b_l),
  surf_b_r : calcInnerProdList(surfVars, 1, subst(cv=1, bC), avg_b_r),
 
  /* Note that this recovery is higher order as we will take more derivatives */
  lst_rhoux_l : makelist(rhoux_l[i], i, 0, NC-1),
  lst_rhoux_c : makelist(rhoux_c[i], i, 0, NC-1),
  lst_rhoux_r : makelist(rhoux_r[i], i, 0, NC-1),

  lst_rhouy_l : makelist(rhouy_l[i], i, 0, NC-1),
  lst_rhouy_c : makelist(rhouy_c[i], i, 0, NC-1),
  lst_rhouy_r : makelist(rhouy_r[i], i, 0, NC-1),

  lst_rhouz_l : makelist(rhouz_l[i], i, 0, NC-1),
  lst_rhouz_c : makelist(rhouz_c[i], i, 0, NC-1),
  lst_rhouz_r : makelist(rhouz_r[i], i, 0, NC-1),

  if (polyOrder = 1 or polyOrder = 2) then (
    /* Hyper diffusion Jacobian factor 4th order with p=1 */
    printf(fh, "  const double dxHyp = dx1*dx1*dx1*dx1; ~%"),
    printf(fh, "~%"),

    rhoux_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 1, 
      dg(lst_rhoux_l), dg(lst_rhoux_c), dg(lst_rhoux_r)),

    rhouy_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 1, 
      dg(lst_rhouy_l), dg(lst_rhouy_c), dg(lst_rhouy_r)),

    rhouz_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 1, 
      dg(lst_rhouz_l), dg(lst_rhouz_c), dg(lst_rhouz_r))
  ),
  /*
  elseif (polyOrder = 2) then (
    /* Hyper diffusion Jacobian factor 6th order with p=2 */
    printf(fh, "  const double dxHyp = dx1*dx1*dx1*dx1*dx1*dx1; ~%"),
    printf(fh, "~%"),

    rhoux_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 2, 
      dg(lst_rhoux_l), dg(lst_rhoux_c), dg(lst_rhoux_r)),

    rhouy_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 2, 
      dg(lst_rhouy_l), dg(lst_rhouy_c), dg(lst_rhouy_r)),

    rhouz_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 2, 
      dg(lst_rhouz_l), dg(lst_rhouz_c), dg(lst_rhouz_r))
  ), */

  /* Need bb : grad(u), write out grad(u) for each component of u */
  printf(fh, "  double grad_u_x[~a] = {0.0}; ~%", NC),
  printf(fh, "  double grad_u_y[~a] = {0.0}; ~%", NC),
  printf(fh, "  double grad_u_z[~a] = {0.0}; ~%", NC),

  /* Volume term has overall minus sign from integration by parts */
  writeCExprs1(grad_u_x, dx1*(-vol_ux_c + surf_ux_l + surf_ux_r)),
  printf(fh, "~%"),

  writeCExprs1(grad_u_y, dx1*(-vol_uy_c + surf_uy_l + surf_uy_r)),
  printf(fh, "~%"),

  writeCExprs1(grad_u_z, dx1*(-vol_uz_c + surf_uz_l + surf_uz_r)),
  printf(fh, "~%"),

  /* Expand b, bb, 1/rho, and grad(u) for each component of u */
  bx_e : doExpand1(bx, bC),
  by_e : doExpand1(by, bC),
  bz_e : doExpand1(bz, bC),
  bxbx_e : doExpand1(bxbx, bC),
  bxby_e : doExpand1(bxby, bC),
  bxbz_e : doExpand1(bxbz, bC),
  byby_e : doExpand1(byby, bC),
  bybz_e : doExpand1(bybz, bC),
  bzbz_e : doExpand1(bzbz, bC),

  rho_inv_e : doExpand1(rho_inv, bC),

  grad_u_x_e : doExpand1(grad_u_x, bC),
  grad_u_y_e : doExpand1(grad_u_y, bC),
  grad_u_z_e : doExpand1(grad_u_z, bC),

  printf(fh, "  double bx_over_rho[~a] = {0.0}; ~%", NC),
  printf(fh, "  double by_over_rho[~a] = {0.0}; ~%", NC),
  printf(fh, "  double bz_over_rho[~a] = {0.0}; ~%", NC),
  printf(fh, "  double div_b_comp[~a] = {0.0}; ~%", NC),
  printf(fh, "  double div_p_x_comp[~a] = {0.0}; ~%", NC),
  printf(fh, "  double div_p_y_comp[~a] = {0.0}; ~%", NC),
  printf(fh, "  double div_p_z_comp[~a] = {0.0}; ~%", NC),
  printf(fh, "  double bb_grad_u_comp[~a] = {0.0}; ~%", NC),

  bx_over_rho_c : calcInnerProdList(varsC, 1, bC, bx_e*rho_inv_e),
  writeCExprs1(bx_over_rho, bx_over_rho_c),
  printf(fh, "~%"),
  flush_output(fh),

  by_over_rho_c : calcInnerProdList(varsC, 1, bC, by_e*rho_inv_e),
  writeCExprs1(by_over_rho, by_over_rho_c),
  printf(fh, "~%"),
  flush_output(fh),

  bz_over_rho_c : calcInnerProdList(varsC, 1, bC, bz_e*rho_inv_e),
  writeCExprs1(bz_over_rho, bz_over_rho_c),
  printf(fh, "~%"),
  flush_output(fh),

  b_prime_c : calcInnerProdList(varsC, 1, bC, diff(b_rec, cv)),
  writeCExprs1(div_b_comp, dx1*b_prime_c),
  printf(fh, "~%"),
  flush_output(fh),

  div_b_e : doExpand1(div_b_comp, bC),
  div_b_c : calcInnerProdList(varsC, 1, bC, div_b_e),
  writeCIncrExprsCollect1lhsc(div_b, div_b_c),  
  printf(fh, "~%"),

  if (dir = 1) then (  
    writeCIncrExprsCollect1lhsc(div_p_x_comp, dx1*(-vol_Pxx_c + surf_Pxx_l + surf_Pxx_r)),
    printf(fh, "~%"),
    writeCIncrExprsCollect1lhsc(div_p_y_comp, dx1*(-vol_Pxy_c + surf_Pxy_l + surf_Pxy_r)),
    printf(fh, "~%"),
    writeCIncrExprsCollect1lhsc(div_p_z_comp, dx1*(-vol_Pxz_c + surf_Pxz_l + surf_Pxz_r)),
    printf(fh, "~%"),
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC, bxbx_e*grad_u_x_e + bxby_e*grad_u_y_e + bxbz_e*grad_u_z_e)
  )
  elseif (dir = 2) then (
    writeCIncrExprsCollect1lhsc(div_p_x_comp, dx1*(-vol_Pxy_c + surf_Pxy_l + surf_Pxy_r)),
    printf(fh, "~%"),
    writeCIncrExprsCollect1lhsc(div_p_y_comp, dx1*(-vol_Pyy_c + surf_Pyy_l + surf_Pyy_r)),
    printf(fh, "~%"),
    writeCIncrExprsCollect1lhsc(div_p_z_comp, dx1*(-vol_Pyz_c + surf_Pyz_l + surf_Pyz_r)),
    printf(fh, "~%"),
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC, bxby_e*grad_u_x_e + byby_e*grad_u_y_e + bybz_e*grad_u_z_e)
  )
  elseif (dir = 3) then (
    writeCIncrExprsCollect1lhsc(div_p_x_comp, dx1*(-vol_Pxz_c + surf_Pxz_l + surf_Pxz_r)),
    printf(fh, "~%"),
    writeCIncrExprsCollect1lhsc(div_p_y_comp, dx1*(-vol_Pyz_c + surf_Pyz_l + surf_Pyz_r)),
    printf(fh, "~%"),
    writeCIncrExprsCollect1lhsc(div_p_z_comp, dx1*(-vol_Pzz_c + surf_Pzz_l + surf_Pzz_r)),
    printf(fh, "~%"),
    bb_grad_u_comp_c : calcInnerProdList(varsC, 1, bC, bxbz_e*grad_u_x_e + bybz_e*grad_u_y_e + bzbz_e*grad_u_z_e)
  ),
  writeCExprs1(bb_grad_u_comp, bb_grad_u_comp_c),
  printf(fh, "~%"),
  flush_output(fh),
  bb_grad_u_e : doExpand1(bb_grad_u_comp, bC),
  bb_grad_u_c : calcInnerProdList(varsC, 1, bC, bb_grad_u_e),
  writeCIncrExprsCollect1lhsc(bb_grad_u, bb_grad_u_c),  
  printf(fh, "~%"),

  div_p_x_comp_e : doExpand1(div_p_x_comp, bC),
  div_p_y_comp_e : doExpand1(div_p_y_comp, bC),
  div_p_z_comp_e : doExpand1(div_p_z_comp, bC),
  div_p_x_c : calcInnerProdList(varsC, 1, bC, div_p_x_comp_e),
  div_p_y_c : calcInnerProdList(varsC, 1, bC, div_p_y_comp_e),
  div_p_z_c : calcInnerProdList(varsC, 1, bC, div_p_z_comp_e),

  if (polyOrder = 1 or polyOrder = 2) then (
    /* Hyper diffusion Jacobian factor 4th order with p=1 */
    hyper_rhoux_c : calcInnerProdList(varsC, 1, bC, diff(rhoux_rec, cv, 4)),
    hyper_rhouy_c : calcInnerProdList(varsC, 1, bC, diff(rhouy_rec, cv, 4)),
    hyper_rhouz_c : calcInnerProdList(varsC, 1, bC, diff(rhouz_rec, cv, 4))
  ),
  /*
  elseif polyOrder = 2 then (
    /* Hyper diffusion Jacobian factor 6th order with p=2 (NOTE MINUS SIGN) */
    hyper_rhoux_c : calcInnerProdList(varsC, 1, bC, -diff(rhoux_rec, cv, 6)),
    hyper_rhouy_c : calcInnerProdList(varsC, 1, bC, -diff(rhouy_rec, cv, 6)),
    hyper_rhouz_c : calcInnerProdList(varsC, 1, bC, -diff(rhouz_rec, cv, 6))
  ), */

  writeCIncrExprsCollect1lhsc(div_p_x, div_p_x_c + nuHyp*dxHyp*hyper_rhoux_c),
  printf(fh, "~%"),
  writeCIncrExprsCollect1lhsc(div_p_y, div_p_y_c + nuHyp*dxHyp*hyper_rhouy_c),
  printf(fh, "~%"),
  writeCIncrExprsCollect1lhsc(div_p_z, div_p_z_c + nuHyp*dxHyp*hyper_rhouz_c),
  printf(fh, "~%"),

  bx_over_rho_e : doExpand1(bx_over_rho, bC),
  by_over_rho_e : doExpand1(by_over_rho, bC),
  bz_over_rho_e : doExpand1(bz_over_rho, bC),
  T_perp_over_m_e : doExpand1(T_perp_over_m, bC),
  nu_e : doExpand1(nu, bC),

  p_force_c : calcInnerProdList(varsC, 1, bC, bx_over_rho_e*div_p_x_comp_e + by_over_rho_e*div_p_y_comp_e + bz_over_rho_e*div_p_z_comp_e),
  writeCIncrExprsCollect1lhsc(p_force, p_force_c),   
  printf(fh, "~%"),

  /* Configuration space components of vperp characteristics source: bb : grad(u) - div(u) - 2 nu */
  if (dir = 1) then (  
    p_perp_source_c : calcInnerProdList(varsC, 1, bC, bb_grad_u_e - grad_u_x_e - 2.0/cdim*nu_e)
  )
  elseif (dir = 2) then (
    p_perp_source_c : calcInnerProdList(varsC, 1, bC, bb_grad_u_e - grad_u_y_e - 2.0/cdim*nu_e)
  )
  elseif (dir = 3) then (
    p_perp_source_c : calcInnerProdList(varsC, 1, bC, bb_grad_u_e - grad_u_z_e - 2.0/cdim*nu_e)
  ),  
  writeCIncrExprsCollect1lhsc(p_perp_source, p_perp_source_c), 
  printf(fh, "~%"),

  p_perp_div_b_c : calcInnerProdList(varsC, 1, bC, T_perp_over_m_e*div_b_e),
  writeCIncrExprsCollect1lhsc(p_perp_div_b, p_perp_div_b_c),  
  printf(fh, "~%"),

  printf(fh, "} ~%")
)$
