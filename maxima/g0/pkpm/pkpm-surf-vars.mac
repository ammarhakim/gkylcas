/* This script generates the kernels for calculating the *surface* primitive 
   variables required to update the PKPM system. Surface primitive variables include:
   1. u_i, 3.0*Txx/m at left and right x surfaces
   2. u_i, 3.0*Tyy/m at left and right y surfaces
   3. u_i, 3.0*Tzz/m at left and right z surfaces 

   In 1D, these surface expansions can be generated with simple division. 
   In 2D/3D, these surface expansions require weak division and with p=1, we can
   still use the basis_inv method for increased computational efficiency. */

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
fpprec : 24$
cvars : [x, y, z]$

/* Special set of kernels which compute the surface primitive moments in 1D, which
   can be done with simple division without the need for a linear solve */
setPKPMSurfacePrimVars_1d(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, rhouxc_e, rhouyc_e, rhouzc_e, 
   rhouxc_l, rhouxc_r, rhouyc_l, rhouyc_r, rhouzc_l, rhouzc_r, 
   Pxxc_e, rhoc_e, Pxxc_l, Pxxc_r, rhoc_l, rhoc_r],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, 
  const double *vlasov_pkpm_moms, const double *euler_pkpm, 
  const double *p_ij_surf, const int *cell_avg_prim) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count:            integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A:                preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:              preallocated RHS vector. ~%"),
  printf(fh, "  // vlasov_pkpm_moms: Input [rho, p_parallel, p_perp], Moments computed from kinetic equation in pkpm model.~%"),
  printf(fh, "  // euler_pkpm:       Input [rho ux, rho uy, rho uz], Fluid state vector.~%"),
  printf(fh, "  // p_ij_surf:        Input surface expansion of p_ij = (p_par - p_perp) b_i b_j + p_perp g_ij.~%"),
  printf(fh, "  //                   [Pxx_xl, Pxx_xr, Pxy_xl, Pxy_xr, Pxz_xl, Pxz_xr, ~%"),
  printf(fh, "  //                    Pxy_yl, Pxy_yr, Pyy_yl, Pyy_yr, Pyz_yl, Pyz_yr, ~%"),
  printf(fh, "  //                    Pxz_zl, Pxz_zr, Pyz_zl, Pyz_zr, Pzz_zl, Pzz_zr] ~%"),
  printf(fh, "  // cell_avg_prim:    Boolean array to determine if we only use cell averages when computing surface expansions.~%"),
  printf(fh, "~%"),

  /* Surface primitive variables are organized as:
     [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, Txx_xl, Txx_xr, 
      ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, Tyy_yl, Tyy_yr, 
      ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr, Tzz_zl, Tzz_zr] */

  printf(fh, "  // For poly_order = 1, we can analytically invert the matrix and just store the solution ~%"),
  printf(fh, "  struct gkyl_mat rhs_ux_l = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_ux_r = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_l = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_r = gkyl_nmat_get(rhs, count+3); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_l = gkyl_nmat_get(rhs, count+4); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_r = gkyl_nmat_get(rhs, count+5); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Txx_l = gkyl_nmat_get(rhs, count+6); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Txx_r = gkyl_nmat_get(rhs, count+7); ~%"),

  printf(fh, "  // Clear rhs for each component of primitive variables being solved for ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_ux_l, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_ux_r, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uy_l, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uy_r, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uz_l, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uz_r, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_Txx_l, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_Txx_r, 0.0); ~%"),

  printf(fh, "  const double *rhoux = &euler_pkpm[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy = &euler_pkpm[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz = &euler_pkpm[~a]; ~%", 2*NC),

  printf(fh, "  const double *rho = &vlasov_pkpm_moms[~a]; ~%", 0*NC),

  printf(fh, "  const double *Pxx_xl = &p_ij_surf[~a]; ~%", 0),
  printf(fh, "  const double *Pxx_xr = &p_ij_surf[~a]; ~%", 1),

  rhouxc_e : doExpand1(rhoux, bC),
  rhouyc_e : doExpand1(rhouy, bC),
  rhouzc_e : doExpand1(rhouz, bC),

  rhouxc_l : subst(x=-1, rhouxc_e),
  rhouyc_l : subst(x=-1, rhouyc_e),
  rhouzc_l : subst(x=-1, rhouzc_e),

  rhouxc_r : subst(x=1, rhouxc_e),
  rhouyc_r : subst(x=1, rhouyc_e),
  rhouzc_r : subst(x=1, rhouzc_e),

  rhoc_e : doExpand1(rho, bC), 
  rhoc_l : subst(x=-1, rhoc_e),
  rhoc_r : subst(x=1, rhoc_e),

  /* Arrays for storing surface evaluation in 1D */
  printf(fh, "  double ux_l = 0.0; ~%"),
  printf(fh, "  double ux_r = 0.0; ~%"),
  printf(fh, "  double uy_l = 0.0; ~%"),
  printf(fh, "  double uy_r = 0.0; ~%"),
  printf(fh, "  double uz_l = 0.0; ~%"),
  printf(fh, "  double uz_r = 0.0; ~%"),
  printf(fh, "  double Txx_l = 0.0; ~%"),
  printf(fh, "  double Txx_r = 0.0; ~%"),
  printf(fh, "  if (cell_avg_prim[0]) { ~%"),

  printf(fh, "  // If rho or p_perp < 0 at control points, only use cell average. ~%"),
  printf(fh, "  ux_l = rhoux[0]/rho[0]; ~%"),
  printf(fh, "  ux_r = rhoux[0]/rho[0]; ~%"),
  printf(fh, "  uy_l = rhouy[0]/rho[0]; ~%"),
  printf(fh, "  uy_r = rhouy[0]/rho[0]; ~%"),
  printf(fh, "  uz_l = rhouz[0]/rho[0]; ~%"),
  printf(fh, "  uz_r = rhouz[0]/rho[0]; ~%"),
  printf(fh, "  Txx_l = Pxx_xl[0]/rho[0]; ~%"),
  printf(fh, "  Txx_r = Pxx_xr[0]/rho[0]; ~%"),

  printf(fh, "  } else { ~%"),

  printf(fh, "  double rhoux_l = ~a; ~%", float(expand(rhouxc_l))),
  printf(fh, "  double rhoux_r = ~a; ~%", float(expand(rhouxc_r))),
  printf(fh, "  double rhouy_l = ~a; ~%", float(expand(rhouyc_l))),
  printf(fh, "  double rhouy_r = ~a; ~%", float(expand(rhouyc_r))),
  printf(fh, "  double rhouz_l = ~a; ~%", float(expand(rhouzc_l))),
  printf(fh, "  double rhouz_r = ~a; ~%", float(expand(rhouzc_r))),
  printf(fh, "  double rho_l = ~a; ~%", float(expand(rhoc_l))),
  printf(fh, "  double rho_r = ~a; ~%", float(expand(rhoc_r))),
  printf(fh, "  double Pxx_l = Pxx_xl[0]; ~%"),
  printf(fh, "  double Pxx_r = Pxx_xr[0]; ~%"),

  printf(fh, "  ux_l = rhoux_l/rho_l; ~%"),
  printf(fh, "  ux_r = rhoux_r/rho_r; ~%"),
  printf(fh, "  uy_l = rhouy_l/rho_l; ~%"),
  printf(fh, "  uy_r = rhouy_r/rho_r; ~%"),
  printf(fh, "  uz_l = rhouz_l/rho_l; ~%"),
  printf(fh, "  uz_r = rhouz_r/rho_r; ~%"),
  printf(fh, "  Txx_l = Pxx_xl[0]/rho_l; ~%"),
  printf(fh, "  Txx_r = Pxx_xr[0]/rho_r; ~%"),
   
  printf(fh, "  } ~%"),
  printf(fh, " ~%"),

  printf(fh,"  gkyl_mat_set(&rhs_ux_l,0,0,ux_l); ~%"),
  printf(fh,"  gkyl_mat_set(&rhs_ux_r,0,0,ux_r); ~%"),
  printf(fh,"  gkyl_mat_set(&rhs_uy_l,0,0,uy_l); ~%"),
  printf(fh,"  gkyl_mat_set(&rhs_uy_r,0,0,uy_r); ~%"),
  printf(fh,"  gkyl_mat_set(&rhs_uz_l,0,0,uz_l); ~%"),
  printf(fh,"  gkyl_mat_set(&rhs_uz_r,0,0,uz_r); ~%"),
  printf(fh,"  gkyl_mat_set(&rhs_Txx_l,0,0,3.0*Txx_l); ~%"),
  printf(fh,"  gkyl_mat_set(&rhs_Txx_r,0,0,3.0*Txx_r); ~%"),

  printf(fh, "} ~%")
)$

/* Special set of kernels which compute the surface primitive moments in 2D and 3D for p=1, 
   which can be done with basis_inv without the need for a linear solve */
setPKPMSurfacePrimVars_p1(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, surfVarsx, bSurfx, surfVarsy, bSurfy, surfVarsz, bSurfz, NSurf, 
   rhouxc_e, rhouyc_e, rhouzc_e, 
   rhoux_xl_c, rhoux_xr_c, rhoux_yl_c, rhoux_yr_c, rhoux_zl_c, rhoux_zr_c, 
   rhouy_xl_c, rhouy_xr_c, rhouy_yl_c, rhouy_yr_c, rhouy_zl_c, rhouy_zr_c, 
   rhouz_xl_c, rhouz_xr_c, rhouz_yl_c, rhouz_yr_c, rhouz_zl_c, rhouz_zr_c, 
   Pxxc_e, Pyyc_e, Pzzc_e, rhoc_e, 
   Pxx_xl_c, Pxx_xr_c, Pyy_yl_c, Pyy_yr_c, Pzz_zl_c, Pzz_zr_c, 
   rho_xl_c, rho_xr_c, rho_yl_c, rho_yr_c, rho_zl_c, rho_zr_c],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  surfVarsx : delete(x,varsC),
  bSurfx : basisFromVars(basisFun,surfVarsx,polyOrder),
  surfVarsy : delete(y,varsC),
  bSurfy : basisFromVars(basisFun,surfVarsy,polyOrder),
  if (cdim = 3) then (
    surfVarsz : delete(z,varsC),
    bSurfz : basisFromVars(basisFun,surfVarsz,polyOrder)
  ),

  /* Number of basis monomials. */
  NC : length(bC),
  NSurf : length(bSurfx), 

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_inv.h> ~%", basisFun, cdim-1, polyOrder),
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, 
  const double *vlasov_pkpm_moms, const double *euler_pkpm, 
  const double *p_ij_surf, const int *cell_avg_prim) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count:            integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A:                preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:              preallocated RHS vector. ~%"),
  printf(fh, "  // vlasov_pkpm_moms: Input [rho, p_parallel, p_perp], Moments computed from kinetic equation in pkpm model.~%"),
  printf(fh, "  // euler_pkpm:       Input [rho ux, rho uy, rho uz], Fluid input state vector.~%"),
  printf(fh, "  // p_ij_surf:        Input surface expansion of p_ij = (p_par - p_perp) b_i b_j + p_perp g_ij.~%"),
  printf(fh, "  //                   [Pxx_xl, Pxx_xr, Pxy_xl, Pxy_xr, Pxz_xl, Pxz_xr, ~%"),
  printf(fh, "  //                    Pxy_yl, Pxy_yr, Pyy_yl, Pyy_yr, Pyz_yl, Pyz_yr, ~%"),
  printf(fh, "  //                    Pxz_zl, Pxz_zr, Pyz_zl, Pyz_zr, Pzz_zl, Pzz_zr] ~%"),
  printf(fh, "  // cell_avg_prim:    Boolean array to determine if we only use cell averages when computing surface expansions.~%"),
  printf(fh, "~%"),

  /* Surface primitive variables are organized as:
     [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, Txx_xl, Txx_xr, 
      ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, Tyy_yl, Tyy_yr, 
      ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr, Tzz_zl, Tzz_zr] */

  printf(fh, "  // For poly_order = 1, we can analytically invert the matrix and just store the solution ~%"),
  printf(fh, "  struct gkyl_mat rhs_ux_xl = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_ux_xr = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_xl = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_xr = gkyl_nmat_get(rhs, count+3); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_xl = gkyl_nmat_get(rhs, count+4); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_xr = gkyl_nmat_get(rhs, count+5); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Txx_xl = gkyl_nmat_get(rhs, count+6); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Txx_xr = gkyl_nmat_get(rhs, count+7); ~%"),

  printf(fh, "  struct gkyl_mat rhs_ux_yl = gkyl_nmat_get(rhs, count+8); ~%"),
  printf(fh, "  struct gkyl_mat rhs_ux_yr = gkyl_nmat_get(rhs, count+9); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_yl = gkyl_nmat_get(rhs, count+10); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_yr = gkyl_nmat_get(rhs, count+11); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_yl = gkyl_nmat_get(rhs, count+12); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_yr = gkyl_nmat_get(rhs, count+13); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Tyy_yl = gkyl_nmat_get(rhs, count+14); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Tyy_yr = gkyl_nmat_get(rhs, count+15); ~%"),

  if (cdim = 3) then (
    printf(fh, "  struct gkyl_mat rhs_ux_zl = gkyl_nmat_get(rhs, count+16); ~%"),
    printf(fh, "  struct gkyl_mat rhs_ux_zr = gkyl_nmat_get(rhs, count+17); ~%"),
    printf(fh, "  struct gkyl_mat rhs_uy_zl = gkyl_nmat_get(rhs, count+18); ~%"),
    printf(fh, "  struct gkyl_mat rhs_uy_zr = gkyl_nmat_get(rhs, count+19); ~%"),
    printf(fh, "  struct gkyl_mat rhs_uz_zl = gkyl_nmat_get(rhs, count+20); ~%"),
    printf(fh, "  struct gkyl_mat rhs_uz_zr = gkyl_nmat_get(rhs, count+21); ~%"),
    printf(fh, "  struct gkyl_mat rhs_Tzz_zl = gkyl_nmat_get(rhs, count+22); ~%"),
    printf(fh, "  struct gkyl_mat rhs_Tzz_zr = gkyl_nmat_get(rhs, count+23); ~%")
  ),

  printf(fh, "  // Clear rhs for each component of primitive variables being solved for ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_ux_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_ux_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uy_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uy_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uz_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uz_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_Txx_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_Txx_xr, 0.0); ~%"),

  printf(fh, "  gkyl_mat_clear(&rhs_ux_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_ux_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uy_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uy_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uz_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_uz_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_Tyy_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&rhs_Tyy_yr, 0.0); ~%"),

  if (cdim = 3) then (
    printf(fh, "  gkyl_mat_clear(&rhs_ux_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_ux_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_uy_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_uy_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_uz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_uz_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_Tzz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&rhs_Tzz_zr, 0.0); ~%")
  ),

  printf(fh, "  const double *rhoux = &euler_pkpm[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy = &euler_pkpm[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz = &euler_pkpm[~a]; ~%", 2*NC),

  printf(fh, "  const double *rho = &vlasov_pkpm_moms[~a]; ~%", 0*NC),

  printf(fh, "  const double *Pxx_xl = &p_ij_surf[~a]; ~%", 0*NSurf),
  printf(fh, "  const double *Pxx_xr = &p_ij_surf[~a]; ~%", 1*NSurf),
  printf(fh, "  const double *Pyy_yl = &p_ij_surf[~a]; ~%", 8*NSurf),
  printf(fh, "  const double *Pyy_yr = &p_ij_surf[~a]; ~%", 9*NSurf),

  rhouxc_e : doExpand1(rhoux, bC),
  rhouyc_e : doExpand1(rhouy, bC),
  rhouzc_e : doExpand1(rhouz, bC),

  rhoux_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, rhouxc_e)),
  rhouy_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, rhouyc_e)),
  rhouz_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, rhouzc_e)),

  rhoux_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, rhouxc_e)),
  rhouy_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, rhouyc_e)),
  rhouz_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, rhouzc_e)),

  rhoux_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, rhouxc_e)),
  rhouy_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, rhouyc_e)),
  rhouz_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, rhouzc_e)),

  rhoux_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, rhouxc_e)),
  rhouy_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, rhouyc_e)),
  rhouz_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, rhouzc_e)),

  rhoc_e : doExpand1(rho, bC), 
  rho_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, rhoc_e)),
  rho_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, rhoc_e)),
  rho_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, rhoc_e)),
  rho_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, rhoc_e)),

  if (cdim = 3) then (
    printf(fh, "  const double *Pzz_zl = &p_ij_surf[~a]; ~%", 16*NSurf),
    printf(fh, "  const double *Pzz_zr = &p_ij_surf[~a]; ~%", 17*NSurf),
    rhoux_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, rhouxc_e)),
    rhouy_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, rhouyc_e)),
    rhouz_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, rhouzc_e)),

    rhoux_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, rhouxc_e)),
    rhouy_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, rhouyc_e)),
    rhouz_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, rhouzc_e)), 

    rho_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, rhoc_e)),
    rho_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, rhoc_e))
  ),

  /* Arrays for storing surface evaluation expansion */
  printf(fh, "  double ux_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double ux_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uy_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uy_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uz_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uz_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Txx_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Txx_xr[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double ux_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double ux_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uy_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uy_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uz_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double uz_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Tyy_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Tyy_yr[~a] = {0.0}; ~%", NSurf),
  if (cdim = 3) then (
    printf(fh, "  double ux_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double ux_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double uy_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double uy_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double uz_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double uz_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double Tzz_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double Tzz_zr[~a] = {0.0}; ~%", NSurf)
  ),

  printf(fh, "  if (cell_avg_prim[0]) { ~%"),

  printf(fh, "  // If rho or p_perp < 0 at control points, only use cell average. ~%"),
  printf(fh, "  ux_xl[0] = rhoux[0]/rho[0]; ~%"),
  printf(fh, "  ux_xr[0] = rhoux[0]/rho[0]; ~%"),
  printf(fh, "  uy_xl[0] = rhouy[0]/rho[0]; ~%"),
  printf(fh, "  uy_xr[0] = rhouy[0]/rho[0]; ~%"),
  printf(fh, "  uz_xl[0] = rhouz[0]/rho[0]; ~%"),
  printf(fh, "  uz_xr[0] = rhouz[0]/rho[0]; ~%"),
  printf(fh, "  Txx_xl[0] = Pxx_xl[0]/rho[0]; ~%"),
  printf(fh, "  Txx_xr[0] = Pxx_xr[0]/rho[0]; ~%"),

  printf(fh, "  ux_yl[0] = rhoux[0]/rho[0]; ~%"),
  printf(fh, "  ux_yr[0] = rhoux[0]/rho[0]; ~%"),
  printf(fh, "  uy_yl[0] = rhouy[0]/rho[0]; ~%"),
  printf(fh, "  uy_yr[0] = rhouy[0]/rho[0]; ~%"),
  printf(fh, "  uz_yl[0] = rhouz[0]/rho[0]; ~%"),
  printf(fh, "  uz_yr[0] = rhouz[0]/rho[0]; ~%"),
  printf(fh, "  Tyy_yl[0] = Pyy_yl[0]/rho[0]; ~%"),
  printf(fh, "  Tyy_yr[0] = Pyy_yr[0]/rho[0]; ~%"),

  if (cdim = 3) then (
    printf(fh, "  ux_zl[0] = rhoux[0]/rho[0]; ~%"),
    printf(fh, "  ux_zr[0] = rhoux[0]/rho[0]; ~%"),
    printf(fh, "  uy_zl[0] = rhouy[0]/rho[0]; ~%"),
    printf(fh, "  uy_zr[0] = rhouy[0]/rho[0]; ~%"),
    printf(fh, "  uz_zl[0] = rhouz[0]/rho[0]; ~%"),
    printf(fh, "  uz_zr[0] = rhouz[0]/rho[0]; ~%"),
    printf(fh, "  Tzz_zl[0] = Pzz_zl[0]/rho[0]; ~%"),
    printf(fh, "  Tzz_zr[0] = Pzz_zr[0]/rho[0]; ~%")
  ),

  printf(fh, "  } else { ~%"),
  /* Temporary arrays for storing surface expansions of rhou, rho and P_ii at x surfaces */
  printf(fh, "  double rhoux_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhoux_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouy_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouy_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouz_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouz_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_inv_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_inv_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  writeCExprs1(rhoux_xl, rhoux_xl_c), 
  writeCExprs1(rhoux_xr, rhoux_xr_c), 
  writeCExprs1(rhouy_xl, rhouy_xl_c), 
  writeCExprs1(rhouy_xr, rhouy_xr_c), 
  writeCExprs1(rhouz_xl, rhouz_xl_c), 
  writeCExprs1(rhouz_xr, rhouz_xr_c), 
  writeCExprs1(rho_xl, rho_xl_c), 
  writeCExprs1(rho_xr, rho_xr_c), 

  printf(fh, "  ~a_~ax_p~a_inv(rho_xl, rho_inv_xl); ~%", basisFun, cdim-1, polyOrder),
  printf(fh, "  ~a_~ax_p~a_inv(rho_xr, rho_inv_xr); ~%", basisFun, cdim-1, polyOrder),

  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_xl, rhoux_xl, ux_xl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_xr, rhoux_xr, ux_xr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_xl, rhouy_xl, uy_xl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_xr, rhouy_xr, uy_xr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_xl, rhouz_xl, uz_xl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_xr, rhouz_xr, uz_xr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_xl, Pxx_xl, Txx_xl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_xr, Pxx_xr, Txx_xr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, " ~%"), 

  /* Temporary arrays for storing surface expansions of rhou, rho and P_ii at y surfaces */
  printf(fh, "  double rhoux_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhoux_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouy_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouy_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouz_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouz_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_inv_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_inv_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  writeCExprs1(rhoux_yl, rhoux_yl_c), 
  writeCExprs1(rhoux_yr, rhoux_yr_c), 
  writeCExprs1(rhouy_yl, rhouy_yl_c), 
  writeCExprs1(rhouy_yr, rhouy_yr_c), 
  writeCExprs1(rhouz_yl, rhouz_yl_c), 
  writeCExprs1(rhouz_yr, rhouz_yr_c), 
  writeCExprs1(rho_yl, rho_yl_c), 
  writeCExprs1(rho_yr, rho_yr_c), 

  printf(fh, "  ~a_~ax_p~a_inv(rho_yl, rho_inv_yl); ~%", basisFun, cdim-1, polyOrder),
  printf(fh, "  ~a_~ax_p~a_inv(rho_yr, rho_inv_yr); ~%", basisFun, cdim-1, polyOrder),

  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_yl, rhoux_yl, ux_yl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_yr, rhoux_yr, ux_yr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_yl, rhouy_yl, uy_yl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_yr, rhouy_yr, uy_yr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_yl, rhouz_yl, uz_yl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_yr, rhouz_yr, uz_yr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_yl, Pyy_yl, Tyy_yl); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_yr, Pyy_yr, Tyy_yr); ~%", cdim-1, basisFun, polyOrder),
  printf(fh, " ~%"), 
  if (cdim = 3) then (
    /* Temporary arrays for storing surface expansions of rhou, rho and P_ii at z surfaces */
    printf(fh, "  double rhoux_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhoux_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhouy_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhouy_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhouz_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhouz_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rho_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rho_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rho_inv_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rho_inv_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, " ~%"),

    writeCExprs1(rhoux_zl, rhoux_zl_c), 
    writeCExprs1(rhoux_zr, rhoux_zr_c), 
    writeCExprs1(rhouy_zl, rhouy_zl_c), 
    writeCExprs1(rhouy_zr, rhouy_zr_c), 
    writeCExprs1(rhouz_zl, rhouz_zl_c), 
    writeCExprs1(rhouz_zr, rhouz_zr_c), 
    writeCExprs1(rho_zl, rho_zl_c), 
    writeCExprs1(rho_zr, rho_zr_c), 

    printf(fh, "  ~a_~ax_p~a_inv(rho_zl, rho_inv_zl); ~%", basisFun, cdim-1, polyOrder),
    printf(fh, "  ~a_~ax_p~a_inv(rho_zr, rho_inv_zr); ~%", basisFun, cdim-1, polyOrder),

    printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_zl, rhoux_zl, ux_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_zr, rhoux_zr, ux_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_zl, rhouy_zl, uy_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_zr, rhouy_zr, uy_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_zl, rhouz_zl, uz_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_zr, rhouz_zr, uz_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_zl, Pzz_zl, Tzz_zl); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(rho_inv_zr, Pzz_zr, Tzz_zr); ~%", cdim-1, basisFun, polyOrder),
    printf(fh, " ~%")
  ),

  printf(fh, "  } ~%"),
  printf(fh, " ~%"),

  for i : 1 thru NSurf do (
    printf(fh,"  gkyl_mat_set(&rhs_ux_xl,~a,0,ux_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_ux_xr,~a,0,ux_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uy_xl,~a,0,uy_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uy_xr,~a,0,uy_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uz_xl,~a,0,uz_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uz_xr,~a,0,uz_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_Txx_xl,~a,0,3.0*Txx_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_Txx_xr,~a,0,3.0*Txx_xr[~a]); ~%", i-1, i-1),
    printf(fh, " ~%"), 
    printf(fh,"  gkyl_mat_set(&rhs_ux_yl,~a,0,ux_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_ux_yr,~a,0,ux_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uy_yl,~a,0,uy_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uy_yr,~a,0,uy_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uz_yl,~a,0,uz_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uz_yr,~a,0,uz_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_Tyy_yl,~a,0,3.0*Tyy_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_Tyy_yr,~a,0,3.0*Tyy_yr[~a]); ~%", i-1, i-1),
    printf(fh, " ~%"), 
    if (cdim = 3) then (
      printf(fh,"  gkyl_mat_set(&rhs_ux_zl,~a,0,ux_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_ux_zr,~a,0,ux_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_uy_zl,~a,0,uy_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_uy_zr,~a,0,uy_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_uz_zl,~a,0,uz_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_uz_zr,~a,0,uz_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_Tzz_zl,~a,0,3.0*Tzz_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_Tzz_zr,~a,0,3.0*Tzz_zr[~a]); ~%", i-1, i-1),
      printf(fh, " ~%")
    )
  ),
  printf(fh, "} ~%")
)$

/* Kernels for constructing the linear solve in cdim > 1 with p > 1 */
setPKPMSurfacePrimVars(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, surfVarsx, bSurfx, surfVarsy, bSurfy, surfVarsz, bSurfz, NSurf, 
   rhouxc_e, rhouyc_e, rhouzc_e, 
   rhoux_xl_c, rhoux_xr_c, rhoux_yl_c, rhoux_yr_c, rhoux_zl_c, rhoux_zr_c, 
   rhouy_xl_c, rhouy_xr_c, rhouy_yl_c, rhouy_yr_c, rhouy_zl_c, rhouy_zr_c, 
   rhouz_xl_c, rhouz_xr_c, rhouz_yl_c, rhouz_yr_c, rhouz_zl_c, rhouz_zr_c, 
   Pxxc_e, Pyyc_e, Pzzc_e, rhoc_e, 
   Pxx_xl_c, Pxx_xr_c, Pyy_yl_c, Pyy_yr_c, Pzz_zl_c, Pzz_zr_c, 
   rho_xl_c, rho_xr_c, rho_yl_c, rho_yr_c, rho_zl_c, rho_zr_c, 
   rho_xl_e, rho_xr_e, rho_yl_e, rho_yr_e, rho_zl_e, rho_zr_e, 
   uxe, uxn, eq_rho_xl, E_rho_xl, eq_rho_xr, E_rho_xr, 
   uye, uyn, eq_rho_yl, E_rho_yl, eq_rho_yr, E_rho_yr, 
   uze, uzn, eq_rho_zl, E_rho_zl, eq_rho_zr, E_rho_zr],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  surfVarsx : delete(x,varsC),
  bSurfx : basisFromVars(basisFun,surfVarsx,polyOrder),
  surfVarsy : delete(y,varsC),
  bSurfy : basisFromVars(basisFun,surfVarsy,polyOrder),
  if (cdim = 3) then (
    surfVarsz : delete(z,varsC),
    bSurfz : basisFromVars(basisFun,surfVarsz,polyOrder)
  ),

  /* Number of basis monomials. */
  NC : length(bC),
  NSurf : length(bSurfx), 

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *A, struct gkyl_nmat *rhs, 
  const double *vlasov_pkpm_moms, const double *euler_pkpm, 
  const double *p_ij_surf, const int *cell_avg_prim) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count:            integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // A:                preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:              preallocated RHS vector. ~%"),
  printf(fh, "  // vlasov_pkpm_moms: [rho, p_parallel, p_perp], Moments computed from kinetic equation in pkpm model.~%"),
  printf(fh, "  // euler_pkpm:       [rho ux, rho uy, rho uz], Fluid input state vector.~%"),
  printf(fh, "  // p_ij_surf:        Input surface expansion of p_ij = (p_par - p_perp) b_i b_j + p_perp g_ij.~%"),
  printf(fh, "  //                   [Pxx_xl, Pxx_xr, Pxy_xl, Pxy_xr, Pxz_xl, Pxz_xr, ~%"),
  printf(fh, "  //                    Pxy_yl, Pxy_yr, Pyy_yl, Pyy_yr, Pyz_yl, Pyz_yr, ~%"),
  printf(fh, "  //                    Pxz_zl, Pxz_zr, Pyz_zl, Pyz_zr, Pzz_zl, Pzz_zr] ~%"),
  printf(fh, "  // cell_avg_prim:    Boolean array to determine if we only use cell averages when computing surface expansions.~%"),
  printf(fh, "~%"),

  /* Surface primitive variables are organized as:
     [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, Txx_xl, Txx_xr, 
      ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, Tyy_yl, Tyy_yr, 
      ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr, Tzz_zl, Tzz_zr] */

  printf(fh, "  struct gkyl_mat A_ux_xl = gkyl_nmat_get(A, count); ~%"),
  printf(fh, "  struct gkyl_mat A_ux_xr = gkyl_nmat_get(A, count+1); ~%"),
  printf(fh, "  struct gkyl_mat A_uy_xl = gkyl_nmat_get(A, count+2); ~%"),
  printf(fh, "  struct gkyl_mat A_uy_xr = gkyl_nmat_get(A, count+3); ~%"),
  printf(fh, "  struct gkyl_mat A_uz_xl = gkyl_nmat_get(A, count+4); ~%"),
  printf(fh, "  struct gkyl_mat A_uz_xr = gkyl_nmat_get(A, count+5); ~%"),
  printf(fh, "  struct gkyl_mat A_Txx_xl = gkyl_nmat_get(A, count+6); ~%"),
  printf(fh, "  struct gkyl_mat A_Txx_xr = gkyl_nmat_get(A, count+7); ~%"),

  printf(fh, "  struct gkyl_mat A_ux_yl = gkyl_nmat_get(A, count+8); ~%"),
  printf(fh, "  struct gkyl_mat A_ux_yr = gkyl_nmat_get(A, count+9); ~%"),
  printf(fh, "  struct gkyl_mat A_uy_yl = gkyl_nmat_get(A, count+10); ~%"),
  printf(fh, "  struct gkyl_mat A_uy_yr = gkyl_nmat_get(A, count+11); ~%"),
  printf(fh, "  struct gkyl_mat A_uz_yl = gkyl_nmat_get(A, count+12); ~%"),
  printf(fh, "  struct gkyl_mat A_uz_yr = gkyl_nmat_get(A, count+13); ~%"),
  printf(fh, "  struct gkyl_mat A_Tyy_yl = gkyl_nmat_get(A, count+14); ~%"),
  printf(fh, "  struct gkyl_mat A_Tyy_yr = gkyl_nmat_get(A, count+15); ~%"),

  printf(fh, "  struct gkyl_mat rhs_ux_xl = gkyl_nmat_get(rhs, count); ~%"),
  printf(fh, "  struct gkyl_mat rhs_ux_xr = gkyl_nmat_get(rhs, count+1); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_xl = gkyl_nmat_get(rhs, count+2); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_xr = gkyl_nmat_get(rhs, count+3); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_xl = gkyl_nmat_get(rhs, count+4); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_xr = gkyl_nmat_get(rhs, count+5); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Txx_xl = gkyl_nmat_get(rhs, count+6); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Txx_xr = gkyl_nmat_get(rhs, count+7); ~%"),

  printf(fh, "  struct gkyl_mat rhs_ux_yl = gkyl_nmat_get(rhs, count+8); ~%"),
  printf(fh, "  struct gkyl_mat rhs_ux_yr = gkyl_nmat_get(rhs, count+9); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_yl = gkyl_nmat_get(rhs, count+10); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uy_yr = gkyl_nmat_get(rhs, count+11); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_yl = gkyl_nmat_get(rhs, count+12); ~%"),
  printf(fh, "  struct gkyl_mat rhs_uz_yr = gkyl_nmat_get(rhs, count+13); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Tyy_yl = gkyl_nmat_get(rhs, count+14); ~%"),
  printf(fh, "  struct gkyl_mat rhs_Tyy_yr = gkyl_nmat_get(rhs, count+15); ~%"),

  if (cdim = 3) then (
    printf(fh, "  struct gkyl_mat A_ux_zl = gkyl_nmat_get(A, count+16); ~%"),
    printf(fh, "  struct gkyl_mat A_ux_zr = gkyl_nmat_get(A, count+17); ~%"),
    printf(fh, "  struct gkyl_mat A_uy_zl = gkyl_nmat_get(A, count+18); ~%"),
    printf(fh, "  struct gkyl_mat A_uy_zr = gkyl_nmat_get(A, count+19); ~%"),
    printf(fh, "  struct gkyl_mat A_uz_zl = gkyl_nmat_get(A, count+20); ~%"),
    printf(fh, "  struct gkyl_mat A_uz_zr = gkyl_nmat_get(A, count+21); ~%"),
    printf(fh, "  struct gkyl_mat A_Tzz_zl = gkyl_nmat_get(A, count+22); ~%"),
    printf(fh, "  struct gkyl_mat A_Tzz_zr = gkyl_nmat_get(A, count+23); ~%"),

    printf(fh, "  struct gkyl_mat rhs_ux_zl = gkyl_nmat_get(rhs, count+16); ~%"),
    printf(fh, "  struct gkyl_mat rhs_ux_zr = gkyl_nmat_get(rhs, count+17); ~%"),
    printf(fh, "  struct gkyl_mat rhs_uy_zl = gkyl_nmat_get(rhs, count+18); ~%"),
    printf(fh, "  struct gkyl_mat rhs_uy_zr = gkyl_nmat_get(rhs, count+19); ~%"),
    printf(fh, "  struct gkyl_mat rhs_uz_zl = gkyl_nmat_get(rhs, count+20); ~%"),
    printf(fh, "  struct gkyl_mat rhs_uz_zr = gkyl_nmat_get(rhs, count+21); ~%"),
    printf(fh, "  struct gkyl_mat rhs_Tzz_zl = gkyl_nmat_get(rhs, count+22); ~%"),
    printf(fh, "  struct gkyl_mat rhs_Tzz_zr = gkyl_nmat_get(rhs, count+23); ~%")
  ),

  printf(fh, "  // Clear A and rhs for each component of primitive variables being solved for ~%"),
  printf(fh, "  gkyl_mat_clear(&A_ux_xl, 0.0); gkyl_mat_clear(&rhs_ux_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_ux_xr, 0.0); gkyl_mat_clear(&rhs_ux_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uy_xl, 0.0); gkyl_mat_clear(&rhs_uy_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uy_xr, 0.0); gkyl_mat_clear(&rhs_uy_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uz_xl, 0.0); gkyl_mat_clear(&rhs_uz_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uz_xr, 0.0); gkyl_mat_clear(&rhs_uz_xr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_Txx_xl, 0.0); gkyl_mat_clear(&rhs_Txx_xl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_Txx_xr, 0.0); gkyl_mat_clear(&rhs_Txx_xr, 0.0); ~%"),

  printf(fh, "  gkyl_mat_clear(&A_ux_yl, 0.0); gkyl_mat_clear(&rhs_ux_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_ux_yr, 0.0); gkyl_mat_clear(&rhs_ux_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uy_yl, 0.0); gkyl_mat_clear(&rhs_uy_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uy_yr, 0.0); gkyl_mat_clear(&rhs_uy_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uz_yl, 0.0); gkyl_mat_clear(&rhs_uz_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_uz_yr, 0.0); gkyl_mat_clear(&rhs_uz_yr, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_Tyy_yl, 0.0); gkyl_mat_clear(&rhs_Tyy_yl, 0.0); ~%"),
  printf(fh, "  gkyl_mat_clear(&A_Tyy_yr, 0.0); gkyl_mat_clear(&rhs_Tyy_yr, 0.0); ~%"),

  if (cdim = 3) then (
    printf(fh, "  gkyl_mat_clear(&A_ux_zl, 0.0); gkyl_mat_clear(&rhs_ux_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_ux_zr, 0.0); gkyl_mat_clear(&rhs_ux_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_uy_zl, 0.0); gkyl_mat_clear(&rhs_uy_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_uy_zr, 0.0); gkyl_mat_clear(&rhs_uy_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_uz_zl, 0.0); gkyl_mat_clear(&rhs_uz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_uz_zr, 0.0); gkyl_mat_clear(&rhs_uz_zr, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_Tzz_zl, 0.0); gkyl_mat_clear(&rhs_Tzz_zl, 0.0); ~%"),
    printf(fh, "  gkyl_mat_clear(&A_Tzz_zr, 0.0); gkyl_mat_clear(&rhs_Tzz_zr, 0.0); ~%")
  ),

  printf(fh, "  const double *rhoux = &euler_pkpm[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy = &euler_pkpm[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz = &euler_pkpm[~a]; ~%", 2*NC),

  printf(fh, "  const double *rho = &vlasov_pkpm_moms[~a]; ~%", 0*NC),

  printf(fh, "  const double *Pxx_xl = &p_ij_surf[~a]; ~%", 0*NSurf),
  printf(fh, "  const double *Pxx_xr = &p_ij_surf[~a]; ~%", 1*NSurf),
  printf(fh, "  const double *Pyy_yl = &p_ij_surf[~a]; ~%", 8*NSurf),
  printf(fh, "  const double *Pyy_yr = &p_ij_surf[~a]; ~%", 9*NSurf),

  rhouxc_e : doExpand1(rhoux, bC),
  rhouyc_e : doExpand1(rhouy, bC),
  rhouzc_e : doExpand1(rhouz, bC),

  rhoux_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, rhouxc_e)),
  rhouy_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, rhouyc_e)),
  rhouz_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, rhouzc_e)),

  rhoux_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, rhouxc_e)),
  rhouy_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, rhouyc_e)),
  rhouz_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, rhouzc_e)),

  rhoux_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, rhouxc_e)),
  rhouy_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, rhouyc_e)),
  rhouz_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, rhouzc_e)),

  rhoux_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, rhouxc_e)),
  rhouy_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, rhouyc_e)),
  rhouz_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, rhouzc_e)),

  rhoc_e : doExpand1(rho, bC), 
  rho_xl_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=-1, rhoc_e)),
  rho_xr_c : calcInnerProdList(surfVarsx, 1, bSurfx, subst(x=1, rhoc_e)),
  rho_yl_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=-1, rhoc_e)),
  rho_yr_c : calcInnerProdList(surfVarsy, 1, bSurfy, subst(y=1, rhoc_e)),

  if (cdim = 3) then (
    printf(fh, "  const double *Pzz_zl = &p_ij_surf[~a]; ~%", 16*NSurf),
    printf(fh, "  const double *Pzz_zr = &p_ij_surf[~a]; ~%", 17*NSurf),
    rhoux_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, rhouxc_e)),
    rhouy_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, rhouyc_e)),
    rhouz_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, rhouzc_e)),

    rhoux_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, rhouxc_e)),
    rhouy_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, rhouyc_e)),
    rhouz_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, rhouzc_e)), 

    rho_zl_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=-1, rhoc_e)),
    rho_zr_c : calcInnerProdList(surfVarsz, 1, bSurfz, subst(z=1, rhoc_e))
  ),

  /* Allocate and write out rho at interfaces for matrix construction */
  printf(fh, "  double rho_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_xr[~a] = {0.0}; ~%", NSurf),
  writeCExprs1(rho_xl, rho_xl_c), 
  writeCExprs1(rho_xr, rho_xr_c), 
  rho_xl_e : doExpand1(rho_xl, bSurfx),
  rho_xr_e : doExpand1(rho_xr, bSurfx),

  printf(fh, "  double rho_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rho_yr[~a] = {0.0}; ~%", NSurf),
  writeCExprs1(rho_yl, rho_yl_c), 
  writeCExprs1(rho_yr, rho_yr_c), 
  rho_yl_e : doExpand1(rho_yl, bSurfy),
  rho_yr_e : doExpand1(rho_yr, bSurfy),

  if (cdim = 3) then (
    printf(fh, "  double rho_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rho_zr[~a] = {0.0}; ~%", NSurf),
    writeCExprs1(rho_zl, rho_zl_c), 
    writeCExprs1(rho_zr, rho_zr_c),
    rho_zl_e : doExpand1(rho_zl, bSurfz),
    rho_zr_e : doExpand1(rho_zr, bSurfz)
  ),

  printf(fh, "  if (cell_avg_prim[0]) { ~%"),

  /* Zero out higher order components if using only cell averages */
  expr_rhoux : float(expand(append([rhoux[0]],makelist(0.0,i,1,NSurf-1)))),
  expr_rhouy : float(expand(append([rhouy[0]],makelist(0.0,i,1,NSurf-1)))),
  expr_rhouz : float(expand(append([rhouz[0]],makelist(0.0,i,1,NSurf-1)))),
  expr_Pxx_xl : float(expand(append([3.0*Pxx_xl[0]],makelist(0.0,i,1,NSurf-1)))),
  expr_Pxx_xr : float(expand(append([3.0*Pxx_xr[0]],makelist(0.0,i,1,NSurf-1)))),
  expr_Pyy_yl : float(expand(append([3.0*Pyy_yl[0]],makelist(0.0,i,1,NSurf-1)))),
  expr_Pyy_yr : float(expand(append([3.0*Pyy_yr[0]],makelist(0.0,i,1,NSurf-1)))),
  expr_Pzz_zl : float(expand(append([3.0*Pzz_zl[0]],makelist(0.0,i,1,NSurf-1)))),
  expr_Pzz_zr : float(expand(append([3.0*Pzz_zr[0]],makelist(0.0,i,1,NSurf-1)))),

  for i : 1 thru NSurf do (
    if (i = 1) then (
      printf(fh,"  rho_xl[~a] = rho[0]; ~%", i-1),
      printf(fh,"  rho_xr[~a] = rho[0]; ~%", i-1),
      printf(fh,"  rho_yl[~a] = rho[0]; ~%", i-1),
      printf(fh,"  rho_yr[~a] = rho[0]; ~%", i-1)
    )
    else (
      printf(fh,"  rho_xl[~a] = 0.0; ~%", i-1),
      printf(fh,"  rho_xr[~a] = 0.0; ~%", i-1),
      printf(fh,"  rho_yl[~a] = 0.0; ~%", i-1),
      printf(fh,"  rho_yr[~a] = 0.0; ~%", i-1)
    ),
    printf(fh, " ~%"), 
    printf(fh,"  gkyl_mat_set(&rhs_ux_xl,~a,0,~a); ~%", i-1, expr_rhoux[i]),
    printf(fh,"  gkyl_mat_set(&rhs_ux_xr,~a,0,~a); ~%", i-1, expr_rhoux[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uy_xl,~a,0,~a); ~%", i-1, expr_rhouy[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uy_xr,~a,0,~a); ~%", i-1, expr_rhouy[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uz_xl,~a,0,~a); ~%", i-1, expr_rhouz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uz_xr,~a,0,~a); ~%", i-1, expr_rhouz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_Txx_xl,~a,0,~a); ~%", i-1, expr_Pxx_xl[i]),
    printf(fh,"  gkyl_mat_set(&rhs_Txx_xr,~a,0,~a); ~%", i-1, expr_Pxx_xr[i]),
    printf(fh, " ~%"), 
    printf(fh,"  gkyl_mat_set(&rhs_ux_yl,~a,0,~a); ~%", i-1, expr_rhoux[i]),
    printf(fh,"  gkyl_mat_set(&rhs_ux_yr,~a,0,~a); ~%", i-1, expr_rhoux[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uy_yl,~a,0,~a); ~%", i-1, expr_rhouy[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uy_yr,~a,0,~a); ~%", i-1, expr_rhouy[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uz_yl,~a,0,~a); ~%", i-1, expr_rhouz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_uz_yr,~a,0,~a); ~%", i-1, expr_rhouz[i]),
    printf(fh,"  gkyl_mat_set(&rhs_Tyy_yl,~a,0,~a); ~%", i-1, expr_Pyy_yl[i]),
    printf(fh,"  gkyl_mat_set(&rhs_Tyy_yr,~a,0,~a); ~%", i-1, expr_Pyy_yr[i]),
    printf(fh, " ~%"), 
    if (cdim = 3) then (
      if (i = 1) then (
        printf(fh,"  rho_zl[~a] = rho[0]; ~%", i-1),
        printf(fh,"  rho_zr[~a] = rho[0]; ~%", i-1)
      )
      else (
        printf(fh,"  rho_zl[~a] = 0.0; ~%", i-1),
        printf(fh,"  rho_zr[~a] = 0.0; ~%", i-1)
      ),
      printf(fh, " ~%"), 
      printf(fh,"  gkyl_mat_set(&rhs_ux_zl,~a,0,~a); ~%", i-1, expr_rhoux[i]),
      printf(fh,"  gkyl_mat_set(&rhs_ux_zr,~a,0,~a); ~%", i-1, expr_rhoux[i]),
      printf(fh,"  gkyl_mat_set(&rhs_uy_zl,~a,0,~a); ~%", i-1, expr_rhouy[i]),
      printf(fh,"  gkyl_mat_set(&rhs_uy_zr,~a,0,~a); ~%", i-1, expr_rhouy[i]),
      printf(fh,"  gkyl_mat_set(&rhs_uz_zl,~a,0,~a); ~%", i-1, expr_rhouz[i]),
      printf(fh,"  gkyl_mat_set(&rhs_uz_zr,~a,0,~a); ~%", i-1, expr_rhouz[i]),
      printf(fh,"  gkyl_mat_set(&rhs_Txx_zl,~a,0,~a); ~%", i-1, expr_Pzz_zl[i]),
      printf(fh,"  gkyl_mat_set(&rhs_Txx_zr,~a,0,~a); ~%", i-1, expr_Pzz_zr[i]),
      printf(fh, " ~%")
    )
  ),

  printf(fh, "  } else { ~%"),
  
  /* Temporary arrays for storing surface expansions of rhou, rho and P_ii at x surfaces */
  printf(fh, "  double rhoux_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhoux_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouy_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouy_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouz_xl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouz_xr[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  writeCExprs1(rhoux_xl, rhoux_xl_c), 
  writeCExprs1(rhoux_xr, rhoux_xr_c), 
  writeCExprs1(rhouy_xl, rhouy_xl_c), 
  writeCExprs1(rhouy_xr, rhouy_xr_c), 
  writeCExprs1(rhouz_xl, rhouz_xl_c), 
  writeCExprs1(rhouz_xr, rhouz_xr_c), 

  /* Temporary arrays for storing surface expansions of rhou, rho and P_ii at y surfaces */
  printf(fh, "  double rhoux_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhoux_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouy_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouy_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouz_yl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double rhouz_yr[~a] = {0.0}; ~%", NSurf),
  printf(fh, " ~%"),

  writeCExprs1(rhoux_yl, rhoux_yl_c), 
  writeCExprs1(rhoux_yr, rhoux_yr_c), 
  writeCExprs1(rhouy_yl, rhouy_yl_c), 
  writeCExprs1(rhouy_yr, rhouy_yr_c), 
  writeCExprs1(rhouz_yl, rhouz_yl_c), 
  writeCExprs1(rhouz_yr, rhouz_yr_c), 
  printf(fh, " ~%"), 
  if (cdim = 3) then (
    /* Temporary arrays for storing surface expansions of rhou, rho and P_ii at z surfaces */
    printf(fh, "  double rhoux_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhoux_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhouy_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhouy_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhouz_zl[~a] = {0.0}; ~%", NSurf),
    printf(fh, "  double rhouz_zr[~a] = {0.0}; ~%", NSurf),
    printf(fh, " ~%"),

    writeCExprs1(rhoux_zl, rhoux_zl_c), 
    writeCExprs1(rhoux_zr, rhoux_zr_c), 
    writeCExprs1(rhouy_zl, rhouy_zl_c), 
    writeCExprs1(rhouy_zr, rhouy_zr_c), 
    writeCExprs1(rhouz_zl, rhouz_zl_c), 
    writeCExprs1(rhouz_zr, rhouz_zr_c), 
    printf(fh, " ~%")
  ),

  for i : 1 thru NSurf do (
    printf(fh,"  gkyl_mat_set(&rhs_ux_xl,~a,0,rhoux_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_ux_xr,~a,0,rhoux_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uy_xl,~a,0,rhouy_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uy_xr,~a,0,rhouy_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uz_xl,~a,0,rhouz_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uz_xr,~a,0,rhouz_xr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_Txx_xl,~a,0,3.0*Pxx_xl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_Txx_xr,~a,0,3.0*Pxx_xr[~a]); ~%", i-1, i-1),
    printf(fh, " ~%"), 
    printf(fh,"  gkyl_mat_set(&rhs_ux_yl,~a,0,rhoux_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_ux_yr,~a,0,rhoux_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uy_yl,~a,0,rhouy_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uy_yr,~a,0,rhouy_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uz_yl,~a,0,rhouz_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_uz_yr,~a,0,rhouz_yr[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_Tyy_yl,~a,0,3.0*Pyy_yl[~a]); ~%", i-1, i-1),
    printf(fh,"  gkyl_mat_set(&rhs_Tyy_yr,~a,0,3.0*Pyy_yr[~a]); ~%", i-1, i-1),
    printf(fh, " ~%"), 
    if (cdim = 3) then (
      printf(fh,"  gkyl_mat_set(&rhs_ux_zl,~a,0,rhoux_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_ux_zr,~a,0,rhoux_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_uy_zl,~a,0,rhouy_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_uy_zr,~a,0,rhouy_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_uz_zl,~a,0,rhouz_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_uz_zr,~a,0,rhouz_zr[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_Tzz_zl,~a,0,3.0*Pzz_zl[~a]); ~%", i-1, i-1),
      printf(fh,"  gkyl_mat_set(&rhs_Tzz_zr,~a,0,3.0*Pzz_zr[~a]); ~%", i-1, i-1),
      printf(fh, " ~%")
    )
  ),
  printf(fh, "  } ~%"),
  printf(fh, " ~%"),
  /* Generate matrix of unknown coefficients for x surfaces */
  uxe : doExpand1(ux,bSurfx),
  uxn : makelist(ux[i],i,0,NSurf-1),
  eq_rho_xl : calcInnerProdList(surfVarsx,uxe,bSurfx,rho_xl_e),
  E_rho_xl : fullratsimp(coefmatrix(eq_rho_xl,uxn)),
  eq_rho_xr : calcInnerProdList(surfVarsx,uxe,bSurfx,rho_xr_e),
  E_rho_xr : fullratsimp(coefmatrix(eq_rho_xr,uxn)),

  /* Generate matrix of unknown coefficients for y surfaces */
  uye : doExpand1(uy,bSurfy),
  uyn : makelist(uy[i],i,0,NSurf-1),
  eq_rho_yl : calcInnerProdList(surfVarsy,uye,bSurfy,rho_yl_e),
  E_rho_yl : fullratsimp(coefmatrix(eq_rho_yl,uyn)),
  eq_rho_yr : calcInnerProdList(surfVarsy,uye,bSurfy,rho_yr_e),
  E_rho_yr : fullratsimp(coefmatrix(eq_rho_yr,uyn)),

  /* declare temporary variables since multiple matrix entries in A are the same */
  printf(fh, "  double temp_rho_xl = 0.0; ~%"),
  printf(fh, "  double temp_rho_xr = 0.0; ~%"),
  printf(fh, "  double temp_rho_yl = 0.0; ~%"),
  printf(fh, "  double temp_rho_yr = 0.0; ~%"),

  /* Generate matrix of unknown coefficients and temporary variables for z surfaces */
  if (cdim = 3) then (
    uze : doExpand1(uz,bSurfz),
    uzn : makelist(uz[i],i,0,NSurf-1),
    eq_rho_zl : calcInnerProdList(surfVarsz,uze,bSurfz,rho_zl_e),
    E_rho_zl : fullratsimp(coefmatrix(eq_rho_zl,uzn)),
    eq_rho_zr : calcInnerProdList(surfVarsz,uze,bSurfz,rho_zr_e),
    E_rho_zr : fullratsimp(coefmatrix(eq_rho_zr,uzn)),
    printf(fh, "  double temp_rho_zl = 0.0; ~%"),
    printf(fh, "  double temp_rho_zr = 0.0; ~%")
  ),
  /* Matrix is dense so just do a simple write routine */
  for i : 1 thru NSurf do (
    for j : 1 thru NSurf do (
      printf(fh,"  temp_rho_xl = ~a; ~%", float(expand(E_rho_xl[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_ux_xl,~a,~a,~a); ~%", i-1, j-1, temp_rho_xl),
      printf(fh,"  gkyl_mat_set(&A_uy_xl,~a,~a,~a); ~%", i-1, j-1, temp_rho_xl),
      printf(fh,"  gkyl_mat_set(&A_uz_xl,~a,~a,~a); ~%", i-1, j-1, temp_rho_xl),
      printf(fh,"  gkyl_mat_set(&A_Txx_xl,~a,~a,~a); ~%", i-1, j-1, temp_rho_xl),
      printf(fh, " ~%"),

      printf(fh,"  temp_rho_xr = ~a; ~%", float(expand(E_rho_xr[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_ux_xr,~a,~a,~a); ~%", i-1, j-1, temp_rho_xr),
      printf(fh,"  gkyl_mat_set(&A_uy_xr,~a,~a,~a); ~%", i-1, j-1, temp_rho_xr),
      printf(fh,"  gkyl_mat_set(&A_uz_xr,~a,~a,~a); ~%", i-1, j-1, temp_rho_xr),
      printf(fh,"  gkyl_mat_set(&A_Txx_xr,~a,~a,~a); ~%", i-1, j-1, temp_rho_xr),
      printf(fh, " ~%"),

      printf(fh,"  temp_rho_yl = ~a; ~%", float(expand(E_rho_yl[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_ux_yl,~a,~a,~a); ~%", i-1, j-1, temp_rho_yl),
      printf(fh,"  gkyl_mat_set(&A_uy_yl,~a,~a,~a); ~%", i-1, j-1, temp_rho_yl),
      printf(fh,"  gkyl_mat_set(&A_uz_yl,~a,~a,~a); ~%", i-1, j-1, temp_rho_yl),
      printf(fh,"  gkyl_mat_set(&A_Tyy_yl,~a,~a,~a); ~%", i-1, j-1, temp_rho_yl),
      printf(fh, " ~%"),

      printf(fh,"  temp_rho_yr = ~a; ~%", float(expand(E_rho_yr[i,j]))),
      printf(fh,"  gkyl_mat_set(&A_ux_yr,~a,~a,~a); ~%", i-1, j-1, temp_rho_yr),
      printf(fh,"  gkyl_mat_set(&A_uy_yr,~a,~a,~a); ~%", i-1, j-1, temp_rho_yr),
      printf(fh,"  gkyl_mat_set(&A_uz_yr,~a,~a,~a); ~%", i-1, j-1, temp_rho_yr),
      printf(fh,"  gkyl_mat_set(&A_Tyy_yr,~a,~a,~a); ~%", i-1, j-1, temp_rho_yr),
      printf(fh, " ~%"),
      if (cdim = 3) then (
        printf(fh,"  temp_rho_zl = ~a; ~%", float(expand(E_rho_zl[i,j]))),
        printf(fh,"  gkyl_mat_set(&A_ux_zl,~a,~a,~a); ~%", i-1, j-1, temp_rho_zl),
        printf(fh,"  gkyl_mat_set(&A_uy_zl,~a,~a,~a); ~%", i-1, j-1, temp_rho_zl),
        printf(fh,"  gkyl_mat_set(&A_uz_zl,~a,~a,~a); ~%", i-1, j-1, temp_rho_zl),
        printf(fh,"  gkyl_mat_set(&A_Tzz_zl,~a,~a,~a); ~%", i-1, j-1, temp_rho_zl),
        printf(fh, " ~%"),

        printf(fh,"  temp_rho_zr = ~a; ~%", float(expand(E_rho_zr[i,j]))),
        printf(fh,"  gkyl_mat_set(&A_ux_zr,~a,~a,~a); ~%", i-1, j-1, temp_rho_zr),
        printf(fh,"  gkyl_mat_set(&A_uy_zr,~a,~a,~a); ~%", i-1, j-1, temp_rho_zr),
        printf(fh,"  gkyl_mat_set(&A_uz_zr,~a,~a,~a); ~%", i-1, j-1, temp_rho_zr),
        printf(fh,"  gkyl_mat_set(&A_Tzz_zr,~a,~a,~a); ~%", i-1, j-1, temp_rho_zr),
        printf(fh, " ~%")
      )
    )
  ),  
  printf(fh, "} ~%")
)$

copyPKPMSurfacePrimVars(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, surfVarsx, bSurfx, NSurf],

  kill(varsC, basisC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),
  surfVarsx : delete(x,varsC),
  bSurfx : basisFromVars(basisFun,surfVarsx,polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),
  if (cdim = 1) then (
    NSurf : 1
  )
  else (
    NSurf : length(bSurfx)
  ),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(int count, struct gkyl_nmat *x, double* GKYL_RESTRICT prim_surf) ~%{ ~%", funcNm),
  printf(fh, "  // count: integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // x:     Input solution vector. ~%"),
  printf(fh, "  // prim_surf: Primitive variables at surfaces.~%"),
  printf(fh, " ~%"),

  /* Surface primitive variables are organized as:
     [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, Txx_xl, Txx_xr, 
      ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, Tyy_yl, Tyy_yr, 
      ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr, Tzz_zl, Tzz_zr] */

  printf(fh, "  struct gkyl_mat x_ux_xl = gkyl_nmat_get(x, count); ~%"),
  printf(fh, "  struct gkyl_mat x_ux_xr = gkyl_nmat_get(x, count+1); ~%"),
  printf(fh, "  struct gkyl_mat x_uy_xl = gkyl_nmat_get(x, count+2); ~%"),
  printf(fh, "  struct gkyl_mat x_uy_xr = gkyl_nmat_get(x, count+3); ~%"),
  printf(fh, "  struct gkyl_mat x_uz_xl = gkyl_nmat_get(x, count+4); ~%"),
  printf(fh, "  struct gkyl_mat x_uz_xr = gkyl_nmat_get(x, count+5); ~%"),
  printf(fh, "  struct gkyl_mat x_Txx_xl = gkyl_nmat_get(x, count+6); ~%"),
  printf(fh, "  struct gkyl_mat x_Txx_xr = gkyl_nmat_get(x, count+7); ~%"),
  printf(fh, " ~%"), 
  printf(fh, "  double *ux_xl = &prim_surf[~a]; ~%", 0*NSurf),
  printf(fh, "  double *ux_xr = &prim_surf[~a]; ~%", 1*NSurf),
  printf(fh, "  double *uy_xl = &prim_surf[~a]; ~%", 2*NSurf),
  printf(fh, "  double *uy_xr = &prim_surf[~a]; ~%", 3*NSurf),
  printf(fh, "  double *uz_xl = &prim_surf[~a]; ~%", 4*NSurf),
  printf(fh, "  double *uz_xr = &prim_surf[~a]; ~%", 5*NSurf),
  printf(fh, "  double *Txx_xl = &prim_surf[~a]; ~%", 6*NSurf),
  printf(fh, "  double *Txx_xr = &prim_surf[~a]; ~%", 7*NSurf),
  printf(fh, " ~%"), 
  if (cdim > 1) then (
    printf(fh, "  struct gkyl_mat x_ux_yl = gkyl_nmat_get(x, count+8); ~%"),
    printf(fh, "  struct gkyl_mat x_ux_yr = gkyl_nmat_get(x, count+9); ~%"),
    printf(fh, "  struct gkyl_mat x_uy_yl = gkyl_nmat_get(x, count+10); ~%"),
    printf(fh, "  struct gkyl_mat x_uy_yr = gkyl_nmat_get(x, count+11); ~%"),
    printf(fh, "  struct gkyl_mat x_uz_yl = gkyl_nmat_get(x, count+12); ~%"),
    printf(fh, "  struct gkyl_mat x_uz_yr = gkyl_nmat_get(x, count+13); ~%"),
    printf(fh, "  struct gkyl_mat x_Tyy_yl = gkyl_nmat_get(x, count+14); ~%"),
    printf(fh, "  struct gkyl_mat x_Tyy_yr = gkyl_nmat_get(x, count+15); ~%"),
    printf(fh, " ~%"), 
    printf(fh, "  double *ux_yl = &prim_surf[~a]; ~%", 8*NSurf),
    printf(fh, "  double *ux_yr = &prim_surf[~a]; ~%", 9*NSurf),
    printf(fh, "  double *uy_yl = &prim_surf[~a]; ~%", 10*NSurf),
    printf(fh, "  double *uy_yr = &prim_surf[~a]; ~%", 11*NSurf),
    printf(fh, "  double *uz_yl = &prim_surf[~a]; ~%", 12*NSurf),
    printf(fh, "  double *uz_yr = &prim_surf[~a]; ~%", 13*NSurf),
    printf(fh, "  double *Tyy_yl = &prim_surf[~a]; ~%", 14*NSurf),
    printf(fh, "  double *Tyy_yr = &prim_surf[~a]; ~%", 15*NSurf),
    printf(fh, " ~%")
  ),
  if (cdim = 3) then (
    printf(fh, "  struct gkyl_mat x_ux_zl = gkyl_nmat_get(x, count+16); ~%"),
    printf(fh, "  struct gkyl_mat x_ux_zr = gkyl_nmat_get(x, count+17); ~%"),
    printf(fh, "  struct gkyl_mat x_uy_zl = gkyl_nmat_get(x, count+18); ~%"),
    printf(fh, "  struct gkyl_mat x_uy_zr = gkyl_nmat_get(x, count+19); ~%"),
    printf(fh, "  struct gkyl_mat x_uz_zl = gkyl_nmat_get(x, count+20); ~%"),
    printf(fh, "  struct gkyl_mat x_uz_zr = gkyl_nmat_get(x, count+21); ~%"),
    printf(fh, "  struct gkyl_mat x_Tzz_zl = gkyl_nmat_get(x, count+22); ~%"),
    printf(fh, "  struct gkyl_mat x_Tzz_zr = gkyl_nmat_get(x, count+23); ~%"),
    printf(fh, " ~%"), 
    printf(fh, "  double *ux_zl = &prim_surf[~a]; ~%", 16*NSurf),
    printf(fh, "  double *ux_zr = &prim_surf[~a]; ~%", 17*NSurf),
    printf(fh, "  double *uy_zl = &prim_surf[~a]; ~%", 18*NSurf),
    printf(fh, "  double *uy_zr = &prim_surf[~a]; ~%", 19*NSurf),
    printf(fh, "  double *uz_zl = &prim_surf[~a]; ~%", 20*NSurf),
    printf(fh, "  double *uz_zr = &prim_surf[~a]; ~%", 21*NSurf),
    printf(fh, "  double *Tzz_zl = &prim_surf[~a]; ~%", 22*NSurf),
    printf(fh, "  double *Tzz_zr = &prim_surf[~a]; ~%", 23*NSurf),
    printf(fh, " ~%")
  ),
  for i : 1 thru NSurf do (
    printf(fh,"  ux_xl[~a] = gkyl_mat_get(&x_ux_xl,~a,0); ~%", i-1, i-1),
    printf(fh,"  ux_xr[~a] = gkyl_mat_get(&x_ux_xr,~a,0); ~%", i-1, i-1),
    printf(fh,"  uy_xl[~a] = gkyl_mat_get(&x_uy_xl,~a,0); ~%", i-1, i-1),
    printf(fh,"  uy_xr[~a] = gkyl_mat_get(&x_uy_xr,~a,0); ~%", i-1, i-1),
    printf(fh,"  uz_xl[~a] = gkyl_mat_get(&x_uz_xl,~a,0); ~%", i-1, i-1),
    printf(fh,"  uz_xr[~a] = gkyl_mat_get(&x_uz_xr,~a,0); ~%", i-1, i-1),
    printf(fh,"  Txx_xl[~a] = gkyl_mat_get(&x_Txx_xl,~a,0); ~%", i-1, i-1),
    printf(fh,"  Txx_xr[~a] = gkyl_mat_get(&x_Txx_xr,~a,0); ~%", i-1, i-1), 
    printf(fh, " ~%"), 
    if (cdim > 1) then (
      printf(fh,"  ux_yl[~a] = gkyl_mat_get(&x_ux_yl,~a,0); ~%", i-1, i-1),
      printf(fh,"  ux_yr[~a] = gkyl_mat_get(&x_ux_yr,~a,0); ~%", i-1, i-1),
      printf(fh,"  uy_yl[~a] = gkyl_mat_get(&x_uy_yl,~a,0); ~%", i-1, i-1),
      printf(fh,"  uy_yr[~a] = gkyl_mat_get(&x_uy_yr,~a,0); ~%", i-1, i-1),
      printf(fh,"  uz_yl[~a] = gkyl_mat_get(&x_uz_yl,~a,0); ~%", i-1, i-1),
      printf(fh,"  uz_yr[~a] = gkyl_mat_get(&x_uz_yr,~a,0); ~%", i-1, i-1),
      printf(fh,"  Tyy_yl[~a] = gkyl_mat_get(&x_Tyy_yl,~a,0); ~%", i-1, i-1),
      printf(fh,"  Tyy_yr[~a] = gkyl_mat_get(&x_Tyy_yr,~a,0); ~%", i-1, i-1), 
      printf(fh, " ~%")
    ), 
    if (cdim = 3) then (
      printf(fh,"  ux_zl[~a] = gkyl_mat_get(&x_ux_zl,~a,0); ~%", i-1, i-1),
      printf(fh,"  ux_zr[~a] = gkyl_mat_get(&x_ux_zr,~a,0); ~%", i-1, i-1),
      printf(fh,"  uy_zl[~a] = gkyl_mat_get(&x_uy_zl,~a,0); ~%", i-1, i-1),
      printf(fh,"  uy_zr[~a] = gkyl_mat_get(&x_uy_zr,~a,0); ~%", i-1, i-1),
      printf(fh,"  uz_zl[~a] = gkyl_mat_get(&x_uz_zl,~a,0); ~%", i-1, i-1),
      printf(fh,"  uz_zr[~a] = gkyl_mat_get(&x_uz_zr,~a,0); ~%", i-1, i-1),
      printf(fh,"  Tzz_zl[~a] = gkyl_mat_get(&x_Tzz_zl,~a,0); ~%", i-1, i-1),
      printf(fh,"  Tzz_zr[~a] = gkyl_mat_get(&x_Tzz_zr,~a,0); ~%", i-1, i-1),
      printf(fh, " ~%")
    )
  ),
  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$
