/* This script generates the kernels for calculating the distribution function pkpm variables including:

   1. Compute div(p_par b) from the streaming term div(v_par b F_0) for a consistent pressure force which
   prevents the development of spurious flows: integral(v_par F_0)
   2. In the mirror force for the T_perp/m*G = T_perp/m*(F_0 - F_1) kinetic equation, compute the distribution function 
   source along with the vperp characteristics which are a pure source term in the first Laguerre moment update.
   g_dist_source = [2.0*T_perp/m*(2.0*T_perp/m G + T_perp/m (F_2 - F_0)), 
                    (-vpar div(b) + bb:grad(u) - div(u) - 2 nu) T_perp/m G + 2 nu vth^2 F_0 ]
   First output is mirror force source *distribution*, second output is *total* vperp characteristics source.
                    
   Note that T_perp/m*G is the evolved quantity for the first Laguerre moment. 
   Also outputs F_1 from T_perp/m*G for the evolution of F_2 if F_2 is present. 
   To simplify internal Gkeyll logic, kernels assume F_2 is present and outputs F_1 even if F_2 = 0.0. */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
load("recovery")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx0, dx1, dx2]$

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Helper functions for expanding in basis functions a quantity we know should be sparse 
   For example, alpha, the phase space flow only depends on a few phase space coordinates */
/* List output is a vector with some offset off */
doMakeExprLstOff(vals, S, off)  := makelist(if vals[i] # 0 then S[off+i-1] else 0, i, 1, length(vals))$
/* List output is a scalar */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

calcPKPMDivPParUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NP, pDim, cid, vid, cv, surfVars, bSurf, NSurf, surfNodes, numNodes, basisStr, 
   F_0l_e, F_0c_e, F_0r_e, bl_e, bc_e, br_e, vTrans, 
   alpha_l_c, alpha_c_c, alpha_r_c, lst_alpha_l, lst_alpha_c, lst_alpha_r, alpha_rec_l, alpha_rec_r, 
   alphaSurf_l_c, alphaSurf_r_c, alst_l, alst_r, alphaSurf_l_e, alphaSurf_r_e, alphaOrd_l_n, alphaOrd_r_n,
   F_0_HatSurf_l_e, F_0_HatSurf_r_e, 
   Ghat_F_0_l_c, Ghat_F_0_r_c, 
   Ghat_F_0_l_e, Ghat_F_0_r_e, 
   incr_F_0_l, incr_F_0_r, incr_F_0_vol],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  printf(fh, "GKYL_CU_DH void ~a_~a_~ax~av_~a_p~a(const double *w, const double *dxv, 
     const double *bvarl, const double *bvarc, const double *bvarr, 
     const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT pkpm_div_ppar) ~%{ ~%", funcNm, cvars[dir], cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:           Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:         Cell spacing.~%"),
  printf(fh, "  // bvarl/bvarc/bvarr: Input magnetic field unit vector in left/center/right cells.~%"),
  printf(fh, "  // fl/fc/fr:          Input Distribution function [F_0, T_perp G = T_perp (F_1 - F_0)] in left/center/right cells.~%"),
  printf(fh, "  // pkpm_div_ppar:     Increment to volume expansion of div(p_par b).~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* cv = variable in direction of surface update. */
  cv : varsP[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsP),
  surfConfVars : delete(cv,varsC),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),
  printf(fh, "  const double volFact = dxv[~a]/2.0; ~%", cdim),
  printf(fh, "  const double *bl = &bvarl[~a]; ~%", NC*(dir-1)),
  printf(fh, "  const double *bc = &bvarc[~a]; ~%", NC*(dir-1)),
  printf(fh, "  const double *br = &bvarr[~a]; ~%", NC*(dir-1)),

  /* Access F_0 and T_perp G, first two Laguerre moments */
  printf(fh, "  const double *F_0l = &fl[~a]; ~%", 0), 
  printf(fh, "  const double *F_0c = &fc[~a]; ~%", 0),
  printf(fh, "  const double *F_0r = &fr[~a]; ~%", 0),

  /* Expand bulk velocity, magnetic field unit vector, and distribution function 
      in left, center, and right cells */
  F_0l_e : doExpand1(F_0l,bP),
  F_0c_e : doExpand1(F_0c,bP),
  F_0r_e : doExpand1(F_0r,bP),

  bl_e : doExpand1(bl,bC),
  bc_e : doExpand1(bc,bC),
  br_e : doExpand1(br,bC),

  /* Coordinate transformation for velocity space */
  vTrans : vx*dvpar/2+wvpar,

  /* Compute phase space flux due to parallel streaming in left, center, and right cells.
     The, write out phase space flux in left, center, and right cells
     for use in recovery procedure */
  printf(fh, "  double alpha_l[~a] = {0.0}; ~%", NP),
  printf(fh, "  double alpha_c[~a] = {0.0}; ~%", NP),
  printf(fh, "  double alpha_r[~a] = {0.0}; ~%", NP),

  alpha_l_c : calcInnerProdList(varsP, 1, bP, vTrans*bl_e),
  alpha_c_c : calcInnerProdList(varsP, 1, bP, vTrans*bc_e),
  alpha_r_c : calcInnerProdList(varsP, 1, bP, vTrans*br_e),

  writeCExprs1(alpha_l, alpha_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(alpha_c, alpha_c_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(alpha_r, alpha_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  alst_vol : doMakeExprLst(alpha_c_c, alpha_c),
  alphaVol_e : doExpand(alst_vol, bP),

  /* We use recovery to compute the interface phase space flux */
  /* Create safety lists for recovery */
  lst_alpha_l : doMakeExprLst(alpha_l_c, alpha_l), 
  lst_alpha_c : doMakeExprLst(alpha_c_c, alpha_c), 
  lst_alpha_r : doMakeExprLst(alpha_r_c, alpha_r),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no cv dependence. */
  /* Also generate recovery, necessary basis strings, and surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),
    bSurfConf : basisFromVars(basisFun,surfConfVars,polyOrder),

    alpha_rec_l : calcRecov2CellGen("hyb", cv, varsP, polyOrder,
      dg(lst_alpha_l), dg(lst_alpha_c)),
    alpha_rec_r : calcRecov2CellGen("hyb", cv, varsP, polyOrder,
      dg(lst_alpha_c), dg(lst_alpha_r)),

    surf_cdim : cdim-1,  surf_vdim : 1,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim),
    surfConfNodes : gaussOrd(polyOrder+1, cdim-1),

    basisStr : sconcat("hyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder), 
    bSurfConf : basisFromVars(basisFun,surfConfVars,polyOrder),

    alpha_rec_l : calcRecov2CellGen(basisFun, cv, varsP, polyOrder,
      dg(lst_alpha_l), dg(lst_alpha_c)),
    alpha_rec_r : calcRecov2CellGen(basisFun, cv, varsP, polyOrder,
      dg(lst_alpha_c), dg(lst_alpha_r)), 

    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    surfConfNodes : gaussOrd(polyOrder+1, cdim-1),

    basisStr : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  NSurfConf : length(bSurfConf),
  NSurf : length(bSurf),
  numNodes : length(surfNodes),
  numConfNodes : length(surfConfNodes),

  /* Project alpha evaluated at interior surface onto surf basis. */
  alphaSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, alpha_rec_l))),
  alphaSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, alpha_rec_r))),
  alst_l        : doMakeExprLst(alphaSurf_l_c, alphaSurf_l),
  alst_r        : doMakeExprLst(alphaSurf_r_c, alphaSurf_r),
  alphaSurf_l_e : doExpand(alst_l, bSurf),
  alphaSurf_r_e : doExpand(alst_r, bSurf),
  printf(fh, "  double alphaSurf_l[~a] = {0.0}; ~%", NSurf),
  writeCExprs1(alphaSurf_l, alphaSurf_l_c),
  printf(fh, "~%"),
  printf(fh, "  double alphaSurf_r[~a] = {0.0}; ~%", NSurf),
  writeCExprs1(alphaSurf_r, alphaSurf_r_c),
  printf(fh, "~%"),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous. */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaSurf_r_e,surfNodes,surfVars))),

  printf(fh, "  double F_0_UpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_UpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_Upwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double F_0_Upwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_F_0_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_F_0_r[~a] = {0.0}; ~%", NSurf),

  /* Check sign of each quadrature point and choose appropriate distribution function at 
     quadrature points. 
     If alphaSurf_l > 0, need f_l (at +1), else f_c (at -1). 
     If alphaSurf_r > 0, need f_c (at +1), else f_r (at -1). */

  for i : 1 thru length(alphaOrd_l_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_l_n[i]),
    printf(fh, "    F_0_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0l); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0c); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } ~%"),
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_r_n[i]),
    printf(fh, "    F_0_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0c); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0r); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_xdir_upwind_quad_to_modal(F_0_UpwindQuad_l, F_0_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_xdir_upwind_quad_to_modal(F_0_UpwindQuad_r, F_0_Upwind_r); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad_l, F_0_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad_r, F_0_Upwind_r); ~%", basisStr)
  ),
  printf(fh, "~%"),

  /* Create expansions of F_0_hat, G_1_hat (upwinded first two Laguerre moments) on the left and right in the surface basis. */
  F_0_HatSurf_l_e : doExpand1(F_0_Upwind_l, bSurf),
  F_0_HatSurf_r_e : doExpand1(F_0_Upwind_r, bSurf),

  /* Print C exprs for Ghat across surface boundary, (LEFT BOUNDARY) */
  Ghat_F_0_l_c : fullratsimp(innerProd(surfVars, alphaSurf_l_e, bSurf, F_0_HatSurf_l_e)),
  writeCExprs1(Ghat_F_0_l, Ghat_F_0_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Print C exprs for Ghat across surface boundary, (RIGHT BOUNDARY) */
  Ghat_F_0_r_c : fullratsimp(innerProd(surfVars, alphaSurf_r_e, bSurf, F_0_HatSurf_r_e)),
  writeCExprs1(Ghat_F_0_r, Ghat_F_0_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Expand G_hat in surface basis. */
  Ghat_F_0_l_e     : doExpand1(Ghat_F_0_l, bSurf),
  Ghat_F_0_r_e     : doExpand1(Ghat_F_0_r, bSurf),

  /* Compute surface contribution integral(phi^- Ghat) on the left and right. */
  incr_F_0_l : calcInnerProdList(surfVars, -vTrans, subst(cv=-1.0, bC), Ghat_F_0_l_e),
  incr_F_0_r : calcInnerProdList(surfVars, vTrans, subst(cv=1.0, bC), Ghat_F_0_r_e),
  incr_F_0_vol : calcInnerProdList(varsP, vTrans, diff(bC,cv), alphaVol_e*F_0c_e),
  writeCIncrExprsCollect1lhsc(pkpm_div_ppar, volFact*dx1*(incr_F_0_l + incr_F_0_r - incr_F_0_vol)),  
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "} ~%")
);

calcPKPMDistMirrorForce(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NC, NP, clst, 
   vTrans, div_b_e, p_perp_source_e, alpha_G_1_source_c, alpha_G_1_source_NoZero, alpha_G_1_source_NoZero_e, 
   F_0_e, G_1_e, F_2_e, T_perp_over_m_e, T_perp_over_m_inv_e, 
   F_2_m_F_0_c, F_2_m_F_0_e, T_perp_F_0_c, T_perp_F_0_e, 
   T_perp_g_dist_c, T_perp_g_dist_e, out_g_dist_c, nu_vthsq_e, out_g_dist_vperp_c, 
   F_0_m_F_1_c, F_0_m_F_1_e, out_F_1_c],

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),

  printf(fh, "#include <gkyl_vlasov_pkpm_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a_p~a(const double *w, const double *dxv, 
  const double* pkpm_prim, const double *nu_vthsq, const double* pkpm_accel,  
  const double* f, const double* F_k_p_1, double* g_dist_source, double* F_k_m_1) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // w[NDIM]:       Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:     Cell spacing.~%"),
  printf(fh, "  // pkpm_prim:     [ux, uy, uz, pxx, pxy, pxz, pyy, pyz, pzz, T_perp/m = p_perp/rho, m/T_perp = rho/p_perp].~%"),
  printf(fh, "  // nu_vthsq:      Input nu*vth^2.~%"),
  printf(fh, "  // pkpm_accel:    pkpm acceleration variables [div(b), bb:grad(u), p_force, p_perp_source, T_perp/m*div(b)].~%"), 
  printf(fh, "  // f:             Input distribution function [F_0, T_perp/m G = T_perp/m (F_0 - F_1)].~%"),
  printf(fh, "  // F_k_p_1:       Input k+1 distribution function. F_2 expansion is the first NP coefficients. ~%"),
  printf(fh, "  // g_dist_source: Output [2.0*T_perp/m*(2.0*T_perp/m G + T_perp/m (F_2 - F_0)),  ~%"), 
  printf(fh, "  //                (-vpar div(b) + bb:grad(u) - div(u) - 2 nu) T_perp/m G + 2 nu vth^2 F_0 ].~%"), 
  printf(fh, "  //                First output is mirror force source, second output is vperp characteristics source.~%"), 
  printf(fh, "  // F_k_m_1:       Output k-1 distribution function. F_1 expansion is the first NP coefficients. ~%"),
  printf(fh, "~%"),

  /* grid spacing in v_parallel and v_parallel coordinate */
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),
  /* Coordinate transformation for velocity space */
  vTrans : vx*dvpar/2+wvpar,
  clst : [dvpar, wvpar],

  /* Access pkpm primitive variables T_perp/m and m/T_perp */  
  printf(fh, "  const double *T_perp_over_m = &pkpm_prim[~a]; ~%", 7*NC),
  printf(fh, "  const double *T_perp_over_m_inv = &pkpm_prim[~a]; ~%", 8*NC),
  printf(fh, "~%"),

  /* Access pkpm acceleration variables for forces and sources 
     Need div(b) and p_perp_source = bb:grad(u) - div(u) - 2 nu 
     for vperp characteristics source */
  printf(fh, "  const double *div_b = &pkpm_accel[~a]; ~%", 0*NC),
  printf(fh, "  const double *p_perp_source = &pkpm_accel[~a]; ~%", 3*NC),
  printf(fh, "~%"),

  div_b_e : doExpand1(div_b, bC),
  p_perp_source_e : doExpand1(p_perp_source, bC),

  printf(fh, "  double alpha_G_1_source[~a] = {0.0}; ~%", NP),
  printf(fh, "~%"),

  /* Note that G vperp characteristics source does not involve an integration by parts and is just a pure source term 
     alpha_G_1_source = (bb : grad(u) - div(u) - 2 nu - v_parallel div(b)) T_perp/m G 
     alpha_G_1_source consolidated as alpha_G_1_source = p_perp_source - v_parallel div(b) (p_perp_source pre-computed) 
     After computing this part of the vperp characteristics source, still need to add 2*nu*vth^2*F_0 */
  alpha_G_1_source_c : calcInnerProdList(varsP, 1, bP, p_perp_source_e - div_b_e*vTrans),
  writeCExprsCollect1(alpha_G_1_source, alpha_G_1_source_c, clst),
  printf(fh, "~%"),
  /* Zero out components of G_1 vperp source which are empty. */
  alpha_G_1_source_NoZero : doMakeExprLst(alpha_G_1_source_c, alpha_G_1_source),
  alpha_G_1_source_NoZero_e : doExpand(alpha_G_1_source_NoZero, bP),

  /* Access F_0 and T_perp/m G, first two Laguerre moments */
  printf(fh, "  const double *F_0 = &f[~a]; ~%", 0),
  printf(fh, "  const double *G_1 = &f[~a]; ~%", NP),
  printf(fh, "  const double *F_2 = &F_k_p_1[~a]; ~%", 0),  
  printf(fh, "~%"), 

  /* Access the output components of g_dist_source
     First NP components are source distribution for mirror force: 2.0*T_perp/m*(2.0*T_perp/m G + T_perp/m (F_2 - F_0))
     Second NP components are source for vperp characteristics: (-vpar div(b) + bb:grad(u) - div(u) - 2 nu) T_perp/m G + 2 nu vth^2 F_0 */
  printf(fh, "  double *out_G_1_mirror = &g_dist_source[~a]; ~%", 0),  
  printf(fh, "  double *out_G_1_vperp = &g_dist_source[~a]; ~%", NP),  

  /* Access the output components of F_k_m_1 (only first NP components are F_1) */
  printf(fh, "  double *out_F_1 = &F_k_m_1[~a]; ~%", 0), 
  printf(fh, "~%"), 

  /* Expand distribution functions F_0 and T_perp/m G in phase basis. */
  F_0_e : doExpand1(F_0, bP),
  G_1_e : doExpand1(G_1, bP),
  F_2_e : doExpand1(F_2, bP),

  T_perp_over_m_e : doExpand1(T_perp_over_m, bC),
  T_perp_over_m_inv_e : doExpand1(T_perp_over_m_inv, bC),

  printf(fh, "  double tmp_F_2_m_F_0[~a] = {0.0}; ~%", NP),
  printf(fh, "  double tmp_T_perp_F_0[~a] = {0.0}; ~%", NP),
  printf(fh, "  double tmp_T_perp_g_dist[~a] = {0.0}; ~%", NP),
  printf(fh, "  double tmp_F_0_m_F_1[~a] = {0.0}; ~%", NP),
  printf(fh, "~%"),  

  F_2_m_F_0_c : calcInnerProdList(varsP, 1, bP, F_2_e - F_0_e),
  writeCExprs1(tmp_F_2_m_F_0, F_2_m_F_0_c),
  printf(fh, "~%"),  

  F_2_m_F_0_e : doExpand1(tmp_F_2_m_F_0, bP),
  T_perp_F_0_c : calcInnerProdList(varsP, 1, bP, T_perp_over_m_e*F_2_m_F_0_e),
  writeCExprs1(tmp_T_perp_F_0, T_perp_F_0_c),
  printf(fh, "~%"),  

  T_perp_F_0_e : doExpand1(tmp_T_perp_F_0, bP),
  T_perp_g_dist_c : calcInnerProdList(varsP, 1, bP, 2.0*G_1_e + T_perp_F_0_e), 
  writeCExprs1(tmp_T_perp_g_dist, T_perp_g_dist_c),
  printf(fh, "~%"),  

  T_perp_g_dist_e : doExpand1(tmp_T_perp_g_dist, bP),
  out_g_dist_c : calcInnerProdList(varsP, 1, bP, 2.0*T_perp_over_m_e*T_perp_g_dist_e),
  writeCExprs1(out_G_1_mirror, out_g_dist_c),
  printf(fh, "~%"), 

  nu_vthsq_e : doExpand1(nu_vthsq, bC),
  out_g_dist_vperp_c : calcInnerProdList(varsP, 1, bP, alpha_G_1_source_NoZero_e*G_1_e + 2.0*nu_vthsq_e*F_0_e),
  writeCExprs1(out_G_1_vperp, out_g_dist_vperp_c),
  printf(fh, "~%"), 

  F_0_m_F_1_c : calcInnerProdList(varsP, 1, bP, T_perp_over_m_inv_e*G_1_e),
  writeCExprs1(tmp_F_0_m_F_1, F_0_m_F_1_c),
  printf(fh, "~%"),

  F_0_m_F_1_e : doExpand1(tmp_F_0_m_F_1, bP),
  out_F_1_c : calcInnerProdList(varsP, 1, bP, F_0_e - F_0_m_F_1_e),
  writeCExprs1(out_F_1, out_F_1_c),

  printf(fh, "} ~%")
)$
