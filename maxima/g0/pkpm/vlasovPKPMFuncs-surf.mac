/* This script generates the kernels for the surface term of the 
   advection in velocity space for the Vlasov equation
   in the parallel-kinetic-perpendicular-moment (pkpm) model */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
load("recovery")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx0, dx1, dx2]$

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

calcVlasovPKPMStreamUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NP, pDim, cid, vid, cv, surfVars, bSurf, NSurf, surfNodes, numNodes, basisStr, 
   F_0l_e, F_0c_e, F_0r_e, G_1l_e, G_1c_e, G_1r_e, 
   ul_e, vth_sql_e, bl_e, uc_e, vth_sqc_e, bc_e,ur_e, vth_sqr_e, br_e, vTrans, 
   alpha_l_c, alpha_c_c, alpha_r_c, lst_alpha_l, lst_alpha_c, lst_alpha_r, alpha_rec_l, alpha_rec_r, 
   alphaSurf_l_c, alphaSurf_r_c, alst_l, alst_r, alphaSurf_l_e, alphaSurf_r_e, alphaOrd_l_n, alphaOrd_r_n,
   F_0_HatSurf_l_e, F_0_HatSurf_r_e, G_1_HatSurf_l_e, G_1_HatSurf_r_e, 
   Ghat_F_0_l_c, Ghat_F_0_r_c, Ghat_G_1_l_c, Ghat_G_1_r_c, 
   Ghat_F_0_l_e, Ghat_F_0_r_e, Ghat_G_1_l_e, Ghat_G_1_r_e, 
   incr_F_0_l, incr_F_0_r, incr_G_1_l, incr_G_1_r,  
   F_0l_rx_c, F_0c_lx_c, F_0c_rx_c, F_0r_lx_c, G_1l_rx_c, G_1c_lx_c, G_1c_rx_c, G_1r_lx_c, 
   ul_r, uc_l, uc_r, ur_l, avg_u_l_c, avg_u_r_c, avg_u_l_e, avg_u_r_e, 
   max_speed_modal_l_e, max_speed_modal_r_e, 
   F_0l_rx_temp, F_0l_rx_temp_e, G_1l_rx_temp, G_1l_rx_temp_e, 
   F_0c_lx_temp, F_0c_lx_temp_e, G_1c_lx_temp, G_1c_lx_temp_e, 
   F_0c_rx_temp, F_0c_rx_temp_e, G_1c_rx_temp, G_1c_rx_temp_e, 
   F_0r_lx_temp, F_0r_lx_temp_e, G_1r_lx_temp, G_1r_lx_temp_e, 
   out_F_0_c, out_G_1_c],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax~av_~a_p~a(const double *w, const double *dxv, 
    const double *bvar_l, const double *bvar_c, const double *bvar_r, 
    const double *pkpm_prim_surf_l, const double *pkpm_prim_surf_c, const double *pkpm_prim_surf_r, 
    const double *fl, const double *fc, const double *fr, 
    const double *pkpm_lax, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:              Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:            Cell spacing.~%"),
  printf(fh, "  // bvar_l/c/r:           Input magnetic field unit vector in left/center/right cells.~%"),
  printf(fh, "  // pkpm_prim_surf_l/c/r: Input surface primitive variables [u_i, 3*T_ii/m] in left/center/right cells in each direction.~%"),
  printf(fh, "  // fl/fc/fr:             Input Distribution function [F_0, T_perp G = T_perp (F_1 - F_0)] in left/center/right cells.~%"),
  printf(fh, "  // pkpm_lax:             Surface expansion of pkpm Lax penalization: lambda_i = |u_i| + sqrt(3.0*T_ii/m).~%"),
  printf(fh, "  // out:                  Incremented distribution function in center cell.~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* cv = variable in direction of surface update. */
  cv : varsP[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsP),
  surfConfVars : delete(cv,varsC),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),
  printf(fh, "  const double *bl = &bvar_l[~a]; ~%", (dir-1)*NC),
  printf(fh, "  const double *bc = &bvar_c[~a]; ~%", (dir-1)*NC),
  printf(fh, "  const double *br = &bvar_r[~a]; ~%", (dir-1)*NC),

  /* Access F_0 and T_perp G, first two Laguerre moments */
  printf(fh, "  const double *F_0l = &fl[~a]; ~%", 0),
  printf(fh, "  const double *G_1l = &fl[~a]; ~%", NP),  
  printf(fh, "  const double *F_0c = &fc[~a]; ~%", 0),
  printf(fh, "  const double *G_1c = &fc[~a]; ~%", NP), 
  printf(fh, "  const double *F_0r = &fr[~a]; ~%", 0),
  printf(fh, "  const double *G_1r = &fr[~a]; ~%", NP), 

  /* Access the components of out for the first two Laguerre moments */
  printf(fh, "  double *out_F_0 = &out[~a]; ~%", 0),
  printf(fh, "  double *out_G_1 = &out[~a]; ~%", NP),    

  /* Expand bulk velocity, magnetic field unit vector, and distribution function 
      in left, center, and right cells */
  F_0l_e : doExpand1(F_0l,bP),
  F_0c_e : doExpand1(F_0c,bP),
  F_0r_e : doExpand1(F_0r,bP),

  G_1l_e : doExpand1(G_1l,bP),
  G_1c_e : doExpand1(G_1c,bP),
  G_1r_e : doExpand1(G_1r,bP),

  bl_e : doExpand1(bl,bC),
  bc_e : doExpand1(bc,bC),
  br_e : doExpand1(br,bC),

  /* Coordinate transformation for velocity space */
  vTrans : vx*dvpar/2+wvpar,

  /* First half of the update div(v_par b_hat F_0) and div(v_par b_hat G_1) */
  /* Compute phase space flux due to parallel streaming in left, center, and right cells.
     The, write out phase space flux in left, center, and right cells
     for use in recovery procedure */
  printf(fh, "  double alpha_l[~a] = {0.0}; ~%", NP),
  printf(fh, "  double alpha_c[~a] = {0.0}; ~%", NP),
  printf(fh, "  double alpha_r[~a] = {0.0}; ~%", NP),

  alpha_l_c : calcInnerProdList(varsP, 1, bP, vTrans*bl_e),
  alpha_c_c : calcInnerProdList(varsP, 1, bP, vTrans*bc_e),
  alpha_r_c : calcInnerProdList(varsP, 1, bP, vTrans*br_e),

  writeCExprs1(alpha_l, alpha_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(alpha_c, alpha_c_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(alpha_r, alpha_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* We use recovery to compute the interface phase space flux */
  /* Create safety lists for recovery */
  lst_alpha_l : doMakeExprLst(alpha_l_c, alpha_l), 
  lst_alpha_c : doMakeExprLst(alpha_c_c, alpha_c), 
  lst_alpha_r : doMakeExprLst(alpha_r_c, alpha_r),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no cv dependence. */
  /* Also generate recovery, necessary basis strings, and surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),
    bSurfConf : basisFromVars(basisFun,surfConfVars,polyOrder),

    alpha_rec_l : calcRecov2CellGen("hyb", cv, varsP, polyOrder,
      dg(lst_alpha_l), dg(lst_alpha_c)),
    alpha_rec_r : calcRecov2CellGen("hyb", cv, varsP, polyOrder,
      dg(lst_alpha_c), dg(lst_alpha_r)),

    surf_cdim : cdim-1,  surf_vdim : 1,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim),
    surfConfNodes : gaussOrd(polyOrder+1, cdim-1),

    basisStr : sconcat("hyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder), 
    bSurfConf : basisFromVars(basisFun,surfConfVars,polyOrder),

    alpha_rec_l : calcRecov2CellGen(basisFun, cv, varsP, polyOrder,
      dg(lst_alpha_l), dg(lst_alpha_c)),
    alpha_rec_r : calcRecov2CellGen(basisFun, cv, varsP, polyOrder,
      dg(lst_alpha_c), dg(lst_alpha_r)), 

    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    surfConfNodes : gaussOrd(polyOrder+1, cdim-1),

    basisStr : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  /* If cdim = 1, need to set the size of the surface basis because the surface basis is empty */
  if (cdim = 1) then (
    NSurfConf : 1,
    numConfNodes : 1
  )
  else (
    NSurfConf : length(bSurfConf), 
    numConfNodes : length(surfConfNodes)
  ),
  NSurf : length(bSurf),
  numNodes : length(surfNodes),

  /* Project alpha evaluated at interior surface onto surf basis. */
  alphaSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, alpha_rec_l))),
  alphaSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, alpha_rec_r))),
  alst_l        : doMakeExprLst(alphaSurf_l_c, alphaSurf_l),
  alst_r        : doMakeExprLst(alphaSurf_r_c, alphaSurf_r),
  alphaSurf_l_e : doExpand(alst_l, bSurf),
  alphaSurf_r_e : doExpand(alst_r, bSurf),
  printf(fh, "  double alphaSurf_l[~a] = {0.0}; ~%", NSurf),
  writeCExprs1(alphaSurf_l, alphaSurf_l_c),
  printf(fh, "~%"),
  printf(fh, "  double alphaSurf_r[~a] = {0.0}; ~%", NSurf),
  writeCExprs1(alphaSurf_r, alphaSurf_r_c),
  printf(fh, "~%"),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous. */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaSurf_r_e,surfNodes,surfVars))),

  printf(fh, "  double F_0_UpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_UpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_Upwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double F_0_Upwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_F_0_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_F_0_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double G_1_UpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double G_1_UpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double G_1_Upwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double G_1_Upwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_G_1_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_G_1_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  /* Check sign of each quadrature point and choose appropriate distribution function at 
     quadrature points. 
     If alphaSurf_l > 0, need f_l (at +1), else f_c (at -1). 
     If alphaSurf_r > 0, need f_c (at +1), else f_r (at -1). */

  for i : 1 thru length(alphaOrd_l_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_l_n[i]),
    printf(fh, "    F_0_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0l); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "    G_1_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1l); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0c); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "    G_1_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1c); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } ~%"),
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_r_n[i]),
    printf(fh, "    F_0_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0c); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "    G_1_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1c); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0r); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "    G_1_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1r); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_xdir_upwind_quad_to_modal(F_0_UpwindQuad_l, F_0_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_xdir_upwind_quad_to_modal(F_0_UpwindQuad_r, F_0_Upwind_r); ~%", basisStr),
    printf(fh, "  ~a_xdir_upwind_quad_to_modal(G_1_UpwindQuad_l, G_1_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_xdir_upwind_quad_to_modal(G_1_UpwindQuad_r, G_1_Upwind_r); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad_l, F_0_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad_r, F_0_Upwind_r); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_UpwindQuad_l, G_1_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_UpwindQuad_r, G_1_Upwind_r); ~%", basisStr)
  ),
  printf(fh, "~%"),

  /* Create expansions of F_0_hat, G_1_hat (upwinded first two Laguerre moments) on the left and right in the surface basis. */
  F_0_HatSurf_l_e : doExpand1(F_0_Upwind_l, bSurf),
  F_0_HatSurf_r_e : doExpand1(F_0_Upwind_r, bSurf),
  G_1_HatSurf_l_e : doExpand1(G_1_Upwind_l, bSurf),
  G_1_HatSurf_r_e : doExpand1(G_1_Upwind_r, bSurf),

  /* Print C exprs for Ghat across surface boundary, (LEFT BOUNDARY) */
  Ghat_F_0_l_c : fullratsimp(innerProd(surfVars, alphaSurf_l_e, bSurf, F_0_HatSurf_l_e)),
  Ghat_G_1_l_c : fullratsimp(innerProd(surfVars, alphaSurf_l_e, bSurf, G_1_HatSurf_l_e)),
  writeCExprs1(Ghat_F_0_l, Ghat_F_0_l_c),
  writeCExprs1(Ghat_G_1_l, Ghat_G_1_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Print C exprs for Ghat across surface boundary, (RIGHT BOUNDARY) */
  Ghat_F_0_r_c : fullratsimp(innerProd(surfVars, alphaSurf_r_e, bSurf, F_0_HatSurf_r_e)),
  Ghat_G_1_r_c : fullratsimp(innerProd(surfVars, alphaSurf_r_e, bSurf, G_1_HatSurf_r_e)),
  writeCExprs1(Ghat_F_0_r, Ghat_F_0_r_c),
  writeCExprs1(Ghat_G_1_r, Ghat_G_1_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Expand G_hat in surface basis. */
  Ghat_F_0_l_e     : doExpand1(Ghat_F_0_l, bSurf),
  Ghat_G_1_l_e     : doExpand1(Ghat_G_1_l, bSurf),
  Ghat_F_0_r_e     : doExpand1(Ghat_F_0_r, bSurf),
  Ghat_G_1_r_e     : doExpand1(Ghat_G_1_r, bSurf),

  /* Compute surface contribution integral(phi^- Ghat) on the left and right. */
  incr_F_0_l : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Ghat_F_0_l_e),
  incr_F_0_r : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Ghat_F_0_r_e),
  incr_G_1_l : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Ghat_G_1_l_e),
  incr_G_1_r : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Ghat_G_1_r_e),
  writeCIncrExprsCollect1lhsc(out_F_0, dx1*incr_F_0_l + dx1*incr_F_0_r),  
  writeCIncrExprsCollect1lhsc(out_G_1, dx1*incr_G_1_l + dx1*incr_G_1_r),  
  printf(fh, "~%"),
  flush_output(fh),

  /* Second half of the update div(u F_0) and div(u G_1) */
  /* Surface primitive variables are organized as:
     [ux_xl, ux_xr, uy_xl, uy_xr, uz_xl, uz_xr, Txx_xl, Txx_xr, 
      ux_yl, ux_yr, uy_yl, uy_yr, uz_yl, uz_yr, Tyy_yl, Tyy_yr, 
      ux_zl, ux_zr, uy_zl, uy_zr, uz_zl, uz_zr, Tzz_zl, Tzz_zr] */
  if (dir = 1) then (
    printf(fh, "  const double *u_surf_lr = &pkpm_prim_surf_l[~a]; ~%", (1 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_cl = &pkpm_prim_surf_c[~a]; ~%", (0 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_cr = &pkpm_prim_surf_c[~a]; ~%", (1 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_rl = &pkpm_prim_surf_r[~a]; ~%", (0 + (dir-1)*8)*NSurfConf),
    printf(fh, "~%")
  )
  else if (dir = 2) then (
    printf(fh, "  const double *u_surf_lr = &pkpm_prim_surf_l[~a]; ~%", (3 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_cl = &pkpm_prim_surf_c[~a]; ~%", (2 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_cr = &pkpm_prim_surf_c[~a]; ~%", (3 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_rl = &pkpm_prim_surf_r[~a]; ~%", (2 + (dir-1)*8)*NSurfConf),
    printf(fh, "~%")
  )
  else (
    printf(fh, "  const double *u_surf_lr = &pkpm_prim_surf_l[~a]; ~%", (5 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_cl = &pkpm_prim_surf_c[~a]; ~%", (4 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_cr = &pkpm_prim_surf_c[~a]; ~%", (5 + (dir-1)*8)*NSurfConf),
    printf(fh, "  const double *u_surf_rl = &pkpm_prim_surf_r[~a]; ~%", (4 + (dir-1)*8)*NSurfConf),
    printf(fh, "~%")
  ),

  /* Surface Lax penalization organized as (note T_ii = 3*P_ii/rho, includes necessary factors) : 
     [|ux_xl| + sqrt(Txx_xl), |ux_xr| + sqrt(Txx_xr), 
      |uy_yl| + sqrt(Tyy_yl), |uy_yr| + sqrt(Tyy_yr),
      |uz_zl| + sqrt(Tzz_zl), |uz_zr| + sqrt(Tzz_zr)] */
  printf(fh, "  const double *pkpm_lax_l = &pkpm_lax[~a]; ~%", (0 + (dir-1)*2)*NSurfConf),
  printf(fh, "  const double *pkpm_lax_r = &pkpm_lax[~a]; ~%", (1 + (dir-1)*2)*NSurfConf),
  printf(fh, "~%"),

  /* Project F_0 and G_1 onto the surface basis on the left and right of the interfaces */
  F_0_lr_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1.0, F_0l_e)),
  F_0_cl_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1.0, F_0c_e)),
  F_0_cr_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1.0, F_0c_e)),
  F_0_rl_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1.0, F_0r_e)),

  G_1_lr_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1.0, G_1l_e)),
  G_1_cl_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1.0, G_1c_e)),
  G_1_cr_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1.0, G_1c_e)),
  G_1_rl_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=-1.0, G_1r_e)),

  printf(fh, "  double F_0_lr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double F_0_cl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double F_0_cr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double F_0_rl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_F_0_u_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_F_0_u_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  printf(fh, "  double G_1_lr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double G_1_cl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double G_1_cr[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double G_1_rl[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_G_1_u_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_G_1_u_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  writeCExprs1(F_0_lr, F_0_lr_c), 
  printf(fh, "~%"),
  flush_output(fh),
  F_0_lr_e : doExpand1(F_0_lr, bSurf), 

  writeCExprs1(F_0_cl, F_0_cl_c), 
  printf(fh, "~%"),
  flush_output(fh),
  F_0_cl_e : doExpand1(F_0_cl, bSurf), 

  writeCExprs1(F_0_cr, F_0_cr_c), 
  printf(fh, "~%"),
  flush_output(fh),
  F_0_cr_e : doExpand1(F_0_cr, bSurf), 

  writeCExprs1(F_0_rl, F_0_rl_c), 
  printf(fh, "~%"),
  flush_output(fh),  
  F_0_rl_e : doExpand1(F_0_rl, bSurf), 

  writeCExprs1(G_1_lr, G_1_lr_c), 
  printf(fh, "~%"),
  flush_output(fh),
  G_1_lr_e : doExpand1(G_1_lr, bSurf), 

  writeCExprs1(G_1_cl, G_1_cl_c), 
  printf(fh, "~%"),
  flush_output(fh),
  G_1_cl_e : doExpand1(G_1_cl, bSurf), 

  writeCExprs1(G_1_cr, G_1_cr_c), 
  printf(fh, "~%"),
  flush_output(fh),
  G_1_cr_e : doExpand1(G_1_cr, bSurf), 

  writeCExprs1(G_1_rl, G_1_rl_c), 
  printf(fh, "~%"),
  flush_output(fh),  
  G_1_rl_e : doExpand1(G_1_rl, bSurf), 
  if cdim = 1 then (
    /* Fetch u and Lax penalization at surface interfaces */
    printf(fh, "  double ul_r = u_surf_lr[0]; ~%"),
    printf(fh, "  double uc_l = u_surf_cl[0]; ~%"),
    printf(fh, "  double uc_r = u_surf_cr[0]; ~%"),
    printf(fh, "  double ur_l = u_surf_rl[0]; ~%"),
    printf(fh, "  double avg_u_l = 0.5*(ul_r + uc_l); ~%"),
    printf(fh, "  double avg_u_r = 0.5*(uc_r + ur_l); ~%"),
    printf(fh, "~%"),
    printf(fh, "  double max_speed_l = pkpm_lax_l[0]; ~%"),
    printf(fh, "  double max_speed_r = pkpm_lax_r[0]; ~%"),
    printf(fh, "~%"),
    /* Print C exprs for Ghat for div(u F_0) and div(u G_1) across surface boundary, (LEFT BOUNDARY) */
    Ghat_F_0_u_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, 0.5*(F_0_lr_e + F_0_cl_e)*avg_u_l - 0.5*max_speed_l*(F_0_cl_e - F_0_lr_e))),
    Ghat_G_1_u_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, 0.5*(G_1_lr_e + G_1_cl_e)*avg_u_l - 0.5*max_speed_l*(G_1_cl_e - G_1_lr_e))),
    writeCExprs1(Ghat_F_0_u_l, Ghat_F_0_u_l_c),
    writeCExprs1(Ghat_G_1_u_l, Ghat_G_1_u_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    /* Print C exprs for Ghat for div(u F_0) and div(u G_1) across surface boundary, (RIGHT BOUNDARY) */
    Ghat_F_0_u_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, 0.5*(F_0_cr_e + F_0_rl_e)*avg_u_r - 0.5*max_speed_r*(F_0_rl_e - F_0_cr_e))),
    Ghat_G_1_u_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, 0.5*(G_1_cr_e + G_1_rl_e)*avg_u_r - 0.5*max_speed_r*(G_1_rl_e - G_1_cr_e))),
    writeCExprs1(Ghat_F_0_u_r, Ghat_F_0_u_r_c),
    writeCExprs1(Ghat_G_1_u_r, Ghat_G_1_u_r_c),
    printf(fh, "~%"),
    flush_output(fh) 
  )
  else (
    /* Expand surface basis quantities u_i and pkpm Lax penalization */
    u_surf_lr_e : doExpand1(u_surf_lr, bSurfConf),
    u_surf_cl_e : doExpand1(u_surf_cl, bSurfConf),
    u_surf_cr_e : doExpand1(u_surf_cr, bSurfConf),
    u_surf_rl_e : doExpand1(u_surf_rl, bSurfConf),

    pkpm_lax_l_e : doExpand1(pkpm_lax_l, bSurfConf),
    pkpm_lax_r_e : doExpand1(pkpm_lax_r, bSurfConf),

    /* Print C exprs for Ghat for div(u F_0) and div(u G_1) across surface boundary, (LEFT BOUNDARY) */
    Ghat_F_0_u_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, 0.5*(F_0_lr_e + F_0_cl_e)*0.5*(u_surf_lr_e + u_surf_cl_e) - 0.5*pkpm_lax_l_e*(F_0_cl_e - F_0_lr_e))),
    Ghat_G_1_u_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, 0.5*(G_1_lr_e + G_1_cl_e)*0.5*(u_surf_lr_e + u_surf_cl_e) - 0.5*pkpm_lax_l_e*(G_1_cl_e - G_1_lr_e))),
    writeCExprs1(Ghat_F_0_u_l, Ghat_F_0_u_l_c),
    writeCExprs1(Ghat_G_1_u_l, Ghat_G_1_u_l_c),
    printf(fh, "~%"),
    flush_output(fh),

    /* Print C exprs for Ghat for div(u F_0) and div(u G_1) across surface boundary, (RIGHT BOUNDARY) */
    Ghat_F_0_u_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, 0.5*(F_0_cr_e + F_0_rl_e)*0.5*(u_surf_cr_e + u_surf_rl_e) - 0.5*pkpm_lax_r_e*(F_0_rl_e - F_0_cr_e))),
    Ghat_G_1_u_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, 0.5*(G_1_cr_e + G_1_rl_e)*0.5*(u_surf_cr_e + u_surf_rl_e) - 0.5*pkpm_lax_r_e*(G_1_rl_e - G_1_cr_e))),
    writeCExprs1(Ghat_F_0_u_r, Ghat_F_0_u_r_c),
    writeCExprs1(Ghat_G_1_u_r, Ghat_G_1_u_r_c),
    printf(fh, "~%"),
    flush_output(fh)
  ),
  /* Expand G_hat for div(u F_0) and div(u G_1) in surface basis. */
  Ghat_F_0_u_l_e : doExpand1(Ghat_F_0_u_l, bSurf),
  Ghat_G_1_u_l_e : doExpand1(Ghat_G_1_u_l, bSurf),
  Ghat_F_0_u_r_e : doExpand1(Ghat_F_0_u_r, bSurf),
  Ghat_G_1_u_r_e : doExpand1(Ghat_G_1_u_r, bSurf),

  /* Compute surface contribution integral(phi^- Ghat) for div(u F_0) and div(u G_1) on the left and right. */
  incr_F_0_u_l : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Ghat_F_0_u_l_e),
  incr_F_0_u_r : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Ghat_F_0_u_r_e),
  incr_G_1_u_l : calcInnerProdList(surfVars, 1, subst(cv=-1.0, bP), Ghat_G_1_u_l_e),
  incr_G_1_u_r : calcInnerProdList(surfVars, -1, subst(cv=1.0, bP), Ghat_G_1_u_r_e),
  writeCIncrExprsCollect1lhsc(out_F_0, dx1*incr_F_0_u_l + dx1*incr_F_0_u_r),  
  writeCIncrExprsCollect1lhsc(out_G_1, dx1*incr_G_1_u_l + dx1*incr_G_1_u_r),  
  printf(fh, "~%"),
  flush_output(fh),
  printf(fh, "} ~%")
);

calcVlasovPKPMAccelUpdate(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NP, NC, pDim, cid, vid, 
   p_force_e, bb_grad_u_e, div_b_e, p_perp_div_b_e, acc_e, 
   surfVars, bSurf, surf_cdim, surf_vdim, surfNodes, basisStr, numNodes, NSurf, 
   alphaSurf_l_c, alphaSurf_r_c, alst_l, alst_r, alphaSurf_l_e, alphaSurf_r_e,
   div_b_Surf_c, div_b_lst, div_b_Surf_e, 
   p_perp_div_b_Surf_c, p_perp_div_b_lst, p_perp_div_b_Surf_e, 
   alphaOrd_l_n, alphaOrd_r_n, div_b_Ord_n, 
   F_0_HatSurf_l_e, G_1_HatSurf_l_e, F_0_HatSurf_r_e, G_1_HatSurf_r_e, 
   F_0_div_b_HatSurf_l_e, G_1_div_b_HatSurf_l_e, F_0_div_b_HatSurf_r_e, G_1_div_b_HatSurf_r_e, 
   Ghat_F_0_l_c, Ghat_G_1_l_c, Ghat_F_0_r_c, Ghat_G_1_r_c, 
   Ghat_F_0_div_b_l_c, Ghat_G_1_div_b_l_c, Ghat_F_0_div_b_r_c, Ghat_G_1_div_b_r_c, 
   Ghat_F_0_l_e, Ghat_G_1_l_e, Ghat_F_0_r_e, Ghat_G_1_r_e, 
   Ghat_F_0_div_b_l_e, Ghat_G_1_div_b_l_e, Ghat_F_0_div_b_r_e, Ghat_G_1_div_b_r_e, 
   incr_F_0_l, incr_G_1_l, incr_F_0_r, incr_G_1_r, 
   incr_F_0_div_b_l, incr_G_1_div_b_l, incr_F_0_div_b_r, incr_G_1_div_b_r],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim  : length(varsP),

  printf(fh, "GKYL_CU_DH void ~a_~ax~av_~a_p~a(const double *w, const double *dxv, const double *pkpm_accel_vars, 
     const double *g_dist_sourcel, const double *g_dist_sourcec, const double *g_dist_sourcer, 
     const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:            Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:          Cell spacing.~%"),
  printf(fh, "  // pkpm_accel_vars:    pkpm acceleration variables~%"), 
  printf(fh, "  // g_dist_sourcel/c/r: 2.0*T_perp/m*(2.0*T_perp/m*G_1 + T_perp/m*(F_2 - F_0)) in left/center/right cells.~%"), 
  printf(fh, "  // fl/fc/fr:           Input Distribution function [F_0, T_perp/m G_1 = T_perp/m (F_0 - F_1)] in left/center/right cells.~%"),
  printf(fh, "  // out:                Incremented distribution function in center cell.~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* grid spacing in v_parallel and v_parallel coordinate */
  printf(fh, "  const double dv1par = 2.0/dxv[~a]; ~%", cdim),
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),

  /* Access F_0 and T_perp/m G, first two Laguerre moments */
  printf(fh, "  const double *F_0l = &fl[~a]; ~%", 0),
  printf(fh, "  const double *G_1l = &fl[~a]; ~%", NP),  
  printf(fh, "  const double *F_0c = &fc[~a]; ~%", 0),
  printf(fh, "  const double *G_1c = &fc[~a]; ~%", NP), 
  printf(fh, "  const double *F_0r = &fr[~a]; ~%", 0),
  printf(fh, "  const double *G_1r = &fr[~a]; ~%", NP),
  printf(fh, "~%"),

  /* Access source distribution functions for mirror force
     F_0 source = T_perp/m G_1; G_1 source = 2.0*T_perp/m*(2.0*T_perp/m*G_1 + T_perp/m*(F_2 - F_0)) = g_dist_source (pre-computed) */
  printf(fh, "  const double *F_0_sourcel = &fl[~a]; ~%", NP),
  printf(fh, "  const double *G_1_sourcel = &g_dist_sourcel[~a]; ~%", 0),  
  printf(fh, "  const double *F_0_sourcec = &fc[~a]; ~%", NP),
  printf(fh, "  const double *G_1_sourcec = &g_dist_sourcec[~a]; ~%", 0), 
  printf(fh, "  const double *F_0_sourcer = &fr[~a]; ~%", NP),
  printf(fh, "  const double *G_1_sourcer = &g_dist_sourcer[~a]; ~%", 0),
  printf(fh, "~%"),

  /* Access pkpm acceleration variables for forces and sources */
  printf(fh, "  const double *div_b = &pkpm_accel_vars[~a]; ~%", 0*NC),
  printf(fh, "  const double *bb_grad_u = &pkpm_accel_vars[~a]; ~%", 1*NC),
  printf(fh, "  const double *p_force = &pkpm_accel_vars[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  /* Access the components of out for the first two Laguerre moments */
  printf(fh, "  double *out_F_0 = &out[~a]; ~%", 0),
  printf(fh, "  double *out_G_1 = &out[~a]; ~%", NP),  
  printf(fh, "~%"),

  /* Expand total pressure force p_force = ( 1/rho div(p_parallel b_hat) - T_perp/m*div(b)), 
     bb : grad(u), and div(b) in configuration space basis */
  p_force_e : doExpand1(p_force, bC),
  bb_grad_u_e : doExpand1(bb_grad_u, bC),
  div_b_e : doExpand1(div_b, bC),

  /* alpha_vdim = ( 1/rho div(p_parallel b_hat) - T_perp/m*div(b)) - v_parallel bb : grad(u)] 
     alpha_vdim consolidated as alpha_vdim = p_force - v_parallel bb_grad_u (pressure forces and bb_grad_u pre-computed) */
  acc_e : p_force_e - (vx*dvpar/2.0+wvpar)*bb_grad_u_e,  

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* Surface variables to integrate over. */
  surfVars : delete(vx,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vx dependence. */
  /* Also generate necessary basis strings, and surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),
    surf_cdim : cdim,  surf_vdim : 0,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim),

    basisStr : sconcat("hyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder),
    surfNodes : gaussOrd(polyOrder+1, pDim-1),

    basisStr : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  numNodes : length(surfNodes),
  NSurf : length(bSurf),

  /* Project alpha_vdim for F_0 and G_1 evaluated at interior surface onto surf basis. */
  clst : [dvpar, wvpar],
  alphaSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=-1,acc_e))),
  alphaSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=1,acc_e))),
  alst_l        : doMakeExprLst(alphaSurf_l_c, alphaSurf_l),
  alst_r        : doMakeExprLst(alphaSurf_r_c, alphaSurf_r),
  alphaSurf_l_e : doExpand(alst_l, bSurf),
  alphaSurf_r_e : doExpand(alst_r, bSurf),
  printf(fh, "  double alphaSurf_l[~a] = {0.0}; ~%", NSurf),
  writeCExprsCollect1(alphaSurf_l, alphaSurf_l_c, clst),
  printf(fh, "~%"),
  printf(fh, "  double alphaSurf_r[~a] = {0.0}; ~%", NSurf),
  writeCExprsCollect1(alphaSurf_r, alphaSurf_r_c, clst),
  printf(fh, "~%"),

  /* project div_b evaluated at interior surface onto surface basis.
     No velocity space dependence so we can just project div_b onto surface basis. */
  div_b_Surf_c : fullratsimp(innerProd(surfVars, 1, bSurf, div_b_e)),
  div_b_lst    : doMakeExprLst(div_b_Surf_c, div_b_Surf),
  div_b_Surf_e : doExpand(div_b_lst, bSurf),
  printf(fh, "  double div_b_Surf[~a] = {0.0}; ~%", NSurf),
  writeCExprsCollect1(div_b_Surf, div_b_Surf_c, clst),
  printf(fh, "~%"),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous. */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaSurf_r_e,surfNodes,surfVars))),

  /* Evaluate div(b) at ordinates.
     Note: div_b_Surf_e is already a surface expansion. 
     In addition, it is continuous and does *not* depend on velocity space. */
  div_b_Ord_n : gcfac(float(evAtNodes(div_b_Surf_e,surfNodes,surfVars))),

  printf(fh, "  double F_0_UpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_UpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_Upwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double F_0_Upwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_F_0_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_F_0_r[~a] = {0.0}; ~%", NSurf),

  printf(fh, "  double G_1_UpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double G_1_UpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double G_1_Upwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double G_1_Upwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_G_1_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_G_1_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  /* Check sign of each quadrature point and choose appropriate distribution function at 
     quadrature points. 
     If alphaSurf_l > 0, need f_l (at +1), else f_c (at -1). 
     If alphaSurf_r > 0, need f_c (at +1), else f_r (at -1). */

  for i : 1 thru length(alphaOrd_l_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_l_n[i]),
    printf(fh, "    F_0_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0l); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1l); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0c); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1c); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%"),
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_r_n[i]),
    printf(fh, "    F_0_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0c); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1c); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0r); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1r); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(F_0_UpwindQuad_l, F_0_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(F_0_UpwindQuad_r, F_0_Upwind_r); ~%", basisStr),
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(G_1_UpwindQuad_l, G_1_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(G_1_UpwindQuad_r, G_1_Upwind_r); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad_l, F_0_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad_r, F_0_Upwind_r); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_UpwindQuad_l, G_1_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_UpwindQuad_r, G_1_Upwind_r); ~%", basisStr)
  ),
  printf(fh, "~%"),

  printf(fh, "  double F_0_div_b_UpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_div_b_UpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_div_b_Upwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double F_0_div_b_Upwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_F_0_div_b_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_F_0_div_b_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  printf(fh, "  double G_1_div_b_UpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double G_1_div_b_UpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double G_1_div_b_Upwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double G_1_div_b_Upwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_G_1_div_b_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_G_1_div_b_r[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),

  /* Check sign of each quadrature point and choose appropriate distribution function at 
     quadrature points. 
     If div_b_Surf > 0, need f_l and f_c (at +1) else f_c and f_r (at -1).
     Can fetch both left and right values because div_b_Surf does not depend on velocity space. */
  for i : 1 thru length(div_b_Ord_n) do (
    printf(fh, "  if (~a > 0) { ~%", div_b_Ord_n[i]),
    printf(fh, "    F_0_div_b_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0_sourcel); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    F_0_div_b_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0_sourcec); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_div_b_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1_sourcel); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_div_b_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1_sourcec); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_div_b_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0_sourcec); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    F_0_div_b_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0_sourcer); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_div_b_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1_sourcec); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_div_b_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1_sourcer); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(F_0_div_b_UpwindQuad_l, F_0_div_b_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(F_0_div_b_UpwindQuad_r, F_0_div_b_Upwind_r); ~%", basisStr),
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(G_1_div_b_UpwindQuad_l, G_1_div_b_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(G_1_div_b_UpwindQuad_r, G_1_div_b_Upwind_r); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_div_b_UpwindQuad_l, F_0_div_b_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_div_b_UpwindQuad_r, F_0_div_b_Upwind_r); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_div_b_UpwindQuad_l, G_1_div_b_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_div_b_UpwindQuad_r, G_1_div_b_Upwind_r); ~%", basisStr)
  ),
  printf(fh, "~%"),

  /* Create expansions of F_0_hat, G_1_hat (upwinded first two Laguerre moments) on the left and right in the surface basis. */
  /* Upwinded values calculated from alpha_vdim = 1/rho (div(p_parallel b_hat) - p_perp div(b)) - v_parallel bb : grad(u)] */
  F_0_HatSurf_l_e : doExpand1(F_0_Upwind_l, bSurf),
  F_0_HatSurf_r_e : doExpand1(F_0_Upwind_r, bSurf),
  G_1_HatSurf_l_e : doExpand1(G_1_Upwind_l, bSurf),
  G_1_HatSurf_r_e : doExpand1(G_1_Upwind_r, bSurf),

  /* Upwinded values calculated from div(b) for additional force 
     Note: force on F_0 is just div(b) because T_perp/m absorbed into G, while force on G_1 is
     2*p_perp/rho*div(b); since only the sign matters, use div(b) for both (perp/rho should *not* be negative) */
  F_0_div_b_HatSurf_l_e : doExpand1(F_0_div_b_Upwind_l, bSurf),
  F_0_div_b_HatSurf_r_e : doExpand1(F_0_div_b_Upwind_r, bSurf),
  G_1_div_b_HatSurf_l_e : doExpand1(G_1_div_b_Upwind_l, bSurf),
  G_1_div_b_HatSurf_r_e : doExpand1(G_1_div_b_Upwind_r, bSurf),

  /* Print C exprs for Ghat across surface boundary, (LEFT BOUNDARY) */
  Ghat_F_0_l_c : fullratsimp(innerProd(surfVars, alphaSurf_l_e, bSurf, F_0_HatSurf_l_e)),
  Ghat_G_1_l_c : fullratsimp(innerProd(surfVars, alphaSurf_l_e, bSurf, G_1_HatSurf_l_e)),
  writeCExprs1(Ghat_F_0_l, Ghat_F_0_l_c),
  writeCExprs1(Ghat_G_1_l, Ghat_G_1_l_c),

  Ghat_F_0_div_b_l_c : fullratsimp(innerProd(surfVars, div_b_Surf_e, bSurf, F_0_div_b_HatSurf_l_e)),
  Ghat_G_1_div_b_l_c : fullratsimp(innerProd(surfVars, div_b_Surf_e, bSurf, G_1_div_b_HatSurf_l_e)),
  writeCExprs1(Ghat_F_0_div_b_l, Ghat_F_0_div_b_l_c),
  writeCExprs1(Ghat_G_1_div_b_l, Ghat_G_1_div_b_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Print C exprs for Ghat across surface boundary, (RIGHT BOUNDARY) */
  Ghat_F_0_r_c : fullratsimp(innerProd(surfVars, alphaSurf_r_e, bSurf, F_0_HatSurf_r_e)),
  Ghat_G_1_r_c : fullratsimp(innerProd(surfVars, alphaSurf_r_e, bSurf, G_1_HatSurf_r_e)),
  writeCExprs1(Ghat_F_0_r, Ghat_F_0_r_c),
  writeCExprs1(Ghat_G_1_r, Ghat_G_1_r_c),

  Ghat_F_0_div_b_r_c : fullratsimp(innerProd(surfVars, div_b_Surf_e, bSurf, F_0_div_b_HatSurf_r_e)),
  Ghat_G_1_div_b_r_c : fullratsimp(innerProd(surfVars, div_b_Surf_e, bSurf, G_1_div_b_HatSurf_r_e)),
  writeCExprs1(Ghat_F_0_div_b_r, Ghat_F_0_div_b_r_c),
  writeCExprs1(Ghat_G_1_div_b_r, Ghat_G_1_div_b_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Expand G_hat in surface basis. */
  Ghat_F_0_l_e       : doExpand1(Ghat_F_0_l, bSurf),
  Ghat_G_1_l_e       : doExpand1(Ghat_G_1_l, bSurf),
  Ghat_F_0_div_b_l_e : doExpand1(Ghat_F_0_div_b_l, bSurf),
  Ghat_G_1_div_b_l_e : doExpand1(Ghat_G_1_div_b_l, bSurf),

  Ghat_F_0_r_e       : doExpand1(Ghat_F_0_r, bSurf),
  Ghat_G_1_r_e       : doExpand1(Ghat_G_1_r, bSurf),
  Ghat_F_0_div_b_r_e : doExpand1(Ghat_F_0_div_b_r, bSurf),
  Ghat_G_1_div_b_r_e : doExpand1(Ghat_G_1_div_b_r, bSurf),

  /* Compute surface contribution integral(phi^- Ghat) on the left and right. */
  incr_F_0_l : calcInnerProdList(surfVars, 1, subst(vx=-1.0, bP), Ghat_F_0_l_e),
  incr_F_0_r : calcInnerProdList(surfVars, -1, subst(vx=1.0, bP), Ghat_F_0_r_e),
  incr_G_1_l : calcInnerProdList(surfVars, 1, subst(vx=-1.0, bP), Ghat_G_1_l_e),
  incr_G_1_r : calcInnerProdList(surfVars, -1, subst(vx=1.0, bP), Ghat_G_1_r_e),

  incr_F_0_div_b_l : calcInnerProdList(surfVars, 1, subst(vx=-1.0, bP), Ghat_F_0_div_b_l_e),
  incr_F_0_div_b_r : calcInnerProdList(surfVars, -1, subst(vx=1.0, bP), Ghat_F_0_div_b_r_e),
  incr_G_1_div_b_l : calcInnerProdList(surfVars, 1, subst(vx=-1.0, bP), Ghat_G_1_div_b_l_e),
  incr_G_1_div_b_r : calcInnerProdList(surfVars, -1, subst(vx=1.0, bP), Ghat_G_1_div_b_r_e),

  writeCIncrExprsCollect1lhsc(out_F_0, dv1par*incr_F_0_l + dv1par*incr_F_0_r + dv1par*incr_F_0_div_b_l + dv1par*incr_F_0_div_b_r),  
  writeCIncrExprsCollect1lhsc(out_G_1, dv1par*incr_G_1_l + dv1par*incr_G_1_r + dv1par*incr_G_1_div_b_l + dv1par*incr_G_1_div_b_r),  
  printf(fh, "~%"),

  printf(fh, "} ~%")
);