/* This script generates the kernels for the surface term of Euler's equations
   for the parallel-kinetic-perpendicular-moment (pkpm) model */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
load("recovery")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx10, dx11, dx12]$

statevec : [rhou0, rhou1, rhou2, p_perp]$
lhs : [outrhou0, outrhou1, outrhou2, outp_perp]$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

/* 1D Euler special since only involves evaluations */
calcEulerPKPM1xUpdateInDir(dir, fh, funcNm, cdim, basisFun, polyOrder) := block(
  [bC,NC,cid,cv,surfVars,
  rhouxl_e,rhouyl_e,rhouzl_e,p_perpl_e,
  rhouxc_e,rhouyc_e,rhouzc_e,p_perpc_e,
  rhouxr_e,rhouyr_e,rhouzr_e,p_perpr_e,
  uxl_e,uxc_e,uxr_e,
  uyl_e,uyc_e,uyr_e,
  uzl_e,uzc_e,uzr_e,
  Pxxl_e,Pxxc_e,Pxxr_e,
  Pxyl_e,Pxyc_e,Pxyr_e,
  Pxzl_e,Pxzc_e,Pxzr_e,
  rhouxl_r,rhouyl_r,rhouzl_r,p_perpl_r,
  rhouxc_l,rhouyc_l,rhouzc_l,p_perpc_l,
  rhouxc_r,rhouyc_r,rhouzc_r,p_perpc_r,
  rhouxr_l,rhouyr_l,rhouzr_l,p_perpr_l,
  Pxxl_r, Pxyl_r, Pxzl_r,
  Pxxc_l, Pxyc_l, Pxzc_l,
  Pxxc_r, Pxyc_r, Pxzc_r,
  Pxxr_l, Pxyr_l, Pxzr_l,
  avg_Pxx_l,avg_Pxx_r,avg_Pxy_l,avg_Pxy_r,avg_Pxz_l,avg_Pxz_r,
  avg_Pyy_l,avg_Pyy_r,avg_Pyz_l,avg_Pyz_r,avg_Pzz_l,avg_Pzz_r,
  Ghat_rhoux_l_exp,Ghat_rhoux_r_exp,Ghat_rhouy_l_exp,Ghat_rhouy_r_exp,Ghat_rhouz_l_exp,Ghat_rhouz_r_exp,Ghat_p_perp_l_exp,Ghat_p_perp_r_exp,
  incr_rhoux_l,incr_rhoux_r,incr_rhouy_l,incr_rhouy_r,incr_rhouz_l,incr_rhouz_r,incr_p_perp_l,incr_p_perp_r],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "GKYL_CU_DH void ~a~a_~ax_~a_p~a(const double *w, const double *dxv, 
  const double *u_i, const double *p_ijl, const double *p_ijc, const double *p_ijr,
  const double *statevecl, const double *statevecc, const double *statevecr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // u_i: Input bulk velocity (ux,uy,uz) in cell being updated (ASSUMED TO BE CONTINUOUS).~%"),
  printf(fh, "  // p_ijl/p_ijc/p_ijr: Pressure tensor in left/center/right cells.~%"),
  printf(fh, "  // statevecl/statevecc/statevecr: [rho ux, rho uy, rho uz, p_perp], Fluid input state vector in left/center/right cells.~%"),
  printf(fh, "  // out: Incremented output.~%"),
  printf(fh, "~%"),

  /* cv = variable in direction of surface update. */
  cv : varsC[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsC),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_l = &statevecl[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_l = &statevecl[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_l = &statevecl[~a]; ~%", 2*NC),
  printf(fh, "  const double *p_perp_l = &statevecl[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_c = &statevecc[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_c = &statevecc[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_c = &statevecc[~a]; ~%", 2*NC),
  printf(fh, "  const double *p_perp_c = &statevecc[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *rhoux_r = &statevecr[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy_r = &statevecr[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz_r = &statevecr[~a]; ~%", 2*NC),
  printf(fh, "  const double *p_perp_r = &statevecr[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *ux_c = &u_i[~a]; ~%", 0*NC),
  printf(fh, "  const double *uy_c = &u_i[~a]; ~%", 1*NC),
  printf(fh, "  const double *uz_c = &u_i[~a]; ~%", 2*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxx_l = &p_ijl[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxx_c = &p_ijc[~a]; ~%", 0*NC),
  printf(fh, "  const double *Pxx_r = &p_ijr[~a]; ~%", 0*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxy_l = &p_ijl[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxy_c = &p_ijc[~a]; ~%", 1*NC),
  printf(fh, "  const double *Pxy_r = &p_ijr[~a]; ~%", 1*NC),

  printf(fh, "~%"),

  printf(fh, "  const double *Pxz_l = &p_ijl[~a]; ~%", 2*NC),
  printf(fh, "  const double *Pxz_c = &p_ijc[~a]; ~%", 2*NC),
  printf(fh, "  const double *Pxz_r = &p_ijr[~a]; ~%", 2*NC),

  printf(fh, "~%"),

  printf(fh, "  double *outrhou0 = &out[~a]; ~%", 0*NC),
  printf(fh, "  double *outrhou1 = &out[~a]; ~%", 1*NC),
  printf(fh, "  double *outrhou2 = &out[~a]; ~%", 2*NC),
  printf(fh, "  double *outp_perp = &out[~a]; ~%", 3*NC),

  printf(fh, "~%"),

  rhouxl_e : doExpand1(rhoux_l, bC),
  rhouyl_e : doExpand1(rhouy_l, bC),
  rhouzl_e : doExpand1(rhouz_l, bC),
  p_perpl_e : doExpand1(p_perp_l, bC),

  rhouxc_e : doExpand1(rhoux_c, bC),
  rhouyc_e : doExpand1(rhouy_c, bC),
  rhouzc_e : doExpand1(rhouz_c, bC),
  p_perpc_e : doExpand1(p_perp_c, bC),

  rhouxr_e : doExpand1(rhoux_r, bC),
  rhouyr_e : doExpand1(rhouy_r, bC),
  rhouzr_e : doExpand1(rhouz_r, bC),
  p_perpr_e : doExpand1(p_perp_r, bC),

  Pxx_l_e : doExpand1(Pxx_l,bC),
  Pxx_c_e : doExpand1(Pxx_c,bC),
  Pxx_r_e : doExpand1(Pxx_r,bC),

  Pxy_l_e : doExpand1(Pxy_l,bC),
  Pxy_c_e : doExpand1(Pxy_c,bC),
  Pxy_r_e : doExpand1(Pxy_r,bC),

  Pxz_l_e : doExpand1(Pxz_l,bC),
  Pxz_c_e : doExpand1(Pxz_c,bC),
  Pxz_r_e : doExpand1(Pxz_r,bC),

  rhouxl_r : subst(cv=1, rhouxl_e),
  rhouyl_r : subst(cv=1, rhouyl_e),
  rhouzl_r : subst(cv=1, rhouzl_e),
  p_perpl_r : subst(cv=1, p_perpl_e),
  Pxx_l_r : subst(cv=1, Pxx_l_e),
  Pxy_l_r : subst(cv=1, Pxy_l_e),
  Pxz_l_r : subst(cv=1, Pxz_l_e),

  rhouxc_l : subst(cv=-1, rhouxc_e),
  rhouyc_l : subst(cv=-1, rhouyc_e),
  rhouzc_l : subst(cv=-1, rhouzc_e),
  p_perpc_l : subst(cv=-1, p_perpc_e),
  Pxx_c_l : subst(cv=-1, Pxx_c_e),
  Pxy_c_l : subst(cv=-1, Pxy_c_e),
  Pxz_c_l : subst(cv=-1, Pxz_c_e),

  rhouxc_r : subst(cv=1, rhouxc_e),
  rhouyc_r : subst(cv=1, rhouyc_e),
  rhouzc_r : subst(cv=1, rhouzc_e),
  p_perpc_r : subst(cv=1, p_perpc_e),
  Pxx_c_r : subst(cv=1, Pxx_c_e),
  Pxy_c_r : subst(cv=1, Pxy_c_e),
  Pxz_c_r : subst(cv=1, Pxz_c_e),

  rhouxr_l : subst(cv=-1, rhouxr_e),
  rhouyr_l : subst(cv=-1, rhouyr_e),
  rhouzr_l : subst(cv=-1, rhouzr_e),
  p_perpr_l : subst(cv=-1, p_perpr_e),
  Pxx_r_l : subst(cv=-1, Pxx_r_e),
  Pxy_r_l : subst(cv=-1, Pxy_r_e),
  Pxz_r_l : subst(cv=-1, Pxz_r_e),

  /* evaluate u at surface interfaces to find max 
     Need ux, uy, and uz because of off-diagonal pressure tensor components */
  printf(fh, "  double ux_c_l = ~a_~ax_p~a_surfx1_eval_quad_node_0_l(ux_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "  double ux_c_r = ~a_~ax_p~a_surfx1_eval_quad_node_0_r(ux_c); ~%", basisFun, cdim, polyOrder),
  printf(fh, "~%"),

  avg_Pxx_l : 0.5*(Pxx_l_r + Pxx_c_l),
  avg_Pxx_r : 0.5*(Pxx_c_r + Pxx_r_l),

  avg_Pxy_l : 0.5*(Pxy_l_r + Pxy_c_l),
  avg_Pxy_r : 0.5*(Pxy_c_r + Pxy_r_l),

  avg_Pxz_l : 0.5*(Pxz_l_r + Pxz_c_l),
  avg_Pxz_r : 0.5*(Pxz_c_r + Pxz_r_l),

  printf(fh, "  double Ghat_rhoux_l = 0.0; ~%"),
  printf(fh, "  double Ghat_rhoux_r = 0.0; ~%"),
  printf(fh, "  double Ghat_rhouy_l = 0.0; ~%"),
  printf(fh, "  double Ghat_rhouy_r = 0.0; ~%"),
  printf(fh, "  double Ghat_rhouz_l = 0.0; ~%"),
  printf(fh, "  double Ghat_rhouz_r = 0.0; ~%"),  

  printf(fh, "  double Ghat_p_perp_l = 0.0; ~%"),
  printf(fh, "  double Ghat_p_perp_r = 0.0; ~%"),  

  printf(fh, "  if (ux_c_l > 0) { ~%"),

  printf(fh, "  Ghat_rhoux_l = ~a; ~%", ux_c_l*float(expand(rhouxl_r)) + float(expand(avg_Pxx_l))),
  printf(fh, "  Ghat_rhouy_l = ~a; ~%", ux_c_l*float(expand(rhouyl_r)) + float(expand(avg_Pxy_l))),
  printf(fh, "  Ghat_rhouz_l = ~a; ~%", ux_c_l*float(expand(rhouzl_r)) + float(expand(avg_Pxz_l))),
  printf(fh, "  Ghat_p_perp_l = ~a; ~%", ux_c_l*float(expand(p_perpl_r))),

  printf(fh, "  } else { ~%"),

  printf(fh, "  Ghat_rhoux_l = ~a; ~%", ux_c_l*float(expand(rhouxc_l)) + float(expand(avg_Pxx_l))),
  printf(fh, "  Ghat_rhouy_l = ~a; ~%", ux_c_l*float(expand(rhouyc_l)) + float(expand(avg_Pxy_l))),
  printf(fh, "  Ghat_rhouz_l = ~a; ~%", ux_c_l*float(expand(rhouzc_l)) + float(expand(avg_Pxz_l))),
  printf(fh, "  Ghat_p_perp_l = ~a; ~%", ux_c_l*float(expand(p_perpc_l))),

  printf(fh, "  } ~%"),

  printf(fh, "  if (ux_c_r > 0) { ~%"),

  printf(fh, "  Ghat_rhoux_r = ~a; ~%", ux_c_r*float(expand(rhouxc_r)) + float(expand(avg_Pxx_r))),
  printf(fh, "  Ghat_rhouy_r = ~a; ~%", ux_c_r*float(expand(rhouyc_r)) + float(expand(avg_Pxy_r))),
  printf(fh, "  Ghat_rhouz_r = ~a; ~%", ux_c_r*float(expand(rhouzc_r)) + float(expand(avg_Pxz_r))),
  printf(fh, "  Ghat_p_perp_r = ~a; ~%", ux_c_r*float(expand(p_perpc_r))),

  printf(fh, "  } else { ~%"),

  printf(fh, "  Ghat_rhoux_r = ~a; ~%", ux_c_r*float(expand(rhouxr_l)) + float(expand(avg_Pxx_r))),
  printf(fh, "  Ghat_rhouy_r = ~a; ~%", ux_c_r*float(expand(rhouyr_l)) + float(expand(avg_Pxy_r))),
  printf(fh, "  Ghat_rhouz_r = ~a; ~%", ux_c_r*float(expand(rhouzr_l)) + float(expand(avg_Pxz_r))),
  printf(fh, "  Ghat_p_perp_r = ~a; ~%", ux_c_r*float(expand(p_perpr_l))),
  printf(fh, "  } ~%"),

  printf(fh, "~%"),

  incr_rhoux_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rhoux_l),
  incr_rhoux_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rhoux_r),

  incr_rhouy_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rhouy_l),
  incr_rhouy_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rhouy_r),

  incr_rhouz_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_rhouz_l),
  incr_rhouz_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_rhouz_r),

  incr_p_perp_l : calcInnerProdList(surfVars, 1, subst(cv=-1, bC), Ghat_p_perp_l),
  incr_p_perp_r : calcInnerProdList(surfVars, -1, subst(cv=1, bC), Ghat_p_perp_r),

  surfTerms : [incr_rhoux_l + incr_rhoux_r,incr_rhouy_l + incr_rhouy_r,incr_rhouz_l + incr_rhouz_r,incr_p_perp_l + incr_p_perp_r],
  for m : 1 thru 4 do (
    surf : surfTerms[m],
    writeCIncrExprs1(lhs[m], dx1*surf),
    printf(fh, "~%")
  ),

  printf(fh, "} ~%")
);
