/* This script generates the kernels for bb : grad(u) 
   for discretization of the parallel-kinetic-perpendicular-moment
   model. Used by kinetic equation. */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("recovery")$
fpprec : 24$
cvars : [x, y, z]$

calcPKPMbbgradu(dir, fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, cv, 
  lst_ux_l, lst_ux_c, lst_ux_r, lst_uy_l, lst_uy_c, lst_uy_r, lst_uz_l, lst_uz_c, lst_uz_r, 
  ux_rec, uy_rec, uz_rec, 
  grad_u_x_c, grad_u_y_c, grad_u_z_c,
  bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e,  
  grad_u_x_e, grad_u_y_e, grad_u_z_e, incr],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  /* cv = variable to perform recovery in. */
  cv : varsC[dir],

  printf(fh, "GKYL_CU_DH void ~a~a_~ax_~a_p~a(const double *dxv, const double *bvar, const double *u_il, const double *u_ic, const double *u_ir, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, basisFun, polyOrder),
  printf(fh, "  // dxv[NDIM]:      Cell spacing.~%"),
  printf(fh, "  // bvar:           magnetic field unit vector (nine components; first three components, b_i, other six components, b_i b_j.) ~%"),
  printf(fh, "  // u_il/u_ic/u_ir: flow velocity in left/center/right cells.~%"),
  printf(fh, "  // out:            Increment to volume expansion of bb : grad_u in one direction.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_l = &u_il[~a]; ~%", 0),
  printf(fh, "  const double *uy_l = &u_il[~a]; ~%", NC),
  printf(fh, "  const double *uz_l = &u_il[~a]; ~%", NC*2),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_c = &u_ic[~a]; ~%", 0),
  printf(fh, "  const double *uy_c = &u_ic[~a]; ~%", NC),
  printf(fh, "  const double *uz_c = &u_ic[~a]; ~%", NC*2),
  printf(fh, "~%"),

  printf(fh, "  const double *ux_r = &u_ir[~a]; ~%", 0),
  printf(fh, "  const double *uy_r = &u_ir[~a]; ~%", NC),
  printf(fh, "  const double *uz_r = &u_ir[~a]; ~%", NC*2),
  printf(fh, "~%"),

  printf(fh, "  const double *bxbx = &bvar[~a]; ~%", NC*3),
  printf(fh, "  const double *bxby = &bvar[~a]; ~%", NC*4),
  printf(fh, "  const double *bxbz = &bvar[~a]; ~%", NC*5),
  printf(fh, "  const double *byby = &bvar[~a]; ~%", NC*6),
  printf(fh, "  const double *bybz = &bvar[~a]; ~%", NC*7),
  printf(fh, "  const double *bzbz = &bvar[~a]; ~%", NC*8),
  printf(fh, "~%"),

  /* We use recovery to compute the divergence of the pressure tensor */
  lst_ux_l : makelist(ux_l[i], i, 0, NC-1),
  lst_ux_c : makelist(ux_c[i], i, 0, NC-1),
  lst_ux_r : makelist(ux_r[i], i, 0, NC-1),

  lst_uy_l : makelist(uy_l[i], i, 0, NC-1),
  lst_uy_c : makelist(uy_c[i], i, 0, NC-1),
  lst_uy_r : makelist(uy_r[i], i, 0, NC-1),

  lst_uz_l : makelist(uz_l[i], i, 0, NC-1),
  lst_uz_c : makelist(uz_c[i], i, 0, NC-1),
  lst_uz_r : makelist(uz_r[i], i, 0, NC-1),

  ux_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 0, 
    dg(lst_ux_l), dg(lst_ux_c), dg(lst_ux_r)),

  uy_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 0, 
    dg(lst_uy_l), dg(lst_uy_c), dg(lst_uy_r)),

  uz_rec : calcRecov1CellGen(basisFun, cv, varsC, polyOrder, 0, 
    dg(lst_uz_l), dg(lst_uz_c), dg(lst_uz_r)),

  printf(fh, "  double grad_u_x[~a] = {0.0}; ~%", NC),
  printf(fh, "  double grad_u_y[~a] = {0.0}; ~%", NC),
  printf(fh, "  double grad_u_z[~a] = {0.0}; ~%", NC),

  grad_u_x_c : calcInnerProdList(varsC, 1, bC, diff(ux_rec , cv)),
  writeCExprs1(grad_u_x, grad_u_x_c),
  printf(fh, "~%"),

  grad_u_y_c : calcInnerProdList(varsC, 1, bC, diff(uy_rec , cv)),
  writeCExprs1(grad_u_y, grad_u_y_c),
  printf(fh, "~%"),

  grad_u_z_c : calcInnerProdList(varsC, 1, bC, diff(uz_rec , cv)),
  writeCExprs1(grad_u_z, grad_u_z_c),
  printf(fh, "~%"),

  bxbx_e : doExpand1(bxbx, bC),
  bxby_e : doExpand1(bxby, bC),
  bxbz_e : doExpand1(bxbz, bC),
  byby_e : doExpand1(byby, bC),
  bybz_e : doExpand1(bybz, bC),
  bzbz_e : doExpand1(bzbz, bC),

  grad_u_x_e : doExpand1(grad_u_x, bC),
  grad_u_y_e : doExpand1(grad_u_y, bC),
  grad_u_z_e : doExpand1(grad_u_z, bC),

  incr : calcInnerProdList(varsC, 1, bC, bxbx_e*grad_u_x_e + bxby_e*grad_u_y_e + bxbz_e*grad_u_z_e),

  writeCIncrExprsCollect1lhsc(out, dx1*incr),  

  printf(fh, "} ~%")
)$
