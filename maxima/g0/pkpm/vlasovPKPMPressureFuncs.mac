/* This script generates the kernels for the surface term of the 
   advection in velocity space for the Vlasov equation
   in the parallel-kinetic-perpendicular-moment (pkpm) model */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
load("recovery")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx0, dx1, dx2]$

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

calcVlasovPKPMPressureUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NP, pDim, cid, vid, cv, surfVars, bSurf, NSurf, surfNodes, numNodes, basisStr, 
   F_0l_e, F_0c_e, F_0r_e, bl_e, bc_e, br_e, vTrans, 
   alpha_l_c, alpha_c_c, alpha_r_c, lst_alpha_l, lst_alpha_c, lst_alpha_r, alpha_rec_l, alpha_rec_r, 
   alphaSurf_l_c, alphaSurf_r_c, alst_l, alst_r, alphaSurf_l_e, alphaSurf_r_e, alphaOrd_l_n, alphaOrd_r_n,
   F_0_HatSurf_l_e, F_0_HatSurf_r_e, 
   Ghat_F_0_l_c, Ghat_F_0_r_c, 
   Ghat_F_0_l_e, Ghat_F_0_r_e, 
   incr_F_0_l, incr_F_0_r, incr_F_0_vol],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  printf(fh, "GKYL_CU_DH void ~a_~a_~ax~av_~a_p~a(const double *w, const double *dxv, 
     const double *bvarl, const double *bvarc, const double *bvarr, 
     const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cvars[dir], cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:                 Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:               Cell spacing.~%"),
  printf(fh, "  // bvarl/bvarc/bvarr:       Input magnetic field unit vector in left/center/right cells.~%"),
  printf(fh, "  // fl/fc/fr:                Input Distribution function [F_0, T_perp G = T_perp (F_1 - F_0)] in left/center/right cells.~%"),
  printf(fh, "  // out:                     Incremented distribution function in center cell.~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* cv = variable in direction of surface update. */
  cv : varsP[dir],

  /* Surface variables to integrate over. */
  surfVars : delete(cv,varsP),
  surfConfVars : delete(cv,varsC),

  printf(fh, "  const double dx1 = 2.0/dxv[~a]; ~%", dir-1),
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),
  printf(fh, "  const double volFact = dxv[~a]/2.0; ~%", cdim),
  printf(fh, "  const double *bl = &bvarl[~a]; ~%", NC*(dir-1)),
  printf(fh, "  const double *bc = &bvarc[~a]; ~%", NC*(dir-1)),
  printf(fh, "  const double *br = &bvarr[~a]; ~%", NC*(dir-1)),

  /* Access F_0 and T_perp G, first two Laguerre moments */
  printf(fh, "  const double *F_0l = &fl[~a]; ~%", 0), 
  printf(fh, "  const double *F_0c = &fc[~a]; ~%", 0),
  printf(fh, "  const double *F_0r = &fr[~a]; ~%", 0),

  /* Access the components of out for the div(p_parallel b_hat) in direction dir */
  printf(fh, "  double *out_pressure = &out[~a]; ~%", NC*(dir-1)),

  /* Expand bulk velocity, magnetic field unit vector, and distribution function 
      in left, center, and right cells */
  F_0l_e : doExpand1(F_0l,bP),
  F_0c_e : doExpand1(F_0c,bP),
  F_0r_e : doExpand1(F_0r,bP),

  bl_e : doExpand1(bl,bC),
  bc_e : doExpand1(bc,bC),
  br_e : doExpand1(br,bC),

  /* Coordinate transformation for velocity space */
  vTrans : vx*dvpar/2+wvpar,

  /* Compute phase space flux due to parallel streaming in left, center, and right cells.
     The, write out phase space flux in left, center, and right cells
     for use in recovery procedure */
  printf(fh, "  double alpha_l[~a] = {0.0}; ~%", NP),
  printf(fh, "  double alpha_c[~a] = {0.0}; ~%", NP),
  printf(fh, "  double alpha_r[~a] = {0.0}; ~%", NP),

  alpha_l_c : calcInnerProdList(varsP, 1, bP, vTrans*bl_e),
  alpha_c_c : calcInnerProdList(varsP, 1, bP, vTrans*bc_e),
  alpha_r_c : calcInnerProdList(varsP, 1, bP, vTrans*br_e),

  writeCExprs1(alpha_l, alpha_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(alpha_c, alpha_c_c),
  printf(fh, "~%"),
  flush_output(fh),

  writeCExprs1(alpha_r, alpha_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  alst_vol : doMakeExprLst(alpha_c_c, alpha_c),
  alphaVol_e : doExpand(alst_vol, bP),

  /* We use recovery to compute the interface phase space flux */
  /* Create safety lists for recovery */
  lst_alpha_l : doMakeExprLst(alpha_l_c, alpha_l), 
  lst_alpha_c : doMakeExprLst(alpha_c_c, alpha_c), 
  lst_alpha_r : doMakeExprLst(alpha_r_c, alpha_r),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no cv dependence. */
  /* Also generate recovery, necessary basis strings, and surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),
    bSurfConf : basisFromVars(basisFun,surfConfVars,polyOrder),

    alpha_rec_l : calcRecov2CellGen("hyb", cv, varsP, polyOrder,
      dg(lst_alpha_l), dg(lst_alpha_c)),
    alpha_rec_r : calcRecov2CellGen("hyb", cv, varsP, polyOrder,
      dg(lst_alpha_c), dg(lst_alpha_r)),

    surf_cdim : cdim-1,  surf_vdim : 1,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim),
    surfConfNodes : gaussOrd(polyOrder+1, cdim-1),

    basisStr : sconcat("hyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder), 
    bSurfConf : basisFromVars(basisFun,surfConfVars,polyOrder),

    alpha_rec_l : calcRecov2CellGen(basisFun, cv, varsP, polyOrder,
      dg(lst_alpha_l), dg(lst_alpha_c)),
    alpha_rec_r : calcRecov2CellGen(basisFun, cv, varsP, polyOrder,
      dg(lst_alpha_c), dg(lst_alpha_r)), 

    surfNodes : gaussOrd(polyOrder+1, pDim-1),
    surfConfNodes : gaussOrd(polyOrder+1, cdim-1),

    basisStr : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  NSurfConf : length(bSurfConf),
  NSurf : length(bSurf),
  numNodes : length(surfNodes),
  numConfNodes : length(surfConfNodes),

  /* Project alpha evaluated at interior surface onto surf basis. */
  alphaSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, alpha_rec_l))),
  alphaSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(cv=0, alpha_rec_r))),
  alst_l        : doMakeExprLst(alphaSurf_l_c, alphaSurf_l),
  alst_r        : doMakeExprLst(alphaSurf_r_c, alphaSurf_r),
  alphaSurf_l_e : doExpand(alst_l, bSurf),
  alphaSurf_r_e : doExpand(alst_r, bSurf),
  printf(fh, "  double alphaSurf_l[~a] = {0.0}; ~%", NSurf),
  writeCExprs1(alphaSurf_l, alphaSurf_l_c),
  printf(fh, "~%"),
  printf(fh, "  double alphaSurf_r[~a] = {0.0}; ~%", NSurf),
  writeCExprs1(alphaSurf_r, alphaSurf_r_c),
  printf(fh, "~%"),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous. */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaSurf_r_e,surfNodes,surfVars))),

  printf(fh, "  double F_0_UpwindQuad_l[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_UpwindQuad_r[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_Upwind_l[~a] = {0.0};~%", NSurf),
  printf(fh, "  double F_0_Upwind_r[~a] = {0.0};~%", NSurf),
  printf(fh, "  double Ghat_F_0_l[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double Ghat_F_0_r[~a] = {0.0}; ~%", NSurf),

  /* Check sign of each quadrature point and choose appropriate distribution function at 
     quadrature points. 
     If alphaSurf_l > 0, need f_l (at +1), else f_c (at -1). 
     If alphaSurf_r > 0, need f_c (at +1), else f_r (at -1). */

  for i : 1 thru length(alphaOrd_l_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_l_n[i]),
    printf(fh, "    F_0_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0l); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad_l[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0c); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } ~%"),
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_r_n[i]),
    printf(fh, "    F_0_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0c); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad_r[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0r); ~%", i-1, basisStr, dir, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_xdir_upwind_quad_to_modal(F_0_UpwindQuad_l, F_0_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_xdir_upwind_quad_to_modal(F_0_UpwindQuad_r, F_0_Upwind_r); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad_l, F_0_Upwind_l); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad_r, F_0_Upwind_r); ~%", basisStr)
  ),
  printf(fh, "~%"),

  /* Create expansions of F_0_hat, G_1_hat (upwinded first two Laguerre moments) on the left and right in the surface basis. */
  F_0_HatSurf_l_e : doExpand1(F_0_Upwind_l, bSurf),
  F_0_HatSurf_r_e : doExpand1(F_0_Upwind_r, bSurf),

  /* Print C exprs for Ghat across surface boundary, (LEFT BOUNDARY) */
  Ghat_F_0_l_c : fullratsimp(innerProd(surfVars, alphaSurf_l_e, bSurf, F_0_HatSurf_l_e)),
  writeCExprs1(Ghat_F_0_l, Ghat_F_0_l_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Print C exprs for Ghat across surface boundary, (RIGHT BOUNDARY) */
  Ghat_F_0_r_c : fullratsimp(innerProd(surfVars, alphaSurf_r_e, bSurf, F_0_HatSurf_r_e)),
  writeCExprs1(Ghat_F_0_r, Ghat_F_0_r_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Expand G_hat in surface basis. */
  Ghat_F_0_l_e     : doExpand1(Ghat_F_0_l, bSurf),
  Ghat_F_0_r_e     : doExpand1(Ghat_F_0_r, bSurf),

  /* Compute surface contribution integral(phi^- Ghat) on the left and right. */
  incr_F_0_l : calcInnerProdList(surfVars, -vTrans, subst(cv=-1.0, bC), Ghat_F_0_l_e),
  incr_F_0_r : calcInnerProdList(surfVars, vTrans, subst(cv=1.0, bC), Ghat_F_0_r_e),
  incr_F_0_vol : calcInnerProdList(varsP, vTrans, diff(bC,cv), alphaVol_e*F_0c_e),
  writeCIncrExprsCollect1lhsc(out_pressure, volFact*dx1*(incr_F_0_l + incr_F_0_r - incr_F_0_vol)),  
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "} ~%")
);