/* This script generates the kernels for the boundary surface term
   of the advection in velocity space for the Vlasov equation
   in the parallel-kinetic-perpendicular-moment (pkpm) model */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx0, dx1, dx2]$

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

calcVlasovPKPMBoundaryAccelUpdate(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NP, pDim, cid, vid, surfVars,  bSurf, NSurf, surfNodes, numNodes, basisStr, 
   fl_e, fc_e, fr_e, vTrans, 
   p_force_e, bb_grad_u_e, acc_e, 
   alphaSurf_l_c, alphaSurf_r_c, alst_l, alst_r, alphaSurf_l_e, alphaSurf_r_e,
   alphaOrd_l_n, alphaOrd_r_n, 
   fHatSurf_e,Ghat_c,glst1,Ghat_e,incr],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim  : length(varsP),

  printf(fh, "GKYL_CU_DH void ~a_~ax~av_~a_p~a(const double *w, const double *dxv, 
     const double *bb_grad_u, const double *p_force, const double *div_b, 
     const int edge, const double *fEdge, const double *fSkin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:     Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:   Cell spacing.~%"),
  printf(fh, "  // p_force:     total pressure force = 1/rho (div(p_parallel b_hat) - p_perp div(b)).~%"),
  printf(fh, "  // bb_grad_u:   bb : grad(u).~%"),
  printf(fh, "  // div_b:       divergence of the magnetic field unit vector.~%"),
  printf(fh, "  // edge:        Determines if the update is for the left edge (-1) or right edge (+1).~%"),
  printf(fh, "  // fSkin/fEdge: Input Distribution function [F_0, T_perp G = T_perp (F_1 - F_0)] in skin cell/last edge cell ~%"),
  printf(fh, "  // out:         Incremented distribution function in center cell.~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* grid spacing in configuration space (for transformation from computational to physical space
     of acceleration [1/rho * b . div(P) - v_parallel bb : grad(u)] */
  for dir : 1 thru cdim do (
    printf(fh, "  const double dx~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir])
  ),
  /* grid spacing in v_parallel and v_parallel coordinate */
  printf(fh, "  const double dv1par = 2.0/dxv[~a]; ~%", cdim),
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),

  /* Access F_0 and T_perp G, first two Laguerre moments */
  printf(fh, "  const double *F_0Skin = &fSkin[~a]; ~%", 0),
  printf(fh, "  const double *G_1Skin = &fSkin[~a]; ~%", NP),  
  printf(fh, "  const double *F_0Edge = &fEdge[~a]; ~%", 0),
  printf(fh, "  const double *G_1Edge = &fEdge[~a]; ~%", NP), 

  /* Access the components of out for the first two Laguerre moments */
  printf(fh, "  double *out_F_0 = &out[~a]; ~%", 0),
  printf(fh, "  double *out_G_1 = &out[~a]; ~%", NP),  
  
  /* Expand pressure force 1/rho * (b_hat . div(P) + p_perp div(b_hat)) and bb : grad(u) in configuration space basis */
  p_force_e : doExpand1(p_force, bC),
  bb_grad_u_e : doExpand1(bb_grad_u, bC),
  div_b_e : doExpand1(div_b, bC),

  /* alpha_vdim = 1/rho (div(p_parallel b_hat) - p_perp div(b)) - v_parallel bb : grad(u)] df/dvpar */
  /* alpha_vdim consolidated as alpha_vdim = p_force - v_parallel bb_grad_u (pressure forces and bb_grad_u pre-computed) */
  acc_e : p_force_e - (vx*dvpar/2.0+wvpar)*bb_grad_u_e, 

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* Surface variables to integrate over. */
  surfVars : delete(vx,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vx dependence. */
  /* Also generate necessary basis strings, and surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),
    surf_cdim : cdim,  surf_vdim : 0,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim),

    basisStr : sconcat("hyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder),
    surfNodes : gaussOrd(polyOrder+1, pDim-1),

    basisStr : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  numNodes : length(surfNodes),
  NSurf : length(bSurf),

  /* Project alpha evaluated at interior surface onto surf basis. */
  clst : [dx0, dx1, dx2, dvpar, wvpar],
  alphaSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=-1,acc_e))),
  alphaSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=1,acc_e))),
  alst_l        : doMakeExprLst(alphaSurf_l_c, alphaSurf),
  alst_r        : doMakeExprLst(alphaSurf_r_c, alphaSurf),
  alphaSurf_l_e : doExpand(alst_l, bSurf),
  alphaSurf_r_e : doExpand(alst_r, bSurf),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     We still require a alpha_l (w - dv/2) and alpha_r (w + dv/2) for the two sides of the cell */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaSurf_r_e,surfNodes,surfVars))),

  /* project div(b) evaluated at interior surface onto surface basis.
     No velocity space dependence so we can just project div_b onto surface basis. */
  div_b_Surf_c : fullratsimp(innerProd(surfVars, 1, bSurf, div_b_e)),
  div_b_lst    : doMakeExprLst(div_b_Surf_c, div_b_Surf),
  div_b_Surf_e : doExpand(div_b_lst, bSurf),
  printf(fh, "  double div_b_Surf[~a] = {0.0}; ~%", NSurf),
  writeCExprsCollect1(div_b_Surf, div_b_Surf_c, clst),
  printf(fh, "~%"),

  /* Evaluate div(b) at ordinates.
     Note: div_b_Surf_e is already a surface expansion. 
     In addition, it is continuous. */
  div_b_Ord_n : gcfac(float(evAtNodes(div_b_Surf_e,surfNodes,surfVars))),

  printf(fh, "  double alphaSurf[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double F_0_UpwindQuad[~a] = {0.0};~%", numNodes),
  printf(fh, "  double F_0_Upwind[~a] = {0.0};;~%", NSurf),
  printf(fh, "  double Ghat_F_0[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double G_1_UpwindQuad[~a] = {0.0};~%", numNodes),
  printf(fh, "  double G_1_Upwind[~a] = {0.0};;~%", NSurf),
  printf(fh, "  double Ghat_G_1[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double G_1_div_b_UpwindQuad[~a] = {0.0};~%", numNodes),
  printf(fh, "  double G_1_div_b_Upwind[~a] = {0.0};;~%", NSurf),
  printf(fh, "  double Ghat_G_1_div_b[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),
  /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evaluated at +1 */
  /* In addition we need the drag term evaluated at +1 (so alpha evaluated on the right) */
  printf(fh, "  if (edge == -1) { ~%~%"),
  /* Write out drag term for far left edge boundary.
     Need alpha evaluated at +1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far left boundary, no surface term on -1 surface */
  writeCExprsCollect1(alphaSurf, alphaSurf_r_c, clst),
  printf(fh, "~%"),
  /* Write out fUpwindQuad for the far left edge */
  /* Within the skin cell, we need alpha_r (alpha evaluated at +1)
     just like how the skin cell is evaluated at +1 */
  for i : 1 thru length(alphaOrd_r_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_r_n[i]),
    printf(fh, "    F_0_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0Skin); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1Skin); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0Edge); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1Edge); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(F_0_UpwindQuad, F_0_Upwind); ~%", basisStr),
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(G_1_UpwindQuad, G_1_Upwind); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad, F_0_Upwind); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_UpwindQuad, G_1_Upwind); ~%", basisStr)
  ),
  printf(fh, "~%"),

  for i : 1 thru length(div_b_Ord_n) do (
    printf(fh, "  if (~a > 0) { ~%", div_b_Ord_n[i]),
    printf(fh, "    G_1_div_b_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1Skin); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    G_1_div_b_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1Edge); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(G_1_div_b_UpwindQuad, G_1_div_b_Upwind); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_div_b_UpwindQuad, G_1_div_b_Upwind); ~%", basisStr)
  ),
  printf(fh, "~%"),

  /* Create expansions of F_0_hat, G_1_hat (upwinded first two Laguerre moments) on the surface basis. */
  F_0_HatSurf_e : doExpand1(F_0_Upwind, bSurf),
  G_1_HatSurf_e : doExpand1(G_1_Upwind, bSurf),
  G_1_div_b_HatSurf_e : doExpand1(G_1_div_b_Upwind, bSurf),

  Ghat_F_0_c : calcInnerProdList(surfVars,alphaSurf_r_e,bSurf,F_0_HatSurf_e),
  Ghat_G_1_c : calcInnerProdList(surfVars,alphaSurf_r_e,bSurf,G_1_HatSurf_e),
  Ghat_G_1_div_b_c : calcInnerProdList(surfVars,div_b_Surf_e,bSurf,G_1_div_b_HatSurf_e),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  writeCExprs1(Ghat_F_0, Ghat_F_0_c),
  writeCExprs1(Ghat_G_1, Ghat_G_1_c),
  writeCExprs1(Ghat_G_1_div_b, Ghat_G_1_div_b_c),
  printf(fh, "~%"),
  flush_output(fh),

  Ghat_F_0_e       : doExpand1(Ghat_F_0, bSurf),
  Ghat_G_1_e       : doExpand1(Ghat_G_1, bSurf),
  Ghat_G_1_div_b_e : doExpand1(Ghat_G_1_div_b, bSurf),

  /* Increments to the far left skin cell (some dimensional factors missing). */
  incr_F_0 : calcInnerProdList(surfVars, -1.0, subst(vx=1.0, bP), Ghat_F_0_e),
  incr_G_1 : calcInnerProdList(surfVars, -1.0, subst(vx=1.0, bP), Ghat_G_1_e),
  incr_G_1_div_b : calcInnerProdList(surfVars, -1.0, subst(vx=1.0, bP), Ghat_G_1_div_b_e),

  /* Write out contribution */
  writeCIncrExprs1(out_F_0, dv1par*incr_F_0 + dv1par*incr_G_1_div_b),
  writeCIncrExprs1(out_G_1, dv1par*incr_G_1),

  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "~%  } else { ~%~%"),
  /* Write out drag term for far right edge boundary.
     Need alpha evaluated at -1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far right boundary, no surface term on +1 surface */
  writeCExprsCollect1(alphaSurf, alphaSurf_l_c, clst),
  printf(fh, "~%"),
  /* Write out fUpwindQuad for the far right edge */
  /* Within the skin cell, we need alpha_l (alpha evaluated at -1)
     just like how the skin cell is evaluated at -1 */
  for i : 1 thru length(alphaOrd_l_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_l_n[i]),
    printf(fh, "    F_0_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_r(F_0Edge); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1Edge); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    F_0_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_l(F_0Skin); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "    G_1_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1Skin); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(F_0_UpwindQuad, F_0_Upwind); ~%", basisStr),
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(G_1_UpwindQuad, G_1_Upwind); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(F_0_UpwindQuad, F_0_Upwind); ~%", basisStr),
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_UpwindQuad, G_1_Upwind); ~%", basisStr)
  ),
  printf(fh, "~%"),
  for i : 1 thru length(div_b_Ord_n) do (
    printf(fh, "  if (~a > 0) { ~%", div_b_Ord_n[i]),
    printf(fh, "    G_1_div_b_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_r(G_1Edge); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    G_1_div_b_UpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_l(G_1Skin); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(G_1_div_b_UpwindQuad, G_1_div_b_Upwind); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(G_1_div_b_UpwindQuad, G_1_div_b_Upwind); ~%", basisStr)
  ),
  printf(fh, "~%"),

  /* Create expansions of F_0_hat, G_1_hat (upwinded first two Laguerre moments) on the surface basis. */
  F_0_HatSurf_e : doExpand1(F_0_Upwind, bSurf),
  G_1_HatSurf_e : doExpand1(G_1_Upwind, bSurf),
  G_1_div_b_HatSurf_e : doExpand1(G_1_div_b_Upwind, bSurf),

  Ghat_F_0_c : calcInnerProdList(surfVars,alphaSurf_r_e,bSurf,F_0_HatSurf_e),
  Ghat_G_1_c : calcInnerProdList(surfVars,alphaSurf_r_e,bSurf,G_1_HatSurf_e),
  Ghat_G_1_div_b_c : calcInnerProdList(surfVars,div_b_Surf_e,bSurf,G_1_div_b_HatSurf_e),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  writeCExprs1(Ghat_F_0, Ghat_F_0_c),
  writeCExprs1(Ghat_G_1, Ghat_G_1_c),
  writeCExprs1(Ghat_G_1_div_b, Ghat_G_1_div_b_c),
  printf(fh, "~%"),
  flush_output(fh),

  Ghat_F_0_e       : doExpand1(Ghat_F_0, bSurf),
  Ghat_G_1_e       : doExpand1(Ghat_G_1, bSurf),
  Ghat_G_1_div_b_e : doExpand1(Ghat_G_1_div_b, bSurf),

  /* Increments to the far right edge skin cell (some dimensional factors missing). */
  incr_F_0 : calcInnerProdList(surfVars, 1.0, subst(vx=-1.0, bP), Ghat_F_0_e),
  incr_G_1 : calcInnerProdList(surfVars, 1.0, subst(vx=-1.0, bP), Ghat_G_1_e),
  incr_G_1_div_b : calcInnerProdList(surfVars, 1.0, subst(vx=-1.0, bP), Ghat_G_1_div_b_e),

  /* Write out contribution */
  writeCIncrExprs1(out_F_0, dv1par*incr_F_0 + dv1par*incr_G_1_div_b),
  writeCIncrExprs1(out_G_1, dv1par*incr_G_1),

  printf(fh, "~%"),
  printf(fh, "  } ~%"),
  printf(fh, "} ~%")
);
