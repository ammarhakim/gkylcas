/* This script generates the kernels for the boundary surface term
   of the advection in velocity space for the Vlasov equation
   in the parallel-kinetic-perpendicular-moment (pkpm) model */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

cvars : [x, y, z]$
dx11 : [dx0, dx1, dx2]$

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$

calcVlasovPKPMBoundaryAccelUpdate(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, NP, pDim, cid, vid, surfVars,  bSurf, NSurf, surfNodes, numNodes, basisStr, 
   fl_e, fc_e, fr_e, vTrans, 
   p_force_e, bb_grad_u_e, acc_e, 
   alphaSurf_l_c, alphaSurf_r_c, alst_l, alst_r, alphaSurf_l_e, alphaSurf_r_e,
   alphaOrd_l_n, alphaOrd_r_n, 
   fHatSurf_e,Ghat_c,glst1,Ghat_e,incr],

  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim  : length(varsP),

  printf(fh, "GKYL_CU_DH void ~a_~ax~av_~a_p~a(const double *w, const double *dxv, 
     const double *bb_grad_u, const double *p_force, 
     const int edge, const double *fEdge, const double *fSkin, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  // w[NDIM]:     Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]:   Cell spacing.~%"),
  printf(fh, "  // p_force:     total pressure force = 1/rho (b . div(P) + p_perp div(b)) for Euler PKPM.~%"),
  printf(fh, "  // bb_grad_u:   bb : grad(u).~%"),
  printf(fh, "  // edge:        Determines if the update is for the left edge (-1) or right edge (+1).~%"),
  printf(fh, "  // fSkin/fEdge: Input Distribution function in skin cell/last edge cell ~%"),
  printf(fh, "  // out:         Incremented distribution function in center cell.~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* grid spacing in configuration space (for transformation from computational to physical space
     of acceleration [1/rho * b . div(P) - v_parallel bb : grad(u)] */
  for dir : 1 thru cdim do (
    printf(fh, "  const double dx~a = 2.0/dxv[~a]; ~%", dir-1, cid[dir])
  ),
  /* grid spacing in v_parallel and v_parallel coordinate */
  printf(fh, "  const double dv1par = 2.0/dxv[~a]; ~%", cdim),
  printf(fh, "  const double dvpar = dxv[~a], wvpar = w[~a]; ~%", cdim, cdim),
  
  /* Expand pressure force 1/rho * (b_hat . div(P) + p_perp div(b_hat)) and bb : grad(u) in configuration space basis */
  p_force_e : doExpand1(p_force, bC),
  bb_grad_u_e : doExpand1(bb_grad_u, bC),

  /* Create expansions of f_left, f_center, and f_right on volume basis. */
  fl_e : doExpand1(fl, bP),
  fc_e : doExpand1(fc, bP),
  fr_e : doExpand1(fr, bP),

  /* alpha_vdim = [1/rho * (b_hat . div(P) + p_perp div(b_hat)) - v_parallel bb : grad(u)] df/dvpar */
  /* alpha_vdim consolidated as alpha_vdim = p_force - v_parallel bb_grad_u (pressure forces and bb_grad_u pre-computed) */
  acc_e : p_force_e - (vx*dvpar/2.0+wvpar)*bb_grad_u_e, 

  /* Surface contribution is defined as integral(phi^- Ghat) over the surface. */

  /* Surface variables to integrate over. */
  surfVars : delete(vx,varsP),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vx dependence. */
  /* Also generate necessary basis strings, and surface nodes given by tensor product of Gauss-Legendre quadrature points */
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("hyb",surfVars,polyOrder),
    surf_cdim : cdim,  surf_vdim : 0,
    surfNodes : gaussOrdHyb(1+1, surf_cdim, surf_vdim),

    basisStr : sconcat("hyb_", cdim, "x", vdim, "v", "_p", polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder),
    surfNodes : gaussOrd(polyOrder+1, pDim-1),

    basisStr : sconcat(basisFun, "_", cdim+vdim, "x", "_p", polyOrder)
  ),
  numNodes : length(surfNodes),
  NSurf : length(bSurf),

  /* Project alpha evaluated at interior surface onto surf basis. */
  clst : [dx0, dx1, dx2, dvpar, wvpar],
  alphaSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=-1,acc_e))),
  alphaSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vx=1,acc_e))),
  alst_l        : doMakeExprLst(alphaSurf_l_c, alphaSurf),
  alst_r        : doMakeExprLst(alphaSurf_r_c, alphaSurf),
  alphaSurf_l_e : doExpand(alst_l, bSurf),
  alphaSurf_r_e : doExpand(alst_r, bSurf),

  /* Evaluate alpha at ordinates.
     Note: alphaSurf_e is already a surface expansion. 
     In addition, it is continuous and does not vary with respect to the surface variable.
     We still require a alpha_l (w - dv/2) and alpha_r (w + dv/2) for the two sides of the cell */
  alphaOrd_l_n : gcfac(float(evAtNodes(alphaSurf_l_e,surfNodes,surfVars))),
  alphaOrd_r_n : gcfac(float(evAtNodes(alphaSurf_r_e,surfNodes,surfVars))),

  printf(fh, "  double alphaSurf[~a] = {0.0}; ~%", NSurf),
  printf(fh, "  double fUpwindQuad[~a] = {0.0};~%", numNodes),
  printf(fh, "  double fUpwind[~a] = {0.0};;~%", NSurf),
  printf(fh, "  double Ghat[~a] = {0.0}; ~%", NSurf),
  printf(fh, "~%"),
  /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evaluated at +1 */
  /* In addition we need the drag term evaluated at +1 (so alpha evaluated on the right) */
  printf(fh, "  if (edge == -1) { ~%~%"),
  /* Write out drag term for far left edge boundary.
     Need alpha evaluated at +1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far left boundary, no surface term on -1 surface */
  writeCExprsCollect1(alphaSurf, alphaSurf_r_c, clst),
  printf(fh, "~%"),
  /* Write out fUpwindQuad for the far left edge */
  /* Within the skin cell, we need alpha_r (alpha evaluated at +1)
     just like how the skin cell is evaluated at +1 */
  for i : 1 thru length(alphaOrd_r_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_r_n[i]),
    printf(fh, "    fUpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_r(fSkin); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_l(fEdge); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", basisStr)
  ),
  printf(fh, "~%"),

  /* Create expansions of f_hat (upwinded f) on the left and right in the surface basis. */
  fHatSurf_e : doExpand1(fUpwind, bSurf),

  Ghat_c : calcInnerProdList(surfVars,alphaSurf_r_e,bSurf,fHatSurf_e),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  writeCExprs1(Ghat, Ghat_c),
  printf(fh, "~%"),
  flush_output(fh),

  glst1  : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpand(glst1, bSurf),

  /* Increments to the far left skin cell (some dimensional factors missing). */
  incr : calcInnerProdList(surfVars, -1.0, subst(vx=1.0, bP), Ghat_e),

  /* Write out contribution */
  writeCIncrExprs1(out, dv1par*incr),

  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "~%  } else { ~%~%"),
  /* Write out drag term for far right edge boundary.
     Need alpha evaluated at -1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far right boundary, no surface term on +1 surface */
  writeCExprsCollect1(alphaSurf, alphaSurf_l_c, clst),
  printf(fh, "~%"),
  /* Write out fUpwindQuad for the far right edge */
  /* Within the skin cell, we need alpha_l (alpha evaluated at -1)
     just like how the skin cell is evaluated at -1 */
  for i : 1 thru length(alphaOrd_l_n) do (
    printf(fh, "  if (~a > 0) { ~%", alphaOrd_l_n[i]),
    printf(fh, "    fUpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_r(fEdge); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } else { ~%"),
    printf(fh, "    fUpwindQuad[~a] = ~a_surfx~a_eval_quad_node_~a_l(fSkin); ~%", i-1, basisStr, cdim+1, i-1),
    printf(fh, "  } ~%")
  ),
  printf(fh, "~%"),
  printf(fh, "  // Project tensor nodal quadrature basis back onto modal basis. ~%"),
  if polyOrder=1 then (  /* Force p=1 to use hybrid basis. */
    printf(fh, "  ~a_vdir_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", basisStr)
  ) else (
    printf(fh, "  ~a_upwind_quad_to_modal(fUpwindQuad, fUpwind); ~%", basisStr)
  ),
  printf(fh, "~%"),

  /* Create expansions of f_hat (upwinded f) on the left and right in the surface basis. */
  fHatSurf_e : doExpand1(fUpwind, bSurf),

  Ghat_c : calcInnerProdList(surfVars,alphaSurf_l_e,bSurf,fHatSurf_e),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
  ** on we can simply refer to Ghat. */
  writeCExprs1(Ghat, Ghat_c),
  printf(fh, "~%"),
  flush_output(fh),

  glst1  : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpand(glst1, bSurf),

  /* Increments to the far right edge skin cell (some dimensional factors missing). */
  incr : calcInnerProdList(surfVars, 1, subst(vx=-1, bP), Ghat_e),

  /* Write out contribution. */
  writeCIncrExprs1(out, dv1par*incr),
  printf(fh, "~%"),
  printf(fh, "  } ~%"),
  printf(fh, "} ~%")
);
