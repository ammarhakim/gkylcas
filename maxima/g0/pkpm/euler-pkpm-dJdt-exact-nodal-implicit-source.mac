/* This script generates the kernels for computing the semi-implicit 
   source solve as described in Wang et al. JCP 2020 for the PKPM system
   using the exact linear solve described in Appendix D of Wang et al. JCP 2020.
   We construct a linear system of (3*num_species + 3) for each of the
   species current densities and the three components of the electric field. 
   This solve is performed nodally by converting the input modal coefficients 
   to a nodal basis. Note that performing the solve nodally incurs an aliasing 
   error for p>1 because the linear solve involves triple products of basis functions
   integral(w_i w_j w_k) which requires enough quadrature points to integrate a 3*p 
   polynomial. For p+1 nodes (for the exact conversion between the Gauss-Legendre nodal basis
   and our modal basis), 2*(p+1) - 1 polynomials can be integrated, so 3 for p=1, but only 
   5 for p=2 (when we need degree 6) or 7 for p=3 (when we need degree 9). */

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

PKPMEMSourceNodalSolve(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(int num_species, 
  double qbym[GKYL_MAX_SPECIES], double epsilon0, bool pkpm_field_static, double dt, 
  const double *app_accel[GKYL_MAX_SPECIES], const double *ext_em, const double *app_current, 
  const double *vlasov_pkpm_moms[GKYL_MAX_SPECIES], 
  double* GKYL_RESTRICT euler_pkpm[GKYL_MAX_SPECIES], double* GKYL_RESTRICT em) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // num_species:       number of species being evolved (number of momentum equations). ~%"),
  printf(fh, "  // qbym:              charge/mass ratio for each species. ~%"),
  printf(fh, "  // epsilon0:          permittivity of free space. ~%"),
  printf(fh, "  // pkpm_field_static: boolean for whether or not the self-consistent field is static. ~%"),
  printf(fh, "  // dt:                size of the time step. ~%"),  
  printf(fh, "  // app_accel:         Applied accelerations (external forces).~%"),
  printf(fh, "  // ext_em:            Externally applied EM fields.~%"),
  printf(fh, "  // app_current:       Applied external currents.~%"),
  printf(fh, "  // vlasov_pkpm_moms:  [rho, p_parallel, p_perp], Moments computed from kinetic equation in pkpm model.~%"),
  printf(fh, "  // euler_pkpm:        [rho ux, rho uy, rho uz], PKPM Fluid momentum input state vector.~%"),
  printf(fh, "  // em:                [Ex, Ey, Ez, Bx, By, Bz], EM input state vector.~%"),
  printf(fh, "~%"),

  /* Fetch modal expansion of input variables */
  printf(fh, "  double rho[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double rhoux[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double rhouy[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double rhouz[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "~%"),
  printf(fh, "  double app_accel_x[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double app_accel_y[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double app_accel_z[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "~%"),

  printf(fh, "  for (int i = 0; i < num_species; ++i) { ~%"),
  printf(fh, "    double *inp_euler_pkpm = euler_pkpm[i]; ~%"),
  printf(fh, "    const double *inp_vlasov_pkpm_moms = vlasov_pkpm_moms[i]; ~%"),
  printf(fh, "    const double *inp_app_accel = app_accel[i]; ~%"),  
  printf(fh, "~%"),
  for j : 1 thru NC do (
    printf(fh, "    rho[i][~a] = inp_vlasov_pkpm_moms[~a]; ~%", j-1, j-1), 
    printf(fh, "    rhoux[i][~a] = inp_euler_pkpm[~a]; ~%", j-1, j-1+0*NC), 
    printf(fh, "    rhouy[i][~a] = inp_euler_pkpm[~a]; ~%", j-1, j-1+1*NC), 
    printf(fh, "    rhouz[i][~a] = inp_euler_pkpm[~a]; ~%", j-1, j-1+2*NC),
    printf(fh, "~%"),
    printf(fh, "    app_accel_x[i][~a] = inp_app_accel[~a]; ~%", j-1, j-1+0*NC), 
    printf(fh, "    app_accel_y[i][~a] = inp_app_accel[~a]; ~%", j-1, j-1+1*NC), 
    printf(fh, "    app_accel_z[i][~a] = inp_app_accel[~a]; ~%", j-1, j-1+2*NC),
    printf(fh, "~%")    
  ), 
  printf(fh, "  } ~%"),
  printf(fh, "~%"),

  printf(fh, "  double *Ex = &em[~a]; ~%", 0*NC),
  printf(fh, "  double *Ey = &em[~a]; ~%", 1*NC),
  printf(fh, "  double *Ez = &em[~a]; ~%", 2*NC),
  printf(fh, "  double *Bx = &em[~a]; ~%", 3*NC),
  printf(fh, "  double *By = &em[~a]; ~%", 4*NC),
  printf(fh, "  double *Bz = &em[~a]; ~%", 5*NC),
  printf(fh, "~%"), 
  printf(fh, "  const double *ext_Ex = &ext_em[~a]; ~%", 0*NC),
  printf(fh, "  const double *ext_Ey = &ext_em[~a]; ~%", 1*NC),
  printf(fh, "  const double *ext_Ez = &ext_em[~a]; ~%", 2*NC),
  printf(fh, "  const double *ext_Bx = &ext_em[~a]; ~%", 3*NC),
  printf(fh, "  const double *ext_By = &ext_em[~a]; ~%", 4*NC),
  printf(fh, "  const double *ext_Bz = &ext_em[~a]; ~%", 5*NC),
  printf(fh, "~%"), 
  printf(fh, "  const double *app_curr_x = &app_current[~a]; ~%", 0*NC),
  printf(fh, "  const double *app_curr_y = &app_current[~a]; ~%", 1*NC),
  printf(fh, "  const double *app_curr_z = &app_current[~a]; ~%", 2*NC),
  printf(fh, "~%"), 

  printf(fh, "  double tot_Bx[~a]; ~%", NC), 
  printf(fh, "  double tot_By[~a]; ~%", NC), 
  printf(fh, "  double tot_Bz[~a]; ~%", NC), 
  for j : 1 thru NC do (
    printf(fh, "  tot_Bx[~a] = Bx[~a] + ext_Bx[~a]; ~%", j-1, j-1, j-1), 
    printf(fh, "  tot_By[~a] = By[~a] + ext_By[~a]; ~%", j-1, j-1, j-1), 
    printf(fh, "  tot_Bz[~a] = Bz[~a] + ext_Bz[~a]; ~%", j-1, j-1, j-1) 
  ), 
  printf(fh, "~%"),

  /* Convert modal expansion to nodal expansions */
  nodes : gaussOrd(polyOrder+1, cdim),
  numNodes : length(nodes),  
  printf(fh, "  double rho_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double rhoux_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double rhouy_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double rhouz_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double app_accel_x_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double app_accel_y_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double app_accel_z_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double Ex_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double Ey_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double Ez_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double ext_Ex_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double ext_Ey_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double ext_Ez_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double app_curr_x_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double app_curr_y_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double app_curr_z_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double tot_Bx_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double tot_By_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double tot_Bz_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),

  printf(fh, "  // Project modal expansions onto nodal bases. ~%"), 
  printf(fh, "  for (int s = 0; s < num_species; ++s) { ~%"),
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(rho[s], rho_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(rhoux[s], rhoux_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(rhouy[s], rhouy_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(rhouz[s], rhouz_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(app_accel_x[s], app_accel_x_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(app_accel_y[s], app_accel_y_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(app_accel_z[s], app_accel_z_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  } ~%"),
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(Ex, Ex_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(Ey, Ey_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(Ez, Ez_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(ext_Ex, ext_Ex_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(ext_Ey, ext_Ey_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(ext_Ez, ext_Ez_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(app_curr_x, app_curr_x_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(app_curr_y, app_curr_y_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(app_curr_z, app_curr_z_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(tot_Bx, tot_Bx_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(tot_By, tot_By_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(tot_Bz, tot_Bz_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, " ~%"), 

  printf(fh, "  double rho_s[GKYL_MAX_SPECIES]; ~%"), 
  printf(fh, "  double rhou_s[GKYL_MAX_SPECIES][3]; ~%"), 
  printf(fh, "  double app_accel_s[GKYL_MAX_SPECIES][3]; ~%"), 
  printf(fh, "  double E[3]; ~%"), 
  printf(fh, "  double ext_E[3]; ~%"), 
  printf(fh, "  double tot_B[3]; ~%"), 
  printf(fh, "  double app_curr[3]; ~%"), 
  printf(fh, "~%"),
  for n : 1 thru numNodes do (
    printf(fh, "  for (int s = 0; s < num_species; ++s) { ~%"), 
    printf(fh, "    rho_s[s] = rho_nodal[s][~a]; ~%", n-1), 
    printf(fh, "    rhou_s[s][0] = rhoux_nodal[s][~a]; ~%", n-1), 
    printf(fh, "    rhou_s[s][1] = rhouy_nodal[s][~a]; ~%", n-1), 
    printf(fh, "    rhou_s[s][2] = rhouz_nodal[s][~a]; ~%", n-1), 
    printf(fh, "    app_accel_s[s][0] = app_accel_x_nodal[s][~a]; ~%", n-1), 
    printf(fh, "    app_accel_s[s][1] = app_accel_y_nodal[s][~a]; ~%", n-1), 
    printf(fh, "    app_accel_s[s][2] = app_accel_z_nodal[s][~a]; ~%", n-1), 
    printf(fh, "  } ~%"),  
    printf(fh, "  E[0] = Ex_nodal[~a]; ~%", n-1), 
    printf(fh, "  E[1] = Ey_nodal[~a]; ~%", n-1), 
    printf(fh, "  E[2] = Ez_nodal[~a]; ~%", n-1), 
    printf(fh, "  ext_E[0] = ext_Ex_nodal[~a]; ~%", n-1), 
    printf(fh, "  ext_E[1] = ext_Ey_nodal[~a]; ~%", n-1), 
    printf(fh, "  ext_E[2] = ext_Ez_nodal[~a]; ~%", n-1), 
    printf(fh, "  tot_B[0] = tot_Bx_nodal[~a]; ~%", n-1), 
    printf(fh, "  tot_B[1] = tot_By_nodal[~a]; ~%", n-1), 
    printf(fh, "  tot_B[2] = tot_Bz_nodal[~a]; ~%", n-1), 
    printf(fh, "  app_curr[0] = app_curr_x_nodal[~a]; ~%", n-1), 
    printf(fh, "  app_curr[1] = app_curr_y_nodal[~a]; ~%", n-1), 
    printf(fh, "  app_curr[2] = app_curr_z_nodal[~a]; ~%", n-1), 
    printf(fh, "~%"),
    printf(fh, "  implicit_nodal_pkpm_em_source_update(num_species, dt, qbym, epsilon0, 
    rho_s, rhou_s, app_accel_s, E, ext_E, tot_B, app_curr); ~%"), 
    printf(fh, "~%"),
    printf(fh, "  for (int s = 0; s < num_species; ++s) { ~%"), 
    printf(fh, "    rhoux_nodal[s][~a] = rhou_s[s][0]; ~%", n-1), 
    printf(fh, "    rhouy_nodal[s][~a] = rhou_s[s][1]; ~%", n-1), 
    printf(fh, "    rhouz_nodal[s][~a] = rhou_s[s][2]; ~%", n-1),
    printf(fh, "  } ~%"), 
    printf(fh, "    Ex_nodal[~a] = E[0]; ~%", n-1), 
    printf(fh, "    Ey_nodal[~a] = E[1]; ~%", n-1), 
    printf(fh, "    Ez_nodal[~a] = E[2]; ~%", n-1),  
    printf(fh, "~%")   
  ), 

  /* Modal solution at new timestep */
  printf(fh, "  // Project nodal solution onto modal bases. ~%"),
  printf(fh, "  for (int s = 0; s < num_species; ++s) { ~%"),
  printf(fh, "    double *out_rhoux = &euler_pkpm[s][~a]; ~%", 0*NC),
  printf(fh, "    double *out_rhouy = &euler_pkpm[s][~a]; ~%", 1*NC),
  printf(fh, "    double *out_rhouz = &euler_pkpm[s][~a]; ~%", 2*NC),
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(rhoux_nodal[s], out_rhoux);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(rhouy_nodal[s], out_rhouy);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(rhouz_nodal[s], out_rhouz);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  } ~%"),
  printf(fh, "~%"),
  printf(fh, "  // Update electric field if PKPM field is self-consistent. ~%"), 
  printf(fh, "  if (!pkpm_field_static) { ~%"), 
  printf(fh, "    double *out_Ex = &em[~a]; ~%", 0*NC),
  printf(fh, "    double *out_Ey = &em[~a]; ~%", 1*NC),
  printf(fh, "    double *out_Ez = &em[~a]; ~%", 2*NC),
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(Ex_nodal, out_Ex);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(Ey_nodal, out_Ey);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(Ez_nodal, out_Ez);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  } ~%"), 
  printf(fh, "} ~%")
)$  
