/* This script generates the kernels for integrating the fluid variables
   for diagnostic purposed. Integrates rho, p_parallel, p_perp, rho ux^2, rho uy^2, rho uz^2, 
   3/2 p = 1/2 p_parallel + p_perp, 1/2 rho u^2, and E = 3/2 p + 1/2 rho u^2 */

load("modal-basis")$
load("out-scripts")$
fpprec : 24$

calcEulerPKPMIntVars(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, rhoux_e, rhouy_e, rhouz_e, 
   rho_e, p_par_e, p_perp_e, 
   bxbx_e, bxby_e, bxbz_e, byby_e, bybz_e, bzbz_e, rho_inv_e, 
   ux_c, uy_c, uz_c, 
   Pxx_c, Pxy_c, Pxz_c, Pyy_c, Pyz_c, Pzz_c, 
   Pxx_e, Pxy_e, Pxz_e, Pyy_e, Pyz_e, Pzz_e, 
   Txx_c, Tyy_c, Tzz_c, T_perp_over_m_c],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a_p~a(const double *vlasov_pkpm_moms, const double *statevec, 
  const double* u_i, double* int_pkpm_vars) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // vlasov_pkpm_moms:  [rho, p_parallel, p_perp], Moments computed from kinetic equation in pkpm model.~%"),
  printf(fh, "  // statevec:          [rho ux, rho uy, rho uz], Fluid input state vector.~%"),
  printf(fh, "  // u_i:               [ux, uy, uz] Flow velocity.~%"),
  printf(fh, "  // int_pkpm_vars:     Output integrated variables.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double *rho = &vlasov_pkpm_moms[~a]; ~%", 0*NC),
  printf(fh, "  const double *p_parallel = &vlasov_pkpm_moms[~a]; ~%", 1*NC),
  printf(fh, "  const double *p_perp = &vlasov_pkpm_moms[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *rhoux = &statevec[~a]; ~%", 0*NC),
  printf(fh, "  const double *rhouy = &statevec[~a]; ~%", 1*NC),
  printf(fh, "  const double *rhouz = &statevec[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  printf(fh, "  const double *ux = &u_i[~a]; ~%", 0*NC),
  printf(fh, "  const double *uy = &u_i[~a]; ~%", 1*NC),
  printf(fh, "  const double *uz = &u_i[~a]; ~%", 2*NC),
  printf(fh, "~%"),

  /* Expansion of mass, parallel pressure, perpendicular pressure, 
     momentum density, and flow velocity */
  rho_e : doExpand1(rho, bC),
  p_par_e : doExpand1(p_parallel, bC),
  p_perp_e : doExpand1(p_perp, bC),
  rhoux_e : doExpand1(rhoux, bC),
  rhouy_e : doExpand1(rhouy, bC),
  rhouz_e : doExpand1(rhouz, bC),
  ux_e : doExpand1(ux, bC),
  uy_e : doExpand1(uy, bC),
  uz_e : doExpand1(uz, bC),

  int_rho_c : calcInnerProdList(varsC, 1, [1], rho_e), 
  int_p_par_c : calcInnerProdList(varsC, 1, [1], p_par_e), 
  int_p_perp_c : calcInnerProdList(varsC, 1, [1], p_perp_e), 
  int_rhoux2_c : calcInnerProdList(varsC, 1, [1], rhoux_e*ux_e), 
  int_rhouy2_c : calcInnerProdList(varsC, 1, [1], rhouy_e*uy_e), 
  int_rhouz2_c : calcInnerProdList(varsC, 1, [1], rhouz_e*uz_e), 

  printf(fh, "  double int_p_par = ~a; ~%", float(expand(int_p_par_c[1]))),
  printf(fh, "  double int_p_perp = ~a; ~%", float(expand(int_p_perp_c[1]))),
  printf(fh, "  double int_rhoux2 = ~a; ~%", float(expand(int_rhoux2_c[1]))),
  printf(fh, "  double int_rhouy2 = ~a; ~%", float(expand(int_rhouy2_c[1]))),
  printf(fh, "  double int_rhouz2 = ~a; ~%", float(expand(int_rhouz2_c[1]))),

  printf(fh, "  // Order of integrated variables is (rho, p_parallel, p_perp, rho ux^2, rho uy^2, rho uz^2, 3/2 p, 1/2 rho u^2, E = 3/2 p + 1/2 rho u^2) ~%"),
  printf(fh, "  int_pkpm_vars[0] += ~a; ~%", float(expand(int_rho_c[1]))),
  printf(fh, "  int_pkpm_vars[1] += int_p_par; ~%"),
  printf(fh, "  int_pkpm_vars[2] += int_p_perp; ~%"),
  printf(fh, "  int_pkpm_vars[3] += int_rhoux2; ~%"),
  printf(fh, "  int_pkpm_vars[4] += int_rhouy2; ~%"),
  printf(fh, "  int_pkpm_vars[5] += int_rhouz2; ~%"),
  printf(fh, "  int_pkpm_vars[6] += 0.5*int_p_par + int_p_perp; ~%"),
  printf(fh, "  int_pkpm_vars[7] += 0.5*(int_rhoux2 + int_rhouy2 + int_rhouz2); ~%"),
  printf(fh, "  int_pkpm_vars[8] += 0.5*(int_p_par + 2.0*int_p_perp + int_rhoux2 + int_rhouy2 + int_rhouz2); ~%"),

  printf(fh, "} ~%")
)$
