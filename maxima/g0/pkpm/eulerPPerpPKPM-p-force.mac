/* This script generates the kernels for the total pressure force
   in the parallel-kinetic-perpendicular-moment (pkpm) model,
   p_force = 1/rho (b . div(P) + p_perp div(b)) */

load("modal-basis");
load("out-scripts");
load(stringproc)$
load("scifac")$
fpprec : 24$
cvars : [x, y, z]$

calcEulerPKPMPForce(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC, 
   bx_e, by_e, bz_e, div_p_x_e, div_p_y_e, div_p_z_e, rho_inv_e, p_perp_e, div_b_e, 
   b_div_p_c, b_div_p_e, p_force_c],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "#include <gkyl_euler_kernels.h> ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_inv.h> ~%", basisFun, cdim, polyOrder),
  printf(fh, "GKYL_CU_DH void ~a_p~a(const double *bvar, const double *div_p, const double *vlasov_pkpm_moms, 
  const double *p_perp, const double *div_b, 
  double* p_force) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // bvar:             magnetic field unit vector (nine components; first three components, b_i, other six components, b_i b_j.) ~%"),
  printf(fh, "  // div_p:            Volume expansion of divergence of pressure tensor.~%"),
  printf(fh, "  // vlasov_pkpm_moms: [rho, p_parallel, q_parallel], Moments computed from kinetic equation in pkpm model.~%"),
  printf(fh, "  // p_perp:           Perpendicular pressure.~%"),  
  printf(fh, "  // div_b:            Volume expansion of divergence of magnetic field unit vector.~%"),  
  printf(fh, "  // p_force:          total pressure force = 1/rho (b . div(P) + p_perp div(b)) for Euler PKPM.~%"),
  printf(fh, "~%"),

  printf(fh, "  const double *bx = &bvar[~a]; ~%", 0*NC),
  printf(fh, "  const double *by = &bvar[~a]; ~%", 1*NC),
  printf(fh, "  const double *bz = &bvar[~a]; ~%", 2*NC),
  printf(fh, "  const double *div_p_x = &div_p[~a]; ~%", 0*NC),
  printf(fh, "  const double *div_p_y = &div_p[~a]; ~%", 1*NC),
  printf(fh, "  const double *div_p_z = &div_p[~a]; ~%", 2*NC),
  printf(fh, "  const double *rho = &vlasov_pkpm_moms[~a]; ~%", 0), 
  printf(fh, "~%"),

  bx_e : doExpand1(bx, bC),
  by_e : doExpand1(by, bC),
  bz_e : doExpand1(bz, bC),

  div_p_x_e : doExpand1(div_p_x, bC),
  div_p_y_e : doExpand1(div_p_y, bC),
  div_p_z_e : doExpand1(div_p_z, bC),

  p_perp_e : doExpand1(p_perp, bC), 
  div_b_e : doExpand1(div_b, bC), 

  rho_inv_e : doExpand1(rho_inv, bC),

  printf(fh, "  double b_div_p[~a] = {0.0}; ~%", NC),
  printf(fh, "  double rho_inv[~a] = {0.0}; ~%", NC),
  printf(fh, "  ~a_~ax_p~a_inv(rho, rho_inv); ~%", basisFun, cdim, polyOrder),

  b_div_p_c : calcInnerProdList(varsC, 1, bC, div_p_x_e*bx_e + div_p_y_e*by_e + div_p_z_e*bz_e - p_perp_e*div_b_e),
  writeCExprs1(b_div_p, b_div_p_c),
  printf(fh, "~%"),
  flush_output(fh),

  b_div_p_e : doExpand1(b_div_p, bC),
  p_force_c : calcInnerProdList(varsC, 1, bC, b_div_p_e*rho_inv_e),
  writeCExprs1(p_force, p_force_c),
  printf(fh, "~%"),
  flush_output(fh),

  printf(fh, "} ~%")
)$
