/* This script generates the kernels for computing the semi-implicit 
   source solve as described in Wang et al. JCP 2020 for the PKPM system.
   We construct a linear system of (3*num_species + 3) for each of the
   species current densities and the three components of the electric field. 
   This solve is performed nodally by converting the input modal coefficients 
   to a nodal basis. Note that performing the solve nodally incurs an aliasing 
   error for p>1 because the linear solve involves triple products of basis functions
   integral(w_i w_j w_k) which requires enough quadrature points to integrate a 3*p 
   polynomial. For p+1 nodes (for the exact conversion between the Gauss-Legendre nodal basis
   and our modal basis), 2*(p+1) - 1 polynomials can be integrated, so 3 for p=1, but only 
   5 for p=2 (when we need degree 6) or 7 for p=3 (when we need degree 9). */

load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
load("nodal_operations/nodal_functions")$
fpprec : 24$

setPKPMEMSourceNodalSolve(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(int count, 
  int num_species, double qbym[GKYL_MAX_SPECIES], double epsilon0, bool pkpm_field_static, double dt, 
  struct gkyl_nmat *A_n, struct gkyl_nmat *rhs_n, 
  const double *app_accel[GKYL_MAX_SPECIES], const double *ext_em, const double *app_current, 
  const double *vlasov_pkpm_moms[GKYL_MAX_SPECIES], const double* pkpm_u[GKYL_MAX_SPECIES], 
  double* GKYL_RESTRICT em) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count:             integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // num_species:       number of species being evolved (number of momentum equations). ~%"),
  printf(fh, "  // qbym:              charge/mass ratio for each species. ~%"),
  printf(fh, "  // epsilon0:          permittivity of free space. ~%"),
  printf(fh, "  // pkpm_field_static: boolean for whether or not the self-consistent field is static. ~%"),
  printf(fh, "  // dt:                size of the time step. ~%"),  
  printf(fh, "  // A:                 preallocated LHS matrix. ~%"),
  printf(fh, "  // rhs:               preallocated RHS vector. ~%"),
  printf(fh, "  // app_accel:         Applied accelerations (external forces).~%"),
  printf(fh, "  // ext_em:            Externally applied EM fields.~%"),
  printf(fh, "  // app_current:       Applied external currents.~%"),
  printf(fh, "  // vlasov_pkpm_moms:  [rho, p_parallel, p_perp], Moments computed from kinetic equation in pkpm model.~%"),
  printf(fh, "  // pkpm_u:            [ux, uy, uz], Input flow velocity.~%"),
  printf(fh, "  // em:                [Ex, Ey, Ez, Bx, By, Bz], EM input state vector.~%"),
  printf(fh, "~%"),

  /* Fetch modal expansion of input variables */
  printf(fh, "  double rho[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double ux[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double uy[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double uz[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "~%"),
  printf(fh, "  double app_accel_x[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double app_accel_y[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "  double app_accel_z[GKYL_MAX_SPECIES][~a]; ~%", NC), 
  printf(fh, "~%"),

  printf(fh, "  for (int i = 0; i < num_species; ++i) { ~%"),
  printf(fh, "    const double *inp_u = pkpm_u[i]; ~%"),
  printf(fh, "    const double *inp_app_accel = app_accel[i]; ~%"),
  printf(fh, "    const double *inp_vlasov_pkpm_moms = vlasov_pkpm_moms[i]; ~%"),
  printf(fh, "~%"),
  for j : 1 thru NC do (
    printf(fh, "    rho[i][~a] = inp_vlasov_pkpm_moms[~a]; ~%", j-1, j-1), 
    printf(fh, "    ux[i][~a] = inp_u[~a]; ~%", j-1, j-1+0*NC), 
    printf(fh, "    uy[i][~a] = inp_u[~a]; ~%", j-1, j-1+1*NC), 
    printf(fh, "    uz[i][~a] = inp_u[~a]; ~%", j-1, j-1+2*NC),
    printf(fh, "~%"),
    printf(fh, "    app_accel_x[i][~a] = inp_app_accel[~a]; ~%", j-1, j-1+0*NC), 
    printf(fh, "    app_accel_y[i][~a] = inp_app_accel[~a]; ~%", j-1, j-1+1*NC), 
    printf(fh, "    app_accel_z[i][~a] = inp_app_accel[~a]; ~%", j-1, j-1+2*NC),
    printf(fh, "~%")    
  ), 
  printf(fh, "  } ~%"),
  printf(fh, "~%"),

  printf(fh, "  double *Ex = &em[~a]; ~%", 0*NC),
  printf(fh, "  double *Ey = &em[~a]; ~%", 1*NC),
  printf(fh, "  double *Ez = &em[~a]; ~%", 2*NC),
  printf(fh, "  double *Bx = &em[~a]; ~%", 3*NC),
  printf(fh, "  double *By = &em[~a]; ~%", 4*NC),
  printf(fh, "  double *Bz = &em[~a]; ~%", 5*NC),
  printf(fh, "~%"), 
  printf(fh, "  const double *ext_Ex = &ext_em[~a]; ~%", 0*NC),
  printf(fh, "  const double *ext_Ey = &ext_em[~a]; ~%", 1*NC),
  printf(fh, "  const double *ext_Ez = &ext_em[~a]; ~%", 2*NC),
  printf(fh, "  const double *ext_Bx = &ext_em[~a]; ~%", 3*NC),
  printf(fh, "  const double *ext_By = &ext_em[~a]; ~%", 4*NC),
  printf(fh, "  const double *ext_Bz = &ext_em[~a]; ~%", 5*NC),
  printf(fh, "~%"), 
  printf(fh, "  const double *app_curr_x = &app_current[~a]; ~%", 0*NC),
  printf(fh, "  const double *app_curr_y = &app_current[~a]; ~%", 1*NC),
  printf(fh, "  const double *app_curr_z = &app_current[~a]; ~%", 2*NC),
  printf(fh, "~%"), 

  printf(fh, "  double tot_Bx[~a]; ~%", NC), 
  printf(fh, "  double tot_By[~a]; ~%", NC), 
  printf(fh, "  double tot_Bz[~a]; ~%", NC), 
  for j : 1 thru NC do (
    printf(fh, "  tot_Bx[~a] = Bx[~a] + ext_Bx[~a]; ~%", j-1, j-1, j-1), 
    printf(fh, "  tot_By[~a] = By[~a] + ext_By[~a]; ~%", j-1, j-1, j-1), 
    printf(fh, "  tot_Bz[~a] = Bz[~a] + ext_Bz[~a]; ~%", j-1, j-1, j-1) 
  ), 
  printf(fh, "~%"),

  /* Convert modal expansion to nodal expansions */
  nodes : gaussOrd(polyOrder+1, cdim),
  numNodes : length(nodes),  
  printf(fh, "  double rho_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double ux_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double uy_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double uz_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double app_accel_x_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double app_accel_y_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double app_accel_z_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double Ex_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double Ey_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double Ez_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double ext_Ex_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double ext_Ey_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double ext_Ez_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double app_curr_x_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double app_curr_y_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double app_curr_z_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),
  printf(fh, "  double tot_Bx_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double tot_By_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double tot_Bz_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),

  printf(fh, "  // Project modal expansions onto nodal bases. ~%"), 
  printf(fh, "  for (int s = 0; s < num_species; ++s) { ~%"),
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(rho[s], rho_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(ux[s], ux_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(uy[s], uy_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(uz[s], uz_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(app_accel_x[s], app_accel_x_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(app_accel_y[s], app_accel_y_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    modal_to_quad_nodal_~ad_~a_p~a(app_accel_z[s], app_accel_z_nodal[s]);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  } ~%"),
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(Ex, Ex_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(Ey, Ey_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(Ez, Ez_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(ext_Ex, ext_Ex_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(ext_Ey, ext_Ey_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(ext_Ez, ext_Ez_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(app_curr_x, app_curr_x_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(app_curr_y, app_curr_y_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(app_curr_z, app_curr_z_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(tot_Bx, tot_Bx_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(tot_By, tot_By_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  modal_to_quad_nodal_~ad_~a_p~a(tot_Bz, tot_Bz_nodal);~%", cdim, basisFun, polyOrder), 
  printf(fh, " ~%"), 

  for n : 1 thru numNodes do (
    printf(fh, "  struct gkyl_mat lhs~a = gkyl_nmat_get(A_n, count+~a); ~%", n-1, n-1),
    printf(fh, "  struct gkyl_mat rhs~a = gkyl_nmat_get(rhs_n, count+~a); ~%", n-1, n-1),
    printf(fh, "  // Clear matrix and rhs source solve. ~%"),
    printf(fh, "  gkyl_mat_clear(&lhs~a, 0.0); gkyl_mat_clear(&rhs~a, 0.0); ~%", n-1, n-1),
    printf(fh, "~%"),
    /* Set the RHS and LHS matrix for node n for all known quantities including the solution at the old time-step, 
       and any external electromagnetic fields, applied accelerations, or applied currents */
    printf(fh, "  for (int s = 0; s < num_species; ++s) { ~%"),
    printf(fh, "    // Set RHS for flow velocity equations, including solution at known time-step and external forces. ~%"),   
    printf(fh, "    gkyl_mat_set(&rhs~a, 0 + s*3, 0, ux_nodal[s][~a] + 0.5*dt*(qbym[s]*ext_Ex_nodal[~a] + app_accel_x_nodal[s][~a])); ~%", n-1, n-1, n-1, n-1),
    printf(fh, "    gkyl_mat_set(&rhs~a, 1 + s*3, 0, uy_nodal[s][~a] + 0.5*dt*(qbym[s]*ext_Ey_nodal[~a] + app_accel_y_nodal[s][~a])); ~%", n-1, n-1, n-1, n-1),
    printf(fh, "    gkyl_mat_set(&rhs~a, 2 + s*3, 0, uz_nodal[s][~a] + 0.5*dt*(qbym[s]*ext_Ez_nodal[~a] + app_accel_z_nodal[s][~a])); ~%", n-1, n-1, n-1, n-1),
    printf(fh, " ~%"),

    printf(fh, "    // Set LHS matrix for flow velocity equation: u_s^{n+1} - 0.5*dt*(q_s/m_s*E^{n+1} + q_s/m_s*u_s^{n+1} x B^n). ~%"), 
    printf(fh, "    double E_field_fac = -0.5*dt*qbym[s]/epsilon0; ~%"), 
    printf(fh, "    double B_field_fac = -0.5*dt*qbym[s]; ~%"), 

    /* Matrix is dense so just do a simple write routine */
    /* Diagonal entries of matrix (ux^{n+1}, uy^{n+1}, uz^{n+1}) */
    printf(fh, "    gkyl_mat_set(&lhs~a, 0 + s*3, 0 + s*3, 1.0); ~%", n-1),
    printf(fh, "    gkyl_mat_set(&lhs~a, 1 + s*3, 1 + s*3, 1.0); ~%", n-1),
    printf(fh, "    gkyl_mat_set(&lhs~a, 2 + s*3, 2 + s*3, 1.0); ~%", n-1),
    printf(fh, " ~%"),

    /* Electric field force (-0.5*dt*q/m)/epsilon0 * (epsilon0*E^{n+1}) for Ex, Ey, and Ez */
    printf(fh, "    gkyl_mat_set(&lhs~a, 0 + s*3, 0 + num_species*3, E_field_fac); ~%", n-1),
    printf(fh, "    gkyl_mat_set(&lhs~a, 1 + s*3, 1 + num_species*3, E_field_fac); ~%", n-1),
    printf(fh, "    gkyl_mat_set(&lhs~a, 2 + s*3, 2 + num_species*3, E_field_fac); ~%", n-1),
    printf(fh, " ~%"),

    /* Magnetic force from Bx affects uy and uz (uz*Bx and -uy*Bx respectively) */
    printf(fh, "    gkyl_mat_set(&lhs~a, 1 + s*3, 2 + s*3, B_field_fac*tot_Bx_nodal[~a]); ~%", n-1, n-1),
    printf(fh, "    gkyl_mat_set(&lhs~a, 2 + s*3, 1 + s*3, -B_field_fac*tot_Bx_nodal[~a]); ~%", n-1, n-1),
    printf(fh, " ~%"),

    /* Lorentz force from By affects uz and ux (ux*By and -uz*By respectively) */
    printf(fh, "    gkyl_mat_set(&lhs~a, 2 + s*3, 0 + s*3, B_field_fac*tot_By_nodal[~a]); ~%", n-1, n-1),
    printf(fh, "    gkyl_mat_set(&lhs~a, 0 + s*3, 2 + s*3, -B_field_fac*tot_By_nodal[~a]); ~%", n-1, n-1),
    printf(fh, " ~%"),

    /* Lorentz force from Bz affects ux and uy (uy*Bz and -ux*Bz respectively) */
    printf(fh, "    gkyl_mat_set(&lhs~a, 0 + s*3, 1 + s*3, B_field_fac*tot_Bz_nodal[~a]); ~%", n-1, n-1),
    printf(fh, "    gkyl_mat_set(&lhs~a, 1 + s*3, 0 + s*3, -B_field_fac*tot_Bz_nodal[~a]); ~%", n-1, n-1),
    printf(fh, " ~%"),

    /* Current accumulation in Ampere's Law if the PKPM self-consistent field is dynamic */
    printf(fh, "    // For Ampere's Law LHS: epsilon0*E^{n+1} + 0.5*dt*sum_s q_s/m_s*rho_s^n u_s^{n+1}. ~%"), 
    printf(fh, "    if (!pkpm_field_static) { ~%"), 
    printf(fh, "      gkyl_mat_set(&lhs~a, 0 + num_species*3, 0 + s*3, 0.5*dt*qbym[s]*rho_nodal[s][~a]); ~%", n-1, n-1),
    printf(fh, "      gkyl_mat_set(&lhs~a, 1 + num_species*3, 1 + s*3, 0.5*dt*qbym[s]*rho_nodal[s][~a]); ~%", n-1, n-1),
    printf(fh, "      gkyl_mat_set(&lhs~a, 2 + num_species*3, 2 + s*3, 0.5*dt*qbym[s]*rho_nodal[s][~a]); ~%", n-1, n-1),
    printf(fh, "    } ~%"), 
    printf(fh, "  } ~%"), 

    printf(fh, "  // Set RHS for Ampere's Law, including solution at known time-step and external currents. ~%"),  
    printf(fh, "  gkyl_mat_set(&rhs~a, 0 + num_species*3, 0, epsilon0*Ex_nodal[~a] - 0.5*dt*app_curr_x_nodal[~a]); ~%", n-1, n-1, n-1),
    printf(fh, "  gkyl_mat_set(&rhs~a, 1 + num_species*3, 0, epsilon0*Ey_nodal[~a] - 0.5*dt*app_curr_y_nodal[~a]); ~%", n-1, n-1, n-1),
    printf(fh, "  gkyl_mat_set(&rhs~a, 2 + num_species*3, 0, epsilon0*Ez_nodal[~a] - 0.5*dt*app_curr_z_nodal[~a]); ~%", n-1, n-1, n-1),    
    printf(fh, " ~%"),

    /* Diagonal entries of matrix (Ex^{n+1}, Ey^{n+1}, Ez^{n+1}) 
       Always set so matrix is invertible, even if EM fields are static. */
    printf(fh, "  gkyl_mat_set(&lhs~a, 0 + num_species*3, 0 + num_species*3, 1.0); ~%", n-1),
    printf(fh, "  gkyl_mat_set(&lhs~a, 1 + num_species*3, 0 + num_species*3, 1.0); ~%", n-1),
    printf(fh, "  gkyl_mat_set(&lhs~a, 2 + num_species*3, 0 + num_species*3, 1.0); ~%", n-1),
    printf(fh, " ~%")
  ), 
  printf(fh, "} ~%")
)$  

copyPKPMEMSourceNodalSolve(fh, funcNm, cdim, basisFun, polyOrder) := block(
  [varsC, bC, NC],

  kill(varsC, bC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  /* Number of basis monomials. */
  NC : length(bC),

  printf(fh, "#include <gkyl_mat.h> ~%"),
  printf(fh, "#include <gkyl_euler_pkpm_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(int count, 
  int num_species, double qbym[GKYL_MAX_SPECIES], double epsilon0, 
  struct gkyl_nmat *x, 
  const double *vlasov_pkpm_moms[GKYL_MAX_SPECIES], const double *pkpm_u[GKYL_MAX_SPECIES], 
  double* GKYL_RESTRICT euler_pkpm[GKYL_MAX_SPECIES], double* GKYL_RESTRICT em) ~%{ ~%", funcNm, polyOrder),
  printf(fh, "  // count:       integer to indicate which matrix being fetched. ~%"),
  printf(fh, "  // x:           Input solution vector (nodal basis representation of solution). ~%"),
  printf(fh, "  // vlasov_pkpm_moms: [rho, p_parallel, p_perp], Moments computed from kinetic equation in pkpm model (modal basis) at old time t^n.~%"),
  printf(fh, "  // pkpm_u:      [ux, uy, uz], Input flow velocity (modal basis) at old time t^n.~%"),  
  printf(fh, "  // euler_pkpm:  [rho ux, rho uy, rho uz], Fluid output state vector (modal basis) at time t^{n+1}.~%"),
  printf(fh, "  // em:          [Ex, Ey, Ez, Bx, By, Bz], EM output state vector (modal basis) at time t^{n+1}.~%"),
  printf(fh, "  //              Source solve only updates Ex, Ey, Ez. ~%"),
  printf(fh, "~%"),

  /* Modal solution at new timestep */
  printf(fh, "  double ux_new[~a] = {0.0}; ~%", NC), 
  printf(fh, "  double uy_new[~a] = {0.0}; ~%", NC), 
  printf(fh, "  double uz_new[~a] = {0.0}; ~%", NC), 
  printf(fh, "  double Ex_new[~a] = {0.0}; ~%", NC), 
  printf(fh, "  double Ey_new[~a] = {0.0}; ~%", NC), 
  printf(fh, "  double Ez_new[~a] = {0.0}; ~%", NC), 
  printf(fh, "~%"),

  /* Nodal solution at new timestep */
  nodes : gaussOrd(polyOrder+1, cdim),
  numNodes : length(nodes),  
  printf(fh, "  double ux_new_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double uy_new_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double uz_new_nodal[GKYL_MAX_SPECIES][~a]; ~%", numNodes), 
  printf(fh, "  double Ex_new_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double Ey_new_nodal[~a]; ~%", numNodes), 
  printf(fh, "  double Ez_new_nodal[~a]; ~%", numNodes), 
  printf(fh, "~%"),

  printf(fh, "  // Factor of 2.0 is because solution at new time-step is A^{n+1} = 2.0*A_bar - A^{n}. ~%"), 
  for n : 1 thru numNodes do (
    printf(fh, "  struct gkyl_mat sol~a = gkyl_nmat_get(x, count+~a); ~%", n-1, n-1),
    printf(fh, "  for (int s = 0; s < num_species; ++s) { ~%"),
    printf(fh, "    ux_new_nodal[s][~a] = 2.0*gkyl_mat_get(&sol~a, 0 + s*3, 0); ~%", n-1, n-1),
    printf(fh, "    uy_new_nodal[s][~a] = 2.0*gkyl_mat_get(&sol~a, 1 + s*3, 0); ~%", n-1, n-1),
    printf(fh, "    uz_new_nodal[s][~a] = 2.0*gkyl_mat_get(&sol~a, 2 + s*3, 0); ~%", n-1, n-1),
    printf(fh, "  } ~%"),
    printf(fh, "  Ex_new_nodal[~a] = 2.0*gkyl_mat_get(&sol~a, 0 + num_species*3, 0); ~%", n-1, n-1),
    printf(fh, "  Ey_new_nodal[~a] = 2.0*gkyl_mat_get(&sol~a, 1 + num_species*3, 0); ~%", n-1, n-1),
    printf(fh, "  Ez_new_nodal[~a] = 2.0*gkyl_mat_get(&sol~a, 2 + num_species*3, 0); ~%", n-1, n-1),
    printf(fh, "~%")
  ),

  printf(fh, "  // Project 2.0*nodal solution onto modal bases and subtract solution at old time step. ~%"),
  printf(fh, "  // We then convert back to momentum with rho^n. ~%"),  
  printf(fh, "  for (int s = 0; s < num_species; ++s) { ~%"),
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(ux_new_nodal[s], ux_new);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(uy_new_nodal[s], uy_new);~%", cdim, basisFun, polyOrder), 
  printf(fh, "    quad_nodal_to_modal_~ad_~a_p~a(uz_new_nodal[s], uz_new);~%", cdim, basisFun, polyOrder), 
  printf(fh, " ~%"), 
  printf(fh, "    const double *rho_old = &vlasov_pkpm_moms[s][~a]; ~%", 0*NC),
  printf(fh, "    const double *ux_old = &pkpm_u[s][~a]; ~%", 0*NC),
  printf(fh, "    const double *uy_old = &pkpm_u[s][~a]; ~%", 1*NC),
  printf(fh, "    const double *uz_old = &pkpm_u[s][~a]; ~%", 2*NC),
  for j : 1 thru NC do (
    printf(fh, "    ux_new[~a] -= ux_old[~a]; ~%", j-1, j-1),
    printf(fh, "    uy_new[~a] -= uy_old[~a]; ~%", j-1, j-1),
    printf(fh, "    uz_new[~a] -= uz_old[~a]; ~%", j-1, j-1),
    printf(fh, "~%")
  ), 
  /* We solved for u_s^{n+1}, so we need to weak multiply solution by rho^n to convert back to momentum */
  printf(fh, "    double *out_rhoux = &euler_pkpm[s][~a]; ~%", 0*NC),
  printf(fh, "    double *out_rhouy = &euler_pkpm[s][~a]; ~%", 1*NC),
  printf(fh, "    double *out_rhouz = &euler_pkpm[s][~a]; ~%", 2*NC),
  printf(fh, "~%"),
  printf(fh, "    binop_mul_~ad_~a_p~a(rho_old, ux_new, out_rhoux); ~%", cdim, basisFun, polyOrder),
  printf(fh, "    binop_mul_~ad_~a_p~a(rho_old, uy_new, out_rhouy); ~%", cdim, basisFun, polyOrder),
  printf(fh, "    binop_mul_~ad_~a_p~a(rho_old, uz_new, out_rhouz); ~%", cdim, basisFun, polyOrder),
  printf(fh, "  } ~%"),
  printf(fh, "~%"),
  printf(fh, "  quad_nodal_to_modal_~ad_~a_p~a(Ex_new_nodal, Ex_new);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  quad_nodal_to_modal_~ad_~a_p~a(Ey_new_nodal, Ey_new);~%", cdim, basisFun, polyOrder), 
  printf(fh, "  quad_nodal_to_modal_~ad_~a_p~a(Ez_new_nodal, Ez_new);~%", cdim, basisFun, polyOrder), 
  printf(fh, "~%"),
  printf(fh, "  double *out_Ex = &em[~a]; ~%", 0*NC),
  printf(fh, "  double *out_Ey = &em[~a]; ~%", 1*NC),
  printf(fh, "  double *out_Ez = &em[~a]; ~%", 2*NC),
  printf(fh, "~%"),
  for j : 1 thru NC do (
    /* We solved for epsilon0*E^{n+1}, so we need to divide solution by epsilon0 to convert back to electric field */
    printf(fh, "  out_Ex[~a] = 2.0*Ex_new[~a]/epsilon0 - out_Ex[~a]; ~%", j-1, j-1, j-1), 
    printf(fh, "  out_Ey[~a] = 2.0*Ey_new[~a]/epsilon0 - out_Ey[~a]; ~%", j-1, j-1, j-1), 
    printf(fh, "  out_Ez[~a] = 2.0*Ez_new[~a]/epsilon0 - out_Ez[~a]; ~%", j-1, j-1, j-1), 
    printf(fh, "~%")
  ), 
  printf(fh, "} ~%")
)$  
