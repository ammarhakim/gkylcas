load("modal-basis");
load("recovery");

for ndim : 1 thru maxNdim do (
  dirs : if ndim = 1 then [x] elseif ndim = 2 then [x, y] else [x, y, z],
  for polyOrder : 1 thru maxPolyOrder do (
    for basisIdx : 1 thru min(polyOrder, length(basisNames)) do (
      ba : loadBasis(basisNames[basisIdx], ndim, polyOrder),
      subList : append(
        makelist(fl[i]=fl[i-1], i, 1, length(ba)),
        makelist(fc[i]=fc[i-1], i, 1, length(ba)),
        makelist(fr[i]=fr[i-1], i, 1, length(ba))
      ),
      fname : sconcat(outFn, "/const_diffusion_surf_", ndim, "x_",
        sdowncase(basisNames[basisIdx]), "_p", polyOrder, ".c"),
      fh : openw(fname),
      printf(fh, "#include <gkyl_const_diffusion_kernels.h>~%~%"),
      for dirIdx : 1 thru length(dirs) do (
        rl : calcRecov2CellGen(basisNames[basisIdx], dirs[dirIdx], dirs, polyOrder, dg(fl), dg(fc)),
        rr : calcRecov2CellGen(basisNames[basisIdx], dirs[dirIdx], dirs, polyOrder, dg(fc), dg(fr)),
        surf : subst(x=0, diff(rr, x))*subst(x=1, ba) - subst(x=0, rr)*subst(x=1, diff(ba, x))
             - subst(x=0, diff(rl, x))*subst(x=-1, ba) + subst(x=0, rl)*subst(x=-1, diff(ba, x)),
        out : float(expand(subst(subList, surf))),
        
        printf(fh, "GKYL_CU_DH void~%"),
        fnName : sconcat("const_diffusion_surf", dirs[dirIdx], "_", ndim, "x_",
          sdowncase(basisNames[basisIdx]), "_p", polyOrder),
        printf(fh, fnName),
        printf(fh, "(const double* w, const double* dx,~%"),
        printf(fh, "  const double* D, const double* fl, const double* fc, const double* fr,~%"),
        printf(fh, "  double* GKYL_RESTRICT out)~%"),
        printf(fh, "{~%"),
        printf(fh, "  // w[NDIM]: Cell-center coordinates~%"),
        printf(fh, "  // dxv[NDIM]: Cell spacing~%"),
        printf(fh, "  // D: Constant diffusion coefficient~%"),
        printf(fh, "  // fl: Input distribution function in the left cell~%"),
        printf(fh, "  // fc: Input distribution function in the center cell~%"),
        printf(fh, "  // fr: Input distribution function in the right cell~%"),
        printf(fh, "  // out: Incremented output~%~%"),
        printf(fh, "  const double J = 4/dx[~a]/dx[~a];~%~%", dirIdx-1, dirIdx-1),
        
        for k : 1 thru length(ba) do (
          printf(fh, "  out[~a] += (~a)*D[0]*J;~%", k-1, out[k])
          ),
        printf(fh, "}~%~%")
        ),
      close(fh)
      )
    )
  ) $
