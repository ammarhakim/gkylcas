load("modal-basis");
load("recovery");

for ndim : 1 thru maxNdim do (
  dirs : if ndim = 1 then [x] elseif ndim = 2 then [x, y] else [x, y, z],
  for polyOrder : 1 thru maxPolyOrder do (
    for basisIdx : 1 thru min(polyOrder, length(basisNames)) do (
      ba : getBasis(basisNames[basisIdx], ndim, polyOrder),
      subList : makelist(f[i]=f[i-1], i, 1, length(ba)),
      fname : sconcat(outFn, "/const_diffusion_vol_", ndim, "x_",
        sdowncase(basisNames[basisIdx]), "_p", polyOrder, ".c"),
      fh : openw(fname),
      printf(fh, "#include <gkyl_const_diffusion_kernels.h>~%~%"),
      printf(fh, "GKYL_CU_DH void~%"),
      fnName : sconcat("const_diffusion_vol_", ndim, "x_",
        sdowncase(basisNames[basisIdx]), "_p", polyOrder),
      printf(fh, fnName),
      printf(fh, "(const double* w, const double* dx,~%"),
      printf(fh, "  const double* D, const double* f, double* GKYL_RESTRICT out)~%"),
      printf(fh, "{~%"),
      printf(fh, "  // w[NDIM]: Cell-center coordinates~%"),
      printf(fh, "  // dxv[NDIM]: Cell spacing~%"),
      printf(fh, "  // D: Constant diffusion coefficient~%"),
      printf(fh, "  // f: Input distribution function in the center cell~%"),
      printf(fh, "  // out: Incremented output~%~%"),

      for dirIdx : 1 thru length(dirs) do (
        printf(fh, "  const double J~a = 4/dx[~a]/dx[~a];~%", dirs[dirIdx], dirIdx-1, dirIdx-1)
        ),
      printf(fh, "~%"),
      for dirIdx : 1 thru length(dirs) do (
        rl : calcRecov2CellGen(basisNames[basisIdx], dirs[dirIdx], dirs, polyOrder, dg(fl), dg(fc)),
        rr : calcRecov2CellGen(basisNames[basisIdx], dirs[dirIdx], dirs, polyOrder, dg(fc), dg(fr)),
        surf : ,
        out : float(expand(subst(subList, surf))),
        
        for k : 1 thru length(ba) do (
          printf(fh, "  out[~a] += (~a)*D[0]*J;~%", k-1, out[k])
          ),
        printf(fh, "}~%~%")
        ),
      close(fh)
      )
    )
  ) $
