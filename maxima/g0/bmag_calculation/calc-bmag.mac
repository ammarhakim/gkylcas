load("modal-basis")$
load("recovery")$
load("nodal_operations/nodal_functions")$
load(stringproc)$
load("out-scripts")$

calcBmag(fh, ndim, basisName, polyOrder) := block(
  disp("starting"),

  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisName, ndim, "x")),
  [vars,basis] : [varsC, basisC[polyOrder]],
  
  evNodes : getNodes(basisName, ndim, polyOrder),
  numCoeffs : length(evNodes),
  N2M : calcNodToModWithNodes(basisName, ndim, polyOrder, evNodes),
  calcModCoeff(gij) := float(
    N2M. transpose( makelist(gij[k] , k, 1, numCoeffs))
  ),
  
  
  
  mkzlist(S,N) := makelist(S[i],i,0,N-1),
  zc_all : [x,y],
  zc : makelist(zc_all[k],k,1,ndim),
  
  
  psibyr2_zl : mkzlist(psibyr2,numCoeffs),
  psibyr2_e : doExpand(psibyr2_zl, basis),


  bphi_zl : mkzlist(bphi,numCoeffs),
  bphi_e : doExpand(bphi_zl, basis),
  
  
  dirNames : [charlist("LIR"), charlist("BIT")] ,
  for j : 1 thru ndim do (
    for k : 1 thru 3 do (
      psibyr_zl[j,k] : mkzlist(eval_string(concat("psibyr",dirNames[j][k])), numCoeffs)
    )
  ),
  
  newDirNames : charlist("ILRBT"),
  for i : 1 thru ndim do (
    for j : 1 thru 2*ndim+1 do (
        xList[i,j] : concat("x",i,newDirNames[j])
    )
  ),
  
  for i : 1 thru 2*ndim+1 do (
    xyzList[i] : concat("xyz",newDirNames[i])
  ),
  
  disp("made dir lists"),
  
  /*psip[j] is psi recovered in direction j*/
  /*psiI is center cell, so on*/
  for j : 1 thru ndim do (
    psibyrp[j] : calcRecov1CellGen(basisName, zc[j], zc, polyOrder, 1, dg(psibyr_zl[j,1]), dg(psibyr_zl[j,2]), dg(psibyr_zl[j,3]))
  ),
  
  disp("did recovery"),
  
  /* Now take the derivatives*/
  /*B_R : diff(psip[1], zc[2])/zc[1];*/
  /*B_Z : -diff(psip[2], zc[1])/zc[1];*/
  
  B_R : diff(psibyrp[2], zc[2]),
  B_Z1 : -diff(psibyrp[1], zc[1]),
  B_Z2 : -psibyr2_e,
  B_PHI : bphi_e,
  
  disp("took derivatives"),
  
  
  sublist : makelist(makelist(zc[m] = evNodes[k][m], m,1,ndim),k,1,numCoeffs),
  
  numEvNodes : matrix_size(evNodes)[1],
  
  trimfloat(flt) := if abs(flt) < 1e-15 then 0 else flt ,
  flt(expr) := float(expand(expr)),
  
  
  printf(fh, "static inline double magnitude(double B_R, double B_Z, double B_PHI) ~%"),
  printf(fh, "{ double mag = 0;  mag = sqrt(B_R*B_R + B_Z*B_Z + B_PHI*B_PHI); return mag; } ~%~%", ndim),
  /*printf(fh, "{ double mag = 0;  mag = B_Z; return mag; } ~%~%", ndim);*/
  
  
  
  printf(fh, "GKYL_CU_DH void bmag_~ax_~a_p~a( const double **psibyr, const double *psibyr2, const double *bphi, double *bmagout, double scale_factorR, double scale_factorZ) ~%{ ~%", ndim, basisName, polyOrder),
  
  printf(fh, "double B_R_n[~a], B_Z_n[~a], B_Z1_n[~a], B_Z2_n[~a], B_PHI_n[~a]; ~%", numEvNodes, numEvNodes, numEvNodes, numEvNodes, numEvNodes),
  for i : 1 thru 2*ndim+1 do (
    printf(fh, "const double *psibyr~a = psibyr[~a];~%", newDirNames[i], i-1 )
  ),
  
  printf(fh, "double bmag_n[~a]; ~%", numEvNodes),
  /*Compute B_R,B_z at the nodes*/
  for n : 1 thru numEvNodes do (
    printf(fh, "  B_R_n[~a] = ~a; ~%", n-1, flt(subst(sublist[n], B_R))),
    printf(fh, "  B_R_n[~a] = B_R_n[~a]*scale_factorZ; ~%", n-1, n-1),
    printf(fh, "  B_Z1_n[~a] = ~a; ~%", n-1, flt(subst(sublist[n], B_Z1))),
    printf(fh, "  B_Z2_n[~a] = ~a; ~%", n-1, flt(subst(sublist[n], B_Z2))),
    printf(fh, "  B_Z_n[~a] = B_Z1_n[~a]*scale_factorR + B_Z2_n[~a]; ~%", n-1, n-1,n-1),
    printf(fh, "  B_PHI_n[~a] = ~a; ~%", n-1, flt(subst(sublist[n], B_PHI))),
    printf(fh, "  bmag_n[~a] = magnitude(B_R_n[~a], B_Z_n[~a], B_PHI_n[~a]); ~%", n-1, n-1, n-1, n-1)
  ),
  disp("caomputed br bz at nodes"),
  
  temp : calcModCoeff(mkzlist(bmag_n,numCoeffs)),
  bmag_m : makelist(temp[i][1],i,1,numCoeffs),
  disp("calculated modal coeffs"),
  writeCExprs1(bmagout, bmag_m),
  
  
  
  
  printf(fh, " ~%"),
  printf(fh, "}~%")
)$
