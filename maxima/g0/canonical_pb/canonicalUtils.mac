/*
  Utility functions for canonical poisson bracket Maxima scripts.
*/
load("out-scripts")$
load("vect")$
load("nodal_operations/nodal_functions")$
load("nodal_operations/quadrature_functions")$
load("utilities")$

slcn(lst, n) := makelist(lst[i], i, 1, n)$
slcn_v(lst, n) := makelist(lst[i], i, n+1, length(lst))$

PB(f, g, x_vec, y_vec, dx_vec, dy_vec) := 
  sum(
      (dx_vec[i]*dy_vec[i])*(diff(f, x_vec[i]) * diff(g, y_vec[i]) - diff(g, x_vec[i]) * diff(f, y_vec[i])),
    i, 1, length(x_vec)
  )$

calcAndWrite_CanonicalPB_alpha(fH,surfDir,bP,polyOrder,basisType,rdx2V,rdv2V,hamil,sideStr) := block(
  [varsP, varsC, varsV, varLabel, dirLabel, wSurf, rdSurfVar2, surfVar, surfIntVars, rdx2vec, rdv2vec,
   z, q, p, dq, dp, alpha, alphaUp, bSurf, numSurf, evPoint, replaceList, alpha_c, printf, alphaCvar,
   alphaNoZero_c, alphaSurf, alphaUpSurf], 
  /* Calculate phase space velocity alpha in direction of surfVar. */
  /* We assume alpha.n and hamil is continuous across boundary. */
  /* Distinguish between alpha and alphaUp, where alphaUp is the one used to
     determine upwind direction. */

  varsP : listofvars(bP),
  varsC : slcn(varsP, cdim),
  varsV : slcn_v(varsP, cdim),
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  wSurf      : eval_string(sconcat("w",dirLabel)),
  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */

  /* Calculate phase space velocity alpha_d = {z[d], H} = dz[d]/dt. */
  rdx2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,1,cdim),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),
  z : varsP[surfDir],
  q : varsC, 
  p : varsV, 
  dq : rdx2vec, /* Rename */
  dp : rdv2vec,
  alpha : PB(z,hamil,q,p,dq,dp),
  alphaUp : alpha,

  bSurf : basisFromVars(basisType,surfIntVars,polyOrder),
  numSurf : length(bSurf),

  if sideStr="L" then (evPoint : -1)
  elseif sideStr="R" then (evPoint : 1),

  /* Project full alpha expression evaluated at interior surface
     onto surface basis and print to C variable alpha. */
  alpha_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=evPoint,alpha)),
  alphaCvar : eval_string(sconcat("alpha",sideStr)),
  clst : [rdx2vec, rdv2vec, m_, q_, wvpar],
  writeCExprsCollect1(alphaCvar, alpha_c, clst),
  printf(fh, "~%"),
  flush_output(fh),
  alphaNoZero_c : doMakeExprLst(alpha_c, alphaCvar),
  alphaSurf_e   : doExpand(alphaNoZero_c, bSurf),

  return(alphaSurf_e)
)$



calc_canonical_pb_alpha_no_write(fH,surfDir,bP,polyOrder,basisType,rdx2V,rdv2V,
                   hamil,sideStr) := block(
  [varsP, varsC, varsV, varLabel, dirLabel, wSurf, rdSurfVar2, surfVar, surfIntVars, rdx2vec, rdv2vec,
   z, q, p, dq, dp, alpha, alphaUp, bSurf, numSurf, evPoint, replaceList, alpha_c, printf, alphaCvar,
   alphaNoZero_c, alphaSurf, alphaUpSurf],
  /* Calculate phase space velocity alpha in direction of surfVar. */
  /* We assume alpha.n is continuous across boundary, although H may not be. */
  /* Distinguish between alpha and alphaUp, where alphaUp is the one used to
     determine upwind direction. */

  varsP    : listofvars(bP),
  varsC : slcn(varsP, cdim),
  varsV : slcn_v(varsP, cdim),
  varLabel : makelist(string(varsP[d]),d,1,pDim),
  dirLabel : varLabel[surfDir],

  wSurf      : eval_string(sconcat("w",dirLabel)),
  rdSurfVar2 : eval_string(sconcat("rd",dirLabel,"2")),

  surfVar     : varsP[surfDir],         /* Surface variable. */
  surfIntVars : delete(surfVar,varsP),  /* Surface integral variables. */


  /* Calculate phase space velocity alpha_d = {z[d], H} = dz[d]/dt. */
  rdx2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,1,cdim),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),
  z : varsP[surfDir],
  q : varsC, 
  p : varsV, 
  dq : rdx2vec, /* Rename */
  dp : rdv2vec,
  alpha : PB(z,hamil,q,p,dq,dp),
  alphaUp : alpha,

  bSurf : basisFromVars(basisType,surfIntVars,polyOrder),
  numSurf : length(bSurf),

  if sideStr="L" then (evPoint : -1)
  elseif sideStr="R" then (evPoint : 1),

  /* Project full alpha expression evaluated at interior surface
     onto surface basis and print to C variable alpha. */
  alpha_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=evPoint,alpha_e)),
  alphaCvar : eval_string(sconcat("alpha",sideStr)),
  alphaNoZero_c : doMakeExprLst(alpha_c, alphaCvar),
  alphaSurf_e   : doExpand(alphaNoZero_c, bSurf),

  return(alphaSurf_e)
)$


/* Determine the upwinded distribution function in canonical pb */
calcAndWrite_CanonicalPBfUpwind(file_handle,surfDir,surfVar,surfIntVars,bSurf,NSurf,fl_e,fr_e,basisStr,sideStr) := block(
  [fstrL, fstrR, fLNm, fRNm, fUpNm, sgn_alpha_surfNm, sgn_alphaUpNm, fSurfl_c, fSurfr_c, 
   fSurfl_e, fSurfr_e, sgn_alphaUp_e, fUp_c],
   
    /* Naming convention for subsequent distribution function evaluations 
       for a cell-based update. If performing the left surface update 
       we need fl(surfVar=+1) and fc(surfVar=-1) (f_lr and f_cl) and if we are performing
       the right surface update we need fc(surfVar=+1) and fr(surfVar=-1) (f_cr and f_rl) */
    if (sideStr = "L") then (
      fstrL : "lr",
      fstrR : "cl"
    )
    else (
      fstrL : "cr",
      fstrR : "rl"
    ),
    fLNm : eval_string(sconcat("f_",fstrL)),
    fRNm : eval_string(sconcat("f_",fstrR)),
    fUpNm : eval_string(sconcat("fUp",sideStr)),
    sgn_alpha_surfNm : eval_string(sconcat("sgn_alpha_surf",sideStr)),
    sgn_alphaUpNm : eval_string(sconcat("sgn_alphaUp",sideStr)),

    printf(file_handle, "  double fUp~a[~a] = {0.};~%", sideStr, NSurf),
    fSurfl_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=1, fl_e)),
    fSurfr_c : calcInnerProdList(surfIntVars, 1, bSurf, subst(surfVar=-1, fr_e)),
    fSurfl_e : doExpand1(fLNm, bSurf), 
    fSurfr_e : doExpand1(fRNm, bSurf), 

    /* If sign(alpha_surf) is single signed
       1. f^- (if sign(alpha_surf) = 1), 
       2. f^+ (if sign(alpha_surf) = -1) */
    printf(file_handle, "  if (const_sgn_alpha~a[0] == 1) {  ~%", sideStr),
    printf(file_handle, "    if (sgn_alpha_surf~a[0] == 1.0) {  ~%", sideStr),
    writeCExprs1(fUpNm, fSurfl_c),
    printf(file_handle, "    } else { ~%"),
    writeCExprs1(fUpNm, fSurfr_c),
    printf(file_handle, "    } ~%"),

    /* Else sign(alpha_surf) is changing quadrature point to quadrature point
       1/2*(f^+ + f^-) - 1/2*sgn_alpha_surf*(f^+ - f^-) */
    printf(file_handle, "  } else { ~%"),
    printf(file_handle, "  double f_~a[~a] = {0.};~%", fstrL, NSurf),
    printf(file_handle, "  double f_~a[~a] = {0.};~%", fstrR, NSurf),
    printf(file_handle, "  double sgn_alphaUp~a[~a] = {0.};~%", sideStr, NSurf),
    printf(file_handle, "  ~a_upwind_quad_to_modal(~a, ~a); ~%", basisStr, sgn_alpha_surfNm, sgn_alphaUpNm),
    sgn_alphaUp_e : doExpand1(sgn_alphaUpNm, bSurf),
    printf(file_handle, "~%"),
    writeCExprs1(fLNm, fSurfl_c),
    printf(file_handle, "~%"),
    flush_output(file_handle),
    writeCExprs1(fRNm, fSurfr_c),
    printf(file_handle, "~%"),
    flush_output(file_handle),
    fUp_c : calcInnerProdList(surfIntVars, 1, bSurf, 0.5*(fSurfl_e + fSurfr_e) - 0.5*sgn_alphaUp_e*(fSurfr_e - fSurfl_e)),
    writeCExprsNoExpand1(fUpNm, gcfac(float(expand(fUp_c)))),
    printf(file_handle, "~%"),
    flush_output(file_handle),

    printf(file_handle, "  } ~%")
)$