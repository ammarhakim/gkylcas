/* Generate kernels for computing rest-frame pressure = n*T
   in the general relativistic Vlasov-Maxwell system of equations.
   The moment factor is: 
   gamma*GammaV^2 - 2*GammaV*(v . p) + 1/gamma*((v . p)^2 - 1) 
   where v is the spatial component of the bulk four-velocity: GammaV*V_drift_i, 
   GammaV is the bulk Lorentz boost factor: sqrt(1 + v^2), 
   p is the spatial component of the particle four-velocity, 
   and gamma = sqrt(1 + p^2) is the particle Lorentz boost factor. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
fpprec : 24$ 

let(wx1^2, wx1_sq)$
let(wx2^2, wx2_sq)$
let(wx3^2, wx3_sq)$
let(dv1^2, dv1_sq)$
let(dv2^2, dv2_sq)$
let(dv3^2, dv3_sq)$

volExpr(cdim, vdim) := prod(dxv[cdim+i-1], i, 1, vdim)$
volExprTot(totDim) := prod(dxv[i-1], i, 1, totDim)$
pVsub : [x=vx,y=vy,z=vz]$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
dv11 : [dv10, dv11, dv12]$

vTrans  : [vx*dv1/2.0+wx1, vy*dv2/2.0+wx2, vz*dv3/2.0+wx3]$
wTrans  : [wx1, wx2, wx3]$
dvTrans : [vx*dv1/2.0, vy*dv2/2.0, vz*dv3/2.0]$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

/* total fluid-frame pressure = n*T where n is the fluid-frame density */
calc_gr_pressure(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV,
   GammaV_e, Vx_e, Vy_e, Vz_e, GammaVSq_e, VxSq_e, VySq_e, VzSq_e,
   temp_c, temp_sq_c, tempNoZero, temp_e, tempSqNoZero, tempSq_e, 
   p_fac_c, p_facNoZero, 
   gamma_inv_e, gamma_e, p_fac_e, fl, Pressure, clst, ratprint],

  /* Suppress the rat messages */
  ratprint : false,

  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  /* Load basis of dimensionality requested. */
  if (basisFun="tensor") then (
    /* If we are using the tensor basis, just use the simple load command */
    [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),
    [varsP,bP] : loadBasis(basisFun, cdim+vdim, polyOrder),
    /* Do a variable substitution for the lower dimensional tensor basis functions
       to construct the correct set of variables for the subsequent operations */
    if (cdim+vdim = 2) then (
      varsSub : [y=vx],
      bP : subst(varsSub, copylist(bP)),  
      varsP : subst(varsSub, copylist(varsP))
    )
    else if (cdim+vdim = 3) then (
      varsSub : [y=vx, z=vy],
      bP : subst(varsSub, copylist(bP)),  
      varsP : subst(varsSub, copylist(varsP))
    )
    else if (cdim = 2 and vdim = 2) then (
      varsSub : [vx=y, vy=vx, vz=vy],
      bP : subst(varsSub, copylist(bP)),  
      varsP : subst(varsSub, copylist(varsP))
    )
  )
  else (
    /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
    [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

    /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
       mean hybrid basis. */
    if polyOrder=1 then ( pOrderV : 2 )
  ),

  printf(fh, "#include <gkyl_canonical_pb_gr_Gamma_kernels.h> ~%"),
  printf(fh, "#include <gkyl_binop_mul_ser.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *h_ij_inv, const double *u_i, const double *u_i_sq, const double *GammaV, const double *GammaV_sq, const double *f, double* GKYL_RESTRICT gr_pressure) ~%{ ~%", funcNm),
  printf(fh, "  // w:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv: Cell spacing.~%"),
  printf(fh, "  // h_ij_inv:         Input volume expansion of the inverse metric tensor.~%"),
  printf(fh, "  //                   [Hxx, Hxy, Hxz, ~%"),
  printf(fh, "  //                     - , Hyy, Hyz, ~%"),
  printf(fh, "  //                     - ,  - , Hzz] ~%"),
  printf(fh, "  // u_i:         Spatial components of bulk four-velocity = GammaV*V_drift. ~%"),
  printf(fh, "  // u_i_sq:      Squared spatial components of bulk four-velocity = u_i^2. ~%"),
  printf(fh, "  // GammaV:      Bulk four-velocity Lorentz factor = sqrt(1 + |u_i|^2). ~%"),
  printf(fh, "  // GammaV_sq:   Squared bulk four-velocity Lorentz factor = 1 + |u_i|^2. ~%"),
  printf(fh, "  // f:           Input distribution function.~%"),
  printf(fh, "  // gr_pressure: Output relativistic pressure.~%"),
  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),
  printf(fh, " ~%"),

  for i : 1 thru vdim do (
    /* New */
    printf(fh, "  const double wx~a = w[~a], dv~a = dxv[~a]; ~%", i, cdim+i-1, i, cdim+i-1),
    printf(fh, "  const double wx~a_sq = wx~a*wx~a, dv~a_sq = dv~a*dv~a; ~%", i, i, i, i, i, i),

    printf(fh, "  const double *V_~a = &u_i[~a]; ~%", i-1, NC*(i-1)),
    printf(fh, "  const double *V_~a_sq = &u_i_sq[~a]; ~%", i-1, NC*(i-1)),
    printf(fh, " ~%")
  ),
  printf(fh, "  double p_sq[~a] = {0.0};~%", NP),

  GammaV_e : doExpand1(GammaV, bC),
  Vx_e : doExpand1(V_0, bC),
  Vy_e : doExpand1(V_1, bC),
  Vz_e : doExpand1(V_2, bC),

  GammaVSq_e : doExpand1(GammaV_sq, bC),
  VxSq_e : doExpand1(V_0_sq, bC),
  VySq_e : doExpand1(V_1_sq, bC),
  VzSq_e : doExpand1(V_2_sq, bC),

  /* Compute at quad points h_ij_inv*/
  if (vdim = 1) then (
    printf(fh, "  const double *Hxx = &h_ij_inv[~a]; ~%", 0*NC)
  ),
  if (vdim = 2) then (
    printf(fh, "  const double *Hxx = &h_ij_inv[~a]; ~%", 0*NC),
    printf(fh, "  const double *Hxy = &h_ij_inv[~a]; ~%", 1*NC),
    printf(fh, "  const double *Hyy = &h_ij_inv[~a]; ~%", 2*NC)
  ),
  if (vdim = 3) then (
    printf(fh, "  const double *Hxx = &h_ij_inv[~a]; ~%", 0*NC),
    printf(fh, "  const double *Hxy = &h_ij_inv[~a]; ~%", 1*NC),
    printf(fh, "  const double *Hxz = &h_ij_inv[~a]; ~%", 2*NC),
    printf(fh, "  const double *Hyy = &h_ij_inv[~a]; ~%", 3*NC),
    printf(fh, "  const double *Hyz = &h_ij_inv[~a]; ~%", 4*NC),
    printf(fh, "  const double *Hzz = &h_ij_inv[~a]; ~%", 5*NC)
  ),
  printf(fh, "~%"),
  hxx_e : doExpand1(Hxx, bC),
  hxy_e : doExpand1(Hxy, bC),
  hxz_e : doExpand1(Hxz, bC),
  hyy_e : doExpand1(Hyy, bC),
  hyz_e : doExpand1(Hyz, bC),
  hzz_e : doExpand1(Hzz, bC),

  /* START GAMMA_INV Calc */ 
  Vpx : dv1/2.0*varsV[1] + wx1,
  if (vdim > 1) then (
    Vpy : dv2/2.0*varsV[2] + wx2
  ),
  if (vdim > 2) then (
    Vpz : dv3/2.0*varsV[3] + wx3
  ),
  if (vdim = 1) then (
    p_sq_c : calcInnerProdList(varsP, 1, bP, hxx_e*(Vpx)^2)
  ),
  if (vdim = 2) then (
    p_sq_c : calcInnerProdList(varsP, 1, bP, hxx_e*(Vpx)^2 + hyy_e*(Vpy)^2 + 2.0*hxy_e*Vpx*Vpy)
  ), 
  if (vdim = 3) then (
    p_sq_c : calcInnerProdList(varsP, 1, bP, hxx_e*(Vpx)^2 + hyy_e*(Vpy)^2 + hzz_e*(Vpz)^2 
              + 2.0*hxy_e*Vpx*Vpy + 2.0*hxz_e*Vpx*Vpz + 2.0*hyz_e*Vpy*Vpz)
  ), 
  p_sq_c : map(letsimp, p_sq_c),
  writeCExprs1(p_sq, p_sq_c), 
  printf(fh, "~%"), 
  p_sq_e : doExpand1(p_sq, bP),

  /* For p = 2, we use the nodes (-1, 0, 1) (Gauss-Lobatto nodes) */
  nodes_lobatto : getNodes(basisFun, cdim+vdim, polyOrder),
  num_nodes_lobatto : length(nodes_lobatto), 
  p_sq_nodes : expand(float(evAtNodes(p_sq_e,nodes_lobatto,varsP))),  
  printf(fh, "  double gamma_nodal[~a] = {0.0};~%", num_nodes_lobatto),
  printf(fh, "  double gamma_inv_nodal[~a] = {0.0};~%", num_nodes_lobatto),
  printf(fh, "  double gamma[~a] = {0.0};~%", NP),
  printf(fh, "  double gamma_inv[~a] = {0.0};~%", NP),
  printf(fh, "~%"), 
  for i : 1 thru num_nodes_lobatto do (
    printf(fh, "  gamma_nodal[~a] = sqrt(1.0 + ~a);~%", i-1, p_sq_nodes[i]), 
    printf(fh, "  gamma_inv_nodal[~a] = 1.0/gamma_nodal[~a];~%", i-1, i-1)
  ), 
  printf(fh, "~%"), 
  
  basis_nodal_lobatto : getVarsNodalBasisWithNodes(basisFun, cdim+vdim, polyOrder, varsP, nodes_lobatto), 
  gamma_nodal_e : doExpand1(gamma_nodal,basis_nodal_lobatto),
  gamma_inv_nodal_e : doExpand1(gamma_inv_nodal,basis_nodal_lobatto),

  gamma_c : calcInnerProdList(varsP, 1, bP, gamma_nodal_e), 
  gamma_inv_c : calcInnerProdList(varsP, 1, bP, gamma_inv_nodal_e), 
  writeCExprs1(gamma, gamma_c), 
  printf(fh, "~%"), 
  writeCExprs1(gamma_inv, gamma_inv_c), 
  printf(fh, "~%"), 

  /* Expand gamma and gamma_inv */
  gamma_inv_e : doExpand1(gamma_inv, bP),
  gamma_e : doExpand1(gamma, bP),

  /* END GAMMA, GAMMA_INV Calc */
  printf(fh, "  double temp[~a] = {0.0}; ~%", NP),
  printf(fh, "  double temp_sq[~a] = {0.0}; ~%", NP),
  printf(fh, "  double p_fac[~a] = {0.0}; ~%", NP),

  /* Temporary varaibles to avoid issues with hxx[i]^2 etc. */
  if (vdim = 1) then (
    printf(fh, "  double Hxx_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hxx, Hxx, Hxx_sq); ~%", cdim, basisFun, polyOrder),
    Hxx_sq_e : doExpand1(Hxx_sq, bC)
  ),
  if (vdim = 2) then (
    printf(fh, "  double Hxx_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  double Hxy_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  double Hyy_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hxx, Hxx, Hxx_sq); ~%", cdim, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hxy, Hxy, Hxy_sq); ~%", cdim, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hyy, Hyy, Hyy_sq); ~%", cdim, basisFun, polyOrder),
    Hxx_sq_e : doExpand1(Hxx_sq, bC),
    Hxy_sq_e : doExpand1(Hxy_sq, bC),
    Hyy_sq_e : doExpand1(Hyy_sq, bC)
  ),
  if (vdim = 3) then (
    printf(fh, "  double Hxx_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  double Hxy_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  double Hyy_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  double Hxz_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  double Hyz_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  double Hzz_sq[~a] = {0.0}; ~%", NC),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hxx, Hxx, Hxx_sq); ~%", cdim, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hxy, Hxy, Hxy_sq); ~%", cdim, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hyy, Hyy, Hyy_sq); ~%", cdim, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hxz, Hxz, Hxz_sq); ~%", cdim, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hyz, Hyz, Hyz_sq); ~%", cdim, basisFun, polyOrder),
    printf(fh, "  binop_mul_~ad_~a_p~a(Hzz, Hzz, Hzz_sq); ~%", cdim, basisFun, polyOrder),
    Hxx_sq_e : doExpand1(Hxx_sq, bC),
    Hxy_sq_e : doExpand1(Hxy_sq, bC),
    Hyy_sq_e : doExpand1(Hyy_sq, bC),
    Hxz_sq_e : doExpand1(Hxz_sq, bC),
    Hyz_sq_e : doExpand1(Hyz_sq, bC),
    Hzz_sq_e : doExpand1(Hzz_sq, bC)
  ),

  /* Maxima couldn't generate these kernels raw, here we introduce smaller
  temporary variables to break it down and make the writes easier*/

  N_p_fac_p_fac_c_comps : 3,
  for j : 1 thru N_p_fac_p_fac_c_comps do (
    printf(fh, "  double p_fac~a[~a] = {0.0};~%", j, NP)
  ),
  if (vdim = 1) then (
    N_temp_c_comps : 1,
    N_temp_sq_c_comps : 1
  )
  else if (vdim = 2) then (
    N_temp_c_comps : 4,
    N_temp_sq_c_comps : 7
  )
  else ( 
    N_temp_c_comps : 9,
    N_temp_sq_c_comps : 27
  ),
  for j : 1 thru N_temp_c_comps do (
    printf(fh, "  double temp~a[~a] = {0.0};~%", j, NP)
  ),
  for j : 1 thru N_temp_sq_c_comps do (
    printf(fh, "  double temp_sq~a[~a] = {0.0};~%", j, NP)
  ),
  printf(fh, "~%"),

  if (vdim = 1) then (
    temp1_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxx_e*vTrans[1]*Vx_e)),
    writeCExprs1(temp1, temp1_c), printf(fh, "~%"), flush_output(fh),
    temp_sq1_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxx_sq_e*vTrans[1]*vTrans[1]*VxSq_e)),
    temp_sq1_c : map(letsimp, temp_sq1_c),
    writeCExprs1(temp_sq1, temp_sq1_c), printf(fh, "~%"), flush_output(fh)
  )
  else if (vdim = 2) then (
    /* Temporary varaiables for temp_c */
    temp1_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxx_e*vTrans[1]*Vx_e)),
    temp2_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxy_e*vTrans[2]*Vx_e)),
    temp3_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxy_e*vTrans[1]*Vy_e)),
    temp4_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hyy_e*vTrans[2]*Vy_e)),
    writeCExprs1(temp1, temp1_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp2, temp2_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp3, temp3_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp4, temp4_c), printf(fh, "~%"), flush_output(fh),
    temp_sq1_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxx_sq_e*vTrans[1]*vTrans[1]*VxSq_e)),
    temp_sq2_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hyy_sq_e*vTrans[2]*vTrans[2]*VySq_e)),
    temp_sq3_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxx_e*hxy_e*vTrans[1]*vTrans[1]*Vx_e*Vy_e)),
    temp_sq4_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxy_e*hyy_e*vTrans[2]*vTrans[2]*Vx_e*Vy_e)),
    temp_sq5_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxy_sq_e*vTrans[1]*vTrans[1]*VySq_e )),
    temp_sq6_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxy_sq_e*2*vTrans[1]*vTrans[2]*Vx_e*Vy_e )),
    temp_sq7_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxy_sq_e*vTrans[2]*vTrans[2]*VxSq_e)),
    temp_sq1_c : map(letsimp, temp_sq1_c),
    temp_sq2_c : map(letsimp, temp_sq2_c),
    temp_sq3_c : map(letsimp, temp_sq3_c),
    temp_sq4_c : map(letsimp, temp_sq4_c),
    temp_sq5_c : map(letsimp, temp_sq5_c),
    temp_sq6_c : map(letsimp, temp_sq6_c),
    temp_sq7_c : map(letsimp, temp_sq7_c),
    writeCExprs1(temp_sq1, temp_sq1_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq2, temp_sq2_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq3, temp_sq3_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq4, temp_sq4_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq5, temp_sq5_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq6, temp_sq6_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq7, temp_sq7_c), printf(fh, "~%"), flush_output(fh)
  )
  else (
    temp1_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxx_e*vTrans[1]*Vx_e)),
    temp2_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxy_e*vTrans[1]*Vy_e)),
    temp3_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxy_e*vTrans[2]*Vx_e)),
    temp4_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxz_e*vTrans[1]*Vz_e)),
    temp5_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hxz_e*vTrans[3]*Vx_e)),
    temp6_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hyy_e*vTrans[2]*Vy_e)),
    temp7_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hyz_e*vTrans[2]*Vz_e)),
    temp8_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hyz_e*vTrans[3]*Vy_e)),
    temp9_c : fullratsimp(calcInnerProdList(varsP, 1, bP, hzz_e*vTrans[3]*Vz_e)),
    writeCExprs1(temp1, temp1_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp2, temp2_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp3, temp3_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp4, temp4_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp5, temp5_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp6, temp6_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp7, temp7_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp8, temp8_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp9, temp9_c), printf(fh, "~%"), flush_output(fh),
    temp_sq1_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxx_sq_e*vTrans[1]*vTrans[1]*VxSq_e)),
    temp_sq2_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hyy_sq_e*vTrans[2]*vTrans[2]*VySq_e)),
    temp_sq3_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hzz_sq_e*vTrans[3]*vTrans[3]*VzSq_e)),
    temp_sq4_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxx_e*hxy_e*vTrans[1]*vTrans[1]*Vx_e*Vy_e)),
    temp_sq5_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxx_e*hxz_e*vTrans[1]*vTrans[1]*Vx_e*Vz_e)),
    temp_sq6_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hyy_e*hxy_e*vTrans[2]*vTrans[2]*Vx_e*Vy_e)),
    temp_sq7_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hyy_e*hyz_e*vTrans[2]*vTrans[2]*Vy_e*Vz_e)),
    temp_sq8_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hzz_e*hxz_e*vTrans[3]*vTrans[3]*Vx_e*Vz_e)),
    temp_sq9_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hzz_e*hyz_e*vTrans[3]*vTrans[3]*Vy_e*Vz_e)),
    temp_sq10_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxy_sq_e*(vTrans[1]*vTrans[1]*VySq_e))),
    temp_sq11_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxy_sq_e*(2*vTrans[1]*vTrans[2]*Vx_e*Vy_e))),
    temp_sq12_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxy_sq_e*(vTrans[2]*vTrans[2]*VxSq_e))),
    temp_sq13_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxz_sq_e*(vTrans[1]*vTrans[1]*VzSq_e))),
    temp_sq14_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxz_sq_e*(2*vTrans[1]*vTrans[3]*Vx_e*Vz_e))),
    temp_sq15_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hxz_sq_e*(vTrans[3]*vTrans[3]*VxSq_e))),
    temp_sq16_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hyz_sq_e*(vTrans[2]*vTrans[2]*VzSq_e))),
    temp_sq17_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hyz_sq_e*( 2*vTrans[2]*vTrans[3]*Vy_e*Vz_e))),
    temp_sq18_c : fullratsimp(calcInnerProdList(varsP, 1, bP, Hyz_sq_e*(vTrans[3]*vTrans[3]*VySq_e))),
    temp_sq19_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxy_e*hxz_e*(vTrans[1]*vTrans[1]*Vy_e*Vz_e))),
    temp_sq20_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxy_e*hxz_e*(vTrans[1]*vTrans[2]*Vz_e*Vx_e))),
    temp_sq21_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxy_e*hxz_e*(vTrans[1]*vTrans[3]*Vy_e*Vx_e))),
    temp_sq22_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxy_e*hyz_e*(vTrans[2]*vTrans[2]*Vx_e*Vz_e))),
    temp_sq23_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxy_e*hyz_e*(vTrans[2]*vTrans[1]*Vz_e*Vy_e))),
    temp_sq24_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxy_e*hyz_e*(vTrans[2]*vTrans[3]*Vx_e*Vy_e))),
    temp_sq25_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxz_e*hyz_e*(vTrans[3]*vTrans[3]*Vx_e*Vy_e))),
    temp_sq26_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxz_e*hyz_e*(vTrans[3]*vTrans[1]*Vy_e*Vz_e))),
    temp_sq27_c : fullratsimp(calcInnerProdList(varsP, 1, bP, 2*hxz_e*hyz_e*(vTrans[3]*vTrans[2]*Vx_e*Vz_e))),
    temp_sq1_c  : map(letsimp, temp_sq1_c),
    temp_sq2_c  : map(letsimp, temp_sq2_c),
    temp_sq3_c  : map(letsimp, temp_sq3_c),
    temp_sq4_c  : map(letsimp, temp_sq4_c),
    temp_sq5_c  : map(letsimp, temp_sq5_c),
    temp_sq6_c  : map(letsimp, temp_sq6_c),
    temp_sq7_c  : map(letsimp, temp_sq7_c),
    temp_sq8_c  : map(letsimp, temp_sq8_c),
    temp_sq9_c  : map(letsimp, temp_sq9_c),
    temp_sq10_c : map(letsimp, temp_sq10_c),
    temp_sq11_c : map(letsimp, temp_sq11_c),
    temp_sq12_c : map(letsimp, temp_sq12_c),
    temp_sq13_c : map(letsimp, temp_sq13_c),
    temp_sq14_c : map(letsimp, temp_sq14_c),
    temp_sq15_c : map(letsimp, temp_sq15_c),
    temp_sq16_c : map(letsimp, temp_sq16_c),
    temp_sq17_c : map(letsimp, temp_sq17_c),
    temp_sq18_c : map(letsimp, temp_sq18_c),
    temp_sq19_c : map(letsimp, temp_sq19_c),
    temp_sq20_c : map(letsimp, temp_sq20_c),
    temp_sq21_c : map(letsimp, temp_sq21_c),
    temp_sq22_c : map(letsimp, temp_sq22_c),
    temp_sq23_c : map(letsimp, temp_sq23_c),
    temp_sq24_c : map(letsimp, temp_sq24_c),
    temp_sq25_c : map(letsimp, temp_sq25_c),
    temp_sq26_c : map(letsimp, temp_sq26_c),
    temp_sq27_c : map(letsimp, temp_sq27_c),
    writeCExprs1(temp_sq1, temp_sq1_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq2, temp_sq2_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq3, temp_sq3_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq4, temp_sq4_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq5, temp_sq5_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq6, temp_sq6_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq7, temp_sq7_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq8, temp_sq8_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq9, temp_sq9_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq10, temp_sq10_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq11, temp_sq11_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq12, temp_sq12_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq13, temp_sq13_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq14, temp_sq14_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq15, temp_sq15_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq16, temp_sq16_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq17, temp_sq17_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq18, temp_sq18_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq19, temp_sq19_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq20, temp_sq20_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq21, temp_sq21_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq22, temp_sq22_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq23, temp_sq23_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq24, temp_sq24_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq25, temp_sq25_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq26, temp_sq26_c), printf(fh, "~%"), flush_output(fh),
    writeCExprs1(temp_sq27, temp_sq27_c), printf(fh, "~%"), flush_output(fh)
  ),
  
  /* Print the temporary variable sums */
  for i : 1 thru NP do (
    printf(fh, "  temp[~a] =", (i-1)),
    for j : 1 thru N_temp_c_comps do (
      if (j = 1) then (
        printf(fh, " temp~a[~a]", j,(i-1))
      ) 
      else (
        printf(fh, " + temp~a[~a]", j,(i-1))
      )
    ),
    printf(fh, "; ~%")
  ),
  printf(fh, "~%"),
  flush_output(fh),

  /* Print the temporary variable (squares) sums */
  for i : 1 thru NP do (
    printf(fh, "  temp_sq[~a] =", i-1),
    for j : 1 thru N_temp_sq_c_comps do (
      if j = 1 then (
        printf(fh, " temp_sq~a[~a]", j, i-1)
      )
      else (
        printf(fh, " + temp_sq~a[~a]", j, i-1)
      )
    ),
    printf(fh, ";~%")
  ),
  printf(fh, "~%"),
  flush_output(fh),

  temp_e : doExpand1(temp, bP),
  tempSq_e : doExpand1(temp_sq, bP),

  /* Full pressure factor is gamma*GammaV^2 - 2*GammaV*(v . p) + ((v . p)^2 - 1)/gamma
     where v is the four-velocity GammaV*V_drift_i, p is the particle velocity, 
     and gamma = sqrt(1 + p^2) is the particle Lorentz boost factor. */
  p_fac1_c : calcInnerProdList(varsP, 1, bP, gamma_e*GammaVSq_e),
  writeCExprs1(p_fac1, p_fac1_c), printf(fh, "~%"), flush_output(fh),
  p_fac2_c : calcInnerProdList(varsP, 1, bP, - 2*GammaV_e*temp_e),
  writeCExprs1(p_fac2, p_fac2_c), printf(fh, "~%"), flush_output(fh),
  p_fac3_c : calcInnerProdList(varsP, 1, bP, gamma_inv_e*(tempSq_e - 1)),
  writeCExprs1(p_fac3, p_fac3_c), printf(fh, "~%"), flush_output(fh),

  /* Print the p_fac variable (squares) sums */
  for i : 1 thru NP do (
    printf(fh, "  p_fac[~a] =", i-1),
    for j : 1 thru N_p_fac_p_fac_c_comps do (
      if j = 1 then (
        printf(fh, " p_fac~a[~a]", j, i-1)
      )
      else (
        printf(fh, " + p_fac~a[~a]", j, i-1)
      )
    ),
    printf(fh, ";~%")
  ),
  printf(fh, "~%"),
  flush_output(fh),

  p_fac_e : doExpand1(p_fac, bP),
  fl : doExpand1(f, bP),
  
  Pressure : calcInnerProdList(varsP, p_fac_e, bC, fl),
  
  clst : [volFact],
  writeCIncrExprsCollect1(gr_pressure, volFact/vdim*Pressure, clst),

  printf(fh, "} ~%")
)$