/* Generate kernels for computing rest-frame pressure = n*T
   in the general relativistic Vlasov-Maxwell system of equations.
   The moment factor is: 
   gamma*GammaV^2 - 2*GammaV*(v . p) + 1/gamma*((v . p)^2 - 1) 
   where v is the spatial component of the bulk four-velocity: GammaV*V_drift_i, 
   GammaV is the bulk Lorentz boost factor: sqrt(1 + v^2), 
   p is the spatial component of the particle four-velocity, 
   and gamma = sqrt(1 + p^2) is the particle Lorentz boost factor. */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
fpprec : 24$ 

let(wx1^2, wx1_sq)$
let(wx2^2, wx2_sq)$
let(wx3^2, wx3_sq)$
let(dv1^2, dv1_sq)$
let(dv2^2, dv2_sq)$
let(dv3^2, dv3_sq)$

volExpr(cdim, vdim) := prod(dxv[cdim+i-1], i, 1, vdim)$
volExprTot(totDim) := prod(dxv[i-1], i, 1, totDim)$
pVsub : [x=vx,y=vy,z=vz]$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$
dv11 : [dv10, dv11, dv12]$

vTrans  : [vx*dv1/2.0+wx1, vy*dv2/2.0+wx2, vz*dv3/2.0+wx3]$
wTrans  : [wx1, wx2, wx3]$
dvTrans : [vx*dv1/2.0, vy*dv2/2.0, vz*dv3/2.0]$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

/* total fluid-frame pressure = n*T where n is the fluid-frame density */
calc_gr_pressure(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV,
   GammaV_e, Vx_e, Vy_e, Vz_e, GammaVSq_e, VxSq_e, VySq_e, VzSq_e,
   temp_c, temp_sq_c, tempNoZero, temp_e, tempSqNoZero, tempSq_e, 
   p_fac_c, p_facNoZero, 
   gamma_inv_e, gamma_e, p_fac_e, fl, Pressure, clst, ratprint],

  /* Suppress the rat messages */
  ratprint : false,

  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  if polyOrder=1 then ( 
    [varsV, bV] : loadBasis(basisFun, vdim, 2)
  ) 
  else (
    [varsV, bV] : loadBasis(basisFun, vdim, polyOrder)
  ), 
  bV : subst(pVsub, copylist(bV)),  
  varsV : subst(pVsub, copylist(varsV)), 
  NV : length(bV),

  /* Load basis of dimensionality requested. */
  if (basisFun="tensor") then (
    /* If we are using the tensor basis, just use the simple load command */
    [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),
    [varsP,bP] : loadBasis(basisFun, cdim+vdim, polyOrder),
    /* Do a variable substitution for the lower dimensional tensor basis functions
       to construct the correct set of variables for the subsequent operations */
    if (cdim+vdim = 2) then (
      varsSub : [y=vx],
      bP : subst(varsSub, copylist(bP)),  
      varsP : subst(varsSub, copylist(varsP))
    )
    else if (cdim+vdim = 3) then (
      varsSub : [y=vx, z=vy],
      bP : subst(varsSub, copylist(bP)),  
      varsP : subst(varsSub, copylist(varsP))
    )
    else if (cdim = 2 and vdim = 2) then (
      varsSub : [vx=y, vy=vx, vz=vy],
      bP : subst(varsSub, copylist(bP)),  
      varsP : subst(varsSub, copylist(varsP))
    )
  )
  else (
    /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
    [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),

    /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
       mean hybrid basis. */
    if polyOrder=1 then ( pOrderV : 2 )
  ),

  printf(fh, "#include <gkyl_canonical_pb_gr_Gamma_kernels.h> ~%"),
  printf(fh, "GKYL_CU_DH void ~a(const double *w, const double *dxv, const double *h_ij_inv, const double *u_i, const double *u_i_sq, const double *GammaV, const double *GammaV_sq, const double *f, double* GKYL_RESTRICT gr_pressure) ~%{ ~%", funcNm),
  printf(fh, "  // w:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv: Cell spacing.~%"),
  printf(fh, "  // h_ij_inv:         Input volume expansion of the inverse metric tensor.~%"),
  printf(fh, "  //                   [Hxx, Hxy, Hxz, ~%"),
  printf(fh, "  //                     - , Hyy, Hyz, ~%"),
  printf(fh, "  //                     - ,  - , Hzz] ~%"),
  printf(fh, "  // u_i:         Spatial components of bulk four-velocity = GammaV*V_drift. ~%"),
  printf(fh, "  // u_i_sq:      Squared spatial components of bulk four-velocity = u_i^2. ~%"),
  printf(fh, "  // GammaV:      Bulk four-velocity Lorentz factor = sqrt(1 + |u_i|^2). ~%"),
  printf(fh, "  // GammaV_sq:   Squared bulk four-velocity Lorentz factor = 1 + |u_i|^2. ~%"),
  printf(fh, "  // f:           Input distribution function.~%"),
  printf(fh, "  // gr_pressure: Output relativistic pressure.~%"),
  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),
  printf(fh, " ~%"),

  for i : 1 thru vdim do (
    /* New */
    printf(fh, "  const double wx~a = w[~a], dv~a = dxv[~a]; ~%", i, cdim+i-1, i, cdim+i-1),
    printf(fh, "  const double wx~a_sq = wx~a*wx~a, dv~a_sq = dv~a*dv~a; ~%", i, i, i, i, i, i),

    printf(fh, "  const double *V_~a = &u_i[~a]; ~%", i-1, NC*(i-1)),
    printf(fh, "  const double *V_~a_sq = &u_i_sq[~a]; ~%", i-1, NC*(i-1)),
    printf(fh, " ~%")
  ),
  printf(fh, "  double p_sq[~a] = {0.0};~%", NP),

  GammaV_e : doExpand1(GammaV, bC),
  Vx_e : doExpand1(V_0, bC),
  Vy_e : doExpand1(V_1, bC),
  Vz_e : doExpand1(V_2, bC),

  GammaVSq_e : doExpand1(GammaV_sq, bC),
  VxSq_e : doExpand1(V_0_sq, bC),
  VySq_e : doExpand1(V_1_sq, bC),
  VzSq_e : doExpand1(V_2_sq, bC),

  /* Compute at quad points h_ij_inv*/
  if (vdim = 1) then (
    printf(fh, "  const double *Hxx = &h_ij_inv[~a]; ~%", 0*NC)
  ),
  if (vdim = 2) then (
    printf(fh, "  const double *Hxx = &h_ij_inv[~a]; ~%", 0*NC),
    printf(fh, "  const double *Hxy = &h_ij_inv[~a]; ~%", 1*NC),
    printf(fh, "  const double *Hyy = &h_ij_inv[~a]; ~%", 2*NC)
  ),
  if (vdim = 3) then (
    printf(fh, "  const double *Hxx = &h_ij_inv[~a]; ~%", 0*NC),
    printf(fh, "  const double *Hxy = &h_ij_inv[~a]; ~%", 1*NC),
    printf(fh, "  const double *Hxz = &h_ij_inv[~a]; ~%", 2*NC),
    printf(fh, "  const double *Hyy = &h_ij_inv[~a]; ~%", 3*NC),
    printf(fh, "  const double *Hyz = &h_ij_inv[~a]; ~%", 4*NC),
    printf(fh, "  const double *Hzz = &h_ij_inv[~a]; ~%", 5*NC)
  ),
  printf(fh, "~%"),
  hxx_e : doExpand1(Hxx, bC),
  hxy_e : doExpand1(Hxy, bC),
  hxz_e : doExpand1(Hxz, bC),
  hyy_e : doExpand1(Hyy, bC),
  hyz_e : doExpand1(Hyz, bC),
  hzz_e : doExpand1(Hzz, bC),

  /* START GAMMA_INV Calc */ 
  Vpx : dv1/2.0*varsV[1] + wx1,
  if (vdim > 1) then (
    Vpy : dv2/2.0*varsV[2] + wx2
  ),
  if (vdim > 2) then (
    Vpz : dv3/2.0*varsV[3] + wx3
  ),
  if (vdim = 1) then (
    p_sq_c : calcInnerProdList(varsP, 1, bP, hxx_e*(Vpx)^2)
  ),
  if (vdim = 2) then (
    p_sq_c : calcInnerProdList(varsP, 1, bP, hxx_e*(Vpx)^2 + hyy_e*(Vpy)^2 + 2.0*hxy_e*Vpx*Vpy)
  ), 
  if (vdim = 3) then (
    p_sq_c : calcInnerProdList(varsP, 1, bP, hxx_e*(Vpx)^2 + hyy_e*(Vpy)^2 + hzz_e*(Vpz)^2 
              + 2.0*hxy_e*Vpx*Vpy + 2.0*hxz_e*Vpx*Vpz + 2.0*hyz_e*Vpy*Vpz)
  ), 
  p_sq_c : map(letsimp, p_sq_c),
  writeCExprs1(p_sq, p_sq_c), 
  printf(fh, "~%"), 
  p_sq_e : doExpand1(p_sq, bP),

  /* For p = 2, we use the nodes (-1, 0, 1) (Gauss-Lobatto nodes) */
  nodes_lobatto : getNodes(basisFun, cdim+vdim, polyOrder),
  num_nodes_lobatto : length(nodes_lobatto), 
  p_sq_nodes : expand(float(evAtNodes(p_sq_e,nodes_lobatto,varsP))),  
  printf(fh, "  double gamma_nodal[~a] = {0.0};~%", num_nodes_lobatto),
  printf(fh, "  double gamma_inv_nodal[~a] = {0.0};~%", num_nodes_lobatto),
  printf(fh, "  double gamma[~a] = {0.0};~%", NP),
  printf(fh, "  double gamma_inv[~a] = {0.0};~%", NP),
  printf(fh, "~%"), 
  for i : 1 thru num_nodes_lobatto do (
    printf(fh, "  gamma_nodal[~a] = sqrt(1.0 + ~a);~%", i-1, p_sq_nodes[i]), 
    printf(fh, "  gamma_inv_nodal[~a] = 1.0/gamma_nodal[~a];~%", i-1, i-1)
  ), 
  printf(fh, "~%"), 
  
  basis_nodal_lobatto : getVarsNodalBasisWithNodes(basisFun, cdim+vdim, polyOrder, varsP, nodes_lobatto), 
  gamma_nodal_e : doExpand1(gamma_nodal,basis_nodal_lobatto),
  gamma_inv_nodal_e : doExpand1(gamma_inv_nodal,basis_nodal_lobatto),

  gamma_c : calcInnerProdList(varsP, 1, bP, gamma_nodal_e), 
  gamma_inv_c : calcInnerProdList(varsP, 1, bP, gamma_inv_nodal_e), 
  writeCExprs1(gamma, gamma_c), 
  printf(fh, "~%"), 
  writeCExprs1(gamma_inv, gamma_inv_c), 
  printf(fh, "~%"), 

  /* Expand gamma and gamma_inv */
  gamma_inv_e : doExpand1(gamma_inv, bP),
  gamma_e : doExpand1(gamma, bP),

  /* END GAMMA, GAMMA_INV Calc */
  printf(fh, "  double temp[~a] = {0.0}; ~%", NP),
  printf(fh, "  double temp_sq[~a] = {0.0}; ~%", NP),
  printf(fh, "  double p_fac[~a] = {0.0}; ~%", NP),

  /* Maxima couldn't generate these kernels raw, here we introduce smaller
  temporary variables to break it down and make the writes easier*/

  if (vdim = 1) then (
    temp_c : calcInnerProdList(varsP, 1, bP, vTrans[1]*Vx_e),
    temp_sq_c : calcInnerProdList(varsP, 1, bP, vTrans[1]*vTrans[1]*VxSq_e)
  )
  else if (vdim = 2) then (
    temp_c : calcInnerProdList(varsP, 1, bP, vTrans[1]*Vx_e + vTrans[2]*Vy_e),
    temp_sq_c : calcInnerProdList(varsP, 1, bP,
              vTrans[1]*vTrans[1]*VxSq_e + vTrans[2]*vTrans[2]*VySq_e + 2*vTrans[1]*Vx_e*vTrans[2]*Vy_e)
  )
  else (
    temp_c : calcInnerProdList(varsP, 1, bP, vTrans[1]*Vx_e + vTrans[2]*Vy_e + vTrans[3]*Vz_e),
    temp_sq_c : calcInnerProdList(varsP, 1, bP,
              vTrans[1]*vTrans[1]*VxSq_e + vTrans[2]*vTrans[2]*VySq_e + vTrans[3]*vTrans[3]*VzSq_e
              + 2*vTrans[1]*Vx_e*vTrans[2]*Vy_e + 2*vTrans[1]*Vx_e*vTrans[3]*Vz_e + 2*vTrans[2]*Vy_e*vTrans[3]*Vz_e)
  ),
  temp_c : fullratsimp(temp_c),
  temp_sq_c : fullratsimp(temp_sq_c),
  writeCExprs1(temp, temp_c),
  printf(fh, "~%"),
  flush_output(fh),

  temp_sq_c : map(letsimp, temp_sq_c),
  writeCExprs1(temp_sq, temp_sq_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of v . p and (v . p)^2 which are empty. */
  tempNoZero : doMakeExprLst(temp_c, temp),
  temp_e     : doExpandLst(tempNoZero, bP),

  tempSqNoZero : doMakeExprLst(temp_sq_c, temp_sq),
  tempSq_e     : doExpandLst(tempSqNoZero, bP),

  /* Full pressure factor is gamma*GammaV^2 - 2*GammaV*(v . p) + ((v . p)^2 - 1)/gamma
     where v is the four-velocity GammaV*V_drift_i, p is the particle velocity, 
     and gamma = sqrt(1 + p^2) is the particle Lorentz boost factor. */
  p_fac_c : calcInnerProdList(varsP, 1, bP, gamma_e*GammaVSq_e - 2*GammaV_e*temp_e + gamma_inv_e*(tempSq_e - 1)),
  writeCExprs1(p_fac, p_fac_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Zero out components of p . V_drift which are empty. */
  p_facNoZero : doMakeExprLst(p_fac_c, p_fac),
  p_fac_e     : doExpandLst(p_facNoZero, bP),

  fl : doExpand1(f, bP),
  
  Pressure : calcInnerProdList(varsP, p_fac_e, bC, fl),
  
  clst : [volFact],
  writeCIncrExprsCollect1(gr_pressure, volFact/vdim*Pressure, clst),

  printf(fh, "} ~%")
)$