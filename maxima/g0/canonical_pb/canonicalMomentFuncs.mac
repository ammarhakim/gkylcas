/* Functions (called by moment-calc.mac) that compute specific 
moments that differ from their Vlasov counterparts for the can-pb
model. */

load("modal-basis");
load("out-scripts");
load("utilities")$
load("canonical_pb/canonicalUtils.mac")$
load(stringproc)$
fpprec : 24$

volExpr(cdim, vdim) := prod(dxv[cdim+i-1], i, 1, vdim)$
volExprTot(totDim) := prod(dxv[i-1], i, 1, totDim)$
pVsub : [x=vx,y=vy,z=vz]$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

slcn(lst, n) := makelist(lst[i], i, 1, n)$
slcn_v(lst, n) := makelist(lst[i], i, n+1, length(lst))$


/* Energy */
calcCanPBEnergy(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV, fl, M, clst],
  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),
  
  printf(fh, "GKYL_CU_DH void ~a_MEnergy_~ax~av_~a_p~a(const double *dxv, const double *hamil, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),

  printf(fh, "  const double volFact = ~a/~a; ~%", volExpr(cdim, vdim), 2^vdim),

  vid : vidx(cdim,vdim),
  for i : 1 thru vdim do (
    printf(fh, "  const double dv1~a = 2.0/dxv[~a]; ~%", i-1, vid[i])
  ),
  printf(fh, "~%"),
  
  hamill : doExpand1(hamil, bP),
  fl : doExpand1(f, bP),
  
  M : calcInnerProdList(varsP, hamill, bC, fl),
  
  clst : [volFact],
  writeCIncrExprsCollect1(out, volFact*M, clst),
  
  printf(fh, "} ~%")
)$

calcCanPBIntMDist(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC, bC, varsP, bP, varsV, bV, NC, NP, NV, fl, M0, Energy, M1i, clst, int],
  /* Load the specific desired basis, including the loading of the hybrid basis if p=1 */
  [varsC,bC,varsP,bP] : loadPhaseBasis(basisFun, cdim, vdim, polyOrder),
  /* Number of basis monomials. */
  NP : length(bP),
  NC : length(bC),
  pDim : length(varsP),
    
  printf(fh, "GKYL_CU_DH void ~a_int_mom_~ax~av_~a_p~a(const double *dxv, const double *hamil, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm, cdim, vdim, basisFun, polyOrder),
  printf(fh, "  const double volFact = ~a*~a; ~%", volExprTot(cdim+vdim), float(1/(2^(cdim+vdim))) ),
  for i : 1 thru vdim do (
    printf(fh, "  const double dv~a = dxv[~a]; ~%", i, cdim+i-1)
  ),

  fl : doExpand1(f, bP),

  M : [],

  /* Computes: integrated, Density, Momentum, and Energy */
  M0 : fullratsimp(innerProd(varsP, 1, 1, fl)),
  M  : endcons(M0,M),

  /* Grab C, V vars */
  varsP : listofvars(bP),
  varsV : slcn_v(varsP, cdim),
  varLabel : makelist(string(varsP[d]),d,1,pDim),

  /* Calculate phase space velocity alpha_d = {z[d], H} = dz[d]/dt. */
  for d : cdim + 1 thru pDim do (
    printf(fh, "  const double rd~a2 = 2.0/dxv[~a];~%", varLabel[d], d-1)
  ),
  printf(fh, "~%"),
  rdv2vec : makelist(eval_string(sconcat("rd",varLabel[i],"2")),i,cdim+1,pDim),
  p : varsV, 
  dp : rdv2vec,

 /* Calculate phase space velocity alpha_d = {z[d], H} = dz[d]/dt = dH/dp_d. */
  for dir : 1 thru vdim do (
    M1i : fullratsimp(innerProd(varsP, 1, dp[dir]*diff(doExpand1(hamil, bP), p[dir]), fl)),
    M  : endcons(M1i,M)
  ),

  Energy : fullratsimp(innerProd(varsP, 1, doExpand1(hamil, bP), fl)),
  M  : endcons(Energy, M),

  M : map(letsimp, M),
  clst : [volFact],
  writeCIncrExprsCollect1(out, volFact*M, clst),

  printf(fh, "} ~%")
)$

calcCanPBMoments(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block([],
  printf(fh, "#include <gkyl_mom_canonical_pb_kernels.h> ~%"),
  calcCanPBEnergy(fh, funcNm, cdim, vdim, basisFun, polyOrder),
  calcCanPBIntMDist(fh, funcNm, cdim, vdim, basisFun, polyOrder)
)$
