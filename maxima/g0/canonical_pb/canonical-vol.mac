load("modal-basis");
load("out-scripts");
load(stringproc)$
load("canonical_pb/canonicalUtils.mac")$
fpprec : 24$

varsV : [vx, vy, vz]$
varsC : [x, y, z]$
dxv : [dxv0, dxv1, dxv2, dxv3, dxv4, dxv5]$
dxdvInv : [dxdvInv0, dxdvInv1, dxdvInv2]$
dxInv : [dxInv0, dxInv1, dxInv2]$
dvInv : [dvInv0, dvInv1, dvInv2]$

cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

calcCanonicalPBVolUpdater(fh, funcNm, cdim, vdim, basisFun, pmax) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
load(modNm),
/* printf(fh, "#include <cmath> ~%"),
printf(fh, "#include <CanonicalModDecl.h> ~%"), */
for i : 1 thru pmax do (
  bP : basisP[i],
  bC : basisC[i],
  numC : length(bC),
  printf(fh, "double ~aP~a(const double *w, const double *dxv, const double *H, const double *f, double *out) ~%{ ~%", funcNm, i),
  printf(fh, "// w[NDIM]: Cell-center coordinates. dxv[NDIM]: Cell spacing. H/f: Input Hamiltonian/distribution function. out: Incremented output ~%"),
  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  for dir : 1 thru cdim do (
    pbfac[dir] : 4*dxdvInv[dir]
  ),
  volfac : 1,
  /*for d : 1 thru cdim+vdim do (
    volfac : volfac * dxv[d]/2
  ),*/
  for dir : 1 thru cdim do (
    printf(fh, "  double dxdvInv~a = 1.0/(dxv[~a]*dxv[~a]); ~%", dir-1, cid[dir], vid[dir])
  ),
  for dir : 1 thru cdim do (
    printf(fh, "  double dxInv~a = 1.0/dxv[~a]; ~%", dir-1, cid[dir])
  ),
  for dir : 1 thru vdim do (
    printf(fh, "  double dvInv~a = 1.0/dxv[~a]; ~%", dir-1, vid[dir])
  ),
  fl : doExpand1(f, bP),
  Hl : doExpand1(H, bP),
  pb : (pb : 0, for dir : 1 thru cdim do (
     pbBasis : pbfac[dir]*(PB(bP,Hl,varsC[dir],varsV[dir])),
     pb : pb + fullratsimp(volfac*calcInnerProdList(varsP, 1, pbBasis, fl))
     ),
  pb),
  printf(fh, "  return 0.0; ~%"),
  printf(fh, "} ~%")
));
