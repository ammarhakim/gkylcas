/*  Generate kernels for 
    1. u_i^2 (vdim components)
    2. GammaV^2 = 1 + |u_i|^2,
    3. GammaV = sqrt(1 + |u_i|^2),
    where u_i are the spatial components of the four-velocity GammaV*V_drift.
    Uses basis_exp_sq (obtain expansion of A^2 for a DG field A),
    basis_sqrt (obtain expansion of sqrt(A) for a DG field A) */

load("modal-basis");
load("out-scripts");
load("nodal_operations/nodal_functions")$
load(stringproc)$
fpprec : 24$

calc_gammaV_vars(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [bC, NC, VxSq_e, VySq_e, VzSq_e, denom_e],

  kill(varsC, basisC),

  /* Load basis of dimensionality requested. */
  [varsC,bC] : loadBasis(basisFun, cdim, polyOrder),

  NC  : length(bC),

  printf(fh, "#include <gkyl_canonical_pb_gr_Gamma_kernels.h> ~%"),
  printf(fh, "#include <gkyl_canonical_pb_kernels.h>  ~%"),
  printf(fh, "#include <gkyl_basis_~a_~ax_p~a_sqrt.h> ~%", basisFun, cdim, polyOrder),
  /* Function declaration with input/output variables. */
  printf(fh, "GKYL_CU_DH void ~a(const double *h_ij_inv, const double *u_i, double* GKYL_RESTRICT u_i_sq, double* GKYL_RESTRICT GammaV, double* GKYL_RESTRICT GammaV_sq) ~%{ ~%", funcNm),
  printf(fh, "  // h_ij_inv:         Input volume expansion of the inverse metric tensor.~%"),
  printf(fh, "  //                   [Hxx, Hxy, Hxz, ~%"),
  printf(fh, "  //                     - , Hyy, Hyz, ~%"),
  printf(fh, "  //                     - ,  - , Hzz] ~%"),
  printf(fh, "  // u_i:       Input spatial components of bulk four-velocity = GammaV*V_drift. ~%"),
  printf(fh, "  // u_i_sq:    Output squared spatial components of bulk four-velocity = sum_i u_i^2. ~%"),
  printf(fh, "  // GammaV:    Output bulk four-velocity Lorentz factor = sqrt(1 + |u_i|^2). ~%"),
  printf(fh, "  // GammaV_sq: Output squared bulk four-velocity Lorentz factor = 1 + |u_i|^2. ~%"),
  printf(fh, " ~%"),

  /* Get pointers to components of velocity (based on how many components are present). */
  dotFuncName : sconcat("canonical_pb_vars_util_",  cdim, "x", vdim, "v_", bName[bInd], "_p", polyOrder),
  printf(fh, "  ~a(h_ij_inv, u_i, u_i, u_i_sq); ~%", dotFuncName),
  printf(fh, "  double *V_sq = u_i_sq; ~%"),
  printf(fh, " ~%"),

  VSq_e : doExpand1(V_sq, bC),
  denom_e : calcInnerProdList(varsC, 1, bC, 1 + VSq_e),

  writeCExprs1(GammaV_sq, denom_e),
  printf(fh, "~%"),
  flush_output(fh),
  printf(fh, "  ~a_~ax_p~a_sqrt(GammaV_sq, GammaV); ~%", basisFun, cdim, polyOrder),

  printf(fh, "} ~%"),
  printf(fh, " ~%")
)$