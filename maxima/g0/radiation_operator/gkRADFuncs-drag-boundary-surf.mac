load("modal-basis")$
load("out-scripts");
load("nodal_operations/nodal_functions")$
load("recovery")$
load("utilities")$
load(stringproc)$

fpprec : 24$

/* This script generates the kernels for the surface term
   drag contribution from Lenard Bernstein operator. */

varsVAll : [vpar, mu]$
vidx1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

calcGkLBOBoundaryDragUpdateVPar(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,vSub,NP,NC,vid1,vv,surfVars,nuSum_e,nuUSum_e,surf_cvars,surf_vvars,
   bSurf,surfNodes,numNodes,alphaDr,alphaDrSurf_l_c,alphaDrSurf_r_c,alst_l,alst_r,
   alphaDrSurf_l_e,alphaDrSurf_r_e,alphaOrd_l_n,alphaOrd_r_n,surfNodesConfig,
   numNodesConfig,numNodesVel,i,rcoFac_l,rcoFac_r,j,fHatSurf_e,Ghat_c,glst1,Ghat_e,incr],

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bC),  NP : length(bP),

  pDim : cdim+vdim,
  vid1 : vidx1(cdim,vdim),
  vv   : varsVAll[1],
  surfVars : delete(vv,varsP),

  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *nI, const double *vnu, const double *fSkin, const double *fEdge,, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:     cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:   cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nI:        ion density. ~%"),
  printf(fh, "  // vnu:       2/pi*v*nu(v) field dg representation (v'(v||,mu) in notes~%", (1+1)*NC),
  printf(fh, "  // fSkin/Edge:    Distribution function in cells ~%"),
  printf(fh, "  // out:           Incremented distribution function in cell ~%"),
  printf(fh, "~%"),

  printf(fh, "  double rdv2 = 2.0/dxv[~a]; ~%", vid1[dir]),


  /* Expand the ion density and vsq*nu(v) in volume basis */
  nI_e : doExpand1(nI, bC),
  vnu_e : doExpand1(vsqnu, bP),
  
  /* Calculate the alpha-velocity due to drag. */
 /* alphaDr : 2.0*nuSum_e*((1/2)*dxv[vid1[2]]*vv+w[vid1[2]]),*/

  /* Create expansions of f_skin, f_edge on volume basis. */
  fSkin_e : doExpand1(fSkin, bP),
  fEdge_e : doExpand1(fEdge, bP),

  /* Surface basis. Equivalent to basis of one lower
     dimensionality without surface variable. */
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("gkhyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),
  
  /* Calculate alpha-the velocity due to drag in volume basis */
  alphaDr : nI_e*vnu_e,

  /* Project alphaDr evaluated at interior surface onto surf basis. */
  alphaDrSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=-1,alphaDr))),
  alphaDrSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=1,alphaDr))),
  alst_l          : doMakeExprLst(alphaDrSurf_l_c, alphaDrSurf),
  alst_r          : doMakeExprLst(alphaDrSurf_r_c, alphaDrSurf),
  alphaDrSurf_l_e : doExpand(alst_l, bSurf),
  alphaDrSurf_r_e : doExpand(alst_r, bSurf),

  printf(fh, "  double alphaDrSurf[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double Ghat[~a] = {0.0}; ~%", length(bSurf)),
  /* Declare variable with contribution from second integration by parts.
     This second integration by parts is only for the interior surface.
     The other contribution comes from the evaluation of the skin cell at 
     the correct interface (-1 for far left edge, +1 for far right edge). */
  printf(fh, "~%"),
  /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evauluated at +1 */
  /* In addition we need the drag term evaluated at +1 (so alphaDr evaluated on the right) */
  printf(fh, "  if (edge == -1) { ~%~%"),
  /* Write out drag term for far left edge boundary.
     Need alpha evaluated at +1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far left boundary, no drag term on -1 surface */
  writeCExprsNoExpand1(alphaDrSurf, alphaDrSurf_r_c),
  printf(fh, "~%"),

  /* Because nI*vsqnu is positive definite, need left edge value */
  /* Evaluate surface projection of Ghat = nI*vsqnu fSkin to update skin cell. */
  Ghat_c : calcInnerProdList(surfVars,alphaDrSurf_r_e,bSurf,subst(vv=-1, fSkin_e)),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
     on we can simply refer to Ghat. */
  glst1  : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpand(glst1, bSurf),
  
  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then
    writeCExprsNoExpand1(Ghat, Ghat_c)
  else
    writeCExprs1(Ghat, Ghat_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Increments to the far left skin cell (some dimensional factors missing). What dimensional factors? */
  incr : calcInnerProdList(surfVars, 1, subst(vv=1, bP), Ghat_e),
  
  /* Write out contribution. Where does the rdv2 come from?*/
  writeCIncrExprs1(out, rdv2*incr),

  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "~%  } else { ~%~%"),
  /* Write out drag term for far right edge boundary.
     Need alpha evaluated at -1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far right boundary, no drag term on +1 surface */
  writeCExprsNoExpand1(alphaDrSurf, alphaDrSurf_l_c),
  printf(fh, "~%"),

  /* Because vsqnu*nI is positive definite, need left edge value */
  /* Evaluate surface projection of Ghat = nI*vsqnu fSkin to update skin cell. */
  Ghat_c : calcInnerProdList(surfVars,alphaDrSurf_l_e,bSurf,subst(vv=-1, fEdge_e)),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
     on we can simply refer to Ghat. */
  glst1  : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpand(glst1, bSurf),
  
  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then
    writeCExprsNoExpand1(Ghat, Ghat_c)
  else
    writeCExprs1(Ghat, Ghat_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Increments to the far right edge skin cell (some dimensional factors missing). */
  incr : calcInnerProdList(surfVars, -1, subst(vv=-1, bP), Ghat_e),

  /* Write out contribution. */
  writeCIncrExprs1(out, rdv2*incr),
  printf(fh, "~%"),

  printf(fh, "  } ~%"),
  printf(fh, "~%"),

  printf(fh, "  return 0.;~%"),  /* Return CFL frequency in volume kernel. */
  printf(fh, "~%"),

  printf(fh, "} ~%")

);

calcGkLBOBoundaryDragUpdateMu(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,vSub,NP,NC,vid1,vv,surfVars,nuSum_e,
   bSurf,alphaDr,fSkin_e,fEdge_e,alphaDrSurf_l_c,alphaDrSurf_r_c,alst_l,alst_r,
   alphaDrSurf_l_e,alphaDrSurf_r_e,alphaOrd_l_n,alphaOrd_r_n,
   Ghat_c,glst1,Ghat_e,incr],

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bC),  NP : length(bP),

  pDim : cdim+vdim,
  vid1 : vidx1(cdim,vdim),
  vv   : varsVAll[2],
  surfVars : delete(vv,varsP),

  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *nI, const double *vsqnu const int edge, const double *fSkin, const double *fEdge, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:     cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:   cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nI:        ion density. ~%"),
  printf(fh, "  // vsqnu:       2/pi*v*nu(v) field dg representation (v''(v||,mu) in notes~%", (1+1)*NC),
  printf(fh, "  // fSkin/Edge:    Distribution function in cells ~%"),
  printf(fh, "  // out:           Incremented distribution function in cell ~%"),
  printf(fh, "~%"),

  printf(fh, "  double rdv2 = 2.0/dxv[~a]; ~%", vid1[dir]),

  /* Expand the ion density and vsq*nu(v) in volume basis */
  nI_e : doExpand1(nI, bC),
  vsqnu_e : doExpand1(vsqnu, bP),
  
  /* Calculate the alpha-velocity due to drag. */
 /* alphaDr : 2.0*nuSum_e*((1/2)*dxv[vid1[2]]*vv+w[vid1[2]]),*/

  /* Create expansions of f_skin, f_edge on volume basis. */
  fSkin_e : doExpand1(fSkin, bP),
  fEdge_e : doExpand1(fEdge, bP),

  /* Surface basis. Equivalent to basis of one lower
     dimensionality without surface variable. */
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    bSurf : basisFromVars("gkhyb",surfVars,polyOrder)
  ) else (
    bSurf : basisFromVars(basisFun,surfVars,polyOrder)
  ),
  
  /* Calculate alpha-the velocity due to drag in volume basis */
  alphaDr : nI_e*vsqnu_e,

  /* Project alphaDr evaluated at interior surface onto surf basis. */
  alphaDrSurf_l_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=-1,alphaDr))),
  alphaDrSurf_r_c : fullratsimp(innerProd(surfVars, 1, bSurf, subst(vv=1,alphaDr))),
  alst_l          : doMakeExprLst(alphaDrSurf_l_c, alphaDrSurf),
  alst_r          : doMakeExprLst(alphaDrSurf_r_c, alphaDrSurf),
  alphaDrSurf_l_e : doExpand(alst_l, bSurf),
  alphaDrSurf_r_e : doExpand(alst_r, bSurf),

  printf(fh, "  double alphaDrSurf[~a] = {0.0}; ~%", length(bSurf)),
  printf(fh, "  double Ghat[~a] = {0.0}; ~%", length(bSurf)),
  /* Declare variable with contribution from second integration by parts.
     This second integration by parts is only for the interior surface.
     The other contribution comes from the evaluation of the skin cell at 
     the correct interface (-1 for far left edge, +1 for far right edge). */
  printf(fh, "~%"),
  /* if edge == -1, we are doing the left edge boundary and the skin cell needs to be evauluated at +1 */
  /* In addition we need the drag term evaluated at +1 (so alphaDr evaluated on the right) */
  printf(fh, "  if (edge == -1) { ~%~%"),
  /* Write out drag term for far left edge boundary.
     Need alpha evaluated at +1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far left boundary, no drag term on -1 surface */
  writeCExprsNoExpand1(alphaDrSurf, alphaDrSurf_r_c),
  printf(fh, "~%"),

  /* Because nI*vsqnu is positive definite, need left edge value */
  /* Evaluate surface projection of Ghat = nI*vsqnu fSkin to update skin cell. */
  Ghat_c : calcInnerProdList(surfVars,alphaDrSurf_r_e,bSurf,subst(vv=-1, fSkin_e)),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
     on we can simply refer to Ghat. */
  glst1  : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpand(glst1, bSurf),
  
  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then
    writeCExprsNoExpand1(Ghat, Ghat_c)
  else
    writeCExprs1(Ghat, Ghat_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Increments to the far left skin cell (some dimensional factors missing). What dimensional factors? */
  incr : calcInnerProdList(surfVars, 1, subst(vv=1, bP), Ghat_e),
  
  /* Write out contribution. Where does the rdv2 come from?*/
  writeCIncrExprs1(out, rdv2*incr),

  /* otherwise edge == +1, we are doing the right edge boundary and the skin cell needs to be evauluated at -1 */
  printf(fh, "~%  } else { ~%~%"),
  /* Write out drag term for far right edge boundary.
     Need alpha evaluated at -1 for skin-edge interface.
     NOTE: zero-flux boundary conditions means for far right boundary, no drag term on +1 surface */
  writeCExprsNoExpand1(alphaDrSurf, alphaDrSurf_l_c),
  printf(fh, "~%"),

  /* Because vsqnu*nI is positive definite, need left edge value */
  /* Evaluate surface projection of Ghat = nI*vsqnu fSkin to update skin cell. */
  Ghat_c : calcInnerProdList(surfVars,alphaDrSurf_l_e,bSurf,subst(vv=-1, fEdge_e)),
  /* Ghat_c (coefficients of Ghat) is what gets written. From here
     on we can simply refer to Ghat. */
  glst1  : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpand(glst1, bSurf),
  
  /* Clever factorization is possible for polyOrder = 1, but for higher
     polynomial orders, factorization is *too* clever and can lead to 
     deeply nested parentheses, not ideal for compiler optimizations */
  if (polyOrder = 1) then
    writeCExprsNoExpand1(Ghat, Ghat_c)
  else
    writeCExprs1(Ghat, Ghat_c),
  printf(fh, "~%"),
  flush_output(fh),

  /* Increments to the far right edge skin cell (some dimensional factors missing). */
  incr : calcInnerProdList(surfVars, -1, subst(vv=-1, bP), Ghat_e),

  /* Write out contribution. */
  writeCIncrExprs1(out, rdv2*incr),
  printf(fh, "~%"),

  printf(fh, "  } ~%"),
  printf(fh, "~%"),

  printf(fh, "  return 0.;~%"),  /* Return CFL frequency in volume kernel. */
  printf(fh, "~%"),

  printf(fh, "} ~%")
);
