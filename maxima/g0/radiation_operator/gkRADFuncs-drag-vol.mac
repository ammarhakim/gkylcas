load("modal-basis")$
load("out-scripts")$
load(stringproc)$
fpprec : 24$

/*This script generates the kernels for the drag volume
	   kernel of the radiation operator for the
	   gyrokinetic equation.*/
varsVAll : [vpar, mu]$
vIndex1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/*Helper functions for expanding (in basis functions) a quantity that should be sparse. */
doMakeExprLstOff(vals, S, off)  := makelist(if vals[i] # 0 then S[off+i-1] else 0, i, 1, length(vals))$

calcGkRADDragVolUpdater(fh, funcNm, cdim, vdim, basisFun, polyOrder) := block(
  [varsC,bC,varsP,bP,NP,NC,pOrderVpar,zr,vidx1,dir,f_e,nuSum_e,nuUSum_e,
   incrDrag,cflFreq_mid,alphaDrag_e,expr,i,alphaDrag_NoZero,alphaDrag_NoZero_e],

  printf(fh, "#include <gkyl_rad_gyrokinetic_kernels.h> ~%"),

  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder),
  NC : length(bC),  NP : length(bP),

  /* Identify polyOrder in velocity space as p=2 for p=1 since we force p=1 to
     mean hybrid basis. */
  pOrderVpar : polyOrder,
  if polyOrder=1 then ( pOrderVpar : 2 ),

  /* Specify a point to evaluate alpha at for use in computing CFL */
  /* Here we choose to evaluate things in the middle of the cell, where
     coordinates = 0. */
  zr : makelist(varsP[d]=0, d, 1, length(varsP)),

  vidx1 : vIndex1(cdim,vdim),
  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *nI, const double *vnu, const double *vsqnu, const double *f, double* GKYL_RESTRICT out) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]: cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]: cell spacing. ~%", cdim+vdim),
  printf(fh, "  // nI: atomic density ~%"),
  printf(fh, "  // vnu: 2/pi*v*nu(v) dg field representation (v'(v||,mu) in notes) ~%"),
  printf(fh, "  // vsqnu: sqrt(mu*me/2B)*v^2*nu(v) dg field representation (v''(v||,mu) in notes) ~%"),
  printf(fh, "  // f: input distribution function.~%"),
  printf(fh, "  // out: incremented output ~%"),
  printf(fh, "~%"),

  printf(fh, "  double rdv2[~a]; ~%", vdim),
  for dir : 1 thru vdim do (
    printf(fh, "  rdv2[~a] = 2.0/dxv[~a]; ~%", dir-1, vidx1[dir])
  ),
  printf(fh, "~%"),

  /* Expand distribution function f in phase basis.            */
  f_e : doExpand1(f, bP),
  /*Expand nu'(v) and nu''(v) in phase basis.*/
  vnu_e : doExpand1(vnu, bP),
  vsqnu_e : doExpand1(vsqnu, bP),
  /* Expand nI in configuration basis.*/
  nI_e : doExpand1(nI, bC),

  incrDrag : 0,
  cflFreq_mid : makelist(0, i, 1, vdim),
  
  vparAlphaDrag_c : calcInnerProdList(varsP, 1, bP, nI_e*vnu_e*rdv2[0]),
  alst        : doMakeExprLst(vparAlphaDrag_c, alphaDrag),
  vparAlphaDrag_e : doExpand(alst, bP),
  
  printf(fh, "  double alphaDrag[~a] = {0,0}; ~%", length(bP)),
  writeCExprs1(alphaDrag, vparAlphaDrag_c),
  printf(fh, "~%"),

  incrDrag : incrDrag + calcInnerProdList(varsP, 1, diff(bP,varsVAll[1]),vparAlphaDrag_e*f_e),

  cflFreq_mid[1] : gcfac(float(expand(subst(zr,(2*pOrderVpar+1)*0.5*vparAlphaDrag_e)))),

  /* mu contribution */
  if vdim = 2 then (
    muAlphaDrag_c : calcInnerProdList(varsP, 1, bP, nI_e*vsqnu_e*rdv2[1]),
    alst        : doMakeExprLst(muAlphaDrag_c, alphaDrag),
    muAlphaDrag_e : doExpand(alst, bP),
    
    writeCIncrExprs1(alphaDrag, muAlphaDrag_c),
    printf(fh, "~%"),
    
    incrDrag : incrDrag + calcInnerProdList(varsP, 1, diff(bP,varsVAll[2]),muAlphaDrag_e*f_e)
  ),

  /* Write out first attempts to simplify the radicals with radcan, e.g.
     force sqrt(3)*sqrt(5) = sqrt(15). */
  vDrag_sim : radcan(incrDrag),
 
  writeCExprsCollect1c(vDrag_sim),
  if vdim = 1 then (
      printf(fh, "~%"), 
      printf(fh, "  return fabs(~a); ~%", cflFreq_mid[1])
  ) else if vdim = 2 then (
      cflFreq_mid[2] : gcfac(float(expand(subst(zr,(2*polyOrder+1)*0.5*muAlphaDrag_e)))),
      printf(fh, "~%"),
      printf(fh, "  return fabs(~a)+fabs(~a); ~%", cflFreq_mid[1], cflFreq_mid[2])
  ),
  

  printf(fh, "~%"),
  printf(fh, "} ~%")
);