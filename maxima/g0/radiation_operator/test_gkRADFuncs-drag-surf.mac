load("modal-basis")$
load("out-scripts");
load("nodal_operations/nodal_functions")$
load("utilities")$
load(stringproc)$
fpprec : 24$

/* This script generates the kernels for the surface term
   drag contribution from Lenard Bernstein operator. */

varsVAll : [vpar, mu]$
vidx1(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$


/* For Testing */
fh : openw("test_surf.c");
funcNm : "funcName";
cdim : 3;
vdim : 2;
basisFun : "ser";
polyOrder : 1;
/* End Test vars */

  
  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder);
  NC : length(bC);  NP : length(bP);

  pDim     : cdim+vdim;
  vid1     : vidx1(cdim,vdim);
  vv       : varsVAll[1];
  surfVars : delete(vv,varsP);

  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *bmag_inv, const double *nI, const double *vnu, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm);
  printf(fh, "  // w[~a]:     cell-center coordinates. ~%", cdim+vdim);
  printf(fh, "  // dxv[~a]:   cell spacing. ~%", cdim+vdim);
  printf(fh, "  // bmag_inv:  1/(magnetic field magnitude). ~%");
  printf(fh, "  // nI:        ion density. ~%");
  printf(fh, "  // vnu:       v*nu(v) field dg representation. ~%");
  printf(fh, "  // fl/fc/fr:  distribution function in cells ~%");
  printf(fh, "  // out:       incremented distribution function in cell ~%");
  printf(fh, "~%");

  printf(fh, "  double rdv2 = 2.0/dxv[~a]; ~%", vid1[1]);
  printf(fh, "~%");

  /* Surface basis (equivalent to basis of one lower
     dimensionality without surface variable) */
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    bSurf     : basisFromVars("gkhyb",surfVars,polyOrder)
  ) else (
    bSurf     : basisFromVars(basisFun,surfVars,polyOrder)
  );

  /* Expand the ion density in configuration basis. */
  ni_e : doExpand1(nI, bC);
  disp("expanded nI");
  /* Expand v*nu(v) in surface basis*/
  vnu_e : doExpand1(vnu, bSurf);
  disp("expanded vnu");
  /* Create expansions of f_left, f_center, and f_right on surface basis. */
  fl_e : doExpand1(fl, bSurf);
  fc_e : doExpand1(fc, bSurf);
  fr_e : doExpand1(fr, bSurf);
  disp("expanded fs");
  /* Calculate integrand */
  vpar_integrand_l : -2/%pi*nI_e*vnu_e*fl_e; /* Don't think I need, since vnu*nI>=0*/
  vpar_integrand_c : 2/%pi*nI_e*vnu_e*fc_e;
  vpar_integrand_r : 2/%pi*nI_e*vnu_e*fr_e;
  disp("calculated integrands");
  /* Drag on left side of interface */
  vDrag_l : 0;
  vDrag_l : vDrag_l + subst(a0=0,calcInnerProdList(surfVars, 1, bSurf, vpar_integrand_c));
  disp("Calculated vdrag(l)");
  /* Drag on right side of interface */
  vDrag_r : 0;
  vDrag_r : vDrag_r + subst(a0=0,calcInnerProdList(surfVars, 1, bSurf, vpar_integrand_r));
  disp("Calculated vdrag(r)");
  
  writeCExprsCollect1c(radcan(vDrag_r-vDrag_l));
  disp("Wrote to c");
  printf(fh, "  return 0.;~%");  /* Return CFL frequency in volume kernel. */
  printf(fh, "~%");
  
  printf(fh, "} ~%");


  /* Load basis of dimensionality requested. */
  [varsC,bC,varsP,bP,vSub] : loadGkBasis(basisFun, cdim, vdim, polyOrder);
  NC : length(bC);  NP : length(bP);

  pDim     : cdim+vdim;
  vid1     : vidx1(cdim,vdim);
  vv       : varsVAll[2];
  surfVars : delete(vv,varsP);

  printf(fh, "GKYL_CU_DH double ~a(const double *w, const double *dxv, const double *bmag_inv, const double *nI, const double *vnu, const double *fl, const double *fc, const double *fr, double* GKYL_RESTRICT out) ~%{ ~%", funcNm);
  printf(fh, "  // w[~a]:     cell-center coordinates. ~%", cdim+vdim);
  printf(fh, "  // dxv[~a]:   cell spacing. ~%", cdim+vdim);
  printf(fh, "  // bmag_inv:  1/(magnetic field magnitude). ~%");
  printf(fh, "  // nI:        ion density. ~%");
  printf(fh, "  // vnu:       v*nu(v) field dg representation. ~%");
  printf(fh, "  // fl/fc/fr:  distribution function in cells ~%");
  printf(fh, "  // out:       incremented distribution function in cell ~%");
  printf(fh, "~%");

  printf(fh, "  double rdv2 = 2.0/dxv[~a]; ~%", vid1[2]);
  printf(fh, "~%");

  /* Surface basis (equivalent to basis of one lower
     dimensionality without surface variable) */
  if polyOrder = 1 then (  /* Force p=1 to use hybrid basis. */
    bSurf     : basisFromVars("gkhyb",surfVars,polyOrder)
  ) else (
    bSurf     : basisFromVars(basisFun,surfVars,polyOrder)
  );

  /* Expand the ion density in configuration basis. */
  nI_e : doExpand1(nI, bC);
  disp("expanded nI");
  /* Expand v*nu(v) in surface basis*/
  vnu_e : doExpand1(vnu, bSurf);
  disp("expanded vnu");
  /* Create expansions of f_left, f_center, and f_right on surface basis. */
  fl_e : doExpand1(fl, bSurf);
  fc_e : doExpand1(fc, bSurf);
  fr_e : doExpand1(fr, bSurf);
  disp("expanded fs");
  /* Calculate integrand */
  mu_c : w[vidx1[2]]+0.5*dxv[vidx1[2]]*varsVAll[2];
  mu_integrand_l : (mu_c*GKYL_ELECTRON_MASS*bmag_inv/2)^(1/2)*nI_e*vnu_e*f_le; /* Don't think I need, since vnu*nI>=0*/
  mu_integrand_c : (mu_c*GKYL_ELECTRON_MASS*bmag_inv/2)^(1/2)*nI_e*vnu_e*f_ce;
  mu_integrand_r : (mu_c*GKYL_ELECTRON_MASS*bmag_inv/2)^(1/2)*nI_e*vnu_e*f_re;
  disp("calculated integrands");
  /* Drag on left side of interface */
  muDrag_l : 0;
  muDrag_l : muDrag_l + subst(a0=NP, calcInnerProdList(surfVars, 1, bSurf, mu_integrand_c));
  disp("Calculated mudrag(l)");
  /* Drag on right side of interface */
  muDrag_r : 0;
  muDrag_r : muDrag_r + subst(a0=NP,calcInnerProdList(surfVars, 1, bSurf, mu_integrand_r));
  disp("Calculated mudrag(r)");
  
  writeCExprsCollect1c(radcan(muDrag_r-muDrag_l));
  disp("Wrote to c");
  printf(fh, "  return 0.;~%");  /* Return CFL frequency in volume kernel. */
  printf(fh, "~%");
  
  printf(fh, "} ~%");


  close(fh);
