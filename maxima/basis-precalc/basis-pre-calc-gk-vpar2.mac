load("basis-precalc/basis-pre-calc");

/* Special basis functions that retain vpar^2 in the expansion */

vars : [x,y,z,vx,vy,vz]$

makevarsC(cdim) := makelist(vars[i],i,cdim)$
makevarsP(cdim,vdim) := append(makelist(vars[i],i,cdim), makelist(vars[i],i,4,3+vdim))$

/* Compute and write hybrid basis to file */
writeHybBasisToFile(cdim, vdim, fname) := block([varsC, varsP, basisC, basisP],
  varsC : makevarsC(cdim),
  varsP : makevarsP(cdim,vdim),
  basisC : [ gsOrthoNorm(varsC, makeSerendipBasis(varsC, 1)) ],
  basisP : [ gsOrthoNorm(varsP, append(
      makeSerendipBasis(varsP, 1), vx^2*makeSerendipBasis(delete(vx, varsP), 1)
      )
    )
  ],
  save(fname, varsC, varsP, basisC, basisP)
  )$

/* Compute list of monomials */
calcHybMonoList(cdim, vdim) := block([varsC, varsP, basisC, basisP],
  varsC : makevarsC(cdim),
  varsP : makevarsP(cdim,vdim),
  return (append(makeSerendipBasis(varsP, 1),
      vx^2*makeSerendipBasis(delete(vx, varsP), 1)
      )
    )
)$  

writeHybBasisToFile(1, 1, "~/max-out/basisHybrid1x1v.lisp")$
writeHybBasisToFile(1, 2, "~/max-out/basisHybrid1x2v.lisp")$
writeHybBasisToFile(2, 2, "~/max-out/basisHybrid2x2v.lisp")$
writeHybBasisToFile(3, 2, "~/max-out/basisHybrid3x2v.lisp")$

fh : openw("~/max-out/mono-list")$

printf(fh, "~a", calcHybMonoList(1, 1))$
printf(fh, "~a", calcHybMonoList(1, 2))$
printf(fh, "~a", calcHybMonoList(2, 2))$
printf(fh, "~a", calcHybMonoList(3, 2))$

close(fh)$



