load("modal-basis") $
assume(dv[0]>0, dv[1]>0, dv[2]>0) $

/* A helper function to shift basis functions in only one direction.
Example: etaDir(y, dy/2, dy, basis) */  
etaDir(dir, xc, dx, basis) := subst(td=dir, subst(dir=2*(td-xc)/dx, basis)) $

/* A helper function to shift basis functions in all directions together
Example: eta([x, y], [dx/2, -dy/2], [dx, dy], basis( */
eta(xc, dx, basis) := block([out, tx, ty, tz],
  out : subst(tx=x, subst(x=2*(tx-xc[1])/dx[1], basis)),
  if length(dx) > 1 then ( out : subst(ty=y, subst(y=2*(ty-xc[2])/dx[2], out)) ),
  if length(dx) > 2 then ( out : subst(tz=z, subst(z=2*(tz-xc[3])/dx[3], out)) ),
  return(out)
  ) $

/* A simple helper function to convert x, y, or z to indices 1, 2, or 3 respectively */
getDirIdx(dir, numDims) := block([],
  if numDims = 1 then return(1),
  if dir = x then return(1),
  if dir = y then return(2),
  if dir = z then return(3)
  ) $

getBasis(name, polyOrder) := block(
  [varsC, basisC, basisConstant],
  load(name),
  if polyOrder > 0 then (
    return(basisC[polyOrder])
    )
  else (
    return([basisC[1][1]])
    )
  ) $


/* Returns recovered polynomial across two neigbouring cells in terms of expansion coefficients at the minus side (qLo) and the plus side (qUp).
Inputs:
  dir : direction of the recovery (x, y, or z)
  dx : a list of cell sizes; if the specified length is greater than zero, the no-recovered direction are backsubstitued to the output
  polyOrder : polynomial order of the inputs
  qLo : expansion coeficients of the recovered quatity at the minus side
  qUp : expansion coeficients of the recovered quatity at the plus side
Outputs:
  a polynomial in terms of qLo and qUp
*/
getRecov2CellGen(dir, dx, polyOrder, qLo, qUp) := block(
  [numDims, dIdx, basisC, basis1D, baLo1D, baUp1D, N, rExp, recEqList, rSol, rSub, projSubList, basisND, xc, baLoND, baUpND, dimProjM, dimProjP],
  numDims : length(dx),
  dIdx : getDirIdx(dir, numDims), /* Converting x, y, or z into 1, 2, or 3 */
  basisC : getBasis("basis-precalc/basisSer1x", polyOrder), /* Loading basis functions */
  basis1D : subst(x=dir, basisC),
  baLo1D : etaDir(dir, -dx[dIdx]/2, dx[dIdx], basis1D),
  baUp1D : etaDir(dir, dx[dIdx]/2, dx[dIdx], basis1D),
  
  /* Forming and solving the equation system */
  N : polyOrder + 1, /* Number of degrees of freedom */
  rExp : doExpand(r, makelist(dir^i, i, 0, 2*N-1)), /* Recovery polynomial */
  recEqList : append( /* Equations frm the weak equality */
    calcInnerProdListGen([dir], [[-dx[dIdx], 0]], 1, baLo1D, rExp-doExpand(qLo1D, baLo1D)),
    calcInnerProdListGen([dir], [[0, dx[dIdx]]], 1, baUp1D, rExp-doExpand(qUp1D, baUp1D))
    ),
  rSol : linsolve(recEqList, makelist(r[i], i, 1, 2*N)),
  rSub : fullratsimp(subst(rSol, rExp)),
  
  /* Backsubstitute the non-recovered directtions if needed */
  if numDims > 1 then (
    basisC : getBasis(sconcat("basis-precalc/basisSer", numDims, "x"), polyOrder), /* Loading higher dimensional basis */
    basisND : basisC,
    xc : [0, 0, 0],
    xc[dIdx] : -dx[dIdx]/2,
    baLoND : eta(xc, dx, basisND), /* Shifting the multi-D basis in only one direction */
    xc[dIdx] : dx[dIdx]/2,
    baUpND : eta(xc, dx, basisND), /* Shifting the multi-D basis in only one direction */
    dimProjM : calcInnerProdListGen([dir], [[-dx[dIdx], 0]], 1, baLo1D, doExpand(qLo, baLoND)),
    dimProjP : calcInnerProdListGen([dir], [[0, dx[dIdx]]], 1, baUp1D, doExpand(qUp, baUpND)),
    projSubList : append ( /* Substitution list fot the backprojection */
      makelist(qLo1D[i]=dimProjM[i], i, 1, length(basis1D)),
      makelist(qUp1D[i]=dimProjP[i], i, 1, length(basis1D))
      )
    )
  else (
    projSubList : append (
      makelist(qLo1D[i]=qLo[i], i, 1, length(basis1D)),
      makelist(qUp1D[i]=qUp[i], i, 1, length(basis1D))
      )
    ),

  return(subst(projSubList, rSub))
  ) $


/* Returns recovered polynomial across three cells in terms of expansion coefficients in the lower cell (qLo), center (qCe), and the upper cell (qUp). Alternatively, qLo and qUp can be used as prescribed Dirichlet or Neumann boundary conditions when [bc] parameter is set (see bellow).
This is done in two stages. In the first stage, getRecov2CellGen is used to calculate recovery polynomials at the two pairs of cells. These are then evaluated at the interfaces (only values for C=0; values and first derivatives for C=1). This addition information is then used to recover higher order solution in the central cell. 
Inputs:
  dir : direction of the recovery (x, y, or z)
  dx : a list of cell sizes; if the specified length is greater than zero, the no-recovered direction are backsubstitued to the output
  polyOrder : polynomial order of the inputs
  C : continuity of the recovered solution (either 0 or 1)
  qLo : expansion coeficients of the recovered quatity in the lower cell (or a prescribed BC)
  qCe : expansion coeficients of the recovered quatity in the central cell
  qUp : expansion coeficients of the recovered quatity in the upper cell (or a prescribed BC)
  [bc] : (optional) an optional argument that enables setting boundary conditions; by default, it is set to [0, 0] which uses the 3-cell recovery as explained above; alternatively, 0 can be changed to 1 (Dirichlet) or 2 (Neumann), in that case the recovery in the first step is not performed and the value of qLo (or qUp) is instead used in the second step as the prescribed value or slope at the interface; all the combinations are possible, e.g., [1, 2]; not that when C is set to 1, applying the BC decreases the recover polynomial order as only a value or a slope is imposed at the bounday
Outputs:
  a polynomial in terms of qLo, qCe, and qUp
*/
getRecov3CellGen(dir, dx, polyOrder, C, qLo, qCe, qUp, [bc]) := block(
  [numDims, dIdx, basisC, basis1D, baC1D, N, rExp, rLo, rUp, recEqList, rSol, rSub, projSubList,baLo1D,baUp1D,basisND,xc,baLoND,baCND,baUpND,dimProjM,dimProjC,dimProjP, bcLo, bcUp],
  if length(bc) = 0 then (
    bcLo : [0,0],
    bcUp : [0,0]
    ) else (
    if length(bc) = 1 then (
      if bc[1][1]=0 then bcLo : [0,0],
      if bc[1][1]=1 then bcLo : [1,0],
      if bc[1][1]=2 then bcLo : [0,1],
      if bc[1][2]=0 then bcUp : [0,0],
      if bc[1][2]=1 then bcUp : [1,0],
      if bc[1][2]=2 then bcUp : [0,1]
      ) else ( 
      bcLo : bc[1],
      bcUp : bc[2]
      )
    ),
  numDims : length(dx),
  dIdx : getDirIdx(dir, numDims),
  basisC : getBasis("basis-precalc/basisSer1x", polyOrder),
  basis1D : subst(x=dir, basisC),
  baC1D : etaDir(dir, 0, dx[dIdx], basis1D),
  
  N : polyOrder + 3,
  for i : 1 thru C do (
    /* Increase the final namuber of degrees of freedom for C_1 continuity */
    if bcLo[1]=0 and bcLo[2]=0 then N : N + 1,
    if bcUp[1]=0 and bcUp[2]=0 then N : N + 1
    ),
  
  /* Forming and solving the equation system */
  rExp : doExpand(r, makelist(dir^i, i, 0, N-1)), /* Final recovery polynomial */
  recEqList : calcInnerProdListGen([dir], [[-dx[dIdx]/2, dx[dIdx]/2]], 1, baC1D, rExp-doExpand(qCe1D, baC1D)), /* New solution is weakly equal to the original representation */
  if bcLo[1]=0 and bcLo[2]=0 then (
    for i : 0 thru C do (
      rLo : getRecov2CellGen(dir, [dx[dIdx]], polyOrder, qLo1D, qCe1D),
      recEqList : append(
        recEqList,
        [subst(dir=0, diff(rLo, dir, i)) - subst(dir=-dx[dIdx]/2, diff(rExp, dir, i))]
        )
      )
    ) else (
    recEqList : append(
      recEqList,
      [qLo - bcLo[1]*subst(dir=-dx[dIdx]/2, rExp) - bcLo[2]*subst(dir=-dx[dIdx]/2, diff(rExp, dir))]
      )
    ),
  if bcUp[1]=0 and bcUp[2]=0 then (
    for i : 0 thru C do (
      rUp : getRecov2CellGen(dir, [dx[dIdx]], polyOrder, qCe1D, qUp1D),
      recEqList : append(
        recEqList,
        [subst(dir=0, diff(rUp, dir, i)) - subst(dir=dx[dIdx]/2, diff(rExp, dir, i))]
        )
      )
    ) else (
    recEqList : append(
      recEqList,
      [qUp - bcUp[1]*subst(dir=dx[dIdx]/2, rExp) - bcUp[2]*subst(dir=dx[dIdx]/2, diff(rExp, dir))]
      )
    ),
  rSol : linsolve(recEqList, makelist(r[i], i, 1, N)),
  rSub : fullratsimp(subst(rSol, rExp)),
  
  /* Backsubstitute the non-recovered directtions if needed */
  if numDims > 1 then (
    baLo1D : etaDir(dir, -dx[dIdx], dx[dIdx], basis1D),
    baUp1D : etaDir(dir, dx[dIdx], dx[dIdx], basis1D),
    basisC : getBasis(sconcat("basis-precalc/basisSer", numDims, "x"), polyOrder),
    basisND : basisC,
    xc : [0, 0, 0],
    xc[dIdx] : -dx[dIdx],
    baLoND : eta(xc, dx, basisND),
    xc[dIdx] : 0,
    baCND : eta(xc, dx, basisND),
    xc[dIdx] : dx[dIdx],
    baUpND : eta(xc, dx, basisND),
    
    dimProjC : calcInnerProdListGen([dir], [[-dx[dIdx]/2, dx[dIdx]/2]], 1, baC1D, doExpand(qCe, baCND)),
    projSubList : makelist(qCe1D[i]=dimProjC[i], i, 1, length(basis1D)),
    if bcLo[1]=0 and bcLo[2]=0 then (
      dimProjM : calcInnerProdListGen([dir], [[-3*dx[dIdx]/2, -dx[dIdx]/2]], 1, baLo1D, doExpand(qLo, baLoND)),
      projSubList : append (
        projSubList,
        makelist(qLo1D[i]=dimProjM[i], i, 1, length(basis1D))
        )
      ),
    if bcUp[1]=0 and bcUp[2]=0 then (
      dimProjP : calcInnerProdListGen([dir], [[dx[dIdx]/2, 3*dx[dIdx]/2]], 1, baUp1D, doExpand(qUp, baUpND)),
      projSubList : append (
        projSubList,
        makelist(qUp1D[i]=dimProjP[i], i, 1, length(basis1D))
        )
      )
    )
  else (
    projSubList : makelist(qCe1D[i]=qCe[i], i, 1, length(basis1D)),
    if bcLo[1]=0 and bcLo[2]=0 then (
      projSubList : append(
        projSubList,
        makelist(qLo1D[i]=qLo[i], i, 1, length(basis1D))
        )
      ),
    if bcUp[1]=0 and bcUp[2]=0 then (
      projSubList : append(
        projSubList,
        makelist(qUp1D[i]=qUp[i], i, 1, length(basis1D))
        )
      )
    ),
  
  return(subst(projSubList, rSub))
  ) $



getRecov6CellGen(dir, dx, polyOrder, C, qLL, qLU, qCL, qCU, qUL, qUU) := block(
  [perpDir, perpDirIdx, rLo, rCe, rUp, basisC, baC, rLoCoef, rCeCoef, rUpCoef, r],
  if dir = x then perpDir : y else perpDir : x, /* Hard-coded; needs generalization for 3D */
  numDims : length(dx),
  perpDirIdx : getDirIdx(perpDir, numDims),

  rLo : getRecov2CellGen(dir, dx, polyOrder, qLL, qLU),
  rCe : getRecov2CellGen(dir, dx, polyOrder, qCL, qCU),
  rUp : getRecov2CellGen(dir, dx, polyOrder, qUL, qUU),
  
  basisC : subst(x=perpDir, getBasis("basis-precalc/basisSer1x", polyOrder)),
  baC : etaDir(perpDir, 0, dx[perpDirIdx], basisC),
  rLoCoef : calcInnerProdListGen([perpDir],
    [[-dx[perpDirIdx]/2, dx[perpDirIdx]/2]],
    1, baC, subst(dir=0, rLo)),
  rCeCoef : calcInnerProdListGen([perpDir],
    [[-dx[perpDirIdx]/2, dx[perpDirIdx]/2]],
    1, baC, subst(dir=0, rCe)),
  rUpCoef : calcInnerProdListGen([perpDir],
    [[-dx[perpDirIdx]/2, dx[perpDirIdx]/2]],
    1, baC, subst(dir=0, rUp)),
  
  r : getRecov3CellGen(perpDir, [dx[perpDirIdx]], polyOrder, C,
    rLoCoef, rCeCoef, rUpCoef),  

  return(r)
  ) $
