/* Generate kernels for CartFieldInterpolate updater. */

load("modal-basis");
load("out-scripts");
fpprec : 24$

writeCIncrExprs1sub(lhs, rhs, sublist) := block([expr],
  /* Perform some substitutions before printing. No expand. */
  expr : float(rhs),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      ep     : string(expr[i]),
      outStr : ssubst(sublist[1][2],sublist[1][1],ep),
      for s : 2 thru length(sublist) do (
        outStr : ssubst(sublist[s][2],sublist[s][1],outStr)
      ),
      printf(fh, "  ~a += ~a; ~%", lhs[i-1], outStr)
    )
  )
)$

calcInterpolationOp(fh, funcNm, dim, basisFun, pMax) := block([],
  /* Interpolation operator transfering a field defined on one grid to
     another grid. This kernel is called to compute contribution from a single
     origin-grid cell, to a single target-grid cell. */
  kill(varsC, varsP, basisC, basisP),

  if (dim < 4) then (
    load(sconcat("basis-precalc/basis", basisFun, dim, "x")),
    vars  : varsC
  ) else (
    load(sconcat("basis-precalc/basis", basisFun, dim-3, "x3v")),
    vars  : varsP
  ),

  for polyOrder : 1 thru pMax do (

    if (dim < 4) then (
      basis : basisC[polyOrder]
    ) else (
      basis : basisP[polyOrder]
    ),
    N : length(basis),

    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(const double *wC, const double *wF, const double *dxC, const double *dxF, const double *fldC, double *fldF) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // wC:   cell center of coarse-grid cell.~%"),
    printf(fh, "  // wF:   cell center of fine-grid cell.~%"),
    printf(fh, "  // dxC:  cell length of coarse-grid cell.~%"),
    printf(fh, "  // dxF:  cell length of fine-grid cell.~%"),
    printf(fh, "  // fldC: coarse-grid field.~%"),
    printf(fh, "  // fldF: fine-grid field in cells pointed to by the stencil.~%"),
    printf(fh, "~%"),

    /* Create a variable saving limits of integration. */
    printf(fh, "  double eLo[~a];~%", dim),
    printf(fh, "  double eUp[~a];~%", dim),
    for d : 0 thru dim-1 do (
      printf(fh, "  eLo[~a] = std::max(-1.0,~a);~%", d, float(1-(2/dxF[d])*(wF[d]+dxF[d]/2-(wC[d]-dxC[d]/2)))),
      printf(fh, "  eUp[~a] = std::min( 1.0,~a);~%", d, float(-1+(2/dxF[d])*(wC[d]+dxC[d]/2-(wF[d]-dxF[d]/2))))
    ),
    printf(fh, "~%"),

    /* Field expansions and list of coefficients. */
    cFld_e : doExpand1(fldC,basis),         /* Expand coarse-grid field in basis. */
    cFld_c : makelist(fldC[i],i,0,N-1),
    fFld_e : doExpand1(fldF,basis),         /* Expand fine-grid field in basis. */
    fFld_c : makelist(fldF[i],i,0,N-1),

    /* Create a table of the relationship between the logical coordinates
       in each direction of the coarse and fine grids, that is, the linear map
         xi_c = L(xi_f)
       where xi_c and xi_f are the is the coarse and fine logical coordinates. */
    varMap : makelist((2/dxC[i])*(wF[i]-wC[i]+(dxF[i]/2)*vars[i+1]),i,0,dim-1),

    /* Compute the inner product, on fine grid of current cell,
       of the coarse field times the basis fine-grid functions. */
    intLims : makelist([eLo[d-1], eUp[d-1]],d,1,dim),
    IcFld   : fullratsimp(calcInnerProdListGen(vars,intLims,1.0,basis,subst(makelist(vars[i]=varMap[i],i,1,dim),cFld_e))),

    /* In general these expressions are very complex. It would be beneficial to
       perform some kind of common subexpression elimination. For now we'll just eliminate the exponents. */
    subList : [],
    maxExponent : 8,
    expQ        : [wC, wF, dxC, dxF, eLo, eUp],
    for eI : 1 thru length(expQ) do (
      for f : 2 thru maxExponent do (
        for d : 0 thru dim-1 do (
          doSub : false,
          for k : 1 thru N do (
            if (not freeof(expQ[eI][d]^f,IcFld[k])) then ( doSub : true )
          ),
          if (doSub) then (
            /* Define a separate variable. */
            lhsS : sconcat("  double ",string(expQ[eI]),d,"R",f),
            rhsS : sconcat("std::pow(",string(expQ[eI][d]),",",f,");~%"),
            printf(fh, sconcat(lhsS," = ",rhsS)),
            /* Add to the string substitution list, used in writing file. */
            subList : append(subList,[[sconcat(string(expQ[eI][d]), "^",f), sconcat(string(expQ[eI]),d,"R",f)]])
          )
        )
      )
    ),
    printf(fh, "~%"),

    writeCIncrExprs1sub(fldF,IcFld,subList),
    printf(fh, "~%"),

    printf(fh, "}~%"),
    printf(fh, "~%")

  )
)$

