load("modal-basis")$
load("out-scripts");
load(stringproc)$
load("recovery")$
fpprec : 24$

/* This script generates the kernels needed for adding the
   contributions from second order diffusion in all directions
   using two integrations by parts. */

surfLabels : [X1, X2, X3, X4, X5, X6]$

writeCExprsCollect1s(lhs, rhs, clst, nSpaces) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e : apply(collectterms, param),
      ep : string(e),
      ep : ssubst("g1Sq","g1^2",ep),
      ep : ssubst("std::sinh","sinh",ep),
      printf(fh, sconcat(smake(nSpaces," "),"  ~a = ~a; ~%"), lhs[i-1], ep)
    )
  )
)$

writeCIncrExprs1s(lhs, rhs, nSpaces) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    ep : string(expr[i]),
    ep : ssubst("g1Sq","g1^2",ep),
    ep : ssubst("std::sinh","sinh",ep),
    if expr[i] # 0.0 then printf(fh, sconcat(smake(nSpaces," "),"  ~a += ~a; ~%"), lhs[i-1], ep)
  )
)$

writeCIncrCollect1s(lhs, rhs, clst, nSpaces) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e  : gcfac(apply(collectterms, param)),
      ep : string(e),
      ep : ssubst("g1Sq","g1^2",ep),
      ep : ssubst("std::sinh","sinh",ep),
      printf(fh,sconcat(smake(nSpaces," "),"  ~a += ~a; ~%"), lhs[i-1], ep)
    )
  )
)$

writeCExprs1s(lhs, rhs, nSpaces) := block([expr],
  expr : expand(float(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      ep : string(expr[i]),
      ep : ssubst("std::sinh","sinh",ep),
      for iC : 0 thru Ncp-1 do (
        ep : ssubst(sconcat("xBarSq[",string(iC),"]"),
                    sconcat("xBar[",string(iC),"]^2"),ep),
        ep : ssubst(sconcat("g1Sq"),
                    sconcat("g1[",string(iC),"]^2"),ep)
      ),
      printf(fh,sconcat(smake(nSpaces," "),"  ~a = ~a; ~%"), lhs[i-1], ep)
    )
  )
)$

writeCExprs1sI(lhs, iOut, rhs, nSpaces) := block([expr],
  expr : expand(float(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      ep : string(expr[i]),
      ep : ssubst("std::sinh","sinh",ep),
      for iC : 0 thru Ncp-1 do (
        ep : ssubst(sconcat("xBarSq[",string(iC),"]"),
                    sconcat("xBar[",string(iC),"]^2"),ep),
        ep : ssubst(sconcat("g1Sq"),
                    sconcat("g1[",string(iC),"]^2"),ep)
      ),
      printf(fh,sconcat(smake(nSpaces," "),"  ~a = ~a; ~%"), lhs[iOut], ep)
    )
  )
)$

writeCExprs1so(lhs, rhs, nSpaces) := block([expr],
  for i : 1 thru length(rhs) do (
    expr : float(expand(num(rhs[i]))/denom(rhs[i])),
    if expr # 0 then (
      printf(fh,sconcat(smake(nSpaces," "),"  ~a = ~a; ~%"), lhs[i-1], expr)
    )
  )
)$

writeCExprs1sP(lhs, rhs, nSpaces) := block([expr],
  expr : expand(float(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      ep : string(expr[i]),
      for iC : 0 thru Ncp-1 do (
        ep : ssubst(sconcat("xBar[",string(iC),"]*xBar[",string(iC),"]"),
                    sconcat("xBar[",string(iC),"]^2"),ep)
      ),
      printf(fh,sconcat(smake(nSpaces," "),"  ~a = ~a; ~%"), lhs[i-1], ep)
    )
  )
)$

/* Functions loadBasisX and getDirCombos ought to match those in the
   header-generating script. */

loadBasisX(dimTot, basisType, pOrder) := block([basis,vars],
  /* Load a basis based on dimensionality and basis type alone. */
  kill(varsC, varsP, basisC, basisP),
  if (dimTot < 4) then (
    load(sconcat("basis-precalc/basis", basisType, dimTot, "x"))
  ) else (
    load(sconcat("basis-precalc/basis", basisType, dimTot-3, "x", 3, "v"))
  ),

  if (dimTot < 4) then (
    basis : basisC[pOrder],
    vars  : varsC
  ) else (
    basis : basisP[pOrder],
    vars  : varsP
  ),
  return([basis,vars])
)$

getDirCombos(varsIn) := block([dirCombosSet,dirCombos,d],
  dirCombosSet : setify([]),
  for d : 1 thru length(varsIn) do (
    dirCombosSet : union(dirCombosSet,powerset(setify(varsIn),d))
  ),
  dirCombos : full_listify(dirCombosSet),
  dirCombos : makelist(sort(dirCombos[i],lambda([a,b],slength(string(a)) < slength(string(b)))),i,1,length(dirCombos)),
  return(dirCombos)
)$


/* Given the value of the recovery polynomial (fRec) and its derivative
   (frecP) at the interface, this function computes the increments and
   writes them to the kernel file. */
compWriteIncr(varsIn, basisIn, dirIn, fRec, fRecP, nSpaces) := block([cv,surfVars,incr_s1,incr_s2,clst,i,numB],

    cv       : varsIn[dirIn],
    surfVars : delete(cv,varsIn),
    numB     : length(basisIn),

    /* Contribution to vector to the left and right of the boundary. */
    /* incr_r2 has 3 minus signs. One comes from the second integration
    ** by parts, another from evaluating at upper surface Minus lower
    ** surface, and the last one from evaluating at cv=-1. */
    incr_l1 : calcInnerProdList(surfVars,1,subst(cv=1,basisIn),fRecP),
    incr_l2 : calcInnerProdList(surfVars,-1,subst(cv=1,diff(basisIn,cv)),fRec),

    incr_r1 : -calcInnerProdList(surfVars,1,subst(cv=-1,basisIn),fRecP),
    incr_r2 : -calcInnerProdList(surfVars,-1,subst(cv=-1,diff(basisIn,cv)),fRec),
    
    clst : [wxr, dvxr],
    writeCExprsCollect1s(incr1, incr_r1, clst, nSpaces),
    printf(fh,"~%"),
    writeCExprsCollect1s(incr2, incr_r2, clst, nSpaces),
    printf(fh, "~%"),

    incr_s1 : makelist(incr1[i-1], i, 1, numB),
    incr_s2 : makelist(incr2[i-1], i, 1, numB),
    /* Don't do coefficients where the increment is zero */
    for i : 1 thru numB do (
      if (incr_r1[i] = 0) then
        incr_s1[i] : 0,
      if (incr_r2[i] = 0) then
        incr_s2[i] : 0
    ), 
    writeCIncrExprs1s(outr, rdxSq4nur*(incr_s1+incr_s2), nSpaces),
    printf(fh, "~%"),
  
    signs1 : makelist(1,i,1,numB),
    signs2 : makelist(1,i,1,numB),
    for i : 1 thru numB do (
        if (incr_r1[i] = 0) then
          false
        else
          signs1[i] : fullratsimp(incr_l1[i]/incr_r1[i]),
        if (incr_r2[i] = 0) then
          false
        else
          signs2[i] : fullratsimp(incr_l2[i]/incr_r2[i])
    ),
    incr_s1 : makelist(signs1[i]*incr1[i-1], i, 1, numB),
    incr_s2 : makelist(signs2[i]*incr2[i-1], i, 1, numB),
    /* Don't do coefficients where the increment is zero */
    for i : 1 thru numB do (
      if (incr_r1[i] = 0) then
        incr_s1[i] : 0
    ), 
    for i : 1 thru numB do (
      if (incr_r2[i] = 0) then
        incr_s2[i] : 0
    ), 
    writeCIncrExprs1s(outl, rdxSq4nul*(incr_s1+incr_s2),nSpaces)
)$

calcUpdateInDir(dir, diffDir, fh, funcNm, dim, basisFun, polyOrder, applyPos) := block([],

  /* Positivity preserving algorithm only for p=1 for now. */
  if applyPos then (
    polyOrder : 1
  ),

  tmpLst : loadBasisX(dim, basisFun, polyOrder),
  basis  : tmpLst[1],
  vars   : tmpLst[2],

  numB : length(basis),

  /* Variables. */
  cv       : vars[dir],
  surfVars : delete(cv,vars),

  /* Recovery polynomial and its coefficients. */
  hOrder : 2*polyOrder+1,
  h      : calcRecov2CellGen(basisFun,cv,vars,polyOrder,dg(makelist(fl[i],i,0,numB)), dg(makelist(fr[i],i,0,numB))),
  hsol   : cons(subst(cv=0,h),makelist(subst(cv=0,diff(h,cv,ord)/(ord!)),ord,1,hOrder)),

  printf(fh,"void ~a_~a(const double *wl, const double *wr, const double *dxl, const double *dxr, const double *nu, const double *fl, const double *fr, double *outl, double *outr) ~%{ ~%", funcNm, surfLabels[dir]),
  printf(fh,"  // w[~a]:      Cell-center coordinates.~%",dim),
  printf(fh,"  // dx[~a]:     Cell spacing.~%",dim),
  printf(fh,"  // nu[~a]:     diffusion coefficient (collisionality).~%",dim),
  printf(fh,"  // fl/fr:     Distribution function in left/right cells.~%"),
  printf(fh,"  // outl/outr: Incremented distribution function in left/right cells ~%"),
  printf(fh,"  double rdxSq4nul = 4.0*nu[~a]/(dxl[~a]*dxl[~a]); ~%", diffDir-1, dir-1, dir-1),
  printf(fh,"  double rdxSq4nur = 4.0*nu[~a]/(dxr[~a]*dxr[~a]); ~%", diffDir-1, dir-1, dir-1),
  printf(fh,"~%"),
  
  printf(fh,"  double incr1[~a]; ~%", numB),
  printf(fh,"  double incr2[~a]; ~%", numB),
  printf(fh,"~%"),

  if (not applyPos) then (

    compWriteIncr(vars, basis, dir, hsol[1], hsol[2], 0)

  ) else (

    /* This function evaluates the coefficients of the recovery polynomial
       (fIn) in variables evalVars at all combinations of (+/- evalPoint)
       points, and places it in the list fEvOut. */
    pointEval(fEvOut,fIn,evalVars,evalPoint,compIn) := block([v1,otherVars,fSub],
      v1        : evalVars[1],
      otherVars : delete(v1,evalVars),
      for iQ : -1 step 2 thru 1 do (
        fSub : subst(v1=iQ*evalPoint,fIn),
        if length(otherVars)>0 then (
          pointEval(fEvOut,fSub,otherVars,evalPoint,compIn)
        ) else (
          fEvOut[compIn][iHe] : fSub,
          iHe : iHe + 1
        )
      )
    ),

    /* Evaluate boundary value of recovery polynomial at key (control) points. */
    Ncp   : 2^(dim-1),  /* Number of control points. */
    hsolKP: [makelist(0,j,1,Ncp)],
    iHe   : 1,
    if (length(surfVars)>0) then (
      pointEval(hsolKP,hsol[1],surfVars,1/3,1)
    ) else (
      hsolKP[1][iHe] : hsol[1]
    ),


    /* If value of recovery polynomial at the interface, evaluated at key
       points, is below zero, use its exponential representation. */
    hsolKPifCond : "(",
    for iS : 1 thru length(hsolKP[1]) do (
      hsolKPifCond : sconcat(hsolKPifCond,string(float(expand(hsolKP[1][iS]))),">=0.0)"),
      if iS<length(hsolKP[1]) then (
        hsolKPifCond : sconcat(hsolKPifCond," && (")
      )
    ),
    printf(fh,"  if ( ~a ) {~%",hsolKPifCond),

    compWriteIncr(vars, basis, dir, hsol[1], hsol[2], 2),

    printf(fh,"  } else {~%"),
    printf(fh,"~%"),

    Ncp    : 2^(dim-1),  /* Number of control points. */
    hsolEv : makelist(makelist(0,j,1,Ncp),i,1,4),
    for iC : 1 thru 4 do (
      iHe : 1,
      if (length(surfVars)>0) then (
        pointEval(hsolEv,hsol[iC],surfVars,1/3,iC)
      ) else (
        hsolEv[iC][iHe] : hsol[iC]
      )
    ),

    /* At each point we evaluated the recovery poly, need to reconstruct
       an exponential, for which we need xBar, xBarSq and g1. */
    xBars : makelist(0,i,1,Ncp),
    for iCP : 1 thru Ncp do (
      xBars[iCP] : (hsolEv[2][iCP]+3*hsolEv[4][iCP]/5)/(3*hsolEv[1][iCP]+hsolEv[3][iCP])
    ),

    xBarsSq : makelist(xBar[i]*xBar[i],i,0,Ncp-1),
    g1s     : makelist(xBar[i]*(3-xBarSq[i])/(1-xBarSq[i]),i,0,Ncp-1),

    printf(fh,"    double xBar[~a];~%",Ncp),
    writeCExprs1so(xBar,xBars,2),
    printf(fh,"~%"),

    printf(fh,"    double xBarSq[~a];~%", Ncp),
    writeCExprs1sP(xBarSq,xBarsSq,2),
    printf(fh,"~%"),

    printf(fh,"    double g1[~a];~%",Ncp),
    writeCExprs1s(g1,g1s,2),
    printf(fh,"~%"),

    printf(fh,"    double gBound[~a];~%",Ncp),
    printf(fh,"    double gBoundP[~a];~%",Ncp),
    printf(fh,"~%"),

    for iCP : 1 thru Ncp do (
      /* When the function is very flat we need to compute the exponential
         differently so that 1/sinh(g1) doesn't blow up. */
      printf(fh,"    if (std::abs(g1[~a]) > 1.0e-15) {~%",iCP-1),

      printf(fh,"      double g1Sq = g1[~a]*g1[~a];~%",iCP-1,iCP-1),

      expg0  : [g1[iCP-1]*(hsolEv[1][iCP]+hsolEv[3][iCP]/3)/sinh(g1[iCP-1])],
      gprime : [g1[iCP-1]*expg0[1]],

      writeCExprs1sI(gBound,iCP-1,expg0,4),
      writeCExprs1sI(gBoundP,iCP-1,gprime,4),

      printf(fh,"    } else {~%"),

      expg0  : [hsolEv[1][iCP]+hsolEv[3][iCP]/3],
      gprime : [0.0],

      writeCExprs1sI(gBound,iCP-1,expg0,4),
      writeCExprs1sI(gBoundP,iCP-1,gprime,4),

      printf(fh,"    };~%"),
      printf(fh, "~%")
    ),

    if (dim=1) then (
      compWriteIncr(vars, basis, dir, gBound[0], gBoundP[0], 2)
    ) else (

      /*........... Create nodal to modal transform matrix .......... */
      /* Surface basis: basis of one lower dimensionality w/o surf variable. */
      bSurf  : sqrt(2)*delete(0,fullratsimp(innerProd(vars,1,basis,subst(cv=0,basis)))*basis),
      gFsurf : doExpand(gF,bSurf),
      /* Evaluate the g-Function at various combinations of control points. */
      gFsurfCP : [makelist(0,i,1,Ncp)],
      iHe      : 1,
      pointEval(gFsurfCP,gFsurf,surfVars,1/3,1),
      /* Construct the nodal-to-modal matrix. */
      n2m : invert(coefmatrix(gFsurfCP[1],makelist(gF[i],i,1,length(bSurf)))),
      /*........... Built nodal to modal transform matrix .......... */

      modalV  : n2m . makelist(gBound[i-1],i,1,Ncp),
      gRec0   : doExpand(makelist(modalV[i][1],i,1,length(bSurf)),bSurf),

      modalV  : n2m . makelist(gBoundP[i-1],i,1,Ncp),
      gRecP0  : doExpand(makelist(modalV[i][1],i,1,length(bSurf)),bSurf),

      compWriteIncr(vars, basis, dir, gRec0,gRecP0,2)
    ), 

    printf(fh,"  };~%")
  ),
  printf(fh, "~%"),
  
  
  printf(fh, "} ~%")
);

calcBoundaryUpdateInDir(dir, diffDir, fh, funcNm, dim, basisFun, polyOrder, applyPos) := block([],

  /* Positivity preserving algorithm only for p=1 for now. */
  if applyPos then (
    polyOrder : 1
  ),

  tmpLst : loadBasisX(dim, basisFun, polyOrder),
  basis  : tmpLst[1],
  vars   : tmpLst[2],

  numB : length(basis),

  /* Variables. */
  cv       : vars[dir],
  surfVars : delete(cv,vars),

  /* Recovery polynomial and its coefficients. */
  hOrder : 2*polyOrder+1,
  h      : calcRecov2CellGen(basisFun,cv,vars,polyOrder,dg(makelist(fl[i],i,0,numB)), dg(makelist(fr[i],i,0,numB))),
  hsol   : cons(subst(cv=0,h),makelist(subst(cv=0,diff(h,cv,ord)/(ord!)),ord,1,hOrder)),

  printf(fh,"void ~a_~a(const double *wl, const double *wr, const double *dxl, const double *dxr, const int *idxl, const int *idxr, const double *nu, const double *fl, const double *fr, double *outl, double *outr) ~%{ ~%", funcNm, surfLabels[dir]),
  printf(fh,"  // w[~a]:      Cell-center coordinates.~%",dim),
  printf(fh,"  // dx[~a]:     Cell spacing.~%",dim),
  printf(fh,"  // idx[~a]:    current grid index.~%",dim),
  printf(fh,"  // nu[~a]:     diffusion coefficient (collisionality).~%",dim),
  printf(fh,"  // fl/fr:     Distribution function in left/right cells.~%"),
  printf(fh,"  // outl/outr: Incremented distribution function in left/right cells ~%"),
  printf(fh,"  double rdxSq4nul = 4.0*nu[~a]/(dxl[~a]*dxl[~a]); ~%", diffDir-1, dir-1, dir-1),
  printf(fh,"  double rdxSq4nur = 4.0*nu[~a]/(dxr[~a]*dxr[~a]); ~%", diffDir-1, dir-1, dir-1),
  printf(fh,"~%"),
  
  printf(fh,"  double incr1[~a]; ~%", numB),
  printf(fh,"  double incr2[~a]; ~%", numB),
  printf(fh,"~%"),

  if (not applyPos) then (

    compWriteIncr(vars, basis, dir, hsol[1], hsol[2], 0)

  ) else (

    /* This function evaluates the coefficients of the recovery polynomial
       (fIn) in variables evalVars at all combinations of (+/- evalPoint)
       points, and places it in the list fEvOut. */
    pointEval(fEvOut,fIn,evalVars,evalPoint,compIn) := block([v1,otherVars,fSub],
      v1        : evalVars[1],
      otherVars : delete(v1,evalVars),
      for iQ : -1 step 2 thru 1 do (
        fSub : subst(v1=iQ*evalPoint,fIn),
        if length(otherVars)>0 then (
          pointEval(fEvOut,fSub,otherVars,evalPoint,compIn)
        ) else (
          fEvOut[compIn][iHe] : fSub,
          iHe : iHe + 1
        )
      )
    ),

    /* Evaluate boundary value of recovery polynomial at key (control) points. */
    Ncp : 2^(dim-1),  /* Number of control points. */
    hsolKP: [makelist(0,j,1,Ncp)],
    iHe : 1,
    if (length(surfVars)>0) then (
      pointEval(hsolKP,hsol[1],surfVars,1/3,1)
    ) else (
      hsolKP[1][iHe] : hsol[1]
    ),


    /* If value of recovery polynomial at the interface, evaluated at key
       points, is below zero, use its exponential representation. */
    hsolKPifCond : "(",
    for iS : 1 thru length(hsolKP[1]) do (
      hsolKPifCond : sconcat(hsolKPifCond,string(float(expand(hsolKP[1][iS]))),">=0.0)"),
      if iS<length(hsolKP[1]) then (
        hsolKPifCond : sconcat(hsolKPifCond," && (")
      )
    ),
    printf(fh,"  if ( ~a ) {~%",hsolKPifCond),

    compWriteIncr(vars, basis, dir, hsol[1], hsol[2], 2),

    printf(fh,"  } else {~%"),
    printf(fh,"~%"),

    Ncp : 2^(dim-1),  /* Number of control points. */
    hsolEv : makelist(makelist(0,j,1,Ncp),i,1,4),
    for iC : 1 thru 4 do (
      iHe : 1,
      if (length(surfVars)>0) then (
        pointEval(hsolEv,hsol[iC],surfVars,1/3,iC)
      ) else (
        hsolEv[iC][iHe] : hsol[iC]
      )
    ),

    /* At each point we evaluated the recovery poly, need to reconstruct
       an exponential, for which we need xBar, xBarSq and g1. */
    xBars : makelist(0,i,1,Ncp),
    for iCP : 1 thru Ncp do (
      xBars[iCP] : (hsolEv[2][iCP]+3*hsolEv[4][iCP]/5)/(3*hsolEv[1][iCP]+hsolEv[3][iCP])
    ),

    xBarsSq : makelist(xBar[i]*xBar[i],i,0,Ncp-1),
    g1s     : makelist(xBar[i]*(3-xBarSq[i])/(1-xBarSq[i]),i,0,Ncp-1),

    printf(fh,"    double xBar[~a];~%",Ncp),
    writeCExprs1so(xBar,xBars,2),
    printf(fh,"~%"),

    printf(fh,"    double xBarSq[~a];~%", Ncp),
    writeCExprs1sP(xBarSq,xBarsSq,2),
    printf(fh,"~%"),

    printf(fh,"    double g1[~a];~%",Ncp),
    writeCExprs1s(g1,g1s,2),
    printf(fh,"~%"),

    printf(fh,"    double gBound[~a];~%",Ncp),
    printf(fh,"    double gBoundP[~a];~%",Ncp),
    printf(fh,"~%"),

    for iCP : 1 thru Ncp do (
      /* When the function is very flat we need to compute the exponential
         differently so that 1/sinh(g1) doesn't blow up. */
      printf(fh,"    if (std::abs(g1[~a]) > 1.0e-15) {~%",iCP-1),

      printf(fh,"      double g1Sq = g1[~a]*g1[~a];~%",iCP-1,iCP-1),

      expg0  : [g1[iCP-1]*(hsolEv[1][iCP]+hsolEv[3][iCP]/3)/sinh(g1[iCP-1])],
      gprime : [g1[iCP-1]*expg0[1]],

      writeCExprs1sI(gBound,iCP-1,expg0,4),
      writeCExprs1sI(gBoundP,iCP-1,gprime,4),

      printf(fh,"    } else {~%"),

      expg0  : [hsolEv[1][iCP]+hsolEv[3][iCP]/3],
      gprime : [0.0],

      writeCExprs1sI(gBound,iCP-1,expg0,4),
      writeCExprs1sI(gBoundP,iCP-1,gprime,4),

      printf(fh,"    };~%"),
      printf(fh, "~%")
    ),

    if (dim=1) then (
      compWriteIncr(vars, basis, dir, gBound[0], gBoundP[0], 2)
    ) else (

      /*........... Create nodal to modal transform matrix .......... */
      /* Surface basis: basis of one lower dimensionality w/o surf variable. */
      bSurf  : sqrt(2)*delete(0,fullratsimp(innerProd(vars,1,basis,subst(cv=0,basis)))*basis),
      gFsurf : doExpand(gF,bSurf),
      /* Evaluate the g-Function at various combinations of control points. */
      gFsurfCP : [makelist(0,i,1,Ncp)],
      iHe      : 1,
      pointEval(gFsurfCP,gFsurf,surfVars,1/3,1),
      /* Construct the nodal-to-modal matrix. */
      n2m : invert(coefmatrix(gFsurfCP[1],makelist(gF[i],i,1,length(bSurf)))),
      /*........... Built nodal to modal transform matrix .......... */

      modalV  : n2m . makelist(gBound[i-1],i,1,Ncp),
      gRec0   : doExpand(makelist(modalV[i][1],i,1,length(bSurf)),bSurf),

      modalV  : n2m . makelist(gBoundP[i-1],i,1,Ncp),
      gRecP0  : doExpand(makelist(modalV[i][1],i,1,length(bSurf)),bSurf),

      compWriteIncr(vars, basis, dir, gRec0, gRecP0, 2)
    ),

    printf(fh,"  };~%")
  ),
  printf(fh, "~%"),

  printf(fh, "} ~%")
);

calcConstDiffusionSurfUpdater(fh, funcNm, dim, basisFun, polyOrder, usePos) := block([tmpLst,vars,diffDirCombos,d,dir],
  printf(fh, "#include <ConstDiffusionModDecl.h> ~%"),
  /* For a given dimensionality get the combinations of
     directions in which to apply diffusion. */
  tmpLst        : loadBasisX(dim, basisFun, polyOrder),
  vars          : tmpLst[2],
  diffDirCombos : getDirCombos(vars),
  for diffDirs in diffDirCombos do (
    diffDirNum : length(diffDirs),
    diffDirInP : makelist(sublist_indices(vars,lambda([x], x=diffDirs[i]))[1],i,1,diffDirNum),

    diffDirsStr :"",
    for dI in diffDirInP do (diffDirsStr : sconcat(diffDirsStr,string(dI))),
    funcNmNew : sconcat(funcNm, "P", polyOrder, "_diffDirs", diffDirsStr),

    for d : 1 thru diffDirNum do (
      dir : diffDirInP[d],
      calcUpdateInDir(dir, d, fh, funcNmNew, dim, basisFun, polyOrder, usePos)
    )
  )
)$

calcConstDiffusionBoundarySurfUpdater(fh, funcNm, dim, basisFun, polyOrder, usePos) := block([tmpLst,vars,diffDirCombos,d,dir],
  printf(fh, "#include <ConstDiffusionModDecl.h> ~%"),
  tmpLst        : loadBasisX(dim, basisFun, polyOrder),
  vars          : tmpLst[2],
  diffDirCombos : getDirCombos(vars),
  for diffDirs in diffDirCombos do (
    diffDirNum : length(diffDirs),
    diffDirInP : makelist(sublist_indices(vars,lambda([x], x=diffDirs[i]))[1],i,1,diffDirNum),

    diffDirsStr :"",
    for dI in diffDirInP do (diffDirsStr : sconcat(diffDirsStr,string(dI))),
    funcNmNew : sconcat(funcNm, "P", polyOrder, "_diffDirs", diffDirsStr),

    for d : 1 thru diffDirNum do (
      dir : diffDirInP[d],
      calcBoundaryUpdateInDir(dir, d, fh, funcNmNew, dim, basisFun, polyOrder, usePos)
    )
  )
)$

