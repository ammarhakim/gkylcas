load("modal-basis")$
load("out-scripts");
load(stringproc)$
fpprec : 24$

/* This script generates the kernels needed for adding the
   volume contributions from second order diffusion in all
   directions using two integrations by parts. */

loadBasisX(dimTot, basisType, pOrder) := block([basis,vars],
  /* Load a basis based on dimensionality and basis type alone. */
  kill(varsC, varsP, basisC, basisP),
  if (dimTot < 4) then (
    load(sconcat("basis-precalc/basis", basisType, dimTot, "x"))
  ) else (
    load(sconcat("basis-precalc/basis", basisType, dimTot-3, "x", 3, "v"))
  ),

  if (dimTot < 4) then (
    basis : basisC[pOrder],
    vars  : varsC
  ) else (
    basis : basisP[pOrder],
    vars  : varsP
  ),
  return([basis,vars])
)$

getDirCombos(varsIn) := block([dirCombosSet,dirCombos,d],
  dirCombosSet : setify([]),
  for d : 1 thru length(varsIn) do (
    dirCombosSet : union(dirCombosSet,powerset(setify(varsIn),d))
  ),
  dirCombos : full_listify(dirCombosSet),
  dirCombos : makelist(sort(dirCombos[i],lambda([a,b],slength(string(a)) < slength(string(b)))),i,1,length(dirCombos)),
  return(dirCombos)
)$

calcConstDiffusionVolUpdater(fh, funcNm, dim, basisFun, polyOrder) := block([tmpLst,basis,vars,numB,diffDirCombos,diffDirs],
  /* Generate the volume kernels for adding constant diffusion in all
     or a subset of dimensions. */
  printf(fh, "#include <ConstDiffusionModDecl.h> ~%"),

  tmpLst : loadBasisX(dim, basisFun, polyOrder),
  basis  : tmpLst[1], 
  vars   : tmpLst[2], 

  numB : length(basis),

  fg : doExpand1(f, basis),	/* Function expanded in basis. */
    
  /* For a given dimensionality get the combinations of
     directions in which to apply diffusion. */
  diffDirCombos : getDirCombos(vars),

  for diffDirs in diffDirCombos do (

    diffDirNum : length(diffDirs),
    diffDirInP : makelist(sublist_indices(vars,lambda([x], x=diffDirs[i]))[1],i,1,diffDirNum),

    diffDirsStr :"",
    for dI in diffDirInP do (diffDirsStr : sconcat(diffDirsStr,string(dI))),

    printf(fh,"double ~aP~a_diffDirs~a(const double *w, const double *dx, const double *nu, const double *f, double *out) ~%{ ~%", funcNm, polyOrder,diffDirsStr),
    printf(fh,"  // w[~a]:   Cell-center coordinates.~%",dim),
    printf(fh,"  // dx[~a]:  Cell spacing.~%",dim),
    printf(fh,"  // nu[~a]:  diffusion coefficient (collisionality).~%",dim),
    printf(fh,"  // f:      Input distribution function.~%"),
    printf(fh,"  // out:    Incremented output ~%"),
    printf(fh,"  double rdxSq4nu[~a]; ~%", diffDirNum),
    for d : 1 thru diffDirNum do (
      printf(fh,"  rdxSq4nu[~a] = 4.0*nu[~a]/(dx[~a]*dx[~a]); ~%", d-1, d-1, diffDirInP[d]-1, diffDirInP[d]-1)
    ),
    printf(fh,"~%"),

    /* Volume matrix (convolution of derivatives). */
    incr : (
      incr : 0,
      for d : 1 thru diffDirNum do (
        cv   : vars[diffDirInP[d]],
        incr : incr+calcInnerProdList(vars,rdxSq4nu[d-1],diff(basis,cv,2),fg)
      ),
      incr
    ),

    writeCIncrExprs1(out, incr),
    printf(fh,"~%"),

    /* Return the value used in the CFL calculation. */
    pstr : "  return (rdxSq4nu[0]",
    for d : 2 thru diffDirNum do ( pstr : sconcat(pstr,"+rdxSq4nu[",d-1,"]") ),
    pstr : sconcat(pstr,")*~a;~%"),
    printf(fh, pstr, 0.5*float(((polyOrder+1)**2)/(2*polyOrder+1))),
    printf(fh,"~%"),
  
    printf(fh,"} ~%")
  )
);

