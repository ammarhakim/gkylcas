/* Generate Lua code that fills the left-side matrix entries
   corresponding to the discretization of the generalized Poisson equation
      nabla_i D^ij nabla_j phi  = - rho
   with recovery DG in the 2D interior cells. */

kill(all)$
load("recovery")$

size : [2, 2] $
dirs : [x, y] $
range : [[-1,1], [-1,1]] $
basisNm : ["Ser", "Tensor"] $
Jxx : 4/dx[1]^2 $
Jyy : 4/dx[2]^2 $
Jxy : 4/dx[1]/dx[2] $
C : 1 $

isTop : false $
isBottom : false $
isLeft : false $
isRight : false $

for polyOrder : 1 thru 1 do (
  for bIdx : 1 thru min(length(basisNm),polyOrder) do (
    if polyOrder=1 then bnm : "" else bnm : basisNm[bIdx],
    fname : sconcat("~/max-out/discontGenPoisson", bnm,
                    "Stencil2D",
                    if isTop then "_T" else "",
                    if isBottom then "_B" else "",
                    if isRight then "_R" else "",
                    if isLeft then "_L" else "",
                    "_", polyOrder, "p.lua"),
    fh : openw(fname),
    printf(fh, "local Lin = require \"Lib.Linalg\"~%"),
    printf(fh, "local function stencilFn(dx, Dxx, Dyy, Dxy, Dx, Nx, valx, Dy, Ny, valy)~%"),
    printf(fh, "  local _M = {}~%~%"),
    
    ba : getBasis(sconcat("basis-precalc/basis", basisNm[bIdx], "2x"),
                  polyOrder),
    numBasis : length(ba),

    if isRight then
      recfx : calcRecov1CellGen(basisNm[bIdx], x, size, polyOrder, C,
                                dg(fL), dg(fC), bc(D=Dx, N=Nx, val=valx))
    else if isLeft then
      recfx : calcRecov1CellGen(basisNm[bIdx], x, size, polyOrder, C,
                                bc(D=Dx, N=Nx, val=valx), dg(fC), dg(fC))
    else
      recfx : calcRecov1CellGen(basisNm[bIdx], x, size, polyOrder, C,
                                dg(fL), dg(fC), dg(fR)),
      
    if isTop then
      recfy : calcRecov1CellGen(basisNm[bIdx], y, size, polyOrder, C,
                                dg(fB), dg(fC), bc(D=Dy, N=Ny, val=valy))
    else if isBottom then
      recfy : calcRecov1CellGen(basisNm[bIdx], y, size, polyOrder, C,
                                bc(D=Dy, N=Ny, val=valy), dg(fC), dg(fT))
    else
      recfy : calcRecov1CellGen(basisNm[bIdx], y, size, polyOrder, C,
                                dg(fB), dg(fC), dg(fT)),

    vol : calcInnerProdList(dirs, Jxx, diff(ba, x),
                            doExpand(Dxx, ba)*diff(recfx, x)) +
          calcInnerProdList(dirs, Jxy, diff(ba, x),
                            doExpand(Dxy, ba)*diff(recfy, y)) +
          calcInnerProdList(dirs, Jxy, diff(ba, y),
                            doExpand(Dxy, ba)*diff(recfx, x)) +
          calcInnerProdList(dirs, Jyy, diff(ba, y),
                            doExpand(Dyy, ba)*diff(recfy, y)),

    /* Top */
    if isTop then (
      rec2 : calcRecov2CellGen(basisNm[bIdx], y, size, polyOrder,
                               dg(fB), dg(fC, bc(D=Dy, N=Ny, val=valy))),
      faceT : subst(y=1, doExpand(Dyy, ba))*subst(y=2, diff(rec2, y))*Jyy
    ) else (
      rec2 : calcRecov2CellGen(basisNm[bIdx], y, size, polyOrder,
                               dg(fC), dg(fT)),
      if isRight then
        rec6 : calcRecovFaceGen(basisNm[bIdx], y, 0, size, polyOrder, C,
                                dg(fL, fTL), dg(fC, fT),
                                bc(D=Dx, N=Nx, val=valx))
      else if isLeft then
        rec6 : calcRecovFaceGen(basisNm[bIdx], y, 0, size, polyOrder, C,
                                bc(D=Dx, N=Nx, val=valx),
                                dg(fC, fT), dg(fR, fTR))
      else
        rec6 : calcRecovFaceGen(basisNm[bIdx], y, 0, size, polyOrder, C,
                                dg(fL, fTL), dg(fC, fT), dg(fR, fTR)),
      faceT : subst(y=1, doExpand(Dyy, ba))*subst(y=0, diff(rec2, y))*Jyy +
              subst(y=1, doExpand(Dxy, ba))*diff(rec6, x)*Jxy
    ),
    surfT : calcInnerProdList([x], 1, subst(y=1, ba), faceT),

    /* Bottom */
    if isBottom then (
      rec2 : calcRecov2CellGen(basisNm[bIdx], y, size, polyOrder,
                               dg(fC, bc(D=Dy, N=Ny, val=valy)), dg(fT)),
      faceB : subst(y=-1, doExpand(Dyy, ba))*subst(y=-2, diff(rec2, y))*Jyy
    ) else (
      rec2 : calcRecov2CellGen(basisNm[bIdx], y, size, polyOrder,
                               dg(fB), dg(fC)),
      if isRight then
        rec6 : calcRecovFaceGen(basisNm[bIdx], y, 0, size, polyOrder, C,
                                dg(fBL, fL), dg(fB, fC),
                                bc(D=Dx, N=Nx, val=valx))
      else if isLeft then
        rec6 : calcRecovFaceGen(basisNm[bIdx], y, 0, size, polyOrder, C,
                                bc(D=Dx, N=Nx, val=valx),
                                dg(fB, fC), dg(fBR, fR))
      else
        rec6 : calcRecovFaceGen(basisNm[bIdx], y, 0, size, polyOrder, C,
                                dg(fBL, fL), dg(fB, fC), dg(fBR, fR)),
      faceB : subst(y=-1, doExpand(Dyy, ba))*subst(y=0, diff(rec2, y))*Jyy +
              subst(y=-1, doExpand(Dxy, ba))*diff(rec6, x)*Jxy
    ),
    surfB : calcInnerProdList([x], 1, subst(y=-1, ba), faceB),

    /* Left */
    if isLeft then (
      rec2 : calcRecov2CellGen(basisNm[bIdx], x, size, polyOrder,
                               dg(fC, bc(D=Dx, N=Nx, val=valx)), dg(fR)),
      faceL : subst(x=-1, doExpand(Dxx, ba))*subst(x=-2, diff(rec2, x))*Jxx
    ) else (
      rec2 : calcRecov2CellGen(basisNm[bIdx], x, size, polyOrder,
                               dg(fL), dg(fC)),
      if isTop then
        rec6 : calcRecovFaceGen(basisNm[bIdx], x, 0, size, polyOrder, C,
                                dg(fBL, fB), dg(fL, fC),
                                bc(D=Dy, N=Ny, val=valy))
      else if isBottom then
        rec6 : calcRecovFaceGen(basisNm[bIdx], x, 0, size, polyOrder, C,
                                bc(D=Dy, N=Ny, val=valy),
                                dg(fL, fC), dg(fTL, fT))
      else
        rec6 : calcRecovFaceGen(basisNm[bIdx], y, 0, size, polyOrder, C,
                                dg(fBL, fB), dg(fL, fC), dg(fTL, fT)),
      faceL : subst(x=-1, doExpand(Dxx, ba))*subst(x=0, diff(rec2, x))*Jxx +
              subst(x=-1, doExpand(Dxy, ba))*diff(rec6, y)*Jxy
    ),
    surfL : calcInnerProdList([y], 1, subst(x=-1, ba), faceL),

    /* Right */
    if isRight then (
      rec2 : calcRecov2CellGen(basisNm[bIdx], x, size, polyOrder,
                               dg(fL), dg(fC, bc(D=Dx, N=Nx, val=valx))),
      faceR : subst(x=1, doExpand(Dxx, ba))*subst(x=2, diff(rec2, x))*Jxx
    ) else (
      rec2 : calcRecov2CellGen(basisNm[bIdx], x, size, polyOrder,
                               dg(fC), dg(fR)),
      if isTop then
        rec6 : calcRecovFaceGen(basisNm[bIdx], x, 0, size, polyOrder, C,
                                dg(fB, fBR), dg(fC, fR),
                                bc(D=Dy, N=Ny, val=valy))
      else if isBottom then
        rec6 : calcRecovFaceGen(basisNm[bIdx], x, 0, size, polyOrder, C,
                                bc(D=Dy, N=Ny, val=valy),
                                dg(fC, fR), dg(fT, fTR))
      else
        rec6 : calcRecovFaceGen(basisNm[bIdx], y, 0, size, polyOrder, C,
                                dg(fB, fBR), dg(fC, fR), dg(fT, fTR)),
      faceR : subst(x=1, doExpand(Dxx, ba))*subst(x=0, diff(rec2, x))*Jxx +
              subst(x=1, doExpand(Dxy, ba))*diff(rec6, y)*Jxy
    ),
    surfR : calcInnerProdList([y], 1, subst(x=1, ba), faceR),

    st : surfT - surfB + surfR - surfL - vol,

    fList : [fBL, fL, fTL, fB, fC, fT, fBR, fR, fTR],
    for m : 1 thru 9 do (
      cMat : coefmatrix(st, makelist(fList[m][i], i, 1, numBasis)),
      printf(fh, "  _M[~a] = Lin.Mat(~a,~a)~%", m, numBasis, numBasis),
      for i : 1 thru numBasis do (
        for j : 1 thru numBasis do (
          printf(fh, "  _M[~a][~a][~a] = ~a~%", m, i, j, float(cMat[i][j]))
        )
      )
    ),
    cMatx : coefmatrix(st, [valx]),
    cMaty : coefmatrix(st, [valy]),
    printf(fh, "  _M[10] = Lin.Vec(~a)~%", numBasis),
    for i : 1 thru numBasis do (
      printf(fh, "  _M[10][~a] = ~a*valx + ~a*valy~%", i,
             float(cMatx[i][1]), float(cMaty[i][1]))
    ),

    printf(fh, "  return(_M)~%"),
    printf(fh, "end~%~%"),
    printf(fh, "return(stencilFn)"),
    close(fh)
  )
)$