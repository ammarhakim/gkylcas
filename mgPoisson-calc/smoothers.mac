/* Kernels for the smoothing/relaxation operators for
   the DG Poisson equation
         - L(phi) = rho
   where L=Laplacian. */

load("modal-basis");
load("out-scripts");
load("recovery-calc/recovery");
fpprec : 24$

/* Iterate (phi) in lower and upper cells along each direction. */
phiL : [phiLx, phiLy, phiLz]$
phiU : [phiUx, phiUy, phiUz]$

/* Cell length factors along each direction. */
rdxL   : [rdxLx, rdxLy, rdxLz]$
rdxU   : [rdxUx, rdxUy, rdxUz]$
rdxLSq : [rdxLxSq, rdxLySq, rdxLzSq]$
rdxUSq : [rdxUxSq, rdxUySq, rdxUzSq]$

writeCExprs1sub(lhs, rhs, sublist) := block([expr],
  /* Perform some substitutions before printing. No expand. */
  expr : float(rhs),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      ep     : string(expr[i]),
      outStr : ssubst(sublist[1][2],sublist[1][1],ep),
      for s : 2 thru length(sublist) do (
        outStr : ssubst(sublist[s][2],sublist[s][1],outStr)
      ),
      printf(fh, "  ~a = ~a; ~%", lhs[i-1], outStr)
    )
  )
)$

calcJacobiOp(fh, funcNm, dim, basisFun, pMax, isDamped) := block([],
  /* Jacobi (and damped Jacobi) relaxation on the Poisson equation
     using an RDG discretization. Other options involve LDG and
     interior penalty methods. */

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  ones : makelist(1,i,1,dim),

  stencilWidth : 3,
  stencilSize  : (stencilWidth-1)*dim+1,

  for polyOrder : 1 thru pMax do (

    bC  : basisC[polyOrder],
    N   : length(bC),

    /* Expansion and coefficients of phi in this (center) cell. */
    phiC_e : doExpand1(phiC,bC),
    phiC_c : makelist(phiC[i],i,0,N-1),

    surfTerms : 0,
    volTerms  : 0,
    for dir : 1 thru dim do (

      /* Expand the iterate (phi) in this (center) cell and
         lower/upper cells along dir dimension. */
      phiL_e : doExpand1(phiL[dir],bC),
      phiU_e : doExpand1(phiU[dir],bC),

      phiL_c : makelist(phiL[dir][i],i,0,N-1),
      phiU_c : makelist(phiU[dir][i],i,0,N-1),

      /* Compute recovery coefficients across boundaries. */
      surfDir           : dir,
      surfVar           : varsC[surfDir],
      remainingSurfVars : delete(surfVar,varsC),
      bCp               : diff(bC,surfVar),

      phiRecL  : getRecov2CellGen(surfVar,ones,polyOrder,phiL_c, phiC_c),
      phiRecU  : getRecov2CellGen(surfVar,ones,polyOrder,phiC_c, phiU_c),
      /* Recovery and its derivative evaluated at the boundary. */
      phiRecL0  : subst(surfVar=0,phiRecL),
      phiRecU0  : subst(surfVar=0,phiRecU),
      phiRecLp0 : subst(surfVar=0,diff(phiRecL,surfVar)),
      phiRecUp0 : subst(surfVar=0,diff(phiRecU,surfVar)),

      /* Surface terms. The rdx and 2 factors account for physical cell length. */
      surfTerms : surfTerms + rdxU[dir][surfDir-1]*( calcInnerProdList(remainingSurfVars,1.0,subst(surfVar=1,bC),phiRecUp0)
                                                    -2*calcInnerProdList(remainingSurfVars,1.0,subst(surfVar=1,bCp),phiRecU0) )
                            - rdxL[dir][surfDir-1]*( calcInnerProdList(remainingSurfVars,1.0,subst(surfVar=-1,bC),phiRecLp0)
                                                    -2*calcInnerProdList(remainingSurfVars,1.0,subst(surfVar=-1,bCp),phiRecL0) ),

      /* Volume terms. */
      volTerms : volTerms + rdxC2[dir-1]*calcInnerProdList(varsC,1,diff(bC,varsC[dir],2),phiC_e)

    ),

    /* Left-hand-side of the Poisson equation.*/
    poissonLHS : fullratsimp(- ( surfTerms + volTerms )),

    /* The right-hand-side of the Poisson equation is
       just a projection of the source on the basis. */
    rho_e     : doExpand1(rho,bC),
    sourceRHS : volFac*calcInnerProdList(varsC,1,bC,rho_e),

    /* Solve for the coefficients of this cell to get the stencil. */
    stencilSolve : linsolve(makelist(poissonLHS[i]=sourceRHS[i],i,1,N),phiC_c),

    if (isDamped) then (

      /* Damped Jacobi method. */
      jacStencil : (1-omega)*phiC_c + omega*makelist(rhs(stencilSolve[i]),i,1,N),

      printf(fh, "void ~a_P~a(const double omega, double **dx, const double *rho, double **phi) ~%{ ~%", funcNm, polyOrder),
      printf(fh, "  // omega:     relaxation parameter.~%")

    ) else (

      /* Regular Jacobi.*/
      jacStencil : makelist(rhs(stencilSolve[i]),i,1,N),

      printf(fh, "void ~a_P~a(double **dx, const double *rho, double **phi) ~%{ ~%", funcNm, polyOrder)

    ),
    jacStencil : fullratsimp(jacStencil),

    printf(fh, "  // dx:  cell lengths of cells pointed to by the stencil.~%"),
    printf(fh, "  // rho: right-side source in the current cell.~%"),
    printf(fh, "  // phi: iterate cells pointed to by the stencil.~%"),
    printf(fh, "~%"),

    /* Pointers to the cell lengths in cells pointed to by the stencil. */
    printf(fh, "  double *dxC  = dx[0]; ~%"),
    sI : 1,
    for d : 1 thru dim do (
      printf(fh, "  double *dxU~a = dx[~a]; ~%", varsC[d], sI),
      printf(fh, "  double *dxL~a = dx[~a]; ~%", varsC[d], sI+1),
      sI : sI + 2
    ),
    printf(fh, "~%"),

    /* Some factors based on cell lengths. */
    printf(fh, "  double rdxC2[~a]; ~%", dim),
    for d : 1 thru dim do (
      printf(fh, "  double rdxL~a[~a]; ~%", varsC[d], dim),
      printf(fh, "  double rdxU~a[~a]; ~%", varsC[d], dim),
      printf(fh, "  double rdxL~aSq[~a]; ~%", varsC[d], dim),
      printf(fh, "  double rdxU~aSq[~a]; ~%", varsC[d], dim),
      if (dim=2) then (
        printf(fh, "  double rdxL~aCu[~a]; ~%", varsC[d], dim),
        printf(fh, "  double rdxU~aCu[~a]; ~%", varsC[d], dim),
        printf(fh, "  double rdxL~aR4[~a]; ~%", varsC[d], dim),
        printf(fh, "  double rdxU~aR4[~a]; ~%", varsC[d], dim)
      )
    ),

    for dir : 1 thru dim do (
      printf(fh, "  rdxC2[~a]   = 2.0/dxC[~a]; ~%", dir-1, dir-1),
      for d : 1 thru dim do (
        printf(fh, "  rdxL~a[~a]   = 1.0/dxL~a[~a]; ~%", varsC[dir], d-1, varsC[dir], d-1),
        printf(fh, "  rdxU~a[~a]   = 1.0/dxU~a[~a]; ~%", varsC[dir], d-1, varsC[dir], d-1),
        printf(fh, "  rdxL~aSq[~a] = rdxL~a[~a]*rdxL~a[~a]; ~%", varsC[dir], d-1, varsC[dir], d-1, varsC[dir], d-1),
        printf(fh, "  rdxU~aSq[~a] = rdxU~a[~a]*rdxU~a[~a]; ~%", varsC[dir], d-1, varsC[dir], d-1, varsC[dir], d-1),
        if (dim=2) then (
          printf(fh, "  rdxL~aCu[~a] = rdxL~aSq[~a]*rdxL~a[~a]; ~%", varsC[dir], d-1, varsC[dir], d-1, varsC[dir], d-1),
          printf(fh, "  rdxU~aCu[~a] = rdxU~aSq[~a]*rdxU~a[~a]; ~%", varsC[dir], d-1, varsC[dir], d-1, varsC[dir], d-1),
          printf(fh, "  rdxL~aR4[~a] = rdxL~aCu[~a]*rdxL~a[~a]; ~%", varsC[dir], d-1, varsC[dir], d-1, varsC[dir], d-1),
          printf(fh, "  rdxU~aR4[~a] = rdxU~aCu[~a]*rdxU~a[~a]; ~%", varsC[dir], d-1, varsC[dir], d-1, varsC[dir], d-1)
        )
      )
    ),
    printf(fh, "~%"),

    /* This volume factors appears in front of the right-side source term. */
    volumeFac : 1,
    for dir : 1 thru dim do (
      volumeFac : volumeFac*(1.0/rdxC2[dir-1]) 
    ),
    printf(fh, "  double volFac = ~a; ~%", float(volumeFac)),
    printf(fh, "~%"),

    /* Pointers to the data in cells pointed to by the stencil. */
    printf(fh, "  double *phiC = phi[0]; ~%"),
    sI : 1,
    for d : 1 thru dim do (
      printf(fh, "  double *phiU~a = phi[~a]; ~%", varsC[d], sI),
      printf(fh, "  double *phiL~a = phi[~a]; ~%", varsC[d], sI+1),
      sI : sI + 2
    ),
    printf(fh, "~%"),

    /* Write the relaxation stencil. */
    subNum  : dim*dim*6,  /* This 6 corresponds to the number of entries in the loops below. */
    sublist : makelist(0,i,1,subNum),
    sI      : 1,
    for s : 1 thru dim do (
      for d : 1 thru dim do (
        sublist[sI]   : [sconcat("rdxL",string(varsC[d]),"[",string(s-1),"]^2"), sconcat("rdxL",string(varsC[d]),"Sq[",string(s-1),"]")],
        sublist[sI+1] : [sconcat("rdxU",string(varsC[d]),"[",string(s-1),"]^2"), sconcat("rdxU",string(varsC[d]),"Sq[",string(s-1),"]")],
        sublist[sI+2] : [sconcat("rdxL",string(varsC[d]),"[",string(s-1),"]^3"), sconcat("rdxL",string(varsC[d]),"Cu[",string(s-1),"]")],
        sublist[sI+3] : [sconcat("rdxU",string(varsC[d]),"[",string(s-1),"]^3"), sconcat("rdxU",string(varsC[d]),"Cu[",string(s-1),"]")],
        sublist[sI+4] : [sconcat("rdxL",string(varsC[d]),"[",string(s-1),"]^4"), sconcat("rdxL",string(varsC[d]),"R4[",string(s-1),"]")],
        sublist[sI+5] : [sconcat("rdxU",string(varsC[d]),"[",string(s-1),"]^4"), sconcat("rdxU",string(varsC[d]),"R4[",string(s-1),"]")],
        sI : sI + 6
      )
    ),
    writeCExprs1sub(phiC,jacStencil,sublist),
    printf(fh, "~%"),

    printf(fh, "}~%"),
    printf(fh, "~%")

  )
)$
